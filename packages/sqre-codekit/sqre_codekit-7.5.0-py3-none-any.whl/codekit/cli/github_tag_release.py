#!/usr/bin/env python3

# Technical Debt
# --------------
# - worth doing the smart thing for externals? (yes for Sims)

# Known Bugs
# ----------


from codekit.codetools import debug, info, warn, error
from codekit import codetools, eups, pygithub, versiondb
import argparse
import codekit
import github
import itertools
import os
import re
import sys
import textwrap
import yaml


class GitTagExistsError(Exception):
    pass


class GitTagMissingError(Exception):
    pass


def parse_args():
    """Parse command-line arguments"""
    prog = 'github-tag-release'

    parser = argparse.ArgumentParser(
        prog=prog,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description=textwrap.dedent("""
            Tag git repositories, in a GitHub org, that correspond to the
            products in a published eups distrib tag.

            Examples:

                # eups tag is derived from git tag
                {prog} \\
                    --dry-run \\
                    --debug \\
                    --limit 10 \\
                    --org lsst \\
                    --allow-team 'Data Management' \\
                    --allow-team 'DM Externals' \\
                    'w.2018.18' 'b3595'

                # explicit eups tag and git tag
                {prog} \\
                    --dry-run \\
                    --debug \\
                    --limit 10 \\
                    --org lsst \\
                    --allow-team 'Data Management' \\
                    --allow-team 'DM Externals' \\
                    --external-team 'DM Externals' \\
                    --eups-tag v11_0_rc2 \\
                    11.0.rc2 b1679

                # verify a past eups tag + git tag release
                {prog} \\
                    --verify \\
                    --debug \\
                    --limit 10 \\
                    --org 'lsst' \\
                    --allow-team 'Data Management' \\
                    --allow-team 'DM Externals' \\
                    --external-team 'DM Externals' \\
                    --deny-team 'DM Auxilliaries' \\
                    --email 'sqre-admin@lists.lsst.org' \\
                    --user 'sqreadmin' \\
                    --token "$GITHUB_TOKEN" \\
                    --ignore-git-tagger \\
                    --ignore-git-message \\
                    --manifest 'b3595' \\
                    'w.2018.18'

                # tag a git release from a manifest *without* a pre-existing
                # eups tag.
                {prog} \\
                    --dry-run \\
                    --debug \\
                    --limit 10 \\
                    --org 'lsst' \\
                    --allow-team 'Data Management' \\
                    --allow-team 'DM Externals' \\
                    --external-team 'DM Externals' \\
                    --deny-team 'DM Auxilliaries' \\
                    --email 'sqre-admin@lists.lsst.org' \\
                    --user 'sqreadmin' \\
                    --token "$GITHUB_TOKEN" \\
                    --ignore-git-tagger \\
                    --ignore-git-message \\
                    --manifest 'b3595' \\
                    --manifest-only \\
                    'w.2018.18'

            Note that the access token must have access to these oauth scopes:
                * read:org
                * repo

            The token generated by `github-auth --user` should have sufficient
            permissions.
        """).format(prog=prog),
        epilog='Part of codekit: https://github.com/lsst-sqre/sqre-codekit'
    )

    parser.add_argument(
        '--manifest',
        required=True,
        help='Name of versiondb manifest for git repo sha resolution'
             ' AKA bNNNN')
    parser.add_argument(
        '--org',
        required=True,
        help='Github organization')
    parser.add_argument(
        '--allow-team',
        action='append',
        required=True,
        help='git repos to be tagged MUST be a member of ONE or more of'
             ' these teams (can specify several times)')
    parser.add_argument(
        '--external-team',
        action='append',
        help='git repos in this team MUST not have tags that start with a'
             ' number. Any requested tag that violates this policy will be'
             ' prefixed with \'v\' (can specify several times)')
    parser.add_argument(
        '--deny-team',
        action='append',
        help='git repos to be tagged MUST NOT be a member of ANY of'
             ' these teams (can specify several times)')
    parser.add_argument(
        '--user',
        help='Name of person making the tag - defaults to gitconfig value')
    parser.add_argument(
        '--email',
        help='Email address of tagger - defaults to gitconfig value')
    parser.add_argument(
        '--token-path',
        default='~/.sq_github_token_delete',
        help='Use a token (made with github-auth) in a non-standard location')
    parser.add_argument(
        '--token',
        default=None,
        help='Literal github personal access token string')
    parser.add_argument(
        '--versiondb-base-url',
        default=os.getenv('LSST_VERSIONDB_BASE_URL'),
        help='Override the default versiondb base url')
    parser.add_argument(
        '--eupstag-base-url',
        default=os.getenv('LSST_EUPSTAG_BASE_URL'),
        help='Override the default eupstag base url')
    parser.add_argument(
        '--force-tag',
        action='store_true',
        help='Force moving pre-existing annotated git tags.')
    parser.add_argument(
        '--ignore-manifest-versions',
        action='store_true',
        help='Ignore manifest version strings'
             ' when cross referencing eups tag and manifest data.')
    parser.add_argument(
        '--ignore-git-message',
        action='store_true',
        help='Ignore git tag message when verifying an existing tag.')
    parser.add_argument(
        '--ignore-git-tagger',
        action='store_true',
        help='Ignore git tag "tagger"/author when verifying an existing tag.')
    parser.add_argument(
        '--limit',
        default=None,
        type=int,
        help='Maximum number of products/repos to tags. (useful for testing)')
    parser.add_argument(
        '--fail-fast',
        action='store_true',
        help='Fail immediately on github API error.')
    parser.add_argument(
        '--no-fail-fast',
        action='store_const',
        const=False,
        dest='fail_fast',
        help='DO NOT Fail immediately on github API error(s). (default)')
    parser.add_argument(
        '-d', '--debug',
        action='count',
        default=codetools.debug_lvl_from_env(),
        help='Debug mode (can specify several times)')
    parser.add_argument('-v', '--version', action=codetools.ScmVersionAction)
    parser.add_argument('tag')

    manifest_group = parser.add_mutually_exclusive_group()
    manifest_group.add_argument(
        '--eups-tag',
        help='(mutually exclusive with --manifest-only)')
    manifest_group.add_argument(
        '--manifest-only',
        action='store_true',
        help='Do not cross reference a published eups tag with the manifest'
             ' -- use only the metadata from the manifest to determine'
             ' git tag location.'
             ' This allows a git tag to be created without a prior eups tag.'
             ' (mutually exclusive with --eups-tag)')

    dryrun_group = parser.add_mutually_exclusive_group()
    dryrun_group.add_argument(
        '--dry-run',
        action='store_true',
        help='Do not create/update tag(s) or modify any state.'
             ' (mutually exclusive with --verify)')
    dryrun_group.add_argument(
        '--verify',
        action='store_true',
        help='Verify that all git tags for a release are present and correct.'
             ' will not create/update tag(s) or modify any state.'
             ' (mutually exclusive with --dry-run)')

    return parser.parse_args()


def cmp_dict(d1, d2, ignore_keys=[]):
    """Compare dicts ignoring select keys"""
    # https://stackoverflow.com/questions/10480806/compare-dictionaries-ignoring-specific-keys
    return {k: v for k, v in d1.items() if k not in ignore_keys} \
        == {k: v for k, v in d2.items() if k not in ignore_keys}


def cross_reference_products(
    eups_products,
    manifest_products,
    ignore_manifest_versions=False,
    fail_fast=False,
):
    """
    Cross reference EupsTag and Manifest data and return a merged result

    Parameters
    ----------
    eups_products:
    manifest:
    fail_fast: bool
    ignore_manifest_versions: bool

    Returns
    -------
    products: dict

    Raises
    ------
    RuntimeError
        Upon error if `fail_fast` is `True`.
    """
    products = {}

    problems = []
    for name, eups_data in eups_products.items():
        try:
            manifest_data = manifest_products[name]
        except KeyError:
            yikes = RuntimeError(textwrap.dedent("""\
                failed to find record in manifest for:
                  {product} {eups_version}\
                """).format(
                product=name,
                eups_version=eups_data['eups_version'],
            ))
            if fail_fast:
                raise yikes from None
            problems.append(yikes)
            error(yikes)

        if ignore_manifest_versions:
            # ignore the manifest eups_version string by simply setting it to
            # the eups tag value.  This ensures that the eups tag value will be
            # passed though.
            manifest_data = manifest_data.copy()
            manifest_data['eups_version'] = eups_data['eups_version']

        if eups_data['eups_version'] != manifest_data['eups_version']:
            yikes = RuntimeError(textwrap.dedent("""\
                eups version string mismatch:
                  eups tag: {product} {eups_eups_version}
                  manifest: {product} {manifest_eups_version}\
                """).format(
                product=name,
                eups_eups_version=eups_data['eups_version'],
                manifest_eups_version=manifest_data['eups_version'],
            ))
            if fail_fast:
                raise yikes
            problems.append(yikes)
            error(yikes)

        products[name] = eups_data.copy()
        products[name].update(manifest_data)

    if problems:
        error("{n} product(s) have error(s)".format(n=len(problems)))

    return products, problems


def get_repo_for_products(
    org,
    products,
    allow_teams,
    ext_teams,
    deny_teams,
    fail_fast=False
):
    debug("allowed teams: {allow}".format(allow=allow_teams))
    debug("external teams: {ext}".format(ext=ext_teams))
    debug("denied teams: {deny}".format(deny=deny_teams))

    resolved_products = {}

    global g
    repos_yaml = g.get_repo("lsst/repos").get_contents("etc/repos.yaml")
    repo_index = yaml.safe_load(repos_yaml.decoded_content)

    problems = []
    for name, data in products.items():
        debug("looking for git repo for: {name} [{ver}]".format(
            name=name,
            ver=data['eups_version']
        ))

        try:
            entry = repo_index[name]
            if isinstance(entry, dict):
                entry = entry['url']
            entry = re.sub(
                r"^https?://github\.com/(.+?)(\.git)?$",
                r"\1",
                entry
            )
        except Exception as exc:
            msg = f"repo {name} cannot be found in repos.yaml"
            yikes = RuntimeError(msg)
            if fail_fast:
                raise yikes from exc
            problems.append(yikes)
            error(yikes)
            continue

        try:
            repo = g.get_repo(entry)
        except github.RateLimitExceededException:
            raise
        except github.GithubException as e:
            msg = "error getting repo by name: {r}".format(r=name)
            yikes = pygithub.CaughtOrganizationError(org, e, msg)
            if fail_fast:
                raise yikes from None
            problems.append(yikes)
            error(yikes)

            continue

        debug("  found: {slug}".format(slug=repo.full_name))

        try:
            repo_team_names = [t.name for t in repo.get_teams()]
        except github.RateLimitExceededException:
            raise
        except github.GithubException as e:
            msg = 'error getting teams'
            yikes = pygithub.CaughtRepositoryError(repo, e, msg)
            if fail_fast:
                raise yikes from None
            problems.append(yikes)
            error(yikes)

            continue

        debug("  teams: {teams}".format(teams=repo_team_names))

        try:
            pygithub.check_repo_teams(
                repo,
                allow_teams=allow_teams,
                deny_teams=deny_teams,
                team_names=repo_team_names
            )
        except pygithub.RepositoryTeamMembershipError as e:
            if fail_fast:
                raise
            problems.append(e)
            error(e)

            continue

        has_ext_team = any(x in repo_team_names for x in ext_teams)
        debug("  external repo: {v}".format(v=has_ext_team))

        resolved_products[name] = data.copy()
        resolved_products[name]['repo'] = repo
        resolved_products[name]['v'] = has_ext_team

    if problems:
        error("{n} product(s) have error(s)".format(n=len(problems)))

    return resolved_products, problems


def author_to_dict(obj):
    """Who needs a switch/case statement when you can instead use this easy to
    comprehend drivel?
    """
    def default():
        raise RuntimeError("unsupported type {t}".format(t=type(obj).__name__))

    # a more pythonic way to handle this would be several try blocks to catch
    # missing attributes
    return {
        # GitAuthor has name,email,date properties
        'GitAuthor': lambda x: {'name': x.name, 'email': x.email},
        # InputGitAuthor only has _identity, which returns a dict
        # XXX consider trying to rationalize this upstream...
        'InputGitAuthor': lambda x: x._identity,
    }.get(type(obj).__name__, lambda x: default())(obj)


def cmp_gitauthor(a, b):
    # ignore date
    if cmp_dict(author_to_dict(a), author_to_dict(b), ['date']):
        return True

    return False


def cmp_existing_git_tag(
    t_tag,
    e_tag,
    ignore_git_message=False,
    ignore_git_tagger=False,
):
    assert isinstance(t_tag, codekit.pygithub.TargetTag), type(t_tag)
    assert isinstance(e_tag, github.GitTag.GitTag)

    if t_tag.sha != e_tag.object.sha:
        return False

    if not ignore_git_message:
        if t_tag.message != e_tag.message:
            return False

    if not ignore_git_tagger:
        # ignore date when comparing tag objects
        if not cmp_gitauthor(t_tag.tagger, e_tag.tagger):
            return False

    return True


def check_existing_git_tag(repo, t_tag, **kwargs):
    """
    Check for a pre-existng tag in the github repo.

    Parameters
    ----------
    repo : github.Repository.Repository
        repo to inspect for an existing tagsdf
    t_tag: codekit.pygithub.TargetTag
        dict repesenting a target git tag

    Returns
    -------
    insync : `bool`
        True if tag exists and is in sync. False if tag does not exist.

    Raises
    ------
    GitTagExistsError
        If tag exists but is not in sync.
    """

    assert isinstance(repo, github.Repository.Repository), type(repo)
    assert isinstance(t_tag, codekit.pygithub.TargetTag), type(t_tag)

    debug("looking for existing tag: {tag} in repo: {repo}".format(
        repo=repo.full_name,
        tag=t_tag.name,
    ))

    # find ref/tag by name
    e_ref = pygithub.find_tag_by_name(repo, t_tag.name)
    if not e_ref:
        debug("  not found: {tag}".format(tag=t_tag.name))
        return False

    # find tag object pointed to by the ref
    try:
        e_tag = repo.get_git_tag(e_ref.object.sha)
    except github.RateLimitExceededException:
        raise
    except github.GithubException as e:
        msg = "error getting tag: {tag} [{sha}]".format(
            tag=e_tag.tag,
            sha=e_tag.sha,
        )
        raise pygithub.CaughtRepositoryError(repo, e, msg) from None

    debug("  found existing: {tag} [{sha}]".format(
        tag=e_tag.tag,
        sha=e_tag.sha,
    ))

    if cmp_existing_git_tag(t_tag, e_tag, **kwargs):
        return True

    yikes = GitTagExistsError(textwrap.dedent("""\
        tag: {tag} already exists in repo: {repo}
        with conflicting values:
          existing:
            sha: {e_sha}
            message: {e_message}
            tagger: {e_tagger}
          target:
            sha: {t_sha}
            message: {t_message}
            tagger: {t_tagger}\
    """).format(
        tag=t_tag.name,
        repo=repo.full_name,
        e_sha=e_tag.object.sha,
        e_message=e_tag.message,
        e_tagger=e_tag.tagger,
        t_sha=t_tag.sha,
        t_message=t_tag.message,
        t_tagger=t_tag.tagger,
    ))

    raise yikes


def check_product_tags(
    products,
    git_tag,
    tag_message_template,
    tagger,
    force_tag=False,
    fail_fast=False,
    ignore_git_message=False,
    ignore_git_tagger=False,
):
    assert isinstance(tagger, github.InputGitAuthor), type(tagger)

    checked_products = {}

    problems = []
    for name, data in products.items():
        repo = data['repo']
        tag_name = git_tag

        # prefix tag name with `v`?
        if data['v'] and re.match(r'\d', tag_name):
            tag_name = "v{git_tag}".format(git_tag=tag_name)

        # message can not be formatted until we've determined if the tag must
        # be prefixed.  The 'v' prefix appearing in the tag message is required
        # to match historical behavior and allow verification of past releases.
        message = tag_message_template.format(git_tag=tag_name)

        # "target tag"
        t_tag = codekit.pygithub.TargetTag(
            name=tag_name,
            sha=data['sha'],
            message=message,
            tagger=tagger,
        )

        # control whether to create a new tag or update an existing one
        update_tag = False

        try:
            # if the existing tag is in sync, do nothing
            if check_existing_git_tag(
                repo,
                t_tag,
                ignore_git_message=ignore_git_message,
                ignore_git_tagger=ignore_git_tagger,
            ):
                warn(textwrap.dedent("""\
                    No action for {repo}
                      existing tag: {tag} is already in sync\
                    """).format(
                    repo=repo.full_name,
                    tag=t_tag.name,
                ))

                continue
        except github.RateLimitExceededException:
            raise
        except GitTagExistsError as e:
            # if force_tag is set, and the tag already exists, set
            # update_tag and fall through. Otherwise, treat it as any other
            # exception.
            if force_tag:
                update_tag = True
                warn(textwrap.dedent("""\
                      existing tag: {tag} WILL BE MOVED\
                    """).format(
                    repo=repo.full_name,
                    tag=t_tag.name,
                ))
            elif fail_fast:
                raise
            else:
                problems.append(e)
                error(e)
                continue
        except github.GithubException as e:
            msg = "error checking for existance of tag: {t}".format(
                t=t_tag.name,
            )
            yikes = pygithub.CaughtRepositoryError(repo, e, msg)

            if fail_fast:
                raise yikes from None
            else:
                problems.append(yikes)
                error(yikes)
                continue

        checked_products[name] = data.copy()
        checked_products[name]['target_tag'] = t_tag
        checked_products[name]['update_tag'] = update_tag

    if problems:
        error("{n} product(s) have error(s)".format(n=len(problems)))

    return checked_products, problems


def identify_products_missing_tags(products_to_tag):
    problems = []
    for name, data in products_to_tag.items():
        repo = data['repo']
        t_tag = data['target_tag']

        yikes = GitTagMissingError(textwrap.dedent("""\
            tag: {gt} missing from repo: {repo} @
              sha: {sha}
              (eups version: {et})
              external repo: {v}
              replace existing tag: {update}\
            """).format(
            repo=repo.full_name,
            sha=t_tag.sha,
            gt=t_tag.name,
            et=data['eups_version'],
            v=data['v'],
            update=data['update_tag'],
        ))
        problems.append(yikes)
        error(yikes)

    if problems:
        error("{n} product(s) have error(s)".format(n=len(problems)))

    return problems


def tag_products(
    products,
    fail_fast=False,
    dry_run=False,
):
    problems = []
    for name, data in products.items():
        repo = data['repo']
        t_tag = data['target_tag']

        info(textwrap.dedent("""\
            tagging repo: {repo} @
              sha: {sha} as {gt}
              (eups version: {et})
              external repo: {v}
              replace existing tag: {update}\
            """).format(
            repo=repo.full_name,
            sha=t_tag.sha,
            gt=t_tag.name,
            et=data['eups_version'],
            v=data['v'],
            update=data['update_tag'],
        ))

        if dry_run:
            info('  (noop)')
            continue

        try:
            tag_obj = repo.create_git_tag(
                t_tag.name,
                t_tag.message,
                t_tag.sha,
                'commit',
                tagger=t_tag.tagger,
            )
            debug("  created tag object {tag_obj}".format(tag_obj=tag_obj))

            if data['update_tag']:
                ref = pygithub.find_tag_by_name(
                    repo,
                    t_tag.name,
                    safe=False,
                )
                ref.edit(tag_obj.sha, force=True)
                debug("  updated existing ref: {ref}".format(ref=ref))
            else:
                ref = repo.create_git_ref(
                    "refs/tags/{t}".format(t=t_tag.name),
                    tag_obj.sha
                )
                debug("  created ref: {ref}".format(ref=ref))
        except github.RateLimitExceededException:
            raise
        except github.GithubException as e:
            msg = "error creating tag: {t}".format(t=t_tag.name)
            yikes = pygithub.CaughtRepositoryError(repo, e, msg)
            if fail_fast:
                raise yikes from None
            problems.append(yikes)
            error(yikes)

    if problems:
        msg = "{n} tag failures".format(n=len(problems))
        raise codetools.DogpileError(problems, msg)


def run():
    """Create the tag"""
    args = parse_args()

    codetools.setup_logging(args.debug)

    git_tag = args.tag

    # if email not specified, try getting it from the gitconfig
    git_email = codetools.lookup_email(args)
    # ditto for the name of the git user
    git_user = codetools.lookup_user(args)

    # The default eups tag is derived from the git tag, otherwise specified
    # with the --eups-tag option. The reason to currently do this is that for
    # weeklies and other internal builds, it's okay to eups publish the weekly
    # and git tag post-facto. However for official releases, we don't want to
    # publish until the git tag goes down, because we want to eups publish the
    # build that has the official versions in the eups ref.
    if not args.manifest_only:
        eups_tag = args.eups_tag
        if not eups_tag:
            # generate eups-style version
            eups_tag = eups.git_tag2eups_tag(git_tag)
        debug("using eups tag: {eups_tag}".format(eups_tag=eups_tag))

    # sadly we need to "just" know this
    # XXX this can be parsed from the eups tag file post d_2018_05_08
    manifest = args.manifest
    debug("using manifest: {manifest}".format(manifest=manifest))

    if not args.manifest_only:
        # release from eups tag
        message_template = "Version {{git_tag}}"\
            " release from {eups_tag}/{manifest}".format(
                eups_tag=eups_tag,
                manifest=manifest,
            )
    else:
        # release from manifest only
        message_template = "Version {{git_tag}}"\
            " release from manifest {manifest}".format(
                manifest=manifest,
            )

    debug("using tag message: {msg}".format(msg=message_template))

    tagger = github.InputGitAuthor(
        git_user,
        git_email,
        codetools.current_timestamp(),
    )
    debug("using taggger: {tagger}".format(tagger=tagger))

    global g
    g = pygithub.login_github(token_path=args.token_path, token=args.token)
    org = g.get_organization(args.org)
    info("tagging repos in org: {org}".format(org=org.login))

    problems = []

    manifest_products = versiondb.Manifest(
        manifest,
        base_url=args.versiondb_base_url).products

    if not args.manifest_only:
        # cross-reference eups tag version strings with manifest
        eups_products = eups.EupsTag(
            eups_tag,
            base_url=args.eupstag_base_url).products

        # do not fail-fast on non-write operations
        products, err = cross_reference_products(
            eups_products,
            manifest_products,
            ignore_manifest_versions=args.ignore_manifest_versions,
            fail_fast=False,
        )
        problems += err
    else:
        # no eups tag; use manifest products without sanity check against eups
        # tag version strings
        products = manifest_products

    if args.limit:
        products = dict(itertools.islice(products.items(), args.limit))

    # do not fail-fast on non-write operations
    products, err = get_repo_for_products(
        org=org,
        products=products,
        allow_teams=args.allow_team,
        ext_teams=args.external_team,
        deny_teams=args.deny_team,
        fail_fast=False,
    )
    problems += err

    # do not fail-fast on non-write operations
    products_to_tag, err = check_product_tags(
        products,
        git_tag,
        tag_message_template=message_template,
        tagger=tagger,
        force_tag=args.force_tag,
        fail_fast=False,
        ignore_git_message=args.ignore_git_message,
        ignore_git_tagger=args.ignore_git_tagger,
    )
    problems += err

    if args.verify:
        # in verify mode, it is an error if there are products that need to be
        # tagged.
        err = identify_products_missing_tags(products_to_tag)
        problems += err

    if problems:
        msg = "{n} pre-flight error(s)".format(n=len(problems))
        raise codetools.DogpileError(problems, msg)

    tag_products(
        products_to_tag,
        fail_fast=args.fail_fast,
        dry_run=args.dry_run,
    )


def main():
    try:
        try:
            run()
        except codetools.DogpileError as e:
            error(e)
            n = len(e.errors)
            sys.exit(n if n < 256 else 255)
        else:
            sys.exit(0)
        finally:
            if 'g' in globals():
                pygithub.debug_ratelimit(g)
    except SystemExit as e:
        debug("exit {status}".format(status=str(e)))
        raise e


if __name__ == '__main__':
    main()
