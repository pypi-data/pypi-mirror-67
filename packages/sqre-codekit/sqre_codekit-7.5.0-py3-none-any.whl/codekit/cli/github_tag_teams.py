#!/usr/bin/env python3

from codekit.codetools import debug, error, info, warn
from codekit import codetools, pygithub
import argparse
import codekit.progressbar as pbar
import github
import re
import sys
import textwrap


class GitTagExistsError(Exception):
    pass


def parse_args():
    """Parse command-line arguments"""
    prog = 'github-tag-teams'

    parser = argparse.ArgumentParser(
        prog=prog,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description=textwrap.dedent("""
            Tag the head of the default branch of all repositories in a GitHub
            org which belong to the specified team(s).

            Examples:

                # mininum required arguments
                {prog} --org lsst --team 'DM Auxilliaries' --tag w.2015.33

                # *DELETE* an existing git tag
                # --debug is always recommended
                {prog} \\
                    --debug \\
                    --org lsst \\
                    --team 'DM Auxilliaries' \\
                    --tag w.2015.33 \\
                    --delete

                # "dry run" with multiple git tags
                {prog} \\
                    --debug \\
                    --dry-run \\
                    --org 'lsst' \\
                    --allow-team 'DM Auxilliaries' \\
                    --deny-team 'DM Externals' \\
                    --token "$GITHUB_TOKEN" \\
                    --user 'sqreadmin' \\
                    --email 'sqre-admin@lists.lsst.org' \\
                    --tag 'foo' \\
                    --tag 'bar'

                # *do not* fail if git tag already exists in any repo
                {prog} \\
                    --debug \\
                    --dry-run \\
                    --delete \\
                    --org 'lsst' \\
                    --allow-team 'DM Auxilliaries' \\
                    --deny-team 'DM Externals' \\
                    --token "$GITHUB_TOKEN" \\
                    --user 'sqreadmin' \\
                    --email 'sqre-admin@lists.lsst.org' \\
                    --ignore-existing-tag \\
                    --tag 'v999.0.0.rc1'


            Note that the access token must have access to these oauth scopes:
                * read:org
                * repo

            The token generated by `github-auth --user` should have sufficient
            permissions.
        """).format(prog=prog),
        epilog='Part of codekit: https://github.com/lsst-sqre/sqre-codekit'
    )

    parser.add_argument(
        '--tag',
        action='append',
        required=True,
        help="tag to apply to HEAD of repo (can specify several times")
    parser.add_argument(
        '--org',
        required=True,
        help="Github organization")
    parser.add_argument(
        '--allow-team',
        action='append',
        required=True,
        help='git repos to be tagged MUST be a member of ONE or more of'
             ' these teams (can specify several times)')
    parser.add_argument(
        '--deny-team',
        action='append',
        help='git repos to be tagged MUST NOT be a member of ANY of'
             ' these teams (can specify several times)')
    parser.add_argument('--dry-run', action='store_true')
    parser.add_argument(
        '--user',
        help='Name of person making the tag - defaults to gitconfig value')
    parser.add_argument(
        '--email',
        help='Email address of tagger - defaults to gitconfig value')
    parser.add_argument(
        '--token-path',
        default='~/.sq_github_token_delete',
        help='Use a token (made with github-auth) in a non-standard location')
    parser.add_argument(
        '--token',
        default=None,
        help='Literal github personal access token string')
    parser.add_argument(
        '-d', '--debug',
        action='count',
        default=codetools.debug_lvl_from_env(),
        help='Debug mode (can specify several times)')
    parser.add_argument('-v', '--version', action=codetools.ScmVersionAction)

    delete_group = parser.add_mutually_exclusive_group()
    delete_group.add_argument(
        '--delete',
        action='store_true',
        help='*Delete* instead of create tag(s)'
             ' (mutually exclusive with --ignore-existing-tag)')
    delete_group.add_argument(
        '--ignore-existing-tag',
        action='store_true',
        help='Ignore git tag(s) which already exist in a repo'
             ' -- normally this would be an error.'
             ' (mutually exclusive with --delete)')

    return parser.parse_args()


def tag_name_from_ref(ref):
    assert isinstance(ref, github.GitRef.GitRef), type(ref)
    return re.sub(r'^refs/tags/', '', ref.ref)


# XXX this should be refactored to operate similar to
# github_tag_release.check_product_tags() in that it would create a
# codekit.pygithub.TargetTag object and then compare it to an existing tag (if
# present) -- it should also return list of tags to be applied instead of only
# errors.
def check_tags(repos, tags, ignore_existing=False, fail_fast=False):
    """ check if tags already exist in repos"""

    debug("looking for {n} tag(s):".format(n=len(tags)))
    [debug("  {t}".format(t=t)) for t in tags]
    debug("in {n} repo(s):".format(n=len(repos)))
    [debug("  {r}".format(r=r.full_name)) for r in repos]

    # present/missing tags by repo name
    present_tags = {}
    absent_tags = {}

    problems = []
    for r in repos:
        has_tags = find_tags_in_repo(r, tags)
        if has_tags:
            if not ignore_existing:
                yikes = GitTagExistsError(
                    "tag(s) {tag} already exists in repos {r}".format(
                        tag=list(has_tags.keys()),
                        r=r.full_name
                    ))
                if fail_fast:
                    raise yikes
                problems.append(yikes)
                error(yikes)

            present_tags[r.full_name] = {
                'repo': r,
                'tags': list(has_tags.values()),
            }

        missing_tags = [x for x in tags if x not in has_tags]
        if missing_tags:
            absent_tags[r.full_name] = {
                'repo': r,
                'need_tags': missing_tags,
            }

    debug(textwrap.dedent("""\
        found:
          {n_with:>4} repos with tag(s)
          {n_none:>4} repos with no tag(s)
          {errors:>4} repos with error(s)\
        """).format(
        n_with=len(present_tags),
        n_none=len(absent_tags),
        errors=len(problems),
    ))

    return present_tags, absent_tags, problems


def find_tags_in_repo(repo, tags):
    assert isinstance(repo, github.Repository.Repository), type(repo)

    debug(textwrap.dedent("""\
        looking in repo: {repo}
          for tag(s): {tags}\
        """).format(
        repo=repo.full_name,
        tags=tags,
    ))

    found_tags = {}
    for t in tags:
        ref = pygithub.find_tag_by_name(repo, t)
        if ref and ref.ref:
            debug("  found: {tag} ({ref})".format(tag=t, ref=ref.ref))
            name = tag_name_from_ref(ref)
            found_tags[name] = ref
            continue

        debug("  not found: {tag}".format(tag=t))

    return found_tags


cached_teams = {}


def find_repo_teams(repo):
    # Repository objects are unhashable, so we can't use memoization ;(
    if repo.full_name in cached_teams:
        return cached_teams[repo.full_name]

    try:
        # flatten iterator so the results are cached
        teams = list(repo.get_teams())
    except github.RateLimitExceededException:
        raise
    except github.GithubException as e:
        msg = 'error getting teams'
        raise pygithub.CaughtRepositoryError(repo, e, msg) from None

    cached_teams[repo.full_name] = teams

    return teams


def get_candidate_teams(org, target_teams):
    assert isinstance(org, github.Organization.Organization), type(org)

    try:
        teams = list(org.get_teams())
    except github.RateLimitExceededException:
        raise
    except github.GithubException as e:
        msg = 'error getting teams'
        raise pygithub.CaughtOrganizationError(org, e, msg) from None

    debug("looking for teams: {teams}".format(teams=target_teams))
    tag_teams = [t for t in teams if t.name in target_teams]
    debug("found teams: {teams}".format(teams=tag_teams))

    if not tag_teams:
        raise RuntimeError('No teams found')

    return tag_teams


def get_candidate_repos(teams):
    # flatten generator to list so it can be itererated over multiple times
    repos = list(pygithub.get_repos_by_team(teams))

    # find length of longest repo name to nicely format output
    names = [r.full_name for r in repos]
    max_name_len = len(max(names, key=len))

    team_names = [t.name for t in teams]
    info("found {n} repo(s) [selected by team(s)]:".format(n=len(repos)))
    for r in repos:
        # list only teams which were used to select the repo as a candiate
        # for tagging
        s_teams = [t.name for t in find_repo_teams(r)
                   if t.name in team_names]
        info("  {repo: >{w}} {teams}".format(
            w=max_name_len,
            repo=r.full_name,
            teams=s_teams)
        )

    return repos


def check_repos(repos, allow_teams, deny_teams, fail_fast=False):
    problems = []
    for r in repos:
        try:
            pygithub.check_repo_teams(
                r,
                allow_teams=allow_teams,
                deny_teams=deny_teams,
                team_names=[t.name for t in find_repo_teams(r)],
            )
        except pygithub.RepositoryTeamMembershipError as e:
            if fail_fast:
                raise
            problems.append(e)
            error(e)

            continue

    return problems


def tag_repos(absent_tags, **kwargs):
    if not absent_tags:
        info('nothing to do')
        return

    info("tagging {n} repo(s) [tags]:".format(n=len(absent_tags)))

    max_name_len = len(max(absent_tags, key=len))
    for k in absent_tags:
        info("  {repo: >{w}} {tags}".format(
            w=max_name_len,
            repo=k,
            tags=absent_tags[k]['need_tags']
        ))

    for k in absent_tags:
        r = absent_tags[k]['repo']
        tags = absent_tags[k]['need_tags']
        create_tags(r, tags, **kwargs)


def create_tags(repo, tags, tagger, dry_run=False):
    assert isinstance(repo, github.Repository.Repository), type(repo)

    # tag the head of the designated "default branch"
    # XXX this probably should be resolved via repos.yaml
    head = pygithub.get_default_ref(repo)

    debug(textwrap.dedent("""\
        tagging repo: {repo} @
          default ref: {db}
          type: {obj_type}
          sha: {obj_sha}\
        """).format(
        repo=repo.full_name,
        db=head.ref,
        obj_type=head.object.type,
        obj_sha=head.object.sha
    ))

    for t in tags:
        debug("  creating 'annotated tag' {t}".format(t=t))
        if dry_run:
            debug('    (noop)')
            continue

        tag_obj = repo.create_git_tag(
            t,
            "Version {t}".format(t=t),  # fmt similar to github-tag-release
            head.object.sha,
            head.object.type,
            tagger=tagger
        )
        debug("  created tag object {tag_obj}".format(tag_obj=tag_obj))

        ref = repo.create_git_ref("refs/tags/{t}".format(t=t), tag_obj.sha)
        debug("  created ref: {ref}".format(ref=ref.ref))


def untag_repos(present_tags, **kwargs):
    if not present_tags:
        info('nothing to do')
        return

    warn('Deleting tag(s)')
    pbar.wait_for_user_panic_once()

    info("untagging {n} repo(s) [tags]:".format(n=len(present_tags)))

    max_name_len = len(max(present_tags, key=len))
    for k in present_tags:
        info("  {repo: >{w}} {tags}".format(
            w=max_name_len,
            repo=k,
            tags=[tag_name_from_ref(ref) for ref in present_tags[k]['tags']]
        ))

    for k in present_tags:
        r = present_tags[k]['repo']
        tags = present_tags[k]['tags']
        delete_refs(r, tags, **kwargs)


def delete_refs(repo, refs, dry_run=False):
    """Note that only the ref to a tag can be explicitly removed.  The tag
    object will leave on until it's gargabe collected."""

    assert isinstance(repo, github.Repository.Repository), type(repo)

    debug("removing {n} refs from {repo}".format(
        n=len(refs),
        repo=repo.full_name)
    )

    for r in refs:
        debug("  deleting {ref}".format(ref=r.ref))
        if dry_run:
            debug('    (noop)')
            continue

        r.delete()


def run():
    args = parse_args()

    codetools.setup_logging(args.debug)

    gh_org_name = args.org
    tags = args.tag

    git_email = codetools.lookup_email(args)
    git_user = codetools.lookup_user(args)

    tagger = github.InputGitAuthor(
        git_user,
        git_email,
        codetools.current_timestamp()
    )
    debug(tagger)

    global g
    g = pygithub.login_github(token_path=args.token_path, token=args.token)
    org = g.get_organization(gh_org_name)
    info("tagging repos in org: {org}".format(org=org.login))

    tag_teams = get_candidate_teams(org, args.allow_team)
    target_repos = get_candidate_repos(tag_teams)

    problems = []
    # do not fail-fast on non-write operations
    problems += check_repos(
        target_repos,
        args.allow_team,
        args.deny_team,
        fail_fast=False,
    )

    # existing tags are always ignored (not an error) under --delete
    ignore_existing = True if args.delete else args.ignore_existing_tag

    # do not fail-fast on non-write operations
    present_tags, absent_tags, err = check_tags(
        target_repos,
        tags,
        ignore_existing=ignore_existing,
        fail_fast=False,
    )
    problems += err

    if problems:
        msg = "{n} repo(s) have errors".format(n=len(problems))
        raise codetools.DogpileError(problems, msg)

    if args.delete:
        untag_repos(present_tags, dry_run=args.dry_run)
    else:
        tag_repos(absent_tags, tagger=tagger, dry_run=args.dry_run)


def main():
    try:
        try:
            run()
        except codetools.DogpileError as e:
            error(e)
            n = len(e.errors)
            sys.exit(n if n < 256 else 255)
        else:
            sys.exit(0)
        finally:
            if 'g' in globals():
                pygithub.debug_ratelimit(g)
    except SystemExit as e:
        debug("exit {status}".format(status=str(e)))
        raise e


if __name__ == '__main__':
    main()
