'\n    enable:Banking SDK\n\n    enable:Banking SDK consists of 4 interfaces:  - [Meta](#auth-api) provides information about available connectors; - [Auth](#auth-api) provides PSU (bank user) authentication and token creation   functionality; - [AISP](#aisp-api) provides functions for accessing account information, such as   transactions and balances, on behalf of a PSU; - [PISP](#pisp-api) provides functions for initiating and conforming payment   requests.  The same calls and data structures are used for interacting with different ASPSPs (banks). In order to use each of the interfaces corresponding instance needs to be created. When instantiating any of the interfaces except Meta, ASPSP connector name and settings need to be supplied. The settings differ from one connector to another (although many of them have the same properties) and are described in the [Connectors](#connectors-types) section of the documentation.  enable:Banking SDK interfaces are based on [STET PSD2 specification](https://www.stet.eu/en/psd2/), but have been modified and extended in order to support usage scenarious beyond the original specification.   # noqa: E501\n\n    API version: 0.5.1\n    Contact: hello@enablebanking.com\n    Generated by enable:Banking SDK generator using Swagger Codegen project\n'
_L='address_line'
_K='country_sub_division'
_J='town_name'
_I='post_code'
_H='building_numbder'
_G='street_name'
_F='sub_department'
_E='address_type'
_D='country'
_C='department'
_B='str'
_A=None
import pprint,re
from enablebanking.models.address_type import AddressType
class PostalAddress:
	'NOTE: This class is auto generated by the swagger code generator program.\n\n    Do not edit the class manually.\n    ';'\n    Attributes:\n      swagger_types (dict): The key is attribute name\n                            and the value is attribute type.\n      attribute_map (dict): The key is attribute name\n                            and the value is json key in definition.\n    ';swagger_types={_E:'AddressType',_C:_B,_F:_B,_G:_B,_H:_B,_I:_B,_J:_B,_K:_B,_D:_B,_L:'list[str]'};attribute_map={_E:'addressType',_C:_C,_F:'subDepartment',_G:'streetName',_H:'buildingNumbder',_I:'postCode',_J:'townName',_K:'countrySubDivision',_D:_D,_L:'addressLine'}
	def __init__(A,address_type=_A,department=_A,sub_department=_A,street_name=_A,building_numbder=_A,post_code=_A,town_name=_A,country_sub_division=_A,country=_A,address_line=_A):
		'PostalAddress - a model defined in Swagger';J=address_line;I=country_sub_division;H=town_name;G=post_code;F=building_numbder;E=street_name;D=sub_department;C=department;B=address_type;A._address_type=_A;A._department=_A;A._sub_department=_A;A._street_name=_A;A._building_numbder=_A;A._post_code=_A;A._town_name=_A;A._country_sub_division=_A;A._country=_A;A._address_line=_A;A.discriminator=_A
		if B is not _A:A.address_type=B
		if C is not _A:A.department=C
		if D is not _A:A.sub_department=D
		if E is not _A:A.street_name=E
		if F is not _A:A.building_numbder=F
		if G is not _A:A.post_code=G
		if H is not _A:A.town_name=H
		if I is not _A:A.country_sub_division=I
		A.country=country
		if J is not _A:A.address_line=J
	@property
	def address_type(self):'Gets the address_type of this PostalAddress.  # noqa: E501\n\n\n        :return: The address_type of this PostalAddress.  # noqa: E501\n        :rtype: AddressType\n        ';return self._address_type
	@address_type.setter
	def address_type(self,address_type):'Sets the address_type of this PostalAddress.\n\n\n        :param address_type: The address_type of this PostalAddress.  # noqa: E501\n        :type: AddressType\n        ';self._address_type=address_type
	@property
	def department(self):'Gets the department of this PostalAddress.  # noqa: E501\n\n        Identification of a division of a large organisation or building.  # noqa: E501\n\n        :return: The department of this PostalAddress.  # noqa: E501\n        :rtype: str\n        ';return self._department
	@department.setter
	def department(self,department):
		'Sets the department of this PostalAddress.\n\n        Identification of a division of a large organisation or building.  # noqa: E501\n\n        :param department: The department of this PostalAddress.  # noqa: E501\n        :type: str\n        ';A=department
		if A is not _A and len(A)>70:raise ValueError('Invalid value for `department`, length must be less than or equal to `70`')
		if A is not _A and len(A)<1:raise ValueError('Invalid value for `department`, length must be greater than or equal to `1`')
		self._department=A
	@property
	def sub_department(self):'Gets the sub_department of this PostalAddress.  # noqa: E501\n\n        Identification of a sub-division of a large organisation or building.  # noqa: E501\n\n        :return: The sub_department of this PostalAddress.  # noqa: E501\n        :rtype: str\n        ';return self._sub_department
	@sub_department.setter
	def sub_department(self,sub_department):
		'Sets the sub_department of this PostalAddress.\n\n        Identification of a sub-division of a large organisation or building.  # noqa: E501\n\n        :param sub_department: The sub_department of this PostalAddress.  # noqa: E501\n        :type: str\n        ';A=sub_department
		if A is not _A and len(A)>70:raise ValueError('Invalid value for `sub_department`, length must be less than or equal to `70`')
		if A is not _A and len(A)<1:raise ValueError('Invalid value for `sub_department`, length must be greater than or equal to `1`')
		self._sub_department=A
	@property
	def street_name(self):'Gets the street_name of this PostalAddress.  # noqa: E501\n\n        Name of a street or thoroughfare.  # noqa: E501\n\n        :return: The street_name of this PostalAddress.  # noqa: E501\n        :rtype: str\n        ';return self._street_name
	@street_name.setter
	def street_name(self,street_name):
		'Sets the street_name of this PostalAddress.\n\n        Name of a street or thoroughfare.  # noqa: E501\n\n        :param street_name: The street_name of this PostalAddress.  # noqa: E501\n        :type: str\n        ';A=street_name
		if A is not _A and len(A)>70:raise ValueError('Invalid value for `street_name`, length must be less than or equal to `70`')
		if A is not _A and len(A)<1:raise ValueError('Invalid value for `street_name`, length must be greater than or equal to `1`')
		self._street_name=A
	@property
	def building_numbder(self):'Gets the building_numbder of this PostalAddress.  # noqa: E501\n\n        Number that identifies the position of a building on a street.  # noqa: E501\n\n        :return: The building_numbder of this PostalAddress.  # noqa: E501\n        :rtype: str\n        ';return self._building_numbder
	@building_numbder.setter
	def building_numbder(self,building_numbder):
		'Sets the building_numbder of this PostalAddress.\n\n        Number that identifies the position of a building on a street.  # noqa: E501\n\n        :param building_numbder: The building_numbder of this PostalAddress.  # noqa: E501\n        :type: str\n        ';A=building_numbder
		if A is not _A and len(A)>16:raise ValueError('Invalid value for `building_numbder`, length must be less than or equal to `16`')
		if A is not _A and len(A)<1:raise ValueError('Invalid value for `building_numbder`, length must be greater than or equal to `1`')
		self._building_numbder=A
	@property
	def post_code(self):'Gets the post_code of this PostalAddress.  # noqa: E501\n\n        Identifier consisting of a group of letters and/or numbers that is added to a postal address to assist the sorting of mail.   # noqa: E501\n\n        :return: The post_code of this PostalAddress.  # noqa: E501\n        :rtype: str\n        ';return self._post_code
	@post_code.setter
	def post_code(self,post_code):
		'Sets the post_code of this PostalAddress.\n\n        Identifier consisting of a group of letters and/or numbers that is added to a postal address to assist the sorting of mail.   # noqa: E501\n\n        :param post_code: The post_code of this PostalAddress.  # noqa: E501\n        :type: str\n        ';A=post_code
		if A is not _A and len(A)>16:raise ValueError('Invalid value for `post_code`, length must be less than or equal to `16`')
		if A is not _A and len(A)<1:raise ValueError('Invalid value for `post_code`, length must be greater than or equal to `1`')
		self._post_code=A
	@property
	def town_name(self):'Gets the town_name of this PostalAddress.  # noqa: E501\n\n        Name of a built-up area, with defined boundaries, and a local government.  # noqa: E501\n\n        :return: The town_name of this PostalAddress.  # noqa: E501\n        :rtype: str\n        ';return self._town_name
	@town_name.setter
	def town_name(self,town_name):
		'Sets the town_name of this PostalAddress.\n\n        Name of a built-up area, with defined boundaries, and a local government.  # noqa: E501\n\n        :param town_name: The town_name of this PostalAddress.  # noqa: E501\n        :type: str\n        ';A=town_name
		if A is not _A and len(A)>35:raise ValueError('Invalid value for `town_name`, length must be less than or equal to `35`')
		if A is not _A and len(A)<1:raise ValueError('Invalid value for `town_name`, length must be greater than or equal to `1`')
		self._town_name=A
	@property
	def country_sub_division(self):'Gets the country_sub_division of this PostalAddress.  # noqa: E501\n\n        Identifies a subdivision of a country such as state, region, county.  # noqa: E501\n\n        :return: The country_sub_division of this PostalAddress.  # noqa: E501\n        :rtype: str\n        ';return self._country_sub_division
	@country_sub_division.setter
	def country_sub_division(self,country_sub_division):
		'Sets the country_sub_division of this PostalAddress.\n\n        Identifies a subdivision of a country such as state, region, county.  # noqa: E501\n\n        :param country_sub_division: The country_sub_division of this PostalAddress.  # noqa: E501\n        :type: str\n        ';A=country_sub_division
		if A is not _A and len(A)>35:raise ValueError('Invalid value for `country_sub_division`, length must be less than or equal to `35`')
		if A is not _A and len(A)<1:raise ValueError('Invalid value for `country_sub_division`, length must be greater than or equal to `1`')
		self._country_sub_division=A
	@property
	def country(self):"Gets the country of this PostalAddress.  # noqa: E501\n\n        ISO20022: Country in which a person resides (the place of a person's home). In the case of a company, it is the country from which the affairs of that company are directed.   # noqa: E501\n\n        :return: The country of this PostalAddress.  # noqa: E501\n        :rtype: str\n        ";return self._country
	@country.setter
	def country(self,country):
		"Sets the country of this PostalAddress.\n\n        ISO20022: Country in which a person resides (the place of a person's home). In the case of a company, it is the country from which the affairs of that company are directed.   # noqa: E501\n\n        :param country: The country of this PostalAddress.  # noqa: E501\n        :type: str\n        ";A=country
		if A is _A:raise ValueError('Invalid value for `country`, must not be `None`')
		if A is not _A and not re.search('^([A-Z]{2,2})$',A):raise ValueError('Invalid value for `country`, must be a follow pattern or equal to `/^([A-Z]{2,2})$/`')
		self._country=A
	@property
	def address_line(self):'Gets the address_line of this PostalAddress.  # noqa: E501\n\n        Unstructured address. The two lines must embed zip code and town name  # noqa: E501\n\n        :return: The address_line of this PostalAddress.  # noqa: E501\n        :rtype: list[str]\n        ';return self._address_line
	@address_line.setter
	def address_line(self,address_line):'Sets the address_line of this PostalAddress.\n\n        Unstructured address. The two lines must embed zip code and town name  # noqa: E501\n\n        :param address_line: The address_line of this PostalAddress.  # noqa: E501\n        :type: list[str]\n        ';self._address_line=address_line
	def to_dict(D):
		'Returns the model properties as a dict';E='to_dict';B={}
		for (C,G) in D.swagger_types.items():
			A=getattr(D,C)
			if isinstance(A,list):B[C]=list(map(lambda x:x.to_dict()if hasattr(x,E)else x,A))
			elif hasattr(A,E):B[C]=A.to_dict()
			elif isinstance(A,dict):B[C]=dict(map(lambda item:(item[0],item[1].to_dict())if hasattr(item[1],E)else item,A.items()))
			else:B[C]=A
		if issubclass(PostalAddress,dict):
			for (F,A) in D.items():B[F]=A
		return B
	def to_str(A):'Returns the string representation of the model';return pprint.pformat(A.to_dict())
	def __repr__(A):'For `print` and `pprint`';return A.to_str()
	def __eq__(B,other):
		'Returns true if both objects are equal';A=other
		if not isinstance(A,PostalAddress):return False
		return B.__dict__==A.__dict__
	def __ne__(A,other):'Returns true if both objects are not equal';return not A==other