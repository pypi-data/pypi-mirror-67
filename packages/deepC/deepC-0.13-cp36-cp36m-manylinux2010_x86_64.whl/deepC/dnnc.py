# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_dnnc')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_dnnc')
    _dnnc = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_dnnc', [dirname(__file__)])
        except ImportError:
            import _dnnc
            return _dnnc
        try:
            _mod = imp.load_module('_dnnc', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _dnnc = swig_import_helper()
    del swig_import_helper
else:
    import _dnnc
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

class SwigPyIterator(_object):
    """Proxy of C++ swig::SwigPyIterator class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _dnnc.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self):
        """
        value(self) -> PyObject *

        Parameters
        ----------
        self: swig::SwigPyIterator const *

        """
        return _dnnc.SwigPyIterator_value(self)


    def incr(self, n=1):
        """
        incr(self, n=1) -> SwigPyIterator

        Parameters
        ----------
        n: size_t

        incr(self) -> SwigPyIterator

        Parameters
        ----------
        self: swig::SwigPyIterator *

        """
        return _dnnc.SwigPyIterator_incr(self, n)


    def decr(self, n=1):
        """
        decr(self, n=1) -> SwigPyIterator

        Parameters
        ----------
        n: size_t

        decr(self) -> SwigPyIterator

        Parameters
        ----------
        self: swig::SwigPyIterator *

        """
        return _dnnc.SwigPyIterator_decr(self, n)


    def distance(self, x):
        """
        distance(self, x) -> ptrdiff_t

        Parameters
        ----------
        x: swig::SwigPyIterator const &

        """
        return _dnnc.SwigPyIterator_distance(self, x)


    def equal(self, x):
        """
        equal(self, x) -> bool

        Parameters
        ----------
        x: swig::SwigPyIterator const &

        """
        return _dnnc.SwigPyIterator_equal(self, x)


    def copy(self):
        """
        copy(self) -> SwigPyIterator

        Parameters
        ----------
        self: swig::SwigPyIterator const *

        """
        return _dnnc.SwigPyIterator_copy(self)


    def next(self):
        """
        next(self) -> PyObject *

        Parameters
        ----------
        self: swig::SwigPyIterator *

        """
        return _dnnc.SwigPyIterator_next(self)


    def __next__(self):
        """
        __next__(self) -> PyObject *

        Parameters
        ----------
        self: swig::SwigPyIterator *

        """
        return _dnnc.SwigPyIterator___next__(self)


    def previous(self):
        """
        previous(self) -> PyObject *

        Parameters
        ----------
        self: swig::SwigPyIterator *

        """
        return _dnnc.SwigPyIterator_previous(self)


    def advance(self, n):
        """
        advance(self, n) -> SwigPyIterator

        Parameters
        ----------
        n: ptrdiff_t

        """
        return _dnnc.SwigPyIterator_advance(self, n)


    def __eq__(self, x):
        """
        __eq__(self, x) -> bool

        Parameters
        ----------
        x: swig::SwigPyIterator const &

        """
        return _dnnc.SwigPyIterator___eq__(self, x)


    def __ne__(self, x):
        """
        __ne__(self, x) -> bool

        Parameters
        ----------
        x: swig::SwigPyIterator const &

        """
        return _dnnc.SwigPyIterator___ne__(self, x)


    def __iadd__(self, n):
        """
        __iadd__(self, n) -> SwigPyIterator

        Parameters
        ----------
        n: ptrdiff_t

        """
        return _dnnc.SwigPyIterator___iadd__(self, n)


    def __isub__(self, n):
        """
        __isub__(self, n) -> SwigPyIterator

        Parameters
        ----------
        n: ptrdiff_t

        """
        return _dnnc.SwigPyIterator___isub__(self, n)


    def __add__(self, n):
        """
        __add__(self, n) -> SwigPyIterator

        Parameters
        ----------
        n: ptrdiff_t

        """
        return _dnnc.SwigPyIterator___add__(self, n)


    def __sub__(self, *args):
        """
        __sub__(self, n) -> SwigPyIterator

        Parameters
        ----------
        n: ptrdiff_t

        __sub__(self, x) -> ptrdiff_t

        Parameters
        ----------
        x: swig::SwigPyIterator const &

        """
        return _dnnc.SwigPyIterator___sub__(self, *args)

    def __iter__(self):
        return self
SwigPyIterator_swigregister = _dnnc.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

SHARED_PTR_DISOWN = _dnnc.SHARED_PTR_DISOWN
class vectorBool(_object):
    """Proxy of C++ std::vector<(bool)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectorBool, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectorBool, name)
    __repr__ = _swig_repr

    def iterator(self):
        """
        iterator(self) -> SwigPyIterator

        Parameters
        ----------
        self: std::vector< bool > *

        """
        return _dnnc.vectorBool_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """
        __nonzero__(self) -> bool

        Parameters
        ----------
        self: std::vector< bool > const *

        """
        return _dnnc.vectorBool___nonzero__(self)


    def __bool__(self):
        """
        __bool__(self) -> bool

        Parameters
        ----------
        self: std::vector< bool > const *

        """
        return _dnnc.vectorBool___bool__(self)


    def __len__(self):
        """
        __len__(self) -> std::vector< bool >::size_type

        Parameters
        ----------
        self: std::vector< bool > const *

        """
        return _dnnc.vectorBool___len__(self)


    def __getslice__(self, i, j):
        """
        __getslice__(self, i, j) -> vectorBool

        Parameters
        ----------
        i: std::vector< bool >::difference_type
        j: std::vector< bool >::difference_type

        """
        return _dnnc.vectorBool___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< bool >::difference_type
        j: std::vector< bool >::difference_type

        __setslice__(self, i, j, v)

        Parameters
        ----------
        i: std::vector< bool >::difference_type
        j: std::vector< bool >::difference_type
        v: std::vector< bool,std::allocator< bool > > const &

        """
        return _dnnc.vectorBool___setslice__(self, *args)


    def __delslice__(self, i, j):
        """
        __delslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< bool >::difference_type
        j: std::vector< bool >::difference_type

        """
        return _dnnc.vectorBool___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(self, i)

        Parameters
        ----------
        i: std::vector< bool >::difference_type

        __delitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        """
        return _dnnc.vectorBool___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(self, slice) -> vectorBool

        Parameters
        ----------
        slice: PySliceObject *

        __getitem__(self, i) -> std::vector< bool >::value_type

        Parameters
        ----------
        i: std::vector< bool >::difference_type

        """
        return _dnnc.vectorBool___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(self, slice, v)

        Parameters
        ----------
        slice: PySliceObject *
        v: std::vector< bool,std::allocator< bool > > const &

        __setitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        __setitem__(self, i, x)

        Parameters
        ----------
        i: std::vector< bool >::difference_type
        x: std::vector< bool >::value_type

        """
        return _dnnc.vectorBool___setitem__(self, *args)


    def pop(self):
        """
        pop(self) -> std::vector< bool >::value_type

        Parameters
        ----------
        self: std::vector< bool > *

        """
        return _dnnc.vectorBool_pop(self)


    def append(self, x):
        """
        append(self, x)

        Parameters
        ----------
        x: std::vector< bool >::value_type

        """
        return _dnnc.vectorBool_append(self, x)


    def empty(self):
        """
        empty(self) -> bool

        Parameters
        ----------
        self: std::vector< bool > const *

        """
        return _dnnc.vectorBool_empty(self)


    def size(self):
        """
        size(self) -> std::vector< bool >::size_type

        Parameters
        ----------
        self: std::vector< bool > const *

        """
        return _dnnc.vectorBool_size(self)


    def swap(self, v):
        """
        swap(self, v)

        Parameters
        ----------
        v: std::vector< bool > &

        """
        return _dnnc.vectorBool_swap(self, v)


    def begin(self):
        """
        begin(self) -> std::vector< bool >::iterator

        Parameters
        ----------
        self: std::vector< bool > *

        """
        return _dnnc.vectorBool_begin(self)


    def end(self):
        """
        end(self) -> std::vector< bool >::iterator

        Parameters
        ----------
        self: std::vector< bool > *

        """
        return _dnnc.vectorBool_end(self)


    def rbegin(self):
        """
        rbegin(self) -> std::vector< bool >::reverse_iterator

        Parameters
        ----------
        self: std::vector< bool > *

        """
        return _dnnc.vectorBool_rbegin(self)


    def rend(self):
        """
        rend(self) -> std::vector< bool >::reverse_iterator

        Parameters
        ----------
        self: std::vector< bool > *

        """
        return _dnnc.vectorBool_rend(self)


    def clear(self):
        """
        clear(self)

        Parameters
        ----------
        self: std::vector< bool > *

        """
        return _dnnc.vectorBool_clear(self)


    def get_allocator(self):
        """
        get_allocator(self) -> std::vector< bool >::allocator_type

        Parameters
        ----------
        self: std::vector< bool > const *

        """
        return _dnnc.vectorBool_get_allocator(self)


    def pop_back(self):
        """
        pop_back(self)

        Parameters
        ----------
        self: std::vector< bool > *

        """
        return _dnnc.vectorBool_pop_back(self)


    def erase(self, *args):
        """
        erase(self, pos) -> std::vector< bool >::iterator

        Parameters
        ----------
        pos: std::vector< bool >::iterator

        erase(self, first, last) -> std::vector< bool >::iterator

        Parameters
        ----------
        first: std::vector< bool >::iterator
        last: std::vector< bool >::iterator

        """
        return _dnnc.vectorBool_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(self) -> vectorBool
        __init__(self, arg2) -> vectorBool

        Parameters
        ----------
        arg2: std::vector< bool > const &

        __init__(self, size) -> vectorBool

        Parameters
        ----------
        size: std::vector< bool >::size_type

        __init__(self, size, value) -> vectorBool

        Parameters
        ----------
        size: std::vector< bool >::size_type
        value: std::vector< bool >::value_type

        """
        this = _dnnc.new_vectorBool(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """
        push_back(self, x)

        Parameters
        ----------
        x: std::vector< bool >::value_type

        """
        return _dnnc.vectorBool_push_back(self, x)


    def front(self):
        """
        front(self) -> std::vector< bool >::value_type

        Parameters
        ----------
        self: std::vector< bool > const *

        """
        return _dnnc.vectorBool_front(self)


    def back(self):
        """
        back(self) -> std::vector< bool >::value_type

        Parameters
        ----------
        self: std::vector< bool > const *

        """
        return _dnnc.vectorBool_back(self)


    def assign(self, n, x):
        """
        assign(self, n, x)

        Parameters
        ----------
        n: std::vector< bool >::size_type
        x: std::vector< bool >::value_type

        """
        return _dnnc.vectorBool_assign(self, n, x)


    def resize(self, *args):
        """
        resize(self, new_size)

        Parameters
        ----------
        new_size: std::vector< bool >::size_type

        resize(self, new_size, x)

        Parameters
        ----------
        new_size: std::vector< bool >::size_type
        x: std::vector< bool >::value_type

        """
        return _dnnc.vectorBool_resize(self, *args)


    def insert(self, *args):
        """
        insert(self, pos, x) -> std::vector< bool >::iterator

        Parameters
        ----------
        pos: std::vector< bool >::iterator
        x: std::vector< bool >::value_type

        insert(self, pos, n, x)

        Parameters
        ----------
        pos: std::vector< bool >::iterator
        n: std::vector< bool >::size_type
        x: std::vector< bool >::value_type

        """
        return _dnnc.vectorBool_insert(self, *args)


    def reserve(self, n):
        """
        reserve(self, n)

        Parameters
        ----------
        n: std::vector< bool >::size_type

        """
        return _dnnc.vectorBool_reserve(self, n)


    def capacity(self):
        """
        capacity(self) -> std::vector< bool >::size_type

        Parameters
        ----------
        self: std::vector< bool > const *

        """
        return _dnnc.vectorBool_capacity(self)

    __swig_destroy__ = _dnnc.delete_vectorBool
    __del__ = lambda self: None
vectorBool_swigregister = _dnnc.vectorBool_swigregister
vectorBool_swigregister(vectorBool)

class vectorStr(_object):
    """Proxy of C++ std::vector<(String)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectorStr, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectorStr, name)
    __repr__ = _swig_repr

    def iterator(self):
        """
        iterator(self) -> SwigPyIterator

        Parameters
        ----------
        self: std::vector< String > *

        """
        return _dnnc.vectorStr_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """
        __nonzero__(self) -> bool

        Parameters
        ----------
        self: std::vector< String > const *

        """
        return _dnnc.vectorStr___nonzero__(self)


    def __bool__(self):
        """
        __bool__(self) -> bool

        Parameters
        ----------
        self: std::vector< String > const *

        """
        return _dnnc.vectorStr___bool__(self)


    def __len__(self):
        """
        __len__(self) -> std::vector< std::string >::size_type

        Parameters
        ----------
        self: std::vector< String > const *

        """
        return _dnnc.vectorStr___len__(self)


    def __getslice__(self, i, j):
        """
        __getslice__(self, i, j) -> vectorStr

        Parameters
        ----------
        i: std::vector< std::string >::difference_type
        j: std::vector< std::string >::difference_type

        """
        return _dnnc.vectorStr___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< std::string >::difference_type
        j: std::vector< std::string >::difference_type

        __setslice__(self, i, j, v)

        Parameters
        ----------
        i: std::vector< std::string >::difference_type
        j: std::vector< std::string >::difference_type
        v: std::vector< std::string,std::allocator< std::string > > const &

        """
        return _dnnc.vectorStr___setslice__(self, *args)


    def __delslice__(self, i, j):
        """
        __delslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< std::string >::difference_type
        j: std::vector< std::string >::difference_type

        """
        return _dnnc.vectorStr___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(self, i)

        Parameters
        ----------
        i: std::vector< std::string >::difference_type

        __delitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        """
        return _dnnc.vectorStr___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(self, slice) -> vectorStr

        Parameters
        ----------
        slice: PySliceObject *

        __getitem__(self, i) -> std::vector< std::string >::value_type const &

        Parameters
        ----------
        i: std::vector< std::string >::difference_type

        """
        return _dnnc.vectorStr___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(self, slice, v)

        Parameters
        ----------
        slice: PySliceObject *
        v: std::vector< std::string,std::allocator< std::string > > const &

        __setitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        __setitem__(self, i, x)

        Parameters
        ----------
        i: std::vector< std::string >::difference_type
        x: std::vector< std::string >::value_type const &

        """
        return _dnnc.vectorStr___setitem__(self, *args)


    def pop(self):
        """
        pop(self) -> std::vector< std::string >::value_type

        Parameters
        ----------
        self: std::vector< String > *

        """
        return _dnnc.vectorStr_pop(self)


    def append(self, x):
        """
        append(self, x)

        Parameters
        ----------
        x: std::vector< std::string >::value_type const &

        """
        return _dnnc.vectorStr_append(self, x)


    def empty(self):
        """
        empty(self) -> bool

        Parameters
        ----------
        self: std::vector< String > const *

        """
        return _dnnc.vectorStr_empty(self)


    def size(self):
        """
        size(self) -> std::vector< std::string >::size_type

        Parameters
        ----------
        self: std::vector< String > const *

        """
        return _dnnc.vectorStr_size(self)


    def swap(self, v):
        """
        swap(self, v)

        Parameters
        ----------
        v: std::vector< String > &

        """
        return _dnnc.vectorStr_swap(self, v)


    def begin(self):
        """
        begin(self) -> std::vector< std::string >::iterator

        Parameters
        ----------
        self: std::vector< String > *

        """
        return _dnnc.vectorStr_begin(self)


    def end(self):
        """
        end(self) -> std::vector< std::string >::iterator

        Parameters
        ----------
        self: std::vector< String > *

        """
        return _dnnc.vectorStr_end(self)


    def rbegin(self):
        """
        rbegin(self) -> std::vector< std::string >::reverse_iterator

        Parameters
        ----------
        self: std::vector< String > *

        """
        return _dnnc.vectorStr_rbegin(self)


    def rend(self):
        """
        rend(self) -> std::vector< std::string >::reverse_iterator

        Parameters
        ----------
        self: std::vector< String > *

        """
        return _dnnc.vectorStr_rend(self)


    def clear(self):
        """
        clear(self)

        Parameters
        ----------
        self: std::vector< String > *

        """
        return _dnnc.vectorStr_clear(self)


    def get_allocator(self):
        """
        get_allocator(self) -> std::vector< std::string >::allocator_type

        Parameters
        ----------
        self: std::vector< String > const *

        """
        return _dnnc.vectorStr_get_allocator(self)


    def pop_back(self):
        """
        pop_back(self)

        Parameters
        ----------
        self: std::vector< String > *

        """
        return _dnnc.vectorStr_pop_back(self)


    def erase(self, *args):
        """
        erase(self, pos) -> std::vector< std::string >::iterator

        Parameters
        ----------
        pos: std::vector< std::string >::iterator

        erase(self, first, last) -> std::vector< std::string >::iterator

        Parameters
        ----------
        first: std::vector< std::string >::iterator
        last: std::vector< std::string >::iterator

        """
        return _dnnc.vectorStr_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(self) -> vectorStr
        __init__(self, arg2) -> vectorStr

        Parameters
        ----------
        arg2: std::vector< String > const &

        __init__(self, size) -> vectorStr

        Parameters
        ----------
        size: std::vector< std::string >::size_type

        __init__(self, size, value) -> vectorStr

        Parameters
        ----------
        size: std::vector< std::string >::size_type
        value: std::vector< std::string >::value_type const &

        """
        this = _dnnc.new_vectorStr(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """
        push_back(self, x)

        Parameters
        ----------
        x: std::vector< std::string >::value_type const &

        """
        return _dnnc.vectorStr_push_back(self, x)


    def front(self):
        """
        front(self) -> std::vector< std::string >::value_type const &

        Parameters
        ----------
        self: std::vector< String > const *

        """
        return _dnnc.vectorStr_front(self)


    def back(self):
        """
        back(self) -> std::vector< std::string >::value_type const &

        Parameters
        ----------
        self: std::vector< String > const *

        """
        return _dnnc.vectorStr_back(self)


    def assign(self, n, x):
        """
        assign(self, n, x)

        Parameters
        ----------
        n: std::vector< std::string >::size_type
        x: std::vector< std::string >::value_type const &

        """
        return _dnnc.vectorStr_assign(self, n, x)


    def resize(self, *args):
        """
        resize(self, new_size)

        Parameters
        ----------
        new_size: std::vector< std::string >::size_type

        resize(self, new_size, x)

        Parameters
        ----------
        new_size: std::vector< std::string >::size_type
        x: std::vector< std::string >::value_type const &

        """
        return _dnnc.vectorStr_resize(self, *args)


    def insert(self, *args):
        """
        insert(self, pos, x) -> std::vector< std::string >::iterator

        Parameters
        ----------
        pos: std::vector< std::string >::iterator
        x: std::vector< std::string >::value_type const &

        insert(self, pos, n, x)

        Parameters
        ----------
        pos: std::vector< std::string >::iterator
        n: std::vector< std::string >::size_type
        x: std::vector< std::string >::value_type const &

        """
        return _dnnc.vectorStr_insert(self, *args)


    def reserve(self, n):
        """
        reserve(self, n)

        Parameters
        ----------
        n: std::vector< std::string >::size_type

        """
        return _dnnc.vectorStr_reserve(self, n)


    def capacity(self):
        """
        capacity(self) -> std::vector< std::string >::size_type

        Parameters
        ----------
        self: std::vector< String > const *

        """
        return _dnnc.vectorStr_capacity(self)

    __swig_destroy__ = _dnnc.delete_vectorStr
    __del__ = lambda self: None
vectorStr_swigregister = _dnnc.vectorStr_swigregister
vectorStr_swigregister(vectorStr)

class vectorInt(_object):
    """Proxy of C++ std::vector<(int)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectorInt, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectorInt, name)
    __repr__ = _swig_repr

    def iterator(self):
        """
        iterator(self) -> SwigPyIterator

        Parameters
        ----------
        self: std::vector< int > *

        """
        return _dnnc.vectorInt_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """
        __nonzero__(self) -> bool

        Parameters
        ----------
        self: std::vector< int > const *

        """
        return _dnnc.vectorInt___nonzero__(self)


    def __bool__(self):
        """
        __bool__(self) -> bool

        Parameters
        ----------
        self: std::vector< int > const *

        """
        return _dnnc.vectorInt___bool__(self)


    def __len__(self):
        """
        __len__(self) -> std::vector< int >::size_type

        Parameters
        ----------
        self: std::vector< int > const *

        """
        return _dnnc.vectorInt___len__(self)


    def __getslice__(self, i, j):
        """
        __getslice__(self, i, j) -> vectorInt

        Parameters
        ----------
        i: std::vector< int >::difference_type
        j: std::vector< int >::difference_type

        """
        return _dnnc.vectorInt___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< int >::difference_type
        j: std::vector< int >::difference_type

        __setslice__(self, i, j, v)

        Parameters
        ----------
        i: std::vector< int >::difference_type
        j: std::vector< int >::difference_type
        v: std::vector< int,std::allocator< int > > const &

        """
        return _dnnc.vectorInt___setslice__(self, *args)


    def __delslice__(self, i, j):
        """
        __delslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< int >::difference_type
        j: std::vector< int >::difference_type

        """
        return _dnnc.vectorInt___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(self, i)

        Parameters
        ----------
        i: std::vector< int >::difference_type

        __delitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        """
        return _dnnc.vectorInt___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(self, slice) -> vectorInt

        Parameters
        ----------
        slice: PySliceObject *

        __getitem__(self, i) -> std::vector< int >::value_type const &

        Parameters
        ----------
        i: std::vector< int >::difference_type

        """
        return _dnnc.vectorInt___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(self, slice, v)

        Parameters
        ----------
        slice: PySliceObject *
        v: std::vector< int,std::allocator< int > > const &

        __setitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        __setitem__(self, i, x)

        Parameters
        ----------
        i: std::vector< int >::difference_type
        x: std::vector< int >::value_type const &

        """
        return _dnnc.vectorInt___setitem__(self, *args)


    def pop(self):
        """
        pop(self) -> std::vector< int >::value_type

        Parameters
        ----------
        self: std::vector< int > *

        """
        return _dnnc.vectorInt_pop(self)


    def append(self, x):
        """
        append(self, x)

        Parameters
        ----------
        x: std::vector< int >::value_type const &

        """
        return _dnnc.vectorInt_append(self, x)


    def empty(self):
        """
        empty(self) -> bool

        Parameters
        ----------
        self: std::vector< int > const *

        """
        return _dnnc.vectorInt_empty(self)


    def size(self):
        """
        size(self) -> std::vector< int >::size_type

        Parameters
        ----------
        self: std::vector< int > const *

        """
        return _dnnc.vectorInt_size(self)


    def swap(self, v):
        """
        swap(self, v)

        Parameters
        ----------
        v: std::vector< int > &

        """
        return _dnnc.vectorInt_swap(self, v)


    def begin(self):
        """
        begin(self) -> std::vector< int >::iterator

        Parameters
        ----------
        self: std::vector< int > *

        """
        return _dnnc.vectorInt_begin(self)


    def end(self):
        """
        end(self) -> std::vector< int >::iterator

        Parameters
        ----------
        self: std::vector< int > *

        """
        return _dnnc.vectorInt_end(self)


    def rbegin(self):
        """
        rbegin(self) -> std::vector< int >::reverse_iterator

        Parameters
        ----------
        self: std::vector< int > *

        """
        return _dnnc.vectorInt_rbegin(self)


    def rend(self):
        """
        rend(self) -> std::vector< int >::reverse_iterator

        Parameters
        ----------
        self: std::vector< int > *

        """
        return _dnnc.vectorInt_rend(self)


    def clear(self):
        """
        clear(self)

        Parameters
        ----------
        self: std::vector< int > *

        """
        return _dnnc.vectorInt_clear(self)


    def get_allocator(self):
        """
        get_allocator(self) -> std::vector< int >::allocator_type

        Parameters
        ----------
        self: std::vector< int > const *

        """
        return _dnnc.vectorInt_get_allocator(self)


    def pop_back(self):
        """
        pop_back(self)

        Parameters
        ----------
        self: std::vector< int > *

        """
        return _dnnc.vectorInt_pop_back(self)


    def erase(self, *args):
        """
        erase(self, pos) -> std::vector< int >::iterator

        Parameters
        ----------
        pos: std::vector< int >::iterator

        erase(self, first, last) -> std::vector< int >::iterator

        Parameters
        ----------
        first: std::vector< int >::iterator
        last: std::vector< int >::iterator

        """
        return _dnnc.vectorInt_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(self) -> vectorInt
        __init__(self, arg2) -> vectorInt

        Parameters
        ----------
        arg2: std::vector< int > const &

        __init__(self, size) -> vectorInt

        Parameters
        ----------
        size: std::vector< int >::size_type

        __init__(self, size, value) -> vectorInt

        Parameters
        ----------
        size: std::vector< int >::size_type
        value: std::vector< int >::value_type const &

        """
        this = _dnnc.new_vectorInt(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """
        push_back(self, x)

        Parameters
        ----------
        x: std::vector< int >::value_type const &

        """
        return _dnnc.vectorInt_push_back(self, x)


    def front(self):
        """
        front(self) -> std::vector< int >::value_type const &

        Parameters
        ----------
        self: std::vector< int > const *

        """
        return _dnnc.vectorInt_front(self)


    def back(self):
        """
        back(self) -> std::vector< int >::value_type const &

        Parameters
        ----------
        self: std::vector< int > const *

        """
        return _dnnc.vectorInt_back(self)


    def assign(self, n, x):
        """
        assign(self, n, x)

        Parameters
        ----------
        n: std::vector< int >::size_type
        x: std::vector< int >::value_type const &

        """
        return _dnnc.vectorInt_assign(self, n, x)


    def resize(self, *args):
        """
        resize(self, new_size)

        Parameters
        ----------
        new_size: std::vector< int >::size_type

        resize(self, new_size, x)

        Parameters
        ----------
        new_size: std::vector< int >::size_type
        x: std::vector< int >::value_type const &

        """
        return _dnnc.vectorInt_resize(self, *args)


    def insert(self, *args):
        """
        insert(self, pos, x) -> std::vector< int >::iterator

        Parameters
        ----------
        pos: std::vector< int >::iterator
        x: std::vector< int >::value_type const &

        insert(self, pos, n, x)

        Parameters
        ----------
        pos: std::vector< int >::iterator
        n: std::vector< int >::size_type
        x: std::vector< int >::value_type const &

        """
        return _dnnc.vectorInt_insert(self, *args)


    def reserve(self, n):
        """
        reserve(self, n)

        Parameters
        ----------
        n: std::vector< int >::size_type

        """
        return _dnnc.vectorInt_reserve(self, n)


    def capacity(self):
        """
        capacity(self) -> std::vector< int >::size_type

        Parameters
        ----------
        self: std::vector< int > const *

        """
        return _dnnc.vectorInt_capacity(self)

    __swig_destroy__ = _dnnc.delete_vectorInt
    __del__ = lambda self: None
vectorInt_swigregister = _dnnc.vectorInt_swigregister
vectorInt_swigregister(vectorInt)

class vectorSizeT(_object):
    """Proxy of C++ std::vector<(size_t)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectorSizeT, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectorSizeT, name)
    __repr__ = _swig_repr

    def iterator(self):
        """
        iterator(self) -> SwigPyIterator

        Parameters
        ----------
        self: std::vector< size_t > *

        """
        return _dnnc.vectorSizeT_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """
        __nonzero__(self) -> bool

        Parameters
        ----------
        self: std::vector< size_t > const *

        """
        return _dnnc.vectorSizeT___nonzero__(self)


    def __bool__(self):
        """
        __bool__(self) -> bool

        Parameters
        ----------
        self: std::vector< size_t > const *

        """
        return _dnnc.vectorSizeT___bool__(self)


    def __len__(self):
        """
        __len__(self) -> std::vector< size_t >::size_type

        Parameters
        ----------
        self: std::vector< size_t > const *

        """
        return _dnnc.vectorSizeT___len__(self)


    def __getslice__(self, i, j):
        """
        __getslice__(self, i, j) -> vectorSizeT

        Parameters
        ----------
        i: std::vector< size_t >::difference_type
        j: std::vector< size_t >::difference_type

        """
        return _dnnc.vectorSizeT___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< size_t >::difference_type
        j: std::vector< size_t >::difference_type

        __setslice__(self, i, j, v)

        Parameters
        ----------
        i: std::vector< size_t >::difference_type
        j: std::vector< size_t >::difference_type
        v: std::vector< size_t,std::allocator< size_t > > const &

        """
        return _dnnc.vectorSizeT___setslice__(self, *args)


    def __delslice__(self, i, j):
        """
        __delslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< size_t >::difference_type
        j: std::vector< size_t >::difference_type

        """
        return _dnnc.vectorSizeT___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(self, i)

        Parameters
        ----------
        i: std::vector< size_t >::difference_type

        __delitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        """
        return _dnnc.vectorSizeT___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(self, slice) -> vectorSizeT

        Parameters
        ----------
        slice: PySliceObject *

        __getitem__(self, i) -> std::vector< size_t >::value_type const &

        Parameters
        ----------
        i: std::vector< size_t >::difference_type

        """
        return _dnnc.vectorSizeT___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(self, slice, v)

        Parameters
        ----------
        slice: PySliceObject *
        v: std::vector< size_t,std::allocator< size_t > > const &

        __setitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        __setitem__(self, i, x)

        Parameters
        ----------
        i: std::vector< size_t >::difference_type
        x: std::vector< size_t >::value_type const &

        """
        return _dnnc.vectorSizeT___setitem__(self, *args)


    def pop(self):
        """
        pop(self) -> std::vector< size_t >::value_type

        Parameters
        ----------
        self: std::vector< size_t > *

        """
        return _dnnc.vectorSizeT_pop(self)


    def append(self, x):
        """
        append(self, x)

        Parameters
        ----------
        x: std::vector< size_t >::value_type const &

        """
        return _dnnc.vectorSizeT_append(self, x)


    def empty(self):
        """
        empty(self) -> bool

        Parameters
        ----------
        self: std::vector< size_t > const *

        """
        return _dnnc.vectorSizeT_empty(self)


    def size(self):
        """
        size(self) -> std::vector< size_t >::size_type

        Parameters
        ----------
        self: std::vector< size_t > const *

        """
        return _dnnc.vectorSizeT_size(self)


    def swap(self, v):
        """
        swap(self, v)

        Parameters
        ----------
        v: std::vector< size_t > &

        """
        return _dnnc.vectorSizeT_swap(self, v)


    def begin(self):
        """
        begin(self) -> std::vector< size_t >::iterator

        Parameters
        ----------
        self: std::vector< size_t > *

        """
        return _dnnc.vectorSizeT_begin(self)


    def end(self):
        """
        end(self) -> std::vector< size_t >::iterator

        Parameters
        ----------
        self: std::vector< size_t > *

        """
        return _dnnc.vectorSizeT_end(self)


    def rbegin(self):
        """
        rbegin(self) -> std::vector< size_t >::reverse_iterator

        Parameters
        ----------
        self: std::vector< size_t > *

        """
        return _dnnc.vectorSizeT_rbegin(self)


    def rend(self):
        """
        rend(self) -> std::vector< size_t >::reverse_iterator

        Parameters
        ----------
        self: std::vector< size_t > *

        """
        return _dnnc.vectorSizeT_rend(self)


    def clear(self):
        """
        clear(self)

        Parameters
        ----------
        self: std::vector< size_t > *

        """
        return _dnnc.vectorSizeT_clear(self)


    def get_allocator(self):
        """
        get_allocator(self) -> std::vector< size_t >::allocator_type

        Parameters
        ----------
        self: std::vector< size_t > const *

        """
        return _dnnc.vectorSizeT_get_allocator(self)


    def pop_back(self):
        """
        pop_back(self)

        Parameters
        ----------
        self: std::vector< size_t > *

        """
        return _dnnc.vectorSizeT_pop_back(self)


    def erase(self, *args):
        """
        erase(self, pos) -> std::vector< size_t >::iterator

        Parameters
        ----------
        pos: std::vector< size_t >::iterator

        erase(self, first, last) -> std::vector< size_t >::iterator

        Parameters
        ----------
        first: std::vector< size_t >::iterator
        last: std::vector< size_t >::iterator

        """
        return _dnnc.vectorSizeT_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(self) -> vectorSizeT
        __init__(self, arg2) -> vectorSizeT

        Parameters
        ----------
        arg2: std::vector< size_t > const &

        __init__(self, size) -> vectorSizeT

        Parameters
        ----------
        size: std::vector< size_t >::size_type

        __init__(self, size, value) -> vectorSizeT

        Parameters
        ----------
        size: std::vector< size_t >::size_type
        value: std::vector< size_t >::value_type const &

        """
        this = _dnnc.new_vectorSizeT(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """
        push_back(self, x)

        Parameters
        ----------
        x: std::vector< size_t >::value_type const &

        """
        return _dnnc.vectorSizeT_push_back(self, x)


    def front(self):
        """
        front(self) -> std::vector< size_t >::value_type const &

        Parameters
        ----------
        self: std::vector< size_t > const *

        """
        return _dnnc.vectorSizeT_front(self)


    def back(self):
        """
        back(self) -> std::vector< size_t >::value_type const &

        Parameters
        ----------
        self: std::vector< size_t > const *

        """
        return _dnnc.vectorSizeT_back(self)


    def assign(self, n, x):
        """
        assign(self, n, x)

        Parameters
        ----------
        n: std::vector< size_t >::size_type
        x: std::vector< size_t >::value_type const &

        """
        return _dnnc.vectorSizeT_assign(self, n, x)


    def resize(self, *args):
        """
        resize(self, new_size)

        Parameters
        ----------
        new_size: std::vector< size_t >::size_type

        resize(self, new_size, x)

        Parameters
        ----------
        new_size: std::vector< size_t >::size_type
        x: std::vector< size_t >::value_type const &

        """
        return _dnnc.vectorSizeT_resize(self, *args)


    def insert(self, *args):
        """
        insert(self, pos, x) -> std::vector< size_t >::iterator

        Parameters
        ----------
        pos: std::vector< size_t >::iterator
        x: std::vector< size_t >::value_type const &

        insert(self, pos, n, x)

        Parameters
        ----------
        pos: std::vector< size_t >::iterator
        n: std::vector< size_t >::size_type
        x: std::vector< size_t >::value_type const &

        """
        return _dnnc.vectorSizeT_insert(self, *args)


    def reserve(self, n):
        """
        reserve(self, n)

        Parameters
        ----------
        n: std::vector< size_t >::size_type

        """
        return _dnnc.vectorSizeT_reserve(self, n)


    def capacity(self):
        """
        capacity(self) -> std::vector< size_t >::size_type

        Parameters
        ----------
        self: std::vector< size_t > const *

        """
        return _dnnc.vectorSizeT_capacity(self)

    __swig_destroy__ = _dnnc.delete_vectorSizeT
    __del__ = lambda self: None
vectorSizeT_swigregister = _dnnc.vectorSizeT_swigregister
vectorSizeT_swigregister(vectorSizeT)

class vectorFloat(_object):
    """Proxy of C++ std::vector<(float)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectorFloat, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectorFloat, name)
    __repr__ = _swig_repr

    def iterator(self):
        """
        iterator(self) -> SwigPyIterator

        Parameters
        ----------
        self: std::vector< float > *

        """
        return _dnnc.vectorFloat_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """
        __nonzero__(self) -> bool

        Parameters
        ----------
        self: std::vector< float > const *

        """
        return _dnnc.vectorFloat___nonzero__(self)


    def __bool__(self):
        """
        __bool__(self) -> bool

        Parameters
        ----------
        self: std::vector< float > const *

        """
        return _dnnc.vectorFloat___bool__(self)


    def __len__(self):
        """
        __len__(self) -> std::vector< float >::size_type

        Parameters
        ----------
        self: std::vector< float > const *

        """
        return _dnnc.vectorFloat___len__(self)


    def __getslice__(self, i, j):
        """
        __getslice__(self, i, j) -> vectorFloat

        Parameters
        ----------
        i: std::vector< float >::difference_type
        j: std::vector< float >::difference_type

        """
        return _dnnc.vectorFloat___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< float >::difference_type
        j: std::vector< float >::difference_type

        __setslice__(self, i, j, v)

        Parameters
        ----------
        i: std::vector< float >::difference_type
        j: std::vector< float >::difference_type
        v: std::vector< float,std::allocator< float > > const &

        """
        return _dnnc.vectorFloat___setslice__(self, *args)


    def __delslice__(self, i, j):
        """
        __delslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< float >::difference_type
        j: std::vector< float >::difference_type

        """
        return _dnnc.vectorFloat___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(self, i)

        Parameters
        ----------
        i: std::vector< float >::difference_type

        __delitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        """
        return _dnnc.vectorFloat___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(self, slice) -> vectorFloat

        Parameters
        ----------
        slice: PySliceObject *

        __getitem__(self, i) -> std::vector< float >::value_type const &

        Parameters
        ----------
        i: std::vector< float >::difference_type

        """
        return _dnnc.vectorFloat___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(self, slice, v)

        Parameters
        ----------
        slice: PySliceObject *
        v: std::vector< float,std::allocator< float > > const &

        __setitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        __setitem__(self, i, x)

        Parameters
        ----------
        i: std::vector< float >::difference_type
        x: std::vector< float >::value_type const &

        """
        return _dnnc.vectorFloat___setitem__(self, *args)


    def pop(self):
        """
        pop(self) -> std::vector< float >::value_type

        Parameters
        ----------
        self: std::vector< float > *

        """
        return _dnnc.vectorFloat_pop(self)


    def append(self, x):
        """
        append(self, x)

        Parameters
        ----------
        x: std::vector< float >::value_type const &

        """
        return _dnnc.vectorFloat_append(self, x)


    def empty(self):
        """
        empty(self) -> bool

        Parameters
        ----------
        self: std::vector< float > const *

        """
        return _dnnc.vectorFloat_empty(self)


    def size(self):
        """
        size(self) -> std::vector< float >::size_type

        Parameters
        ----------
        self: std::vector< float > const *

        """
        return _dnnc.vectorFloat_size(self)


    def swap(self, v):
        """
        swap(self, v)

        Parameters
        ----------
        v: std::vector< float > &

        """
        return _dnnc.vectorFloat_swap(self, v)


    def begin(self):
        """
        begin(self) -> std::vector< float >::iterator

        Parameters
        ----------
        self: std::vector< float > *

        """
        return _dnnc.vectorFloat_begin(self)


    def end(self):
        """
        end(self) -> std::vector< float >::iterator

        Parameters
        ----------
        self: std::vector< float > *

        """
        return _dnnc.vectorFloat_end(self)


    def rbegin(self):
        """
        rbegin(self) -> std::vector< float >::reverse_iterator

        Parameters
        ----------
        self: std::vector< float > *

        """
        return _dnnc.vectorFloat_rbegin(self)


    def rend(self):
        """
        rend(self) -> std::vector< float >::reverse_iterator

        Parameters
        ----------
        self: std::vector< float > *

        """
        return _dnnc.vectorFloat_rend(self)


    def clear(self):
        """
        clear(self)

        Parameters
        ----------
        self: std::vector< float > *

        """
        return _dnnc.vectorFloat_clear(self)


    def get_allocator(self):
        """
        get_allocator(self) -> std::vector< float >::allocator_type

        Parameters
        ----------
        self: std::vector< float > const *

        """
        return _dnnc.vectorFloat_get_allocator(self)


    def pop_back(self):
        """
        pop_back(self)

        Parameters
        ----------
        self: std::vector< float > *

        """
        return _dnnc.vectorFloat_pop_back(self)


    def erase(self, *args):
        """
        erase(self, pos) -> std::vector< float >::iterator

        Parameters
        ----------
        pos: std::vector< float >::iterator

        erase(self, first, last) -> std::vector< float >::iterator

        Parameters
        ----------
        first: std::vector< float >::iterator
        last: std::vector< float >::iterator

        """
        return _dnnc.vectorFloat_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(self) -> vectorFloat
        __init__(self, arg2) -> vectorFloat

        Parameters
        ----------
        arg2: std::vector< float > const &

        __init__(self, size) -> vectorFloat

        Parameters
        ----------
        size: std::vector< float >::size_type

        __init__(self, size, value) -> vectorFloat

        Parameters
        ----------
        size: std::vector< float >::size_type
        value: std::vector< float >::value_type const &

        """
        this = _dnnc.new_vectorFloat(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """
        push_back(self, x)

        Parameters
        ----------
        x: std::vector< float >::value_type const &

        """
        return _dnnc.vectorFloat_push_back(self, x)


    def front(self):
        """
        front(self) -> std::vector< float >::value_type const &

        Parameters
        ----------
        self: std::vector< float > const *

        """
        return _dnnc.vectorFloat_front(self)


    def back(self):
        """
        back(self) -> std::vector< float >::value_type const &

        Parameters
        ----------
        self: std::vector< float > const *

        """
        return _dnnc.vectorFloat_back(self)


    def assign(self, n, x):
        """
        assign(self, n, x)

        Parameters
        ----------
        n: std::vector< float >::size_type
        x: std::vector< float >::value_type const &

        """
        return _dnnc.vectorFloat_assign(self, n, x)


    def resize(self, *args):
        """
        resize(self, new_size)

        Parameters
        ----------
        new_size: std::vector< float >::size_type

        resize(self, new_size, x)

        Parameters
        ----------
        new_size: std::vector< float >::size_type
        x: std::vector< float >::value_type const &

        """
        return _dnnc.vectorFloat_resize(self, *args)


    def insert(self, *args):
        """
        insert(self, pos, x) -> std::vector< float >::iterator

        Parameters
        ----------
        pos: std::vector< float >::iterator
        x: std::vector< float >::value_type const &

        insert(self, pos, n, x)

        Parameters
        ----------
        pos: std::vector< float >::iterator
        n: std::vector< float >::size_type
        x: std::vector< float >::value_type const &

        """
        return _dnnc.vectorFloat_insert(self, *args)


    def reserve(self, n):
        """
        reserve(self, n)

        Parameters
        ----------
        n: std::vector< float >::size_type

        """
        return _dnnc.vectorFloat_reserve(self, n)


    def capacity(self):
        """
        capacity(self) -> std::vector< float >::size_type

        Parameters
        ----------
        self: std::vector< float > const *

        """
        return _dnnc.vectorFloat_capacity(self)

    __swig_destroy__ = _dnnc.delete_vectorFloat
    __del__ = lambda self: None
vectorFloat_swigregister = _dnnc.vectorFloat_swigregister
vectorFloat_swigregister(vectorFloat)

_USE_EIGEN = _dnnc._USE_EIGEN
DNNC_TENSOR_MAX_EL = _dnnc.DNNC_TENSOR_MAX_EL
FS_PATH_SEPARATOR = _dnnc.FS_PATH_SEPARATOR
NOTYPE = _dnnc.NOTYPE
FLOAT = _dnnc.FLOAT
UINT8 = _dnnc.UINT8
INT8 = _dnnc.INT8
UINT16 = _dnnc.UINT16
INT16 = _dnnc.INT16
INT32 = _dnnc.INT32
INT64 = _dnnc.INT64
STRING = _dnnc.STRING
BOOL = _dnnc.BOOL
FLOAT16 = _dnnc.FLOAT16
DOUBLE = _dnnc.DOUBLE
UINT32 = _dnnc.UINT32
UINT64 = _dnnc.UINT64
COMPLEX64 = _dnnc.COMPLEX64
COMPLEX128 = _dnnc.COMPLEX128
BFLOAT16 = _dnnc.BFLOAT16
IR_DataType_NOTYPE = _dnnc.IR_DataType_NOTYPE
IR_DataType_FLOAT = _dnnc.IR_DataType_FLOAT
IR_DataType_UINT8 = _dnnc.IR_DataType_UINT8
IR_DataType_INT8 = _dnnc.IR_DataType_INT8
IR_DataType_UINT16 = _dnnc.IR_DataType_UINT16
IR_DataType_INT16 = _dnnc.IR_DataType_INT16
IR_DataType_INT32 = _dnnc.IR_DataType_INT32
IR_DataType_INT64 = _dnnc.IR_DataType_INT64
IR_DataType_STRING = _dnnc.IR_DataType_STRING
IR_DataType_BOOL = _dnnc.IR_DataType_BOOL
IR_DataType_FLOAT16 = _dnnc.IR_DataType_FLOAT16
IR_DataType_DOUBLE = _dnnc.IR_DataType_DOUBLE
IR_DataType_UINT32 = _dnnc.IR_DataType_UINT32
IR_DataType_UINT64 = _dnnc.IR_DataType_UINT64
IR_DataType_COMPLEX64 = _dnnc.IR_DataType_COMPLEX64
IR_DataType_COMPLEX128 = _dnnc.IR_DataType_COMPLEX128
IR_DataType_BFLOAT16 = _dnnc.IR_DataType_BFLOAT16
IR_DataType_TENSOR_BOOL = _dnnc.IR_DataType_TENSOR_BOOL
IR_DataType_TENSOR_INT = _dnnc.IR_DataType_TENSOR_INT
IR_DataType_TENSOR_FLOAT = _dnnc.IR_DataType_TENSOR_FLOAT
IR_DataType_GRAPH = _dnnc.IR_DataType_GRAPH

def dTypeName(*args):
    """
    dTypeName(v) -> char const

    Parameters
    ----------
    v: int8_t

    dTypeName(v) -> char const

    Parameters
    ----------
    v: bool

    dTypeName(v) -> char const

    Parameters
    ----------
    v: char

    dTypeName(v) -> char const

    Parameters
    ----------
    v: double

    dTypeName(v) -> char const

    Parameters
    ----------
    v: long double

    dTypeName(v) -> char const

    Parameters
    ----------
    v: float

    dTypeName(v) -> char const

    Parameters
    ----------
    v: uint8_t

    dTypeName(v) -> char const

    Parameters
    ----------
    v: int32_t

    dTypeName(v) -> char const

    Parameters
    ----------
    v: uint32_t

    dTypeName(v) -> char const

    Parameters
    ----------
    v: int64_t

    dTypeName(v) -> char const

    Parameters
    ----------
    v: uint64_t

    dTypeName(v) -> char const

    Parameters
    ----------
    v: int16_t

    dTypeName(v) -> char const *

    Parameters
    ----------
    v: uint16_t

    """
    return _dnnc.dTypeName(*args)

def getDNNC_DataType(stype):
    """
    getDNNC_DataType(stype) -> dnnc::DNNC_DataType

    Parameters
    ----------
    stype: std::string

    """
    return _dnnc.getDNNC_DataType(stype)

def getDNNC_DataTypeStr(dtype):
    """
    getDNNC_DataTypeStr(dtype) -> std::string

    Parameters
    ----------
    dtype: enum dnnc::DNNC_DataType

    """
    return _dnnc.getDNNC_DataTypeStr(dtype)

def getDNNC_IRType(stype):
    """
    getDNNC_IRType(stype) -> dnnc::IR_DataType

    Parameters
    ----------
    stype: std::string

    """
    return _dnnc.getDNNC_IRType(stype)

def getDNNC_IRTypeStr(dtype):
    """
    getDNNC_IRTypeStr(dtype) -> std::string

    Parameters
    ----------
    dtype: enum dnnc::IR_DataType

    """
    return _dnnc.getDNNC_IRTypeStr(dtype)

def typePrecedence(ty1, ty2):
    """
    typePrecedence(ty1, ty2) -> bool

    Parameters
    ----------
    ty1: enum dnnc::DNNC_DataType
    ty2: enum dnnc::DNNC_DataType

    """
    return _dnnc.typePrecedence(ty1, ty2)
opAbs = _dnnc.opAbs
opAcos = _dnnc.opAcos
opAcosh = _dnnc.opAcosh
opAdd = _dnnc.opAdd
opAnd = _dnnc.opAnd
opArgMax = _dnnc.opArgMax
opArgMin = _dnnc.opArgMin
opAsin = _dnnc.opAsin
opAsinh = _dnnc.opAsinh
opAtan = _dnnc.opAtan
opAtanh = _dnnc.opAtanh
opAveragePool = _dnnc.opAveragePool
opBatchNormalization = _dnnc.opBatchNormalization
opBitShift = _dnnc.opBitShift
opBitwiseAnd = _dnnc.opBitwiseAnd
opBitwiseOr = _dnnc.opBitwiseOr
opBitwiseXor = _dnnc.opBitwiseXor
opCast = _dnnc.opCast
opCeil = _dnnc.opCeil
opClip = _dnnc.opClip
opCompress = _dnnc.opCompress
opConcat = _dnnc.opConcat
opConstant = _dnnc.opConstant
opConstantOfShape = _dnnc.opConstantOfShape
opConv = _dnnc.opConv
opConvInteger = _dnnc.opConvInteger
opConvTranspose = _dnnc.opConvTranspose
opCos = _dnnc.opCos
opCosh = _dnnc.opCosh
opCumSum = _dnnc.opCumSum
opDepthToSpace = _dnnc.opDepthToSpace
opDequantizeLinear = _dnnc.opDequantizeLinear
opDiv = _dnnc.opDiv
opDropout = _dnnc.opDropout
opElu = _dnnc.opElu
opEqual = _dnnc.opEqual
opErf = _dnnc.opErf
opExp = _dnnc.opExp
opExpand = _dnnc.opExpand
opEyeLike = _dnnc.opEyeLike
opFlatten = _dnnc.opFlatten
opFloor = _dnnc.opFloor
opFloorDiv = _dnnc.opFloorDiv
opGRU = _dnnc.opGRU
opGather = _dnnc.opGather
opGemm = _dnnc.opGemm
opGlobalAveragePool = _dnnc.opGlobalAveragePool
opGlobalLpPool = _dnnc.opGlobalLpPool
opGlobalMaxPool = _dnnc.opGlobalMaxPool
opGreater = _dnnc.opGreater
opGreaterEqual = _dnnc.opGreaterEqual
opHardSigmoid = _dnnc.opHardSigmoid
opHardmax = _dnnc.opHardmax
opIdentity = _dnnc.opIdentity
opIf = _dnnc.opIf
opInstanceNormalization = _dnnc.opInstanceNormalization
opIsInf = _dnnc.opIsInf
opIsNaN = _dnnc.opIsNaN
opLRN = _dnnc.opLRN
opLSTM = _dnnc.opLSTM
opLeakyRelu = _dnnc.opLeakyRelu
opLess = _dnnc.opLess
opLessEqual = _dnnc.opLessEqual
opLog = _dnnc.opLog
opLogSoftmax = _dnnc.opLogSoftmax
opLoop = _dnnc.opLoop
opLpNormalization = _dnnc.opLpNormalization
opLpPool = _dnnc.opLpPool
opMatMul = _dnnc.opMatMul
opMatMulInteger = _dnnc.opMatMulInteger
opMax = _dnnc.opMax
opMaxPool = _dnnc.opMaxPool
opMaxRoiPool = _dnnc.opMaxRoiPool
opMaxUnpool = _dnnc.opMaxUnpool
opMean = _dnnc.opMean
opMin = _dnnc.opMin
opMod = _dnnc.opMod
opMul = _dnnc.opMul
opMultinomial = _dnnc.opMultinomial
opNeg = _dnnc.opNeg
opNonMaxSuppression = _dnnc.opNonMaxSuppression
opNonZero = _dnnc.opNonZero
opNot = _dnnc.opNot
opNotEqual = _dnnc.opNotEqual
opOneHot = _dnnc.opOneHot
opOr = _dnnc.opOr
opPRelu = _dnnc.opPRelu
opPad = _dnnc.opPad
opPow = _dnnc.opPow
opQLinearConv = _dnnc.opQLinearConv
opQLinearMatMul = _dnnc.opQLinearMatMul
opQuantizeLinear = _dnnc.opQuantizeLinear
opRNN = _dnnc.opRNN
opRandomNormal = _dnnc.opRandomNormal
opRandomNormalLike = _dnnc.opRandomNormalLike
opRandomUniform = _dnnc.opRandomUniform
opRandomUniformLike = _dnnc.opRandomUniformLike
opReciprocal = _dnnc.opReciprocal
opReduceL1 = _dnnc.opReduceL1
opReduceL2 = _dnnc.opReduceL2
opReduceLogSum = _dnnc.opReduceLogSum
opReduceLogSumExp = _dnnc.opReduceLogSumExp
opReduceMax = _dnnc.opReduceMax
opReduceMean = _dnnc.opReduceMean
opReduceMin = _dnnc.opReduceMin
opReduceProd = _dnnc.opReduceProd
opReduceSum = _dnnc.opReduceSum
opReduceSumSquare = _dnnc.opReduceSumSquare
opRelu = _dnnc.opRelu
opRemainder = _dnnc.opRemainder
opReshape = _dnnc.opReshape
opResize = _dnnc.opResize
opReverseSequence = _dnnc.opReverseSequence
opRoiAlign = _dnnc.opRoiAlign
opRound = _dnnc.opRound
opScan = _dnnc.opScan
opScatter = _dnnc.opScatter
opSelu = _dnnc.opSelu
opShape = _dnnc.opShape
opShrink = _dnnc.opShrink
opSigmoid = _dnnc.opSigmoid
opSign = _dnnc.opSign
opSin = _dnnc.opSin
opSinh = _dnnc.opSinh
opSize = _dnnc.opSize
opSlice = _dnnc.opSlice
opSetSlice = _dnnc.opSetSlice
opSoftmax = _dnnc.opSoftmax
opSoftplus = _dnnc.opSoftplus
opSoftsign = _dnnc.opSoftsign
opSpaceToDepth = _dnnc.opSpaceToDepth
opSplit = _dnnc.opSplit
opSqrt = _dnnc.opSqrt
opSqueeze = _dnnc.opSqueeze
opStringNormalizer = _dnnc.opStringNormalizer
opSub = _dnnc.opSub
opSum = _dnnc.opSum
opTan = _dnnc.opTan
opTanh = _dnnc.opTanh
opTfIdfVectorizer = _dnnc.opTfIdfVectorizer
opThresholdedRelu = _dnnc.opThresholdedRelu
opTile = _dnnc.opTile
opTopK = _dnnc.opTopK
opTranspose = _dnnc.opTranspose
opTrueDiv = _dnnc.opTrueDiv
opUnsqueeze = _dnnc.opUnsqueeze
opUpsample = _dnnc.opUpsample
opWhere = _dnnc.opWhere
opXor = _dnnc.opXor
opInvalid = _dnnc.opInvalid
attr_activation_alpha = _dnnc.attr_activation_alpha
attr_activation_beta = _dnnc.attr_activation_beta
attr_activations = _dnnc.attr_activations
attr_alpha = _dnnc.attr_alpha
attr_auto_pad = _dnnc.attr_auto_pad
attr_axes = _dnnc.attr_axes
attr_axis = _dnnc.attr_axis
attr_batch_axis = _dnnc.attr_batch_axis
attr_beta = _dnnc.attr_beta
attr_bias = _dnnc.attr_bias
attr_blocksize = _dnnc.attr_blocksize
attr_body = _dnnc.attr_body
attr_case_change_action = _dnnc.attr_case_change_action
attr_ceil_mode = _dnnc.attr_ceil_mode
attr_center_point_box = _dnnc.attr_center_point_box
attr_clip = _dnnc.attr_clip
attr_count_include_pad = _dnnc.attr_count_include_pad
attr_detect_negative = _dnnc.attr_detect_negative
attr_detect_positive = _dnnc.attr_detect_positive
attr_dilations = _dnnc.attr_dilations
attr_direction = _dnnc.attr_direction
attr_dtype = _dnnc.attr_dtype
attr_else_branch = _dnnc.attr_else_branch
attr_epsilon = _dnnc.attr_epsilon
attr_exclusive = _dnnc.attr_exclusive
attr_fmod = _dnnc.attr_fmod
attr_gamma = _dnnc.attr_gamma
attr_group = _dnnc.attr_group
attr_hidden_size = _dnnc.attr_hidden_size
attr_high = _dnnc.attr_high
attr_input_forget = _dnnc.attr_input_forget
attr_is_case_sensitive = _dnnc.attr_is_case_sensitive
attr_k = _dnnc.attr_k
attr_keepdims = _dnnc.attr_keepdims
attr_kernel_shape = _dnnc.attr_kernel_shape
attr_lambd = _dnnc.attr_lambd
attr_larges = _dnnc.attr_larges
attr_linear_before_reset = _dnnc.attr_linear_before_reset
attr_locale = _dnnc.attr_locale
attr_low = _dnnc.attr_low
attr_max_gram_length = _dnnc.attr_max_gram_length
attr_max_skip_count = _dnnc.attr_max_skip_count
attr_mean = _dnnc.attr_mean
attr_min_gram_length = _dnnc.attr_min_gram_length
attr_mode = _dnnc.attr_mode
attr_momentum = _dnnc.attr_momentum
attr_ngram_counts = _dnnc.attr_ngram_counts
attr_ngram_indexes = _dnnc.attr_ngram_indexes
attr_num_scan_inputs = _dnnc.attr_num_scan_inputs
attr_output_height = _dnnc.attr_output_height
attr_output_padding = _dnnc.attr_output_padding
attr_output_shape = _dnnc.attr_output_shape
attr_output_width = _dnnc.attr_output_width
attr_p = _dnnc.attr_p
attr_pads = _dnnc.attr_pads
attr_perm = _dnnc.attr_perm
attr_pool_int64s = _dnnc.attr_pool_int64s
attr_pool_strings = _dnnc.attr_pool_strings
attr_pooled_shape = _dnnc.attr_pooled_shape
attr_ratio = _dnnc.attr_ratio
attr_reverse = _dnnc.attr_reverse
attr_sample_size = _dnnc.attr_sample_size
attr_sampling_ratio = _dnnc.attr_sampling_ratio
attr_scale = _dnnc.attr_scale
attr_scan_input_axes = _dnnc.attr_scan_input_axes
attr_scan_input_directions = _dnnc.attr_scan_input_directions
attr_scan_output_axes = _dnnc.attr_scan_output_axes
attr_scan_output_directions = _dnnc.attr_scan_output_directions
attr_seed = _dnnc.attr_seed
attr_shape = _dnnc.attr_shape
attr_size = _dnnc.attr_size
attr_sorted = _dnnc.attr_sorted
attr_spatial_scale = _dnnc.attr_spatial_scale
attr_split = _dnnc.attr_split
attr_stopwords = _dnnc.attr_stopwords
attr_storage_order = _dnnc.attr_storage_order
attr_strides = _dnnc.attr_strides
attr_then_branch = _dnnc.attr_then_branch
attr_time_axis = _dnnc.attr_time_axis
attr_to = _dnnc.attr_to
attr_transA = _dnnc.attr_transA
attr_transB = _dnnc.attr_transB
attr_value = _dnnc.attr_value
attr_weights = _dnnc.attr_weights
attr_invalid = _dnnc.attr_invalid

def getAttrName(attrStr):
    """
    getAttrName(attrStr) -> dnnc::OPATTR

    Parameters
    ----------
    attrStr: std::string

    """
    return _dnnc.getAttrName(attrStr)

def getAttrNameStr(attr):
    """
    getAttrNameStr(attr) -> std::string

    Parameters
    ----------
    attr: enum dnnc::OPATTR

    """
    return _dnnc.getAttrNameStr(attr)

def getOpCode(opCodeStr):
    """
    getOpCode(opCodeStr) -> dnnc::OPCODE

    Parameters
    ----------
    opCodeStr: std::string

    """
    return _dnnc.getOpCode(opCodeStr)

def getOpCodeStr(opCode):
    """
    getOpCodeStr(opCode) -> std::string

    Parameters
    ----------
    opCode: enum dnnc::OPCODE

    """
    return _dnnc.getOpCodeStr(opCode)
INIT_NONE = _dnnc.INIT_NONE
INIT_RANDOM = _dnnc.INIT_RANDOM
INIT_ZERO = _dnnc.INIT_ZERO
INIT_ONE = _dnnc.INIT_ONE
INIT_VALUE = _dnnc.INIT_VALUE

def add(*args):
    """
    add(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< double > &

    add(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< float > &

    add(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< size_t > &

    add(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< int > &

    add(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< bool > &

    add(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< double > &

    add(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< double > &

    add(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< double > &

    add(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< double > &

    add(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< float > &

    add(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< size_t > &

    add(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< int > &

    add(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< bool > &

    add(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< float > &

    add(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< float > &

    add(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< float > &

    add(a, b) -> uLongTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< size_t > &

    add(a, b) -> uLongTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< int > &

    add(a, b) -> uLongTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< bool > &

    add(a, b) -> uLongTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< size_t > &

    add(a, b) -> uLongTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< size_t > &

    add(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< int > &

    add(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< bool > &

    add(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< int > &

    add(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< bool > &

    add(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: double

    add(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: float

    add(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: size_t

    add(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: int

    add(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: bool

    add(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: double

    add(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: double

    add(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: double

    add(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: double

    add(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: float

    add(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: size_t

    add(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: int

    add(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: bool

    add(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: float

    add(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: float

    add(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: float

    add(a, b) -> uLongTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: size_t

    add(a, b) -> uLongTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: int

    add(a, b) -> uLongTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: bool

    add(a, b) -> uLongTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: size_t

    add(a, b) -> uLongTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: size_t

    add(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: int

    add(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: bool

    add(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: int

    add(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: bool

    add(a, b) -> doubleTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< double > &

    add(a, b) -> doubleTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< float > &

    add(a, b) -> doubleTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< size_t > &

    add(a, b) -> doubleTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< int > &

    add(a, b) -> doubleTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< bool > &

    add(a, b) -> doubleTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< double > &

    add(a, b) -> doubleTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< double > &

    add(a, b) -> doubleTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< double > &

    add(a, b) -> doubleTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< double > &

    add(a, b) -> floatTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< float > &

    add(a, b) -> floatTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< size_t > &

    add(a, b) -> floatTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< int > &

    add(a, b) -> floatTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< bool > &

    add(a, b) -> floatTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< float > &

    add(a, b) -> floatTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< float > &

    add(a, b) -> floatTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< float > &

    add(a, b) -> uLongTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< size_t > &

    add(a, b) -> uLongTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< int > &

    add(a, b) -> uLongTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< bool > &

    add(a, b) -> uLongTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< size_t > &

    add(a, b) -> uLongTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< size_t > &

    add(a, b) -> intTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< int > &

    add(a, b) -> intTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< bool > &

    add(a, b) -> intTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< int > &

    add(a, b) -> boolTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< bool > &

    add(a, b) -> double

    Parameters
    ----------
    a: double
    b: double

    add(a, b) -> double

    Parameters
    ----------
    a: double
    b: float

    add(a, b) -> double

    Parameters
    ----------
    a: double
    b: size_t

    add(a, b) -> double

    Parameters
    ----------
    a: double
    b: int

    add(a, b) -> double

    Parameters
    ----------
    a: double
    b: bool

    add(a, b) -> double

    Parameters
    ----------
    a: float
    b: double

    add(a, b) -> double

    Parameters
    ----------
    a: size_t
    b: double

    add(a, b) -> double

    Parameters
    ----------
    a: int
    b: double

    add(a, b) -> double

    Parameters
    ----------
    a: bool
    b: double

    add(a, b) -> float

    Parameters
    ----------
    a: float
    b: float

    add(a, b) -> float

    Parameters
    ----------
    a: float
    b: size_t

    add(a, b) -> float

    Parameters
    ----------
    a: float
    b: int

    add(a, b) -> float

    Parameters
    ----------
    a: float
    b: bool

    add(a, b) -> float

    Parameters
    ----------
    a: size_t
    b: float

    add(a, b) -> float

    Parameters
    ----------
    a: int
    b: float

    add(a, b) -> float

    Parameters
    ----------
    a: bool
    b: float

    add(a, b) -> size_t

    Parameters
    ----------
    a: size_t
    b: size_t

    add(a, b) -> size_t

    Parameters
    ----------
    a: size_t
    b: int

    add(a, b) -> size_t

    Parameters
    ----------
    a: size_t
    b: bool

    add(a, b) -> size_t

    Parameters
    ----------
    a: int
    b: size_t

    add(a, b) -> size_t

    Parameters
    ----------
    a: bool
    b: size_t

    add(a, b) -> int

    Parameters
    ----------
    a: int
    b: int

    add(a, b) -> int

    Parameters
    ----------
    a: int
    b: bool

    add(a, b) -> int

    Parameters
    ----------
    a: bool
    b: int

    add(a, b) -> bool

    Parameters
    ----------
    a: bool
    b: bool

    """
    return _dnnc.add(*args)

def sub(*args):
    """
    sub(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< double > &

    sub(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< float > &

    sub(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< size_t > &

    sub(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< int > &

    sub(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< bool > &

    sub(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< double > &

    sub(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< double > &

    sub(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< double > &

    sub(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< double > &

    sub(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< float > &

    sub(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< size_t > &

    sub(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< int > &

    sub(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< bool > &

    sub(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< float > &

    sub(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< float > &

    sub(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< float > &

    sub(a, b) -> uLongTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< size_t > &

    sub(a, b) -> uLongTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< int > &

    sub(a, b) -> uLongTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< bool > &

    sub(a, b) -> uLongTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< size_t > &

    sub(a, b) -> uLongTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< size_t > &

    sub(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< int > &

    sub(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< bool > &

    sub(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< int > &

    sub(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< bool > &

    sub(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: double

    sub(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: float

    sub(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: size_t

    sub(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: int

    sub(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: bool

    sub(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: double

    sub(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: double

    sub(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: double

    sub(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: double

    sub(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: float

    sub(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: size_t

    sub(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: int

    sub(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: bool

    sub(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: float

    sub(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: float

    sub(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: float

    sub(a, b) -> uLongTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: size_t

    sub(a, b) -> uLongTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: int

    sub(a, b) -> uLongTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: bool

    sub(a, b) -> uLongTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: size_t

    sub(a, b) -> uLongTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: size_t

    sub(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: int

    sub(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: bool

    sub(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: int

    sub(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: bool

    sub(a, b) -> doubleTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< double > &

    sub(a, b) -> doubleTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< float > &

    sub(a, b) -> doubleTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< size_t > &

    sub(a, b) -> doubleTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< int > &

    sub(a, b) -> doubleTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< bool > &

    sub(a, b) -> doubleTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< double > &

    sub(a, b) -> doubleTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< double > &

    sub(a, b) -> doubleTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< double > &

    sub(a, b) -> doubleTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< double > &

    sub(a, b) -> floatTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< float > &

    sub(a, b) -> floatTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< size_t > &

    sub(a, b) -> floatTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< int > &

    sub(a, b) -> floatTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< bool > &

    sub(a, b) -> floatTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< float > &

    sub(a, b) -> floatTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< float > &

    sub(a, b) -> floatTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< float > &

    sub(a, b) -> uLongTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< size_t > &

    sub(a, b) -> uLongTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< int > &

    sub(a, b) -> uLongTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< bool > &

    sub(a, b) -> uLongTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< size_t > &

    sub(a, b) -> uLongTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< size_t > &

    sub(a, b) -> intTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< int > &

    sub(a, b) -> intTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< bool > &

    sub(a, b) -> intTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< int > &

    sub(a, b) -> boolTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< bool > &

    sub(a, b) -> double

    Parameters
    ----------
    a: double
    b: double

    sub(a, b) -> double

    Parameters
    ----------
    a: double
    b: float

    sub(a, b) -> double

    Parameters
    ----------
    a: double
    b: size_t

    sub(a, b) -> double

    Parameters
    ----------
    a: double
    b: int

    sub(a, b) -> double

    Parameters
    ----------
    a: double
    b: bool

    sub(a, b) -> double

    Parameters
    ----------
    a: float
    b: double

    sub(a, b) -> double

    Parameters
    ----------
    a: size_t
    b: double

    sub(a, b) -> double

    Parameters
    ----------
    a: int
    b: double

    sub(a, b) -> double

    Parameters
    ----------
    a: bool
    b: double

    sub(a, b) -> float

    Parameters
    ----------
    a: float
    b: float

    sub(a, b) -> float

    Parameters
    ----------
    a: float
    b: size_t

    sub(a, b) -> float

    Parameters
    ----------
    a: float
    b: int

    sub(a, b) -> float

    Parameters
    ----------
    a: float
    b: bool

    sub(a, b) -> float

    Parameters
    ----------
    a: size_t
    b: float

    sub(a, b) -> float

    Parameters
    ----------
    a: int
    b: float

    sub(a, b) -> float

    Parameters
    ----------
    a: bool
    b: float

    sub(a, b) -> size_t

    Parameters
    ----------
    a: size_t
    b: size_t

    sub(a, b) -> size_t

    Parameters
    ----------
    a: size_t
    b: int

    sub(a, b) -> size_t

    Parameters
    ----------
    a: size_t
    b: bool

    sub(a, b) -> size_t

    Parameters
    ----------
    a: int
    b: size_t

    sub(a, b) -> size_t

    Parameters
    ----------
    a: bool
    b: size_t

    sub(a, b) -> int

    Parameters
    ----------
    a: int
    b: int

    sub(a, b) -> int

    Parameters
    ----------
    a: int
    b: bool

    sub(a, b) -> int

    Parameters
    ----------
    a: bool
    b: int

    sub(a, b) -> bool

    Parameters
    ----------
    a: bool
    b: bool

    """
    return _dnnc.sub(*args)

def mul(*args):
    """
    mul(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< double > &

    mul(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< float > &

    mul(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< size_t > &

    mul(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< int > &

    mul(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< bool > &

    mul(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< double > &

    mul(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< double > &

    mul(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< double > &

    mul(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< double > &

    mul(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< float > &

    mul(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< size_t > &

    mul(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< int > &

    mul(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< bool > &

    mul(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< float > &

    mul(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< float > &

    mul(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< float > &

    mul(a, b) -> uLongTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< size_t > &

    mul(a, b) -> uLongTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< int > &

    mul(a, b) -> uLongTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< bool > &

    mul(a, b) -> uLongTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< size_t > &

    mul(a, b) -> uLongTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< size_t > &

    mul(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< int > &

    mul(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< bool > &

    mul(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< int > &

    mul(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< bool > &

    mul(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: double

    mul(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: float

    mul(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: size_t

    mul(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: int

    mul(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: bool

    mul(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: double

    mul(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: double

    mul(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: double

    mul(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: double

    mul(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: float

    mul(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: size_t

    mul(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: int

    mul(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: bool

    mul(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: float

    mul(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: float

    mul(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: float

    mul(a, b) -> uLongTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: size_t

    mul(a, b) -> uLongTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: int

    mul(a, b) -> uLongTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: bool

    mul(a, b) -> uLongTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: size_t

    mul(a, b) -> uLongTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: size_t

    mul(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: int

    mul(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: bool

    mul(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: int

    mul(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: bool

    mul(a, b) -> doubleTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< double > &

    mul(a, b) -> doubleTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< float > &

    mul(a, b) -> doubleTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< size_t > &

    mul(a, b) -> doubleTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< int > &

    mul(a, b) -> doubleTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< bool > &

    mul(a, b) -> doubleTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< double > &

    mul(a, b) -> doubleTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< double > &

    mul(a, b) -> doubleTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< double > &

    mul(a, b) -> doubleTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< double > &

    mul(a, b) -> floatTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< float > &

    mul(a, b) -> floatTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< size_t > &

    mul(a, b) -> floatTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< int > &

    mul(a, b) -> floatTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< bool > &

    mul(a, b) -> floatTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< float > &

    mul(a, b) -> floatTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< float > &

    mul(a, b) -> floatTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< float > &

    mul(a, b) -> uLongTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< size_t > &

    mul(a, b) -> uLongTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< int > &

    mul(a, b) -> uLongTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< bool > &

    mul(a, b) -> uLongTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< size_t > &

    mul(a, b) -> uLongTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< size_t > &

    mul(a, b) -> intTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< int > &

    mul(a, b) -> intTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< bool > &

    mul(a, b) -> intTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< int > &

    mul(a, b) -> boolTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< bool > &

    mul(a, b) -> double

    Parameters
    ----------
    a: double
    b: double

    mul(a, b) -> double

    Parameters
    ----------
    a: double
    b: float

    mul(a, b) -> double

    Parameters
    ----------
    a: double
    b: size_t

    mul(a, b) -> double

    Parameters
    ----------
    a: double
    b: int

    mul(a, b) -> double

    Parameters
    ----------
    a: double
    b: bool

    mul(a, b) -> double

    Parameters
    ----------
    a: float
    b: double

    mul(a, b) -> double

    Parameters
    ----------
    a: size_t
    b: double

    mul(a, b) -> double

    Parameters
    ----------
    a: int
    b: double

    mul(a, b) -> double

    Parameters
    ----------
    a: bool
    b: double

    mul(a, b) -> float

    Parameters
    ----------
    a: float
    b: float

    mul(a, b) -> float

    Parameters
    ----------
    a: float
    b: size_t

    mul(a, b) -> float

    Parameters
    ----------
    a: float
    b: int

    mul(a, b) -> float

    Parameters
    ----------
    a: float
    b: bool

    mul(a, b) -> float

    Parameters
    ----------
    a: size_t
    b: float

    mul(a, b) -> float

    Parameters
    ----------
    a: int
    b: float

    mul(a, b) -> float

    Parameters
    ----------
    a: bool
    b: float

    mul(a, b) -> size_t

    Parameters
    ----------
    a: size_t
    b: size_t

    mul(a, b) -> size_t

    Parameters
    ----------
    a: size_t
    b: int

    mul(a, b) -> size_t

    Parameters
    ----------
    a: size_t
    b: bool

    mul(a, b) -> size_t

    Parameters
    ----------
    a: int
    b: size_t

    mul(a, b) -> size_t

    Parameters
    ----------
    a: bool
    b: size_t

    mul(a, b) -> int

    Parameters
    ----------
    a: int
    b: int

    mul(a, b) -> int

    Parameters
    ----------
    a: int
    b: bool

    mul(a, b) -> int

    Parameters
    ----------
    a: bool
    b: int

    mul(a, b) -> bool

    Parameters
    ----------
    a: bool
    b: bool

    """
    return _dnnc.mul(*args)

def floor_div(*args):
    """
    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< double > &

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< float > &

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< size_t > &

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< int > &

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< bool > &

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< double > &

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< double > &

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< double > &

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< double > &

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< float > &

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< size_t > &

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< int > &

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< bool > &

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< float > &

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< float > &

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< float > &

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< size_t > &

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< int > &

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< bool > &

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< size_t > &

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< size_t > &

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< int > &

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< bool > &

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< int > &

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< bool > &

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: double

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: float

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: size_t

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: int

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: bool

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: double

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: double

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: double

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: double

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: float

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: size_t

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: int

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: bool

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: float

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: float

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: float

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: size_t

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: int

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: bool

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: size_t

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: size_t

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: int

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: bool

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: int

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: bool

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< double > &

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< float > &

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< size_t > &

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< int > &

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< bool > &

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< double > &

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< double > &

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< double > &

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< double > &

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< float > &

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< size_t > &

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< int > &

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< bool > &

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< float > &

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< float > &

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< float > &

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< size_t > &

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< int > &

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< bool > &

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< size_t > &

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< size_t > &

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< int > &

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< bool > &

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< int > &

    floor_div(a, b) -> intTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< bool > &

    floor_div(a, b) -> int

    Parameters
    ----------
    a: double
    b: double

    floor_div(a, b) -> int

    Parameters
    ----------
    a: double
    b: float

    floor_div(a, b) -> int

    Parameters
    ----------
    a: double
    b: size_t

    floor_div(a, b) -> int

    Parameters
    ----------
    a: double
    b: int

    floor_div(a, b) -> int

    Parameters
    ----------
    a: double
    b: bool

    floor_div(a, b) -> int

    Parameters
    ----------
    a: float
    b: double

    floor_div(a, b) -> int

    Parameters
    ----------
    a: size_t
    b: double

    floor_div(a, b) -> int

    Parameters
    ----------
    a: int
    b: double

    floor_div(a, b) -> int

    Parameters
    ----------
    a: bool
    b: double

    floor_div(a, b) -> int

    Parameters
    ----------
    a: float
    b: float

    floor_div(a, b) -> int

    Parameters
    ----------
    a: float
    b: size_t

    floor_div(a, b) -> int

    Parameters
    ----------
    a: float
    b: int

    floor_div(a, b) -> int

    Parameters
    ----------
    a: float
    b: bool

    floor_div(a, b) -> int

    Parameters
    ----------
    a: size_t
    b: float

    floor_div(a, b) -> int

    Parameters
    ----------
    a: int
    b: float

    floor_div(a, b) -> int

    Parameters
    ----------
    a: bool
    b: float

    floor_div(a, b) -> int

    Parameters
    ----------
    a: size_t
    b: size_t

    floor_div(a, b) -> int

    Parameters
    ----------
    a: size_t
    b: int

    floor_div(a, b) -> int

    Parameters
    ----------
    a: size_t
    b: bool

    floor_div(a, b) -> int

    Parameters
    ----------
    a: int
    b: size_t

    floor_div(a, b) -> int

    Parameters
    ----------
    a: bool
    b: size_t

    floor_div(a, b) -> int

    Parameters
    ----------
    a: int
    b: int

    floor_div(a, b) -> int

    Parameters
    ----------
    a: int
    b: bool

    floor_div(a, b) -> int

    Parameters
    ----------
    a: bool
    b: int

    floor_div(a, b) -> int

    Parameters
    ----------
    a: bool
    b: bool

    """
    return _dnnc.floor_div(*args)

def true_div(*args):
    """
    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< double > &

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< float > &

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< size_t > &

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< int > &

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< bool > &

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< double > &

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< double > &

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< double > &

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< double > &

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< float > &

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< size_t > &

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< int > &

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< bool > &

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< float > &

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< float > &

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< float > &

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< size_t > &

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< int > &

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< bool > &

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< size_t > &

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< size_t > &

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< int > &

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< bool > &

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< int > &

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< bool > &

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: double

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: float

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: size_t

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: int

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: bool

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: double

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: double

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: double

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: double

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: float

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: size_t

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: int

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: bool

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: float

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: float

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: float

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: size_t

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: int

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: bool

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: size_t

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: size_t

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: int

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: bool

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: int

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: bool

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< double > &

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< float > &

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< size_t > &

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< int > &

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< bool > &

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< double > &

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< double > &

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< double > &

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< double > &

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< float > &

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< size_t > &

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< int > &

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< bool > &

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< float > &

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< float > &

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< float > &

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< size_t > &

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< int > &

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< bool > &

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< size_t > &

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< size_t > &

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< int > &

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< bool > &

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< int > &

    true_div(a, b) -> floatTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< bool > &

    true_div(a, b) -> float

    Parameters
    ----------
    a: double
    b: double

    true_div(a, b) -> float

    Parameters
    ----------
    a: double
    b: float

    true_div(a, b) -> float

    Parameters
    ----------
    a: double
    b: size_t

    true_div(a, b) -> float

    Parameters
    ----------
    a: double
    b: int

    true_div(a, b) -> float

    Parameters
    ----------
    a: double
    b: bool

    true_div(a, b) -> float

    Parameters
    ----------
    a: float
    b: double

    true_div(a, b) -> float

    Parameters
    ----------
    a: size_t
    b: double

    true_div(a, b) -> float

    Parameters
    ----------
    a: int
    b: double

    true_div(a, b) -> float

    Parameters
    ----------
    a: bool
    b: double

    true_div(a, b) -> float

    Parameters
    ----------
    a: float
    b: float

    true_div(a, b) -> float

    Parameters
    ----------
    a: float
    b: size_t

    true_div(a, b) -> float

    Parameters
    ----------
    a: float
    b: int

    true_div(a, b) -> float

    Parameters
    ----------
    a: float
    b: bool

    true_div(a, b) -> float

    Parameters
    ----------
    a: size_t
    b: float

    true_div(a, b) -> float

    Parameters
    ----------
    a: int
    b: float

    true_div(a, b) -> float

    Parameters
    ----------
    a: bool
    b: float

    true_div(a, b) -> float

    Parameters
    ----------
    a: size_t
    b: size_t

    true_div(a, b) -> float

    Parameters
    ----------
    a: size_t
    b: int

    true_div(a, b) -> float

    Parameters
    ----------
    a: size_t
    b: bool

    true_div(a, b) -> float

    Parameters
    ----------
    a: int
    b: size_t

    true_div(a, b) -> float

    Parameters
    ----------
    a: bool
    b: size_t

    true_div(a, b) -> float

    Parameters
    ----------
    a: int
    b: int

    true_div(a, b) -> float

    Parameters
    ----------
    a: int
    b: bool

    true_div(a, b) -> float

    Parameters
    ----------
    a: bool
    b: int

    true_div(a, b) -> float

    Parameters
    ----------
    a: bool
    b: bool

    """
    return _dnnc.true_div(*args)

def remainder(*args):
    """
    remainder(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< double > &

    remainder(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< float > &

    remainder(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< size_t > &

    remainder(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< int > &

    remainder(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< bool > &

    remainder(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< double > &

    remainder(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< double > &

    remainder(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< double > &

    remainder(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< double > &

    remainder(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< float > &

    remainder(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< size_t > &

    remainder(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< int > &

    remainder(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< bool > &

    remainder(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< float > &

    remainder(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< float > &

    remainder(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< float > &

    remainder(a, b) -> uLongTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< size_t > &

    remainder(a, b) -> uLongTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< int > &

    remainder(a, b) -> uLongTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< bool > &

    remainder(a, b) -> uLongTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< size_t > &

    remainder(a, b) -> uLongTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< size_t > &

    remainder(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< int > &

    remainder(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< bool > &

    remainder(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< int > &

    remainder(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< bool > &

    remainder(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: double

    remainder(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: float

    remainder(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: size_t

    remainder(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: int

    remainder(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: bool

    remainder(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: double

    remainder(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: double

    remainder(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: double

    remainder(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: double

    remainder(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: float

    remainder(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: size_t

    remainder(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: int

    remainder(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: bool

    remainder(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: float

    remainder(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: float

    remainder(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: float

    remainder(a, b) -> uLongTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: size_t

    remainder(a, b) -> uLongTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: int

    remainder(a, b) -> uLongTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: bool

    remainder(a, b) -> uLongTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: size_t

    remainder(a, b) -> uLongTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: size_t

    remainder(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: int

    remainder(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: bool

    remainder(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: int

    remainder(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: bool

    remainder(a, b) -> doubleTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< double > &

    remainder(a, b) -> doubleTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< float > &

    remainder(a, b) -> doubleTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< size_t > &

    remainder(a, b) -> doubleTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< int > &

    remainder(a, b) -> doubleTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< bool > &

    remainder(a, b) -> doubleTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< double > &

    remainder(a, b) -> doubleTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< double > &

    remainder(a, b) -> doubleTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< double > &

    remainder(a, b) -> doubleTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< double > &

    remainder(a, b) -> floatTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< float > &

    remainder(a, b) -> floatTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< size_t > &

    remainder(a, b) -> floatTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< int > &

    remainder(a, b) -> floatTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< bool > &

    remainder(a, b) -> floatTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< float > &

    remainder(a, b) -> floatTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< float > &

    remainder(a, b) -> floatTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< float > &

    remainder(a, b) -> uLongTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< size_t > &

    remainder(a, b) -> uLongTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< int > &

    remainder(a, b) -> uLongTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< bool > &

    remainder(a, b) -> uLongTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< size_t > &

    remainder(a, b) -> uLongTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< size_t > &

    remainder(a, b) -> intTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< int > &

    remainder(a, b) -> intTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< bool > &

    remainder(a, b) -> intTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< int > &

    remainder(a, b) -> boolTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< bool > &

    remainder(a, b) -> double

    Parameters
    ----------
    a: double
    b: double

    remainder(a, b) -> double

    Parameters
    ----------
    a: double
    b: float

    remainder(a, b) -> double

    Parameters
    ----------
    a: double
    b: size_t

    remainder(a, b) -> double

    Parameters
    ----------
    a: double
    b: int

    remainder(a, b) -> double

    Parameters
    ----------
    a: double
    b: bool

    remainder(a, b) -> double

    Parameters
    ----------
    a: float
    b: double

    remainder(a, b) -> double

    Parameters
    ----------
    a: size_t
    b: double

    remainder(a, b) -> double

    Parameters
    ----------
    a: int
    b: double

    remainder(a, b) -> double

    Parameters
    ----------
    a: bool
    b: double

    remainder(a, b) -> float

    Parameters
    ----------
    a: float
    b: float

    remainder(a, b) -> float

    Parameters
    ----------
    a: float
    b: size_t

    remainder(a, b) -> float

    Parameters
    ----------
    a: float
    b: int

    remainder(a, b) -> float

    Parameters
    ----------
    a: float
    b: bool

    remainder(a, b) -> float

    Parameters
    ----------
    a: size_t
    b: float

    remainder(a, b) -> float

    Parameters
    ----------
    a: int
    b: float

    remainder(a, b) -> float

    Parameters
    ----------
    a: bool
    b: float

    remainder(a, b) -> size_t

    Parameters
    ----------
    a: size_t
    b: size_t

    remainder(a, b) -> size_t

    Parameters
    ----------
    a: size_t
    b: int

    remainder(a, b) -> size_t

    Parameters
    ----------
    a: size_t
    b: bool

    remainder(a, b) -> size_t

    Parameters
    ----------
    a: int
    b: size_t

    remainder(a, b) -> size_t

    Parameters
    ----------
    a: bool
    b: size_t

    remainder(a, b) -> int

    Parameters
    ----------
    a: int
    b: int

    remainder(a, b) -> int

    Parameters
    ----------
    a: int
    b: bool

    remainder(a, b) -> int

    Parameters
    ----------
    a: bool
    b: int

    remainder(a, b) -> bool

    Parameters
    ----------
    a: bool
    b: bool

    """
    return _dnnc.remainder(*args)

def power(*args):
    """
    power(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< double > &

    power(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< float > &

    power(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< size_t > &

    power(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< int > &

    power(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< bool > &

    power(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< double > &

    power(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< double > &

    power(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< double > &

    power(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< double > &

    power(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< float > &

    power(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< size_t > &

    power(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< int > &

    power(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< bool > &

    power(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< float > &

    power(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< float > &

    power(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< float > &

    power(a, b) -> uLongTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< size_t > &

    power(a, b) -> uLongTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< int > &

    power(a, b) -> uLongTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< bool > &

    power(a, b) -> uLongTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< size_t > &

    power(a, b) -> uLongTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< size_t > &

    power(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< int > &

    power(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< bool > &

    power(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< int > &

    power(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< bool > &

    power(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: double

    power(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: float

    power(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: size_t

    power(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: int

    power(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: bool

    power(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: double

    power(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: double

    power(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: double

    power(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: double

    power(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: float

    power(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: size_t

    power(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: int

    power(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: bool

    power(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: float

    power(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: float

    power(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: float

    power(a, b) -> uLongTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: size_t

    power(a, b) -> uLongTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: int

    power(a, b) -> uLongTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: bool

    power(a, b) -> uLongTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: size_t

    power(a, b) -> uLongTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: size_t

    power(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: int

    power(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: bool

    power(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: int

    power(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: bool

    power(a, b) -> doubleTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< double > &

    power(a, b) -> doubleTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< float > &

    power(a, b) -> doubleTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< size_t > &

    power(a, b) -> doubleTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< int > &

    power(a, b) -> doubleTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< bool > &

    power(a, b) -> doubleTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< double > &

    power(a, b) -> doubleTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< double > &

    power(a, b) -> doubleTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< double > &

    power(a, b) -> doubleTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< double > &

    power(a, b) -> floatTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< float > &

    power(a, b) -> floatTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< size_t > &

    power(a, b) -> floatTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< int > &

    power(a, b) -> floatTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< bool > &

    power(a, b) -> floatTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< float > &

    power(a, b) -> floatTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< float > &

    power(a, b) -> floatTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< float > &

    power(a, b) -> uLongTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< size_t > &

    power(a, b) -> uLongTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< int > &

    power(a, b) -> uLongTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< bool > &

    power(a, b) -> uLongTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< size_t > &

    power(a, b) -> uLongTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< size_t > &

    power(a, b) -> intTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< int > &

    power(a, b) -> intTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< bool > &

    power(a, b) -> intTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< int > &

    power(a, b) -> boolTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< bool > &

    power(a, b) -> double

    Parameters
    ----------
    a: double
    b: double

    power(a, b) -> double

    Parameters
    ----------
    a: double
    b: float

    power(a, b) -> double

    Parameters
    ----------
    a: double
    b: size_t

    power(a, b) -> double

    Parameters
    ----------
    a: double
    b: int

    power(a, b) -> double

    Parameters
    ----------
    a: double
    b: bool

    power(a, b) -> double

    Parameters
    ----------
    a: float
    b: double

    power(a, b) -> double

    Parameters
    ----------
    a: size_t
    b: double

    power(a, b) -> double

    Parameters
    ----------
    a: int
    b: double

    power(a, b) -> double

    Parameters
    ----------
    a: bool
    b: double

    power(a, b) -> float

    Parameters
    ----------
    a: float
    b: float

    power(a, b) -> float

    Parameters
    ----------
    a: float
    b: size_t

    power(a, b) -> float

    Parameters
    ----------
    a: float
    b: int

    power(a, b) -> float

    Parameters
    ----------
    a: float
    b: bool

    power(a, b) -> float

    Parameters
    ----------
    a: size_t
    b: float

    power(a, b) -> float

    Parameters
    ----------
    a: int
    b: float

    power(a, b) -> float

    Parameters
    ----------
    a: bool
    b: float

    power(a, b) -> size_t

    Parameters
    ----------
    a: size_t
    b: size_t

    power(a, b) -> size_t

    Parameters
    ----------
    a: size_t
    b: int

    power(a, b) -> size_t

    Parameters
    ----------
    a: size_t
    b: bool

    power(a, b) -> size_t

    Parameters
    ----------
    a: int
    b: size_t

    power(a, b) -> size_t

    Parameters
    ----------
    a: bool
    b: size_t

    power(a, b) -> int

    Parameters
    ----------
    a: int
    b: int

    power(a, b) -> int

    Parameters
    ----------
    a: int
    b: bool

    power(a, b) -> int

    Parameters
    ----------
    a: bool
    b: int

    power(a, b) -> bool

    Parameters
    ----------
    a: bool
    b: bool

    """
    return _dnnc.power(*args)

def bitwise_and(*args):
    """
    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< double > &

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< float > &

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< size_t > &

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< int > &

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< bool > &

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< double > &

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< double > &

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< double > &

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< double > &

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< float > &

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< size_t > &

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< int > &

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< bool > &

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< float > &

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< float > &

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< float > &

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< size_t > &

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< int > &

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< bool > &

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< size_t > &

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< size_t > &

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< int > &

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< bool > &

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< int > &

    bitwise_and(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< bool > &

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: double

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: float

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: size_t

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: int

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: bool

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: double

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: double

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: double

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: double

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: float

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: size_t

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: int

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: bool

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: float

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: float

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: float

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: size_t

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: int

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: bool

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: size_t

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: size_t

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: int

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: bool

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: int

    bitwise_and(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: bool

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< double > &

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< float > &

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< size_t > &

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< int > &

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< bool > &

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< double > &

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< double > &

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< double > &

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< double > &

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< float > &

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< size_t > &

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< int > &

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< bool > &

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< float > &

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< float > &

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< float > &

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< size_t > &

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< int > &

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< bool > &

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< size_t > &

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< size_t > &

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< int > &

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< bool > &

    bitwise_and(a, b) -> intTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< int > &

    bitwise_and(a, b) -> boolTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< bool > &

    bitwise_and(a, b) -> int

    Parameters
    ----------
    a: double
    b: double

    bitwise_and(a, b) -> int

    Parameters
    ----------
    a: double
    b: float

    bitwise_and(a, b) -> int

    Parameters
    ----------
    a: double
    b: size_t

    bitwise_and(a, b) -> int

    Parameters
    ----------
    a: double
    b: int

    bitwise_and(a, b) -> int

    Parameters
    ----------
    a: double
    b: bool

    bitwise_and(a, b) -> int

    Parameters
    ----------
    a: float
    b: double

    bitwise_and(a, b) -> int

    Parameters
    ----------
    a: size_t
    b: double

    bitwise_and(a, b) -> int

    Parameters
    ----------
    a: int
    b: double

    bitwise_and(a, b) -> int

    Parameters
    ----------
    a: bool
    b: double

    bitwise_and(a, b) -> int

    Parameters
    ----------
    a: float
    b: float

    bitwise_and(a, b) -> int

    Parameters
    ----------
    a: float
    b: size_t

    bitwise_and(a, b) -> int

    Parameters
    ----------
    a: float
    b: int

    bitwise_and(a, b) -> int

    Parameters
    ----------
    a: float
    b: bool

    bitwise_and(a, b) -> int

    Parameters
    ----------
    a: size_t
    b: float

    bitwise_and(a, b) -> int

    Parameters
    ----------
    a: int
    b: float

    bitwise_and(a, b) -> int

    Parameters
    ----------
    a: bool
    b: float

    bitwise_and(a, b) -> int

    Parameters
    ----------
    a: size_t
    b: size_t

    bitwise_and(a, b) -> int

    Parameters
    ----------
    a: size_t
    b: int

    bitwise_and(a, b) -> int

    Parameters
    ----------
    a: size_t
    b: bool

    bitwise_and(a, b) -> int

    Parameters
    ----------
    a: int
    b: size_t

    bitwise_and(a, b) -> int

    Parameters
    ----------
    a: bool
    b: size_t

    bitwise_and(a, b) -> int

    Parameters
    ----------
    a: int
    b: int

    bitwise_and(a, b) -> int

    Parameters
    ----------
    a: int
    b: bool

    bitwise_and(a, b) -> int

    Parameters
    ----------
    a: bool
    b: int

    bitwise_and(a, b) -> bool

    Parameters
    ----------
    a: bool
    b: bool

    """
    return _dnnc.bitwise_and(*args)

def bitwise_or(*args):
    """
    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< double > &

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< float > &

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< size_t > &

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< int > &

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< bool > &

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< double > &

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< double > &

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< double > &

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< double > &

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< float > &

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< size_t > &

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< int > &

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< bool > &

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< float > &

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< float > &

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< float > &

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< size_t > &

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< int > &

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< bool > &

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< size_t > &

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< size_t > &

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< int > &

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< bool > &

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< int > &

    bitwise_or(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< bool > &

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: double

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: float

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: size_t

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: int

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: bool

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: double

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: double

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: double

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: double

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: float

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: size_t

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: int

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: bool

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: float

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: float

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: float

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: size_t

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: int

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: bool

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: size_t

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: size_t

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: int

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: bool

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: int

    bitwise_or(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: bool

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< double > &

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< float > &

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< size_t > &

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< int > &

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< bool > &

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< double > &

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< double > &

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< double > &

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< double > &

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< float > &

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< size_t > &

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< int > &

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< bool > &

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< float > &

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< float > &

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< float > &

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< size_t > &

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< int > &

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< bool > &

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< size_t > &

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< size_t > &

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< int > &

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< bool > &

    bitwise_or(a, b) -> intTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< int > &

    bitwise_or(a, b) -> boolTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< bool > &

    bitwise_or(a, b) -> int

    Parameters
    ----------
    a: double
    b: double

    bitwise_or(a, b) -> int

    Parameters
    ----------
    a: double
    b: float

    bitwise_or(a, b) -> int

    Parameters
    ----------
    a: double
    b: size_t

    bitwise_or(a, b) -> int

    Parameters
    ----------
    a: double
    b: int

    bitwise_or(a, b) -> int

    Parameters
    ----------
    a: double
    b: bool

    bitwise_or(a, b) -> int

    Parameters
    ----------
    a: float
    b: double

    bitwise_or(a, b) -> int

    Parameters
    ----------
    a: size_t
    b: double

    bitwise_or(a, b) -> int

    Parameters
    ----------
    a: int
    b: double

    bitwise_or(a, b) -> int

    Parameters
    ----------
    a: bool
    b: double

    bitwise_or(a, b) -> int

    Parameters
    ----------
    a: float
    b: float

    bitwise_or(a, b) -> int

    Parameters
    ----------
    a: float
    b: size_t

    bitwise_or(a, b) -> int

    Parameters
    ----------
    a: float
    b: int

    bitwise_or(a, b) -> int

    Parameters
    ----------
    a: float
    b: bool

    bitwise_or(a, b) -> int

    Parameters
    ----------
    a: size_t
    b: float

    bitwise_or(a, b) -> int

    Parameters
    ----------
    a: int
    b: float

    bitwise_or(a, b) -> int

    Parameters
    ----------
    a: bool
    b: float

    bitwise_or(a, b) -> int

    Parameters
    ----------
    a: size_t
    b: size_t

    bitwise_or(a, b) -> int

    Parameters
    ----------
    a: size_t
    b: int

    bitwise_or(a, b) -> int

    Parameters
    ----------
    a: size_t
    b: bool

    bitwise_or(a, b) -> int

    Parameters
    ----------
    a: int
    b: size_t

    bitwise_or(a, b) -> int

    Parameters
    ----------
    a: bool
    b: size_t

    bitwise_or(a, b) -> int

    Parameters
    ----------
    a: int
    b: int

    bitwise_or(a, b) -> int

    Parameters
    ----------
    a: int
    b: bool

    bitwise_or(a, b) -> int

    Parameters
    ----------
    a: bool
    b: int

    bitwise_or(a, b) -> bool

    Parameters
    ----------
    a: bool
    b: bool

    """
    return _dnnc.bitwise_or(*args)

def bitwise_xor(*args):
    """
    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< double > &

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< float > &

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< size_t > &

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< int > &

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< bool > &

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< double > &

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< double > &

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< double > &

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< double > &

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< float > &

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< size_t > &

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< int > &

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< bool > &

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< float > &

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< float > &

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< float > &

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< size_t > &

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< int > &

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< bool > &

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< size_t > &

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< size_t > &

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< int > &

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< bool > &

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< int > &

    bitwise_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< bool > &

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: double

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: float

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: size_t

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: int

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: bool

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: double

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: double

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: double

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: double

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: float

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: size_t

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: int

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: bool

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: float

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: float

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: float

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: size_t

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: int

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: bool

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: size_t

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: size_t

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: int

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: bool

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: int

    bitwise_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: bool

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< double > &

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< float > &

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< size_t > &

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< int > &

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< bool > &

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< double > &

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< double > &

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< double > &

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< double > &

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< float > &

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< size_t > &

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< int > &

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< bool > &

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< float > &

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< float > &

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< float > &

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< size_t > &

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< int > &

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< bool > &

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< size_t > &

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< size_t > &

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< int > &

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< bool > &

    bitwise_xor(a, b) -> intTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< int > &

    bitwise_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< bool > &

    bitwise_xor(a, b) -> int

    Parameters
    ----------
    a: double
    b: double

    bitwise_xor(a, b) -> int

    Parameters
    ----------
    a: double
    b: float

    bitwise_xor(a, b) -> int

    Parameters
    ----------
    a: double
    b: size_t

    bitwise_xor(a, b) -> int

    Parameters
    ----------
    a: double
    b: int

    bitwise_xor(a, b) -> int

    Parameters
    ----------
    a: double
    b: bool

    bitwise_xor(a, b) -> int

    Parameters
    ----------
    a: float
    b: double

    bitwise_xor(a, b) -> int

    Parameters
    ----------
    a: size_t
    b: double

    bitwise_xor(a, b) -> int

    Parameters
    ----------
    a: int
    b: double

    bitwise_xor(a, b) -> int

    Parameters
    ----------
    a: bool
    b: double

    bitwise_xor(a, b) -> int

    Parameters
    ----------
    a: float
    b: float

    bitwise_xor(a, b) -> int

    Parameters
    ----------
    a: float
    b: size_t

    bitwise_xor(a, b) -> int

    Parameters
    ----------
    a: float
    b: int

    bitwise_xor(a, b) -> int

    Parameters
    ----------
    a: float
    b: bool

    bitwise_xor(a, b) -> int

    Parameters
    ----------
    a: size_t
    b: float

    bitwise_xor(a, b) -> int

    Parameters
    ----------
    a: int
    b: float

    bitwise_xor(a, b) -> int

    Parameters
    ----------
    a: bool
    b: float

    bitwise_xor(a, b) -> int

    Parameters
    ----------
    a: size_t
    b: size_t

    bitwise_xor(a, b) -> int

    Parameters
    ----------
    a: size_t
    b: int

    bitwise_xor(a, b) -> int

    Parameters
    ----------
    a: size_t
    b: bool

    bitwise_xor(a, b) -> int

    Parameters
    ----------
    a: int
    b: size_t

    bitwise_xor(a, b) -> int

    Parameters
    ----------
    a: bool
    b: size_t

    bitwise_xor(a, b) -> int

    Parameters
    ----------
    a: int
    b: int

    bitwise_xor(a, b) -> int

    Parameters
    ----------
    a: int
    b: bool

    bitwise_xor(a, b) -> int

    Parameters
    ----------
    a: bool
    b: int

    bitwise_xor(a, b) -> bool

    Parameters
    ----------
    a: bool
    b: bool

    """
    return _dnnc.bitwise_xor(*args)

def logical_and(*args):
    """
    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< double > &

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< float > &

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< size_t > &

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< int > &

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< bool > &

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< double > &

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< double > &

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< double > &

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< double > &

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< float > &

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< size_t > &

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< int > &

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< bool > &

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< float > &

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< float > &

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< float > &

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< size_t > &

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< int > &

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< bool > &

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< size_t > &

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< size_t > &

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< int > &

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< bool > &

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< int > &

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< bool > &

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: double

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: float

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: size_t

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: int

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: bool

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: double

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: double

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: double

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: double

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: float

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: size_t

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: int

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: bool

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: float

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: float

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: float

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: size_t

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: int

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: bool

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: size_t

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: size_t

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: int

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: bool

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: int

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: bool

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< double > &

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< float > &

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< size_t > &

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< int > &

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< bool > &

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< double > &

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< double > &

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< double > &

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< double > &

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< float > &

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< size_t > &

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< int > &

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< bool > &

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< float > &

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< float > &

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< float > &

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< size_t > &

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< int > &

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< bool > &

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< size_t > &

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< size_t > &

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< int > &

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< bool > &

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< int > &

    logical_and(a, b) -> boolTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< bool > &

    logical_and(a, b) -> bool

    Parameters
    ----------
    a: double
    b: double

    logical_and(a, b) -> bool

    Parameters
    ----------
    a: double
    b: float

    logical_and(a, b) -> bool

    Parameters
    ----------
    a: double
    b: size_t

    logical_and(a, b) -> bool

    Parameters
    ----------
    a: double
    b: int

    logical_and(a, b) -> bool

    Parameters
    ----------
    a: double
    b: bool

    logical_and(a, b) -> bool

    Parameters
    ----------
    a: float
    b: double

    logical_and(a, b) -> bool

    Parameters
    ----------
    a: size_t
    b: double

    logical_and(a, b) -> bool

    Parameters
    ----------
    a: int
    b: double

    logical_and(a, b) -> bool

    Parameters
    ----------
    a: bool
    b: double

    logical_and(a, b) -> bool

    Parameters
    ----------
    a: float
    b: float

    logical_and(a, b) -> bool

    Parameters
    ----------
    a: float
    b: size_t

    logical_and(a, b) -> bool

    Parameters
    ----------
    a: float
    b: int

    logical_and(a, b) -> bool

    Parameters
    ----------
    a: float
    b: bool

    logical_and(a, b) -> bool

    Parameters
    ----------
    a: size_t
    b: float

    logical_and(a, b) -> bool

    Parameters
    ----------
    a: int
    b: float

    logical_and(a, b) -> bool

    Parameters
    ----------
    a: bool
    b: float

    logical_and(a, b) -> bool

    Parameters
    ----------
    a: size_t
    b: size_t

    logical_and(a, b) -> bool

    Parameters
    ----------
    a: size_t
    b: int

    logical_and(a, b) -> bool

    Parameters
    ----------
    a: size_t
    b: bool

    logical_and(a, b) -> bool

    Parameters
    ----------
    a: int
    b: size_t

    logical_and(a, b) -> bool

    Parameters
    ----------
    a: bool
    b: size_t

    logical_and(a, b) -> bool

    Parameters
    ----------
    a: int
    b: int

    logical_and(a, b) -> bool

    Parameters
    ----------
    a: int
    b: bool

    logical_and(a, b) -> bool

    Parameters
    ----------
    a: bool
    b: int

    logical_and(a, b) -> bool

    Parameters
    ----------
    a: bool
    b: bool

    """
    return _dnnc.logical_and(*args)

def logical_or(*args):
    """
    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< double > &

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< float > &

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< size_t > &

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< int > &

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< bool > &

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< double > &

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< double > &

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< double > &

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< double > &

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< float > &

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< size_t > &

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< int > &

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< bool > &

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< float > &

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< float > &

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< float > &

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< size_t > &

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< int > &

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< bool > &

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< size_t > &

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< size_t > &

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< int > &

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< bool > &

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< int > &

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< bool > &

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: double

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: float

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: size_t

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: int

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: bool

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: double

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: double

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: double

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: double

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: float

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: size_t

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: int

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: bool

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: float

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: float

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: float

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: size_t

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: int

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: bool

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: size_t

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: size_t

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: int

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: bool

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: int

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: bool

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< double > &

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< float > &

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< size_t > &

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< int > &

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< bool > &

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< double > &

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< double > &

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< double > &

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< double > &

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< float > &

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< size_t > &

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< int > &

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< bool > &

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< float > &

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< float > &

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< float > &

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< size_t > &

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< int > &

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< bool > &

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< size_t > &

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< size_t > &

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< int > &

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< bool > &

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< int > &

    logical_or(a, b) -> boolTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< bool > &

    logical_or(a, b) -> bool

    Parameters
    ----------
    a: double
    b: double

    logical_or(a, b) -> bool

    Parameters
    ----------
    a: double
    b: float

    logical_or(a, b) -> bool

    Parameters
    ----------
    a: double
    b: size_t

    logical_or(a, b) -> bool

    Parameters
    ----------
    a: double
    b: int

    logical_or(a, b) -> bool

    Parameters
    ----------
    a: double
    b: bool

    logical_or(a, b) -> bool

    Parameters
    ----------
    a: float
    b: double

    logical_or(a, b) -> bool

    Parameters
    ----------
    a: size_t
    b: double

    logical_or(a, b) -> bool

    Parameters
    ----------
    a: int
    b: double

    logical_or(a, b) -> bool

    Parameters
    ----------
    a: bool
    b: double

    logical_or(a, b) -> bool

    Parameters
    ----------
    a: float
    b: float

    logical_or(a, b) -> bool

    Parameters
    ----------
    a: float
    b: size_t

    logical_or(a, b) -> bool

    Parameters
    ----------
    a: float
    b: int

    logical_or(a, b) -> bool

    Parameters
    ----------
    a: float
    b: bool

    logical_or(a, b) -> bool

    Parameters
    ----------
    a: size_t
    b: float

    logical_or(a, b) -> bool

    Parameters
    ----------
    a: int
    b: float

    logical_or(a, b) -> bool

    Parameters
    ----------
    a: bool
    b: float

    logical_or(a, b) -> bool

    Parameters
    ----------
    a: size_t
    b: size_t

    logical_or(a, b) -> bool

    Parameters
    ----------
    a: size_t
    b: int

    logical_or(a, b) -> bool

    Parameters
    ----------
    a: size_t
    b: bool

    logical_or(a, b) -> bool

    Parameters
    ----------
    a: int
    b: size_t

    logical_or(a, b) -> bool

    Parameters
    ----------
    a: bool
    b: size_t

    logical_or(a, b) -> bool

    Parameters
    ----------
    a: int
    b: int

    logical_or(a, b) -> bool

    Parameters
    ----------
    a: int
    b: bool

    logical_or(a, b) -> bool

    Parameters
    ----------
    a: bool
    b: int

    logical_or(a, b) -> bool

    Parameters
    ----------
    a: bool
    b: bool

    """
    return _dnnc.logical_or(*args)

def logical_xor(*args):
    """
    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< double > &

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< float > &

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< size_t > &

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< int > &

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< bool > &

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< double > &

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< double > &

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< double > &

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< double > &

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< float > &

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< size_t > &

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< int > &

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< bool > &

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< float > &

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< float > &

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< float > &

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< size_t > &

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< int > &

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< bool > &

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< size_t > &

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< size_t > &

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< int > &

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< bool > &

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< int > &

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< bool > &

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: double

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: float

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: size_t

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: int

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: bool

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: double

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: double

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: double

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: double

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: float

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: size_t

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: int

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: bool

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: float

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: float

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: float

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: size_t

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: int

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: bool

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: size_t

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: size_t

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: int

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: bool

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: int

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: bool

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< double > &

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< float > &

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< size_t > &

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< int > &

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< bool > &

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< double > &

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< double > &

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< double > &

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< double > &

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< float > &

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< size_t > &

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< int > &

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< bool > &

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< float > &

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< float > &

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< float > &

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< size_t > &

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< int > &

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< bool > &

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< size_t > &

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< size_t > &

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< int > &

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< bool > &

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< int > &

    logical_xor(a, b) -> boolTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< bool > &

    logical_xor(a, b) -> bool

    Parameters
    ----------
    a: double
    b: double

    logical_xor(a, b) -> bool

    Parameters
    ----------
    a: double
    b: float

    logical_xor(a, b) -> bool

    Parameters
    ----------
    a: double
    b: size_t

    logical_xor(a, b) -> bool

    Parameters
    ----------
    a: double
    b: int

    logical_xor(a, b) -> bool

    Parameters
    ----------
    a: double
    b: bool

    logical_xor(a, b) -> bool

    Parameters
    ----------
    a: float
    b: double

    logical_xor(a, b) -> bool

    Parameters
    ----------
    a: size_t
    b: double

    logical_xor(a, b) -> bool

    Parameters
    ----------
    a: int
    b: double

    logical_xor(a, b) -> bool

    Parameters
    ----------
    a: bool
    b: double

    logical_xor(a, b) -> bool

    Parameters
    ----------
    a: float
    b: float

    logical_xor(a, b) -> bool

    Parameters
    ----------
    a: float
    b: size_t

    logical_xor(a, b) -> bool

    Parameters
    ----------
    a: float
    b: int

    logical_xor(a, b) -> bool

    Parameters
    ----------
    a: float
    b: bool

    logical_xor(a, b) -> bool

    Parameters
    ----------
    a: size_t
    b: float

    logical_xor(a, b) -> bool

    Parameters
    ----------
    a: int
    b: float

    logical_xor(a, b) -> bool

    Parameters
    ----------
    a: bool
    b: float

    logical_xor(a, b) -> bool

    Parameters
    ----------
    a: size_t
    b: size_t

    logical_xor(a, b) -> bool

    Parameters
    ----------
    a: size_t
    b: int

    logical_xor(a, b) -> bool

    Parameters
    ----------
    a: size_t
    b: bool

    logical_xor(a, b) -> bool

    Parameters
    ----------
    a: int
    b: size_t

    logical_xor(a, b) -> bool

    Parameters
    ----------
    a: bool
    b: size_t

    logical_xor(a, b) -> bool

    Parameters
    ----------
    a: int
    b: int

    logical_xor(a, b) -> bool

    Parameters
    ----------
    a: int
    b: bool

    logical_xor(a, b) -> bool

    Parameters
    ----------
    a: bool
    b: int

    logical_xor(a, b) -> bool

    Parameters
    ----------
    a: bool
    b: bool

    """
    return _dnnc.logical_xor(*args)

def equal(*args):
    """
    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< double > &

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< float > &

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< size_t > &

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< int > &

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< bool > &

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< double > &

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< double > &

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< double > &

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< double > &

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< float > &

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< size_t > &

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< int > &

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< bool > &

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< float > &

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< float > &

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< float > &

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< size_t > &

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< int > &

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< bool > &

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< size_t > &

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< size_t > &

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< int > &

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< bool > &

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< int > &

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< bool > &

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: double

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: float

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: size_t

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: int

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: bool

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: double

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: double

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: double

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: double

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: float

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: size_t

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: int

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: bool

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: float

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: float

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: float

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: size_t

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: int

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: bool

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: size_t

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: size_t

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: int

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: bool

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: int

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: bool

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< double > &

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< float > &

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< size_t > &

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< int > &

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< bool > &

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< double > &

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< double > &

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< double > &

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< double > &

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< float > &

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< size_t > &

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< int > &

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< bool > &

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< float > &

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< float > &

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< float > &

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< size_t > &

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< int > &

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< bool > &

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< size_t > &

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< size_t > &

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< int > &

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< bool > &

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< int > &

    equal(a, b) -> boolTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< bool > &

    equal(a, b) -> bool

    Parameters
    ----------
    a: double
    b: double

    equal(a, b) -> bool

    Parameters
    ----------
    a: double
    b: float

    equal(a, b) -> bool

    Parameters
    ----------
    a: double
    b: size_t

    equal(a, b) -> bool

    Parameters
    ----------
    a: double
    b: int

    equal(a, b) -> bool

    Parameters
    ----------
    a: double
    b: bool

    equal(a, b) -> bool

    Parameters
    ----------
    a: float
    b: double

    equal(a, b) -> bool

    Parameters
    ----------
    a: size_t
    b: double

    equal(a, b) -> bool

    Parameters
    ----------
    a: int
    b: double

    equal(a, b) -> bool

    Parameters
    ----------
    a: bool
    b: double

    equal(a, b) -> bool

    Parameters
    ----------
    a: float
    b: float

    equal(a, b) -> bool

    Parameters
    ----------
    a: float
    b: size_t

    equal(a, b) -> bool

    Parameters
    ----------
    a: float
    b: int

    equal(a, b) -> bool

    Parameters
    ----------
    a: float
    b: bool

    equal(a, b) -> bool

    Parameters
    ----------
    a: size_t
    b: float

    equal(a, b) -> bool

    Parameters
    ----------
    a: int
    b: float

    equal(a, b) -> bool

    Parameters
    ----------
    a: bool
    b: float

    equal(a, b) -> bool

    Parameters
    ----------
    a: size_t
    b: size_t

    equal(a, b) -> bool

    Parameters
    ----------
    a: size_t
    b: int

    equal(a, b) -> bool

    Parameters
    ----------
    a: size_t
    b: bool

    equal(a, b) -> bool

    Parameters
    ----------
    a: int
    b: size_t

    equal(a, b) -> bool

    Parameters
    ----------
    a: bool
    b: size_t

    equal(a, b) -> bool

    Parameters
    ----------
    a: int
    b: int

    equal(a, b) -> bool

    Parameters
    ----------
    a: int
    b: bool

    equal(a, b) -> bool

    Parameters
    ----------
    a: bool
    b: int

    equal(a, b) -> bool

    Parameters
    ----------
    a: bool
    b: bool

    """
    return _dnnc.equal(*args)

def less(*args):
    """
    less(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< double > &

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< float > &

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< size_t > &

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< int > &

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< bool > &

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< double > &

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< double > &

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< double > &

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< double > &

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< float > &

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< size_t > &

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< int > &

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< bool > &

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< float > &

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< float > &

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< float > &

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< size_t > &

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< int > &

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< bool > &

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< size_t > &

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< size_t > &

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< int > &

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< bool > &

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< int > &

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< bool > &

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: double

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: float

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: size_t

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: int

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: bool

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: double

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: double

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: double

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: double

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: float

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: size_t

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: int

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: bool

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: float

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: float

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: float

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: size_t

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: int

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: bool

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: size_t

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: size_t

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: int

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: bool

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: int

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: bool

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< double > &

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< float > &

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< size_t > &

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< int > &

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< bool > &

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< double > &

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< double > &

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< double > &

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< double > &

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< float > &

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< size_t > &

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< int > &

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< bool > &

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< float > &

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< float > &

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< float > &

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< size_t > &

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< int > &

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< bool > &

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< size_t > &

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< size_t > &

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< int > &

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< bool > &

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< int > &

    less(a, b) -> boolTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< bool > &

    less(a, b) -> bool

    Parameters
    ----------
    a: double
    b: double

    less(a, b) -> bool

    Parameters
    ----------
    a: double
    b: float

    less(a, b) -> bool

    Parameters
    ----------
    a: double
    b: size_t

    less(a, b) -> bool

    Parameters
    ----------
    a: double
    b: int

    less(a, b) -> bool

    Parameters
    ----------
    a: double
    b: bool

    less(a, b) -> bool

    Parameters
    ----------
    a: float
    b: double

    less(a, b) -> bool

    Parameters
    ----------
    a: size_t
    b: double

    less(a, b) -> bool

    Parameters
    ----------
    a: int
    b: double

    less(a, b) -> bool

    Parameters
    ----------
    a: bool
    b: double

    less(a, b) -> bool

    Parameters
    ----------
    a: float
    b: float

    less(a, b) -> bool

    Parameters
    ----------
    a: float
    b: size_t

    less(a, b) -> bool

    Parameters
    ----------
    a: float
    b: int

    less(a, b) -> bool

    Parameters
    ----------
    a: float
    b: bool

    less(a, b) -> bool

    Parameters
    ----------
    a: size_t
    b: float

    less(a, b) -> bool

    Parameters
    ----------
    a: int
    b: float

    less(a, b) -> bool

    Parameters
    ----------
    a: bool
    b: float

    less(a, b) -> bool

    Parameters
    ----------
    a: size_t
    b: size_t

    less(a, b) -> bool

    Parameters
    ----------
    a: size_t
    b: int

    less(a, b) -> bool

    Parameters
    ----------
    a: size_t
    b: bool

    less(a, b) -> bool

    Parameters
    ----------
    a: int
    b: size_t

    less(a, b) -> bool

    Parameters
    ----------
    a: bool
    b: size_t

    less(a, b) -> bool

    Parameters
    ----------
    a: int
    b: int

    less(a, b) -> bool

    Parameters
    ----------
    a: int
    b: bool

    less(a, b) -> bool

    Parameters
    ----------
    a: bool
    b: int

    less(a, b) -> bool

    Parameters
    ----------
    a: bool
    b: bool

    """
    return _dnnc.less(*args)

def greater(*args):
    """
    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< double > &

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< float > &

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< size_t > &

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< int > &

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< bool > &

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< double > &

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< double > &

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< double > &

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< double > &

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< float > &

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< size_t > &

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< int > &

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< bool > &

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< float > &

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< float > &

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< float > &

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< size_t > &

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< int > &

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< bool > &

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< size_t > &

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< size_t > &

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< int > &

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< bool > &

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< int > &

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< bool > &

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: double

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: float

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: size_t

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: int

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: bool

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: double

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: double

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: double

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: double

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: float

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: size_t

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: int

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: bool

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: float

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: float

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: float

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: size_t

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: int

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: bool

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: size_t

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: size_t

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: int

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: bool

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: int

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: bool

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< double > &

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< float > &

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< size_t > &

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< int > &

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< bool > &

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< double > &

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< double > &

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< double > &

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< double > &

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< float > &

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< size_t > &

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< int > &

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< bool > &

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< float > &

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< float > &

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< float > &

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< size_t > &

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< int > &

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< bool > &

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< size_t > &

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< size_t > &

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< int > &

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< bool > &

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< int > &

    greater(a, b) -> boolTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< bool > &

    greater(a, b) -> bool

    Parameters
    ----------
    a: double
    b: double

    greater(a, b) -> bool

    Parameters
    ----------
    a: double
    b: float

    greater(a, b) -> bool

    Parameters
    ----------
    a: double
    b: size_t

    greater(a, b) -> bool

    Parameters
    ----------
    a: double
    b: int

    greater(a, b) -> bool

    Parameters
    ----------
    a: double
    b: bool

    greater(a, b) -> bool

    Parameters
    ----------
    a: float
    b: double

    greater(a, b) -> bool

    Parameters
    ----------
    a: size_t
    b: double

    greater(a, b) -> bool

    Parameters
    ----------
    a: int
    b: double

    greater(a, b) -> bool

    Parameters
    ----------
    a: bool
    b: double

    greater(a, b) -> bool

    Parameters
    ----------
    a: float
    b: float

    greater(a, b) -> bool

    Parameters
    ----------
    a: float
    b: size_t

    greater(a, b) -> bool

    Parameters
    ----------
    a: float
    b: int

    greater(a, b) -> bool

    Parameters
    ----------
    a: float
    b: bool

    greater(a, b) -> bool

    Parameters
    ----------
    a: size_t
    b: float

    greater(a, b) -> bool

    Parameters
    ----------
    a: int
    b: float

    greater(a, b) -> bool

    Parameters
    ----------
    a: bool
    b: float

    greater(a, b) -> bool

    Parameters
    ----------
    a: size_t
    b: size_t

    greater(a, b) -> bool

    Parameters
    ----------
    a: size_t
    b: int

    greater(a, b) -> bool

    Parameters
    ----------
    a: size_t
    b: bool

    greater(a, b) -> bool

    Parameters
    ----------
    a: int
    b: size_t

    greater(a, b) -> bool

    Parameters
    ----------
    a: bool
    b: size_t

    greater(a, b) -> bool

    Parameters
    ----------
    a: int
    b: int

    greater(a, b) -> bool

    Parameters
    ----------
    a: int
    b: bool

    greater(a, b) -> bool

    Parameters
    ----------
    a: bool
    b: int

    greater(a, b) -> bool

    Parameters
    ----------
    a: bool
    b: bool

    """
    return _dnnc.greater(*args)

def not_equal(*args):
    """
    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< double > &

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< float > &

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< size_t > &

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< int > &

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< bool > &

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< double > &

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< double > &

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< double > &

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< double > &

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< float > &

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< size_t > &

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< int > &

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< bool > &

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< float > &

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< float > &

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< float > &

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< size_t > &

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< int > &

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< bool > &

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< size_t > &

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< size_t > &

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< int > &

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< bool > &

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< int > &

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< bool > &

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: double

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: float

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: size_t

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: int

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: bool

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: double

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: double

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: double

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: double

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: float

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: size_t

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: int

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: bool

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: float

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: float

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: float

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: size_t

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: int

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: bool

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: size_t

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: size_t

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: int

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: bool

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: int

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: bool

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< double > &

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< float > &

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< size_t > &

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< int > &

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< bool > &

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< double > &

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< double > &

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< double > &

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< double > &

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< float > &

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< size_t > &

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< int > &

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< bool > &

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< float > &

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< float > &

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< float > &

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< size_t > &

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< int > &

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< bool > &

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< size_t > &

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< size_t > &

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< int > &

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< bool > &

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< int > &

    not_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< bool > &

    not_equal(a, b) -> bool

    Parameters
    ----------
    a: double
    b: double

    not_equal(a, b) -> bool

    Parameters
    ----------
    a: double
    b: float

    not_equal(a, b) -> bool

    Parameters
    ----------
    a: double
    b: size_t

    not_equal(a, b) -> bool

    Parameters
    ----------
    a: double
    b: int

    not_equal(a, b) -> bool

    Parameters
    ----------
    a: double
    b: bool

    not_equal(a, b) -> bool

    Parameters
    ----------
    a: float
    b: double

    not_equal(a, b) -> bool

    Parameters
    ----------
    a: size_t
    b: double

    not_equal(a, b) -> bool

    Parameters
    ----------
    a: int
    b: double

    not_equal(a, b) -> bool

    Parameters
    ----------
    a: bool
    b: double

    not_equal(a, b) -> bool

    Parameters
    ----------
    a: float
    b: float

    not_equal(a, b) -> bool

    Parameters
    ----------
    a: float
    b: size_t

    not_equal(a, b) -> bool

    Parameters
    ----------
    a: float
    b: int

    not_equal(a, b) -> bool

    Parameters
    ----------
    a: float
    b: bool

    not_equal(a, b) -> bool

    Parameters
    ----------
    a: size_t
    b: float

    not_equal(a, b) -> bool

    Parameters
    ----------
    a: int
    b: float

    not_equal(a, b) -> bool

    Parameters
    ----------
    a: bool
    b: float

    not_equal(a, b) -> bool

    Parameters
    ----------
    a: size_t
    b: size_t

    not_equal(a, b) -> bool

    Parameters
    ----------
    a: size_t
    b: int

    not_equal(a, b) -> bool

    Parameters
    ----------
    a: size_t
    b: bool

    not_equal(a, b) -> bool

    Parameters
    ----------
    a: int
    b: size_t

    not_equal(a, b) -> bool

    Parameters
    ----------
    a: bool
    b: size_t

    not_equal(a, b) -> bool

    Parameters
    ----------
    a: int
    b: int

    not_equal(a, b) -> bool

    Parameters
    ----------
    a: int
    b: bool

    not_equal(a, b) -> bool

    Parameters
    ----------
    a: bool
    b: int

    not_equal(a, b) -> bool

    Parameters
    ----------
    a: bool
    b: bool

    """
    return _dnnc.not_equal(*args)

def less_equal(*args):
    """
    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< double > &

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< float > &

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< size_t > &

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< int > &

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< bool > &

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< double > &

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< double > &

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< double > &

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< double > &

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< float > &

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< size_t > &

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< int > &

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< bool > &

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< float > &

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< float > &

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< float > &

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< size_t > &

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< int > &

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< bool > &

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< size_t > &

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< size_t > &

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< int > &

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< bool > &

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< int > &

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< bool > &

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: double

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: float

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: size_t

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: int

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: bool

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: double

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: double

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: double

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: double

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: float

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: size_t

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: int

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: bool

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: float

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: float

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: float

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: size_t

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: int

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: bool

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: size_t

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: size_t

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: int

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: bool

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: int

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: bool

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< double > &

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< float > &

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< size_t > &

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< int > &

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< bool > &

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< double > &

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< double > &

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< double > &

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< double > &

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< float > &

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< size_t > &

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< int > &

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< bool > &

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< float > &

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< float > &

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< float > &

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< size_t > &

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< int > &

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< bool > &

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< size_t > &

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< size_t > &

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< int > &

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< bool > &

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< int > &

    less_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< bool > &

    less_equal(a, b) -> bool

    Parameters
    ----------
    a: double
    b: double

    less_equal(a, b) -> bool

    Parameters
    ----------
    a: double
    b: float

    less_equal(a, b) -> bool

    Parameters
    ----------
    a: double
    b: size_t

    less_equal(a, b) -> bool

    Parameters
    ----------
    a: double
    b: int

    less_equal(a, b) -> bool

    Parameters
    ----------
    a: double
    b: bool

    less_equal(a, b) -> bool

    Parameters
    ----------
    a: float
    b: double

    less_equal(a, b) -> bool

    Parameters
    ----------
    a: size_t
    b: double

    less_equal(a, b) -> bool

    Parameters
    ----------
    a: int
    b: double

    less_equal(a, b) -> bool

    Parameters
    ----------
    a: bool
    b: double

    less_equal(a, b) -> bool

    Parameters
    ----------
    a: float
    b: float

    less_equal(a, b) -> bool

    Parameters
    ----------
    a: float
    b: size_t

    less_equal(a, b) -> bool

    Parameters
    ----------
    a: float
    b: int

    less_equal(a, b) -> bool

    Parameters
    ----------
    a: float
    b: bool

    less_equal(a, b) -> bool

    Parameters
    ----------
    a: size_t
    b: float

    less_equal(a, b) -> bool

    Parameters
    ----------
    a: int
    b: float

    less_equal(a, b) -> bool

    Parameters
    ----------
    a: bool
    b: float

    less_equal(a, b) -> bool

    Parameters
    ----------
    a: size_t
    b: size_t

    less_equal(a, b) -> bool

    Parameters
    ----------
    a: size_t
    b: int

    less_equal(a, b) -> bool

    Parameters
    ----------
    a: size_t
    b: bool

    less_equal(a, b) -> bool

    Parameters
    ----------
    a: int
    b: size_t

    less_equal(a, b) -> bool

    Parameters
    ----------
    a: bool
    b: size_t

    less_equal(a, b) -> bool

    Parameters
    ----------
    a: int
    b: int

    less_equal(a, b) -> bool

    Parameters
    ----------
    a: int
    b: bool

    less_equal(a, b) -> bool

    Parameters
    ----------
    a: bool
    b: int

    less_equal(a, b) -> bool

    Parameters
    ----------
    a: bool
    b: bool

    """
    return _dnnc.less_equal(*args)

def greater_equal(*args):
    """
    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< double > &

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< float > &

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< size_t > &

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< int > &

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< bool > &

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< double > &

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< double > &

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< double > &

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< double > &

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< float > &

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< size_t > &

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< int > &

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< bool > &

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< float > &

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< float > &

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< float > &

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< size_t > &

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< int > &

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: dnnc::tensor< bool > &

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< size_t > &

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< size_t > &

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< int > &

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< bool > &

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< int > &

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< bool > &

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: double

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: float

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: size_t

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: int

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: bool

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: double

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: double

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: double

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: double

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: float

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: size_t

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: int

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: bool

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: float

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: float

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: float

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: size_t

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: int

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< size_t > &
    b: bool

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: size_t

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: size_t

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: int

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: bool

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: int

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: bool

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< double > &

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< float > &

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< size_t > &

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< int > &

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: double
    b: dnnc::tensor< bool > &

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< double > &

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< double > &

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< double > &

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< double > &

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< float > &

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< size_t > &

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< int > &

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: float
    b: dnnc::tensor< bool > &

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< float > &

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< float > &

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< float > &

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< size_t > &

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< int > &

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: size_t
    b: dnnc::tensor< bool > &

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< size_t > &

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< size_t > &

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< int > &

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: int
    b: dnnc::tensor< bool > &

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< int > &

    greater_equal(a, b) -> boolTensor

    Parameters
    ----------
    a: bool
    b: dnnc::tensor< bool > &

    greater_equal(a, b) -> bool

    Parameters
    ----------
    a: double
    b: double

    greater_equal(a, b) -> bool

    Parameters
    ----------
    a: double
    b: float

    greater_equal(a, b) -> bool

    Parameters
    ----------
    a: double
    b: size_t

    greater_equal(a, b) -> bool

    Parameters
    ----------
    a: double
    b: int

    greater_equal(a, b) -> bool

    Parameters
    ----------
    a: double
    b: bool

    greater_equal(a, b) -> bool

    Parameters
    ----------
    a: float
    b: double

    greater_equal(a, b) -> bool

    Parameters
    ----------
    a: size_t
    b: double

    greater_equal(a, b) -> bool

    Parameters
    ----------
    a: int
    b: double

    greater_equal(a, b) -> bool

    Parameters
    ----------
    a: bool
    b: double

    greater_equal(a, b) -> bool

    Parameters
    ----------
    a: float
    b: float

    greater_equal(a, b) -> bool

    Parameters
    ----------
    a: float
    b: size_t

    greater_equal(a, b) -> bool

    Parameters
    ----------
    a: float
    b: int

    greater_equal(a, b) -> bool

    Parameters
    ----------
    a: float
    b: bool

    greater_equal(a, b) -> bool

    Parameters
    ----------
    a: size_t
    b: float

    greater_equal(a, b) -> bool

    Parameters
    ----------
    a: int
    b: float

    greater_equal(a, b) -> bool

    Parameters
    ----------
    a: bool
    b: float

    greater_equal(a, b) -> bool

    Parameters
    ----------
    a: size_t
    b: size_t

    greater_equal(a, b) -> bool

    Parameters
    ----------
    a: size_t
    b: int

    greater_equal(a, b) -> bool

    Parameters
    ----------
    a: size_t
    b: bool

    greater_equal(a, b) -> bool

    Parameters
    ----------
    a: int
    b: size_t

    greater_equal(a, b) -> bool

    Parameters
    ----------
    a: bool
    b: size_t

    greater_equal(a, b) -> bool

    Parameters
    ----------
    a: int
    b: int

    greater_equal(a, b) -> bool

    Parameters
    ----------
    a: int
    b: bool

    greater_equal(a, b) -> bool

    Parameters
    ----------
    a: bool
    b: int

    greater_equal(a, b) -> bool

    Parameters
    ----------
    a: bool
    b: bool

    """
    return _dnnc.greater_equal(*args)

def empty(x, y=0, z=0, w=0):
    """
    empty(x, y=0, z=0, w=0) -> floatTensor

    Parameters
    ----------
    x: size_t
    y: size_t
    z: size_t
    w: size_t

    empty(x, y=0, z=0) -> floatTensor

    Parameters
    ----------
    x: size_t
    y: size_t
    z: size_t

    empty(x, y=0) -> floatTensor

    Parameters
    ----------
    x: size_t
    y: size_t

    empty(x) -> floatTensor

    Parameters
    ----------
    x: size_t

    """
    return _dnnc.empty(x, y, z, w)

def zeros(x, y=0, z=0, w=0):
    """
    zeros(x, y=0, z=0, w=0) -> floatTensor

    Parameters
    ----------
    x: size_t
    y: size_t
    z: size_t
    w: size_t

    zeros(x, y=0, z=0) -> floatTensor

    Parameters
    ----------
    x: size_t
    y: size_t
    z: size_t

    zeros(x, y=0) -> floatTensor

    Parameters
    ----------
    x: size_t
    y: size_t

    zeros(x) -> floatTensor

    Parameters
    ----------
    x: size_t

    """
    return _dnnc.zeros(x, y, z, w)

def ones(x, y=0, z=0, w=0):
    """
    ones(x, y=0, z=0, w=0) -> floatTensor

    Parameters
    ----------
    x: size_t
    y: size_t
    z: size_t
    w: size_t

    ones(x, y=0, z=0) -> floatTensor

    Parameters
    ----------
    x: size_t
    y: size_t
    z: size_t

    ones(x, y=0) -> floatTensor

    Parameters
    ----------
    x: size_t
    y: size_t

    ones(x) -> floatTensor

    Parameters
    ----------
    x: size_t

    """
    return _dnnc.ones(x, y, z, w)

def random(x, y=0, z=0, w=0):
    """
    random(x, y=0, z=0, w=0) -> floatTensor

    Parameters
    ----------
    x: size_t
    y: size_t
    z: size_t
    w: size_t

    random(x, y=0, z=0) -> floatTensor

    Parameters
    ----------
    x: size_t
    y: size_t
    z: size_t

    random(x, y=0) -> floatTensor

    Parameters
    ----------
    x: size_t
    y: size_t

    random(x) -> floatTensor

    Parameters
    ----------
    x: size_t

    """
    return _dnnc.random(x, y, z, w)

def array(*args):
    """
    array(x, y=0, z=0, w=0) -> floatTensor

    Parameters
    ----------
    x: size_t
    y: size_t
    z: size_t
    w: size_t

    array(x, y=0, z=0) -> floatTensor

    Parameters
    ----------
    x: size_t
    y: size_t
    z: size_t

    array(x, y=0) -> floatTensor

    Parameters
    ----------
    x: size_t
    y: size_t

    array(x) -> floatTensor

    Parameters
    ----------
    x: size_t

    array(objects) -> floatTensor

    Parameters
    ----------
    objects: PyObject *

    """
    return _dnnc.array(*args)

def arange(stop, start=0, step=1):
    """
    arange(stop, start=0, step=1) -> floatTensor

    Parameters
    ----------
    stop: int
    start: int
    step: size_t

    arange(stop, start=0) -> floatTensor

    Parameters
    ----------
    stop: int
    start: int

    arange(stop) -> floatTensor

    Parameters
    ----------
    stop: int

    """
    return _dnnc.arange(stop, start, step)

def reshape(*args):
    """
    reshape(tens_obj, newShape) -> doubleTensor

    Parameters
    ----------
    tens_obj: dnnc::tensor< double > &
    newShape: PyObject *

    reshape(tens_obj, newShape) -> floatTensor

    Parameters
    ----------
    tens_obj: dnnc::tensor< float > &
    newShape: PyObject *

    reshape(tens_obj, newShape) -> intTensor

    Parameters
    ----------
    tens_obj: dnnc::tensor< int > &
    newShape: PyObject *

    reshape(tens_obj, newShape) -> boolTensor

    Parameters
    ----------
    tens_obj: dnnc::tensor< bool > &
    newShape: PyObject *

    """
    return _dnnc.reshape(*args)

def matmul(*args):
    """
    matmul(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< double > &

    matmul(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< float > &

    matmul(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< int > &

    """
    return _dnnc.matmul(*args)

def abs(*args):
    """
    abs(a) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &

    abs(a) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &

    abs(a) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &

    """
    return _dnnc.abs(*args)

def acos(*args):
    """
    acos(a) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &

    acos(a) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &

    acos(a) -> float

    Parameters
    ----------
    a: float

    acos(a) -> double

    Parameters
    ----------
    a: double

    """
    return _dnnc.acos(*args)

def acosh(*args):
    """
    acosh(a) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &

    acosh(a) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &

    acosh(a) -> float

    Parameters
    ----------
    a: float

    acosh(a) -> double

    Parameters
    ----------
    a: double

    """
    return _dnnc.acosh(*args)

def asin(*args):
    """
    asin(a) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &

    asin(a) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &

    asin(a) -> float

    Parameters
    ----------
    a: float

    asin(a) -> double

    Parameters
    ----------
    a: double

    """
    return _dnnc.asin(*args)

def asinh(*args):
    """
    asinh(a) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &

    asinh(a) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &

    asinh(a) -> float

    Parameters
    ----------
    a: float

    asinh(a) -> double

    Parameters
    ----------
    a: double

    """
    return _dnnc.asinh(*args)

def atan(*args):
    """
    atan(a) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &

    atan(a) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &

    atan(a) -> float

    Parameters
    ----------
    a: float

    atan(a) -> double

    Parameters
    ----------
    a: double

    """
    return _dnnc.atan(*args)

def atanh(*args):
    """
    atanh(a) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &

    atanh(a) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &

    atanh(a) -> float

    Parameters
    ----------
    a: float

    atanh(a) -> double

    Parameters
    ----------
    a: double

    """
    return _dnnc.atanh(*args)

def cos(*args):
    """
    cos(a) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &

    cos(a) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &

    cos(a) -> float

    Parameters
    ----------
    a: float

    cos(a) -> double

    Parameters
    ----------
    a: double

    """
    return _dnnc.cos(*args)

def cosh(*args):
    """
    cosh(a) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &

    cosh(a) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &

    cosh(a) -> float

    Parameters
    ----------
    a: float

    cosh(a) -> double

    Parameters
    ----------
    a: double

    """
    return _dnnc.cosh(*args)

def argmax(*args):
    """
    argmax(a, axis=0, keepdims=0) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    axis: int
    keepdims: int

    argmax(a, axis=0) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    axis: int

    argmax(a) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &

    argmax(a, axis=0, keepdims=0) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    axis: int
    keepdims: int

    argmax(a, axis=0) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    axis: int

    argmax(a) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &

    argmax(a, axis=0, keepdims=0) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    axis: int
    keepdims: int

    argmax(a, axis=0) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    axis: int

    argmax(a) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &

    """
    return _dnnc.argmax(*args)

def argmin(*args):
    """
    argmin(a, axis=0, keepdims=0) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    axis: int
    keepdims: int

    argmin(a, axis=0) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    axis: int

    argmin(a) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &

    argmin(a, axis=0, keepdims=0) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    axis: int
    keepdims: int

    argmin(a, axis=0) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    axis: int

    argmin(a) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &

    argmin(a, axis=0, keepdims=0) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    axis: int
    keepdims: int

    argmin(a, axis=0) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    axis: int

    argmin(a) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &

    """
    return _dnnc.argmin(*args)

def bitshift(*args):
    """
    bitshift(a, b, direction) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< int > &
    direction: std::string

    bitshift(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< int > &

    """
    return _dnnc.bitshift(*args)

def conv(*args):
    """
    conv(X, W, B, auto_pad, dilations, group=1, kernal_shape, pads, strides) -> floatTensor

    Parameters
    ----------
    X: dnnc::tensor< float >
    W: dnnc::tensor< float >
    B: dnnc::tensor< float >
    auto_pad: std::string
    dilations: std::vector< int,std::allocator< int > >
    group: int
    kernal_shape: std::vector< int,std::allocator< int > >
    pads: std::vector< int,std::allocator< int > >
    strides: std::vector< int,std::allocator< int > >

    conv(X, W, B, auto_pad, dilations, group=1, kernal_shape, pads) -> floatTensor

    Parameters
    ----------
    X: dnnc::tensor< float >
    W: dnnc::tensor< float >
    B: dnnc::tensor< float >
    auto_pad: std::string
    dilations: std::vector< int,std::allocator< int > >
    group: int
    kernal_shape: std::vector< int,std::allocator< int > >
    pads: std::vector< int,std::allocator< int > >

    conv(X, W, B, auto_pad, dilations, group=1, kernal_shape) -> floatTensor

    Parameters
    ----------
    X: dnnc::tensor< float >
    W: dnnc::tensor< float >
    B: dnnc::tensor< float >
    auto_pad: std::string
    dilations: std::vector< int,std::allocator< int > >
    group: int
    kernal_shape: std::vector< int,std::allocator< int > >

    conv(X, W, B, auto_pad, dilations, group=1) -> floatTensor

    Parameters
    ----------
    X: dnnc::tensor< float >
    W: dnnc::tensor< float >
    B: dnnc::tensor< float >
    auto_pad: std::string
    dilations: std::vector< int,std::allocator< int > >
    group: int

    conv(X, W, B, auto_pad, dilations) -> floatTensor

    Parameters
    ----------
    X: dnnc::tensor< float >
    W: dnnc::tensor< float >
    B: dnnc::tensor< float >
    auto_pad: std::string
    dilations: std::vector< int,std::allocator< int > >

    conv(X, W, B, auto_pad) -> floatTensor

    Parameters
    ----------
    X: dnnc::tensor< float >
    W: dnnc::tensor< float >
    B: dnnc::tensor< float >
    auto_pad: std::string

    conv(X, W, B) -> floatTensor

    Parameters
    ----------
    X: dnnc::tensor< float >
    W: dnnc::tensor< float >
    B: dnnc::tensor< float >

    conv(X, W, B, auto_pad, dilations, group=1, kernal_shape, pads, strides) -> doubleTensor

    Parameters
    ----------
    X: dnnc::tensor< double >
    W: dnnc::tensor< double >
    B: dnnc::tensor< double >
    auto_pad: std::string
    dilations: std::vector< int,std::allocator< int > >
    group: int
    kernal_shape: std::vector< int,std::allocator< int > >
    pads: std::vector< int,std::allocator< int > >
    strides: std::vector< int,std::allocator< int > >

    conv(X, W, B, auto_pad, dilations, group=1, kernal_shape, pads) -> doubleTensor

    Parameters
    ----------
    X: dnnc::tensor< double >
    W: dnnc::tensor< double >
    B: dnnc::tensor< double >
    auto_pad: std::string
    dilations: std::vector< int,std::allocator< int > >
    group: int
    kernal_shape: std::vector< int,std::allocator< int > >
    pads: std::vector< int,std::allocator< int > >

    conv(X, W, B, auto_pad, dilations, group=1, kernal_shape) -> doubleTensor

    Parameters
    ----------
    X: dnnc::tensor< double >
    W: dnnc::tensor< double >
    B: dnnc::tensor< double >
    auto_pad: std::string
    dilations: std::vector< int,std::allocator< int > >
    group: int
    kernal_shape: std::vector< int,std::allocator< int > >

    conv(X, W, B, auto_pad, dilations, group=1) -> doubleTensor

    Parameters
    ----------
    X: dnnc::tensor< double >
    W: dnnc::tensor< double >
    B: dnnc::tensor< double >
    auto_pad: std::string
    dilations: std::vector< int,std::allocator< int > >
    group: int

    conv(X, W, B, auto_pad, dilations) -> doubleTensor

    Parameters
    ----------
    X: dnnc::tensor< double >
    W: dnnc::tensor< double >
    B: dnnc::tensor< double >
    auto_pad: std::string
    dilations: std::vector< int,std::allocator< int > >

    conv(X, W, B, auto_pad) -> doubleTensor

    Parameters
    ----------
    X: dnnc::tensor< double >
    W: dnnc::tensor< double >
    B: dnnc::tensor< double >
    auto_pad: std::string

    conv(X, W, B) -> doubleTensor

    Parameters
    ----------
    X: dnnc::tensor< double >
    W: dnnc::tensor< double >
    B: dnnc::tensor< double >

    """
    return _dnnc.conv(*args)

def dequantize_linear(a, b, c):
    """
    dequantize_linear(a, b, c) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< float > &
    c: dnnc::tensor< int > &

    """
    return _dnnc.dequantize_linear(a, b, c)

def dropout(*args):
    """
    dropout(a, ratio=0.5) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    ratio: float

    dropout(a) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &

    dropout(a, ratio=0.5) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    ratio: float

    dropout(a) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &

    """
    return _dnnc.dropout(*args)

def div(*args):
    """
    div(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< double > &

    div(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< float > &

    div(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< int > &

    div(a, b) -> double

    Parameters
    ----------
    a: double
    b: double

    div(a, b) -> float

    Parameters
    ----------
    a: float
    b: float

    div(a, b) -> int

    Parameters
    ----------
    a: int
    b: int

    """
    return _dnnc.div(*args)

def elu(*args):
    """
    elu(a, alpha=1.0) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    alpha: float

    elu(a) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &

    elu(a, alpha=1.0) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    alpha: float

    elu(a) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &

    """
    return _dnnc.elu(*args)

def erf(*args):
    """
    erf(a) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &

    erf(a) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &

    erf(a) -> float

    Parameters
    ----------
    a: float

    erf(a) -> double

    Parameters
    ----------
    a: double

    """
    return _dnnc.erf(*args)

def exp(*args):
    """
    exp(a) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &

    exp(a) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &

    exp(a) -> float

    Parameters
    ----------
    a: float

    exp(a) -> double

    Parameters
    ----------
    a: double

    """
    return _dnnc.exp(*args)

def expand(*args):
    """
    expand(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< int > &

    expand(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< int > &

    """
    return _dnnc.expand(*args)

def eye_like(*args):
    """
    eye_like(a, k=0) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    k: int

    eye_like(a) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &

    eye_like(a, k=0) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    k: int

    eye_like(a) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &

    eye_like(a, k=0) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    k: int

    eye_like(a) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &

    eye_like(a, k=0) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    k: int

    eye_like(a) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &

    """
    return _dnnc.eye_like(*args)

def flatten(*args):
    """
    flatten(a, axis=1) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    axis: int

    flatten(a) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &

    flatten(a, axis=1) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    axis: int

    flatten(a) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &

    flatten(a, axis=1) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    axis: int

    flatten(a) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &

    flatten(a, axis=1) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    axis: int

    flatten(a) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &

    """
    return _dnnc.flatten(*args)

def floor(*args):
    """
    floor(a) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &

    floor(a) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &

    """
    return _dnnc.floor(*args)

def gemm(*args):
    """
    gemm(a, b, c, alpha=1.0, beta=1.0, transA=0, transB=0) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< double > &
    c: dnnc::tensor< double > &
    alpha: float
    beta: float
    transA: int
    transB: int

    gemm(a, b, c, alpha=1.0, beta=1.0, transA=0) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< double > &
    c: dnnc::tensor< double > &
    alpha: float
    beta: float
    transA: int

    gemm(a, b, c, alpha=1.0, beta=1.0) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< double > &
    c: dnnc::tensor< double > &
    alpha: float
    beta: float

    gemm(a, b, c, alpha=1.0) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< double > &
    c: dnnc::tensor< double > &
    alpha: float

    gemm(a, b, c) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< double > &
    c: dnnc::tensor< double > &

    gemm(a, b, c, alpha=1.0, beta=1.0, transA=0, transB=0) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< float > &
    c: dnnc::tensor< float > &
    alpha: float
    beta: float
    transA: int
    transB: int

    gemm(a, b, c, alpha=1.0, beta=1.0, transA=0) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< float > &
    c: dnnc::tensor< float > &
    alpha: float
    beta: float
    transA: int

    gemm(a, b, c, alpha=1.0, beta=1.0) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< float > &
    c: dnnc::tensor< float > &
    alpha: float
    beta: float

    gemm(a, b, c, alpha=1.0) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< float > &
    c: dnnc::tensor< float > &
    alpha: float

    gemm(a, b, c) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< float > &
    c: dnnc::tensor< float > &

    """
    return _dnnc.gemm(*args)

def global_average_pool(*args):
    """
    global_average_pool(a) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &

    global_average_pool(a) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &

    """
    return _dnnc.global_average_pool(*args)

def global_lp_pool(*args):
    """
    global_lp_pool(a, p=2) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    p: int

    global_lp_pool(a) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &

    global_lp_pool(a, p=2) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    p: int

    global_lp_pool(a) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &

    """
    return _dnnc.global_lp_pool(*args)

def global_max_pool(*args):
    """
    global_max_pool(a) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &

    global_max_pool(a) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &

    """
    return _dnnc.global_max_pool(*args)

def hardmax(*args):
    """
    hardmax(a, axis=0) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    axis: int

    hardmax(a) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &

    hardmax(a, axis=0) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    axis: int

    hardmax(a) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &

    """
    return _dnnc.hardmax(*args)

def hardsigmoid(*args):
    """
    hardsigmoid(a, alpha=0.2, beta=0.5) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    alpha: float
    beta: float

    hardsigmoid(a, alpha=0.2) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    alpha: float

    hardsigmoid(a) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &

    hardsigmoid(a, alpha=0.2, beta=0.5) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    alpha: float
    beta: float

    hardsigmoid(a, alpha=0.2) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    alpha: float

    hardsigmoid(a) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &

    """
    return _dnnc.hardsigmoid(*args)

def identity(*args):
    """
    identity(a) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &

    identity(a) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &

    identity(a) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &

    identity(a) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &

    """
    return _dnnc.identity(*args)

def instancenormalization(*args):
    """
    instancenormalization(a, scale, B, epsilon=1e-5) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    scale: dnnc::tensor< float > &
    B: dnnc::tensor< float > &
    epsilon: float

    instancenormalization(a, scale, B) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    scale: dnnc::tensor< float > &
    B: dnnc::tensor< float > &

    instancenormalization(a, scale, B, epsilon=1e-5) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    scale: dnnc::tensor< double > &
    B: dnnc::tensor< double > &
    epsilon: float

    instancenormalization(a, scale, B) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    scale: dnnc::tensor< double > &
    B: dnnc::tensor< double > &

    """
    return _dnnc.instancenormalization(*args)

def isinf(*args):
    """
    isinf(a, detect_positive=1, detect_negative=1) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    detect_positive: int
    detect_negative: int

    isinf(a, detect_positive=1) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    detect_positive: int

    isinf(a) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &

    isinf(a, detect_positive=1, detect_negative=1) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    detect_positive: int
    detect_negative: int

    isinf(a, detect_positive=1) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    detect_positive: int

    isinf(a) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &

    """
    return _dnnc.isinf(*args)

def isnan(*args):
    """
    isnan(a) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &

    isnan(a) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &

    """
    return _dnnc.isnan(*args)

def lrn(*args):
    """
    lrn(a, size, alpha=0.0001, beta=0.75, bias=1.0) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    size: int
    alpha: float
    beta: float
    bias: float

    lrn(a, size, alpha=0.0001, beta=0.75) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    size: int
    alpha: float
    beta: float

    lrn(a, size, alpha=0.0001) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    size: int
    alpha: float

    lrn(a, size) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    size: int

    lrn(a, size, alpha=0.0001, beta=0.75, bias=1.0) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    size: int
    alpha: float
    beta: float
    bias: float

    lrn(a, size, alpha=0.0001, beta=0.75) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    size: int
    alpha: float
    beta: float

    lrn(a, size, alpha=0.0001) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    size: int
    alpha: float

    lrn(a, size) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    size: int

    """
    return _dnnc.lrn(*args)

def leakyrelu(*args):
    """
    leakyrelu(a, alpha=0.01) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    alpha: float

    leakyrelu(a) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &

    leakyrelu(a, alpha=0.01) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    alpha: float

    leakyrelu(a) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &

    """
    return _dnnc.leakyrelu(*args)

def reciprocal(*args):
    """
    reciprocal(a) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &

    reciprocal(a) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &

    """
    return _dnnc.reciprocal(*args)

def log(*args):
    """
    log(a) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &

    log(a) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &

    log(a) -> float

    Parameters
    ----------
    a: float

    log(a) -> double

    Parameters
    ----------
    a: double

    """
    return _dnnc.log(*args)

def logsoftmax(*args):
    """
    logsoftmax(a, axis=1) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    axis: int

    logsoftmax(a) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &

    logsoftmax(a, axis=1) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    axis: int

    logsoftmax(a) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &

    """
    return _dnnc.logsoftmax(*args)

def lpnormalization(*args):
    """
    lpnormalization(a, p=2, axis=-1) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    p: int
    axis: int

    lpnormalization(a, p=2) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    p: int

    lpnormalization(a) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &

    lpnormalization(a, p=2, axis=-1) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    p: int
    axis: int

    lpnormalization(a, p=2) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    p: int

    lpnormalization(a) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &

    """
    return _dnnc.lpnormalization(*args)

def matmulinteger(a, b, c, d):
    """
    matmulinteger(a, b, c, d) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< int > &
    c: dnnc::tensor< int > &
    d: dnnc::tensor< int > &

    """
    return _dnnc.matmulinteger(a, b, c, d)

def min(*args):
    """
    min(a) -> floatTensor

    Parameters
    ----------
    a: std::vector< dnnc::tensor< float >,std::allocator< dnnc::tensor< float > > >

    min(a) -> doubleTensor

    Parameters
    ----------
    a: std::vector< dnnc::tensor< double >,std::allocator< dnnc::tensor< double > > >

    min(a) -> float

    Parameters
    ----------
    a: std::vector< float,std::allocator< float > >

    min(a) -> double

    Parameters
    ----------
    a: std::vector< double,std::allocator< double > >

    """
    return _dnnc.min(*args)

def mean(*args):
    """
    mean(a) -> floatTensor

    Parameters
    ----------
    a: std::vector< dnnc::tensor< float >,std::allocator< dnnc::tensor< float > > >

    mean(a) -> doubleTensor

    Parameters
    ----------
    a: std::vector< dnnc::tensor< double >,std::allocator< dnnc::tensor< double > > >

    mean(a) -> float

    Parameters
    ----------
    a: std::vector< float,std::allocator< float > >

    mean(a) -> double

    Parameters
    ----------
    a: std::vector< double,std::allocator< double > >

    """
    return _dnnc.mean(*args)

def max(*args):
    """
    max(a) -> floatTensor

    Parameters
    ----------
    a: std::vector< dnnc::tensor< float >,std::allocator< dnnc::tensor< float > > >

    max(a) -> doubleTensor

    Parameters
    ----------
    a: std::vector< dnnc::tensor< double >,std::allocator< dnnc::tensor< double > > >

    max(a) -> float

    Parameters
    ----------
    a: std::vector< float,std::allocator< float > >

    max(a) -> double

    Parameters
    ----------
    a: std::vector< double,std::allocator< double > >

    """
    return _dnnc.max(*args)

def mod(*args):
    """
    mod(a, b, fmod_flag=0) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< double > &
    fmod_flag: int

    mod(a, b) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< double > &

    mod(a, b, fmod_flag=0) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< float > &
    fmod_flag: int

    mod(a, b) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< float > &

    mod(a, b, fmod_flag=0) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< int > &
    fmod_flag: int

    mod(a, b) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< int > &

    """
    return _dnnc.mod(*args)

def reduce_sum_square(*args):
    """
    reduce_sum_square(a, axis, keepdims=0) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    axis: std::vector< int,std::allocator< int > >
    keepdims: int

    reduce_sum_square(a, axis) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    axis: std::vector< int,std::allocator< int > >

    reduce_sum_square(a) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &

    reduce_sum_square(a, axis, keepdims=0) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    axis: std::vector< int,std::allocator< int > >
    keepdims: int

    reduce_sum_square(a, axis) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    axis: std::vector< int,std::allocator< int > >

    reduce_sum_square(a) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &

    reduce_sum_square(a, axis, keepdims=0) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    axis: std::vector< int,std::allocator< int > >
    keepdims: int

    reduce_sum_square(a, axis) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    axis: std::vector< int,std::allocator< int > >

    reduce_sum_square(a) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &

    """
    return _dnnc.reduce_sum_square(*args)

def reduce_sum(*args):
    """
    reduce_sum(a, axis, keepdims=0) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    axis: std::vector< int,std::allocator< int > >
    keepdims: int

    reduce_sum(a, axis) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    axis: std::vector< int,std::allocator< int > >

    reduce_sum(a) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &

    reduce_sum(a, axis, keepdims=0) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    axis: std::vector< int,std::allocator< int > >
    keepdims: int

    reduce_sum(a, axis) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    axis: std::vector< int,std::allocator< int > >

    reduce_sum(a) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &

    reduce_sum(a, axis, keepdims=0) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    axis: std::vector< int,std::allocator< int > >
    keepdims: int

    reduce_sum(a, axis) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    axis: std::vector< int,std::allocator< int > >

    reduce_sum(a) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &

    """
    return _dnnc.reduce_sum(*args)

def thresholded_relu(*args):
    """
    thresholded_relu(a) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &

    thresholded_relu(a) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &

    """
    return _dnnc.thresholded_relu(*args)

def neg(*args):
    """
    neg(a) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &

    neg(a) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &

    neg(a) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &

    """
    return _dnnc.neg(*args)

def logical_not(*args):
    """
    logical_not(a) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &

    logical_not(a) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &

    logical_not(a) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &

    logical_not(a) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &

    logical_not(a) -> bool

    Parameters
    ----------
    a: bool

    logical_not(a) -> bool

    Parameters
    ----------
    a: int

    logical_not(a) -> bool

    Parameters
    ----------
    a: float

    logical_not(a) -> bool

    Parameters
    ----------
    a: double

    """
    return _dnnc.logical_not(*args)

def tan(*args):
    """
    tan(a) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &

    tan(a) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &

    tan(a) -> float

    Parameters
    ----------
    a: float

    tan(a) -> double

    Parameters
    ----------
    a: double

    """
    return _dnnc.tan(*args)

def tanh(*args):
    """
    tanh(a) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &

    tanh(a) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &

    tanh(a) -> float

    Parameters
    ----------
    a: float

    tanh(a) -> double

    Parameters
    ----------
    a: double

    """
    return _dnnc.tanh(*args)

def transpose(*args):
    """
    transpose(a) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &

    transpose(a) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &

    transpose(a) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &

    transpose(a) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &

    """
    return _dnnc.transpose(*args)

def sigmoid(a):
    """
    sigmoid(a) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &

    """
    return _dnnc.sigmoid(a)

def sign(*args):
    """
    sign(a) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &

    sign(a) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &

    sign(a) -> float

    Parameters
    ----------
    a: float

    sign(a) -> double

    Parameters
    ----------
    a: double

    """
    return _dnnc.sign(*args)

def sin(*args):
    """
    sin(a) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &

    sin(a) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &

    sin(a) -> float

    Parameters
    ----------
    a: float

    sin(a) -> double

    Parameters
    ----------
    a: double

    """
    return _dnnc.sin(*args)

def sinh(*args):
    """
    sinh(a) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &

    sinh(a) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &

    sinh(a) -> float

    Parameters
    ----------
    a: float

    sinh(a) -> double

    Parameters
    ----------
    a: double

    """
    return _dnnc.sinh(*args)

def softplus(*args):
    """
    softplus(a) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &

    softplus(a) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &

    """
    return _dnnc.softplus(*args)

def softmax(*args):
    """
    softmax(a, axis=1) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    axis: int

    softmax(a) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &

    softmax(a, axis=1) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    axis: int

    softmax(a) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &

    """
    return _dnnc.softmax(*args)

def softsign(*args):
    """
    softsign(a) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &

    softsign(a) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &

    softsign(a) -> float

    Parameters
    ----------
    a: float

    softsign(a) -> double

    Parameters
    ----------
    a: double

    """
    return _dnnc.softsign(*args)

def sqrt(*args):
    """
    sqrt(a) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &

    sqrt(a) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &

    sqrt(a) -> float

    Parameters
    ----------
    a: float

    sqrt(a) -> double

    Parameters
    ----------
    a: double

    """
    return _dnnc.sqrt(*args)

def ceil(*args):
    """
    ceil(a) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &

    ceil(a) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &

    """
    return _dnnc.ceil(*args)

def clip(*args):
    """
    clip(a, min, max) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    min: float
    max: float

    clip(a, min, max) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    min: double
    max: double

    """
    return _dnnc.clip(*args)

def slice(*args):
    """
    slice(a, start, end, axes, steps) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    start: dnnc::tensor< int > &
    end: dnnc::tensor< int > &
    axes: dnnc::tensor< int >
    steps: dnnc::tensor< int >

    slice(a, start, end, axes) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    start: dnnc::tensor< int > &
    end: dnnc::tensor< int > &
    axes: dnnc::tensor< int >

    slice(a, start, end) -> doubleTensor

    Parameters
    ----------
    a: dnnc::tensor< double > &
    start: dnnc::tensor< int > &
    end: dnnc::tensor< int > &

    slice(a, start, end, axes, steps) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    start: dnnc::tensor< int > &
    end: dnnc::tensor< int > &
    axes: dnnc::tensor< int >
    steps: dnnc::tensor< int >

    slice(a, start, end, axes) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    start: dnnc::tensor< int > &
    end: dnnc::tensor< int > &
    axes: dnnc::tensor< int >

    slice(a, start, end) -> floatTensor

    Parameters
    ----------
    a: dnnc::tensor< float > &
    start: dnnc::tensor< int > &
    end: dnnc::tensor< int > &

    slice(a, start, end, axes, steps) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    start: dnnc::tensor< int > &
    end: dnnc::tensor< int > &
    axes: dnnc::tensor< int >
    steps: dnnc::tensor< int >

    slice(a, start, end, axes) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    start: dnnc::tensor< int > &
    end: dnnc::tensor< int > &
    axes: dnnc::tensor< int >

    slice(a, start, end) -> intTensor

    Parameters
    ----------
    a: dnnc::tensor< int > &
    start: dnnc::tensor< int > &
    end: dnnc::tensor< int > &

    slice(a, start, end, axes, steps) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    start: dnnc::tensor< int > &
    end: dnnc::tensor< int > &
    axes: dnnc::tensor< int >
    steps: dnnc::tensor< int >

    slice(a, start, end, axes) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    start: dnnc::tensor< int > &
    end: dnnc::tensor< int > &
    axes: dnnc::tensor< int >

    slice(a, start, end) -> boolTensor

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    start: dnnc::tensor< int > &
    end: dnnc::tensor< int > &

    """
    return _dnnc.slice(*args)

def set_slice(*args):
    """
    set_slice(a, b, start, end, axes, steps)

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< double > &
    start: dnnc::tensor< int > &
    end: dnnc::tensor< int > &
    axes: dnnc::tensor< int >
    steps: dnnc::tensor< int >

    set_slice(a, b, start, end, axes)

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< double > &
    start: dnnc::tensor< int > &
    end: dnnc::tensor< int > &
    axes: dnnc::tensor< int >

    set_slice(a, b, start, end)

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< double > &
    start: dnnc::tensor< int > &
    end: dnnc::tensor< int > &

    set_slice(a, b, start, end, axes, steps)

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< float > &
    start: dnnc::tensor< int > &
    end: dnnc::tensor< int > &
    axes: dnnc::tensor< int >
    steps: dnnc::tensor< int >

    set_slice(a, b, start, end, axes)

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< float > &
    start: dnnc::tensor< int > &
    end: dnnc::tensor< int > &
    axes: dnnc::tensor< int >

    set_slice(a, b, start, end)

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< float > &
    start: dnnc::tensor< int > &
    end: dnnc::tensor< int > &

    set_slice(a, b, start, end, axes, steps)

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< int > &
    start: dnnc::tensor< int > &
    end: dnnc::tensor< int > &
    axes: dnnc::tensor< int >
    steps: dnnc::tensor< int >

    set_slice(a, b, start, end, axes)

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< int > &
    start: dnnc::tensor< int > &
    end: dnnc::tensor< int > &
    axes: dnnc::tensor< int >

    set_slice(a, b, start, end)

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< int > &
    start: dnnc::tensor< int > &
    end: dnnc::tensor< int > &

    set_slice(a, b, start, end, axes, steps)

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< bool > &
    start: dnnc::tensor< int > &
    end: dnnc::tensor< int > &
    axes: dnnc::tensor< int >
    steps: dnnc::tensor< int >

    set_slice(a, b, start, end, axes)

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< bool > &
    start: dnnc::tensor< int > &
    end: dnnc::tensor< int > &
    axes: dnnc::tensor< int >

    set_slice(a, b, start, end)

    Parameters
    ----------
    a: dnnc::tensor< double > &
    b: dnnc::tensor< bool > &
    start: dnnc::tensor< int > &
    end: dnnc::tensor< int > &

    set_slice(a, b, start, end, axes, steps)

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< double > &
    start: dnnc::tensor< int > &
    end: dnnc::tensor< int > &
    axes: dnnc::tensor< int >
    steps: dnnc::tensor< int >

    set_slice(a, b, start, end, axes)

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< double > &
    start: dnnc::tensor< int > &
    end: dnnc::tensor< int > &
    axes: dnnc::tensor< int >

    set_slice(a, b, start, end)

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< double > &
    start: dnnc::tensor< int > &
    end: dnnc::tensor< int > &

    set_slice(a, b, start, end, axes, steps)

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< float > &
    start: dnnc::tensor< int > &
    end: dnnc::tensor< int > &
    axes: dnnc::tensor< int >
    steps: dnnc::tensor< int >

    set_slice(a, b, start, end, axes)

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< float > &
    start: dnnc::tensor< int > &
    end: dnnc::tensor< int > &
    axes: dnnc::tensor< int >

    set_slice(a, b, start, end)

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< float > &
    start: dnnc::tensor< int > &
    end: dnnc::tensor< int > &

    set_slice(a, b, start, end, axes, steps)

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< int > &
    start: dnnc::tensor< int > &
    end: dnnc::tensor< int > &
    axes: dnnc::tensor< int >
    steps: dnnc::tensor< int >

    set_slice(a, b, start, end, axes)

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< int > &
    start: dnnc::tensor< int > &
    end: dnnc::tensor< int > &
    axes: dnnc::tensor< int >

    set_slice(a, b, start, end)

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< int > &
    start: dnnc::tensor< int > &
    end: dnnc::tensor< int > &

    set_slice(a, b, start, end, axes, steps)

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< bool > &
    start: dnnc::tensor< int > &
    end: dnnc::tensor< int > &
    axes: dnnc::tensor< int >
    steps: dnnc::tensor< int >

    set_slice(a, b, start, end, axes)

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< bool > &
    start: dnnc::tensor< int > &
    end: dnnc::tensor< int > &
    axes: dnnc::tensor< int >

    set_slice(a, b, start, end)

    Parameters
    ----------
    a: dnnc::tensor< float > &
    b: dnnc::tensor< bool > &
    start: dnnc::tensor< int > &
    end: dnnc::tensor< int > &

    set_slice(a, b, start, end, axes, steps)

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< double > &
    start: dnnc::tensor< int > &
    end: dnnc::tensor< int > &
    axes: dnnc::tensor< int >
    steps: dnnc::tensor< int >

    set_slice(a, b, start, end, axes)

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< double > &
    start: dnnc::tensor< int > &
    end: dnnc::tensor< int > &
    axes: dnnc::tensor< int >

    set_slice(a, b, start, end)

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< double > &
    start: dnnc::tensor< int > &
    end: dnnc::tensor< int > &

    set_slice(a, b, start, end, axes, steps)

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< float > &
    start: dnnc::tensor< int > &
    end: dnnc::tensor< int > &
    axes: dnnc::tensor< int >
    steps: dnnc::tensor< int >

    set_slice(a, b, start, end, axes)

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< float > &
    start: dnnc::tensor< int > &
    end: dnnc::tensor< int > &
    axes: dnnc::tensor< int >

    set_slice(a, b, start, end)

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< float > &
    start: dnnc::tensor< int > &
    end: dnnc::tensor< int > &

    set_slice(a, b, start, end, axes, steps)

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< int > &
    start: dnnc::tensor< int > &
    end: dnnc::tensor< int > &
    axes: dnnc::tensor< int >
    steps: dnnc::tensor< int >

    set_slice(a, b, start, end, axes)

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< int > &
    start: dnnc::tensor< int > &
    end: dnnc::tensor< int > &
    axes: dnnc::tensor< int >

    set_slice(a, b, start, end)

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< int > &
    start: dnnc::tensor< int > &
    end: dnnc::tensor< int > &

    set_slice(a, b, start, end, axes, steps)

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< bool > &
    start: dnnc::tensor< int > &
    end: dnnc::tensor< int > &
    axes: dnnc::tensor< int >
    steps: dnnc::tensor< int >

    set_slice(a, b, start, end, axes)

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< bool > &
    start: dnnc::tensor< int > &
    end: dnnc::tensor< int > &
    axes: dnnc::tensor< int >

    set_slice(a, b, start, end)

    Parameters
    ----------
    a: dnnc::tensor< int > &
    b: dnnc::tensor< bool > &
    start: dnnc::tensor< int > &
    end: dnnc::tensor< int > &

    set_slice(a, b, start, end, axes, steps)

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< double > &
    start: dnnc::tensor< int > &
    end: dnnc::tensor< int > &
    axes: dnnc::tensor< int >
    steps: dnnc::tensor< int >

    set_slice(a, b, start, end, axes)

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< double > &
    start: dnnc::tensor< int > &
    end: dnnc::tensor< int > &
    axes: dnnc::tensor< int >

    set_slice(a, b, start, end)

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< double > &
    start: dnnc::tensor< int > &
    end: dnnc::tensor< int > &

    set_slice(a, b, start, end, axes, steps)

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< float > &
    start: dnnc::tensor< int > &
    end: dnnc::tensor< int > &
    axes: dnnc::tensor< int >
    steps: dnnc::tensor< int >

    set_slice(a, b, start, end, axes)

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< float > &
    start: dnnc::tensor< int > &
    end: dnnc::tensor< int > &
    axes: dnnc::tensor< int >

    set_slice(a, b, start, end)

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< float > &
    start: dnnc::tensor< int > &
    end: dnnc::tensor< int > &

    set_slice(a, b, start, end, axes, steps)

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< int > &
    start: dnnc::tensor< int > &
    end: dnnc::tensor< int > &
    axes: dnnc::tensor< int >
    steps: dnnc::tensor< int >

    set_slice(a, b, start, end, axes)

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< int > &
    start: dnnc::tensor< int > &
    end: dnnc::tensor< int > &
    axes: dnnc::tensor< int >

    set_slice(a, b, start, end)

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< int > &
    start: dnnc::tensor< int > &
    end: dnnc::tensor< int > &

    set_slice(a, b, start, end, axes, steps)

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< bool > &
    start: dnnc::tensor< int > &
    end: dnnc::tensor< int > &
    axes: dnnc::tensor< int >
    steps: dnnc::tensor< int >

    set_slice(a, b, start, end, axes)

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< bool > &
    start: dnnc::tensor< int > &
    end: dnnc::tensor< int > &
    axes: dnnc::tensor< int >

    set_slice(a, b, start, end)

    Parameters
    ----------
    a: dnnc::tensor< bool > &
    b: dnnc::tensor< bool > &
    start: dnnc::tensor< int > &
    end: dnnc::tensor< int > &

    """
    return _dnnc.set_slice(*args)

def prelu(*args):
    """
    prelu(x, slope) -> floatTensor

    Parameters
    ----------
    x: dnnc::tensor< float > &
    slope: dnnc::tensor< float > &

    prelu(x, slope) -> doubleTensor

    Parameters
    ----------
    x: dnnc::tensor< double > &
    slope: dnnc::tensor< double > &

    prelu(x, slope) -> intTensor

    Parameters
    ----------
    x: dnnc::tensor< int > &
    slope: dnnc::tensor< int > &

    """
    return _dnnc.prelu(*args)
class boolplaceHolder(_object):
    """Proxy of C++ dnnc::placeHolder<(bool)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, boolplaceHolder, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, boolplaceHolder, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, dimn, n) -> boolplaceHolder

        Parameters
        ----------
        dimn: std::vector< dnnc::DIMENSION,std::allocator< dnnc::DIMENSION > >
        n: std::string

        __init__(self, dimn) -> boolplaceHolder

        Parameters
        ----------
        dimn: std::vector< dnnc::DIMENSION,std::allocator< dnnc::DIMENSION > >

        """
        this = _dnnc.new_boolplaceHolder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def name(self, *args):
        """
        name(self, n)

        Parameters
        ----------
        n: std::string

        name(self) -> std::string

        Parameters
        ----------
        self: dnnc::placeHolder< bool > const *

        """
        return _dnnc.boolplaceHolder_name(self, *args)


    def rank(self):
        """
        rank(self) -> dnnc::DIMENSION const

        Parameters
        ----------
        self: dnnc::placeHolder< bool > const *

        """
        return _dnnc.boolplaceHolder_rank(self)


    def shape(self):
        """
        shape(self) -> vectorSizeT

        Parameters
        ----------
        self: dnnc::placeHolder< bool > const *

        """
        return _dnnc.boolplaceHolder_shape(self)


    def length(self):
        """
        length(self) -> dnnc::DIMENSION const

        Parameters
        ----------
        self: dnnc::placeHolder< bool > const *

        """
        return _dnnc.boolplaceHolder_length(self)


    def flatteninplace(self):
        """
        flatteninplace(self)

        Parameters
        ----------
        self: dnnc::placeHolder< bool > *

        """
        return _dnnc.boolplaceHolder_flatteninplace(self)

    __swig_destroy__ = _dnnc.delete_boolplaceHolder
    __del__ = lambda self: None
boolplaceHolder_swigregister = _dnnc.boolplaceHolder_swigregister
boolplaceHolder_swigregister(boolplaceHolder)
cvar = _dnnc.cvar

class intplaceHolder(_object):
    """Proxy of C++ dnnc::placeHolder<(int)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, intplaceHolder, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, intplaceHolder, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, dimn, n) -> intplaceHolder

        Parameters
        ----------
        dimn: std::vector< dnnc::DIMENSION,std::allocator< dnnc::DIMENSION > >
        n: std::string

        __init__(self, dimn) -> intplaceHolder

        Parameters
        ----------
        dimn: std::vector< dnnc::DIMENSION,std::allocator< dnnc::DIMENSION > >

        """
        this = _dnnc.new_intplaceHolder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def name(self, *args):
        """
        name(self, n)

        Parameters
        ----------
        n: std::string

        name(self) -> std::string

        Parameters
        ----------
        self: dnnc::placeHolder< int > const *

        """
        return _dnnc.intplaceHolder_name(self, *args)


    def rank(self):
        """
        rank(self) -> dnnc::DIMENSION const

        Parameters
        ----------
        self: dnnc::placeHolder< int > const *

        """
        return _dnnc.intplaceHolder_rank(self)


    def shape(self):
        """
        shape(self) -> vectorSizeT

        Parameters
        ----------
        self: dnnc::placeHolder< int > const *

        """
        return _dnnc.intplaceHolder_shape(self)


    def length(self):
        """
        length(self) -> dnnc::DIMENSION const

        Parameters
        ----------
        self: dnnc::placeHolder< int > const *

        """
        return _dnnc.intplaceHolder_length(self)


    def flatteninplace(self):
        """
        flatteninplace(self)

        Parameters
        ----------
        self: dnnc::placeHolder< int > *

        """
        return _dnnc.intplaceHolder_flatteninplace(self)

    __swig_destroy__ = _dnnc.delete_intplaceHolder
    __del__ = lambda self: None
intplaceHolder_swigregister = _dnnc.intplaceHolder_swigregister
intplaceHolder_swigregister(intplaceHolder)

class uLongplaceHolder(_object):
    """Proxy of C++ dnnc::placeHolder<(size_t)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, uLongplaceHolder, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, uLongplaceHolder, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, dimn, n) -> uLongplaceHolder

        Parameters
        ----------
        dimn: std::vector< dnnc::DIMENSION,std::allocator< dnnc::DIMENSION > >
        n: std::string

        __init__(self, dimn) -> uLongplaceHolder

        Parameters
        ----------
        dimn: std::vector< dnnc::DIMENSION,std::allocator< dnnc::DIMENSION > >

        """
        this = _dnnc.new_uLongplaceHolder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def name(self, *args):
        """
        name(self, n)

        Parameters
        ----------
        n: std::string

        name(self) -> std::string

        Parameters
        ----------
        self: dnnc::placeHolder< size_t > const *

        """
        return _dnnc.uLongplaceHolder_name(self, *args)


    def rank(self):
        """
        rank(self) -> dnnc::DIMENSION const

        Parameters
        ----------
        self: dnnc::placeHolder< size_t > const *

        """
        return _dnnc.uLongplaceHolder_rank(self)


    def shape(self):
        """
        shape(self) -> vectorSizeT

        Parameters
        ----------
        self: dnnc::placeHolder< size_t > const *

        """
        return _dnnc.uLongplaceHolder_shape(self)


    def length(self):
        """
        length(self) -> dnnc::DIMENSION const

        Parameters
        ----------
        self: dnnc::placeHolder< size_t > const *

        """
        return _dnnc.uLongplaceHolder_length(self)


    def flatteninplace(self):
        """
        flatteninplace(self)

        Parameters
        ----------
        self: dnnc::placeHolder< size_t > *

        """
        return _dnnc.uLongplaceHolder_flatteninplace(self)

    __swig_destroy__ = _dnnc.delete_uLongplaceHolder
    __del__ = lambda self: None
uLongplaceHolder_swigregister = _dnnc.uLongplaceHolder_swigregister
uLongplaceHolder_swigregister(uLongplaceHolder)

class floatplaceHolder(_object):
    """Proxy of C++ dnnc::placeHolder<(float)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, floatplaceHolder, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, floatplaceHolder, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, dimn, n) -> floatplaceHolder

        Parameters
        ----------
        dimn: std::vector< dnnc::DIMENSION,std::allocator< dnnc::DIMENSION > >
        n: std::string

        __init__(self, dimn) -> floatplaceHolder

        Parameters
        ----------
        dimn: std::vector< dnnc::DIMENSION,std::allocator< dnnc::DIMENSION > >

        """
        this = _dnnc.new_floatplaceHolder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def name(self, *args):
        """
        name(self, n)

        Parameters
        ----------
        n: std::string

        name(self) -> std::string

        Parameters
        ----------
        self: dnnc::placeHolder< float > const *

        """
        return _dnnc.floatplaceHolder_name(self, *args)


    def rank(self):
        """
        rank(self) -> dnnc::DIMENSION const

        Parameters
        ----------
        self: dnnc::placeHolder< float > const *

        """
        return _dnnc.floatplaceHolder_rank(self)


    def shape(self):
        """
        shape(self) -> vectorSizeT

        Parameters
        ----------
        self: dnnc::placeHolder< float > const *

        """
        return _dnnc.floatplaceHolder_shape(self)


    def length(self):
        """
        length(self) -> dnnc::DIMENSION const

        Parameters
        ----------
        self: dnnc::placeHolder< float > const *

        """
        return _dnnc.floatplaceHolder_length(self)


    def flatteninplace(self):
        """
        flatteninplace(self)

        Parameters
        ----------
        self: dnnc::placeHolder< float > *

        """
        return _dnnc.floatplaceHolder_flatteninplace(self)

    __swig_destroy__ = _dnnc.delete_floatplaceHolder
    __del__ = lambda self: None
floatplaceHolder_swigregister = _dnnc.floatplaceHolder_swigregister
floatplaceHolder_swigregister(floatplaceHolder)

class doubleplaceHolder(_object):
    """Proxy of C++ dnnc::placeHolder<(double)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, doubleplaceHolder, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, doubleplaceHolder, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, dimn, n) -> doubleplaceHolder

        Parameters
        ----------
        dimn: std::vector< dnnc::DIMENSION,std::allocator< dnnc::DIMENSION > >
        n: std::string

        __init__(self, dimn) -> doubleplaceHolder

        Parameters
        ----------
        dimn: std::vector< dnnc::DIMENSION,std::allocator< dnnc::DIMENSION > >

        """
        this = _dnnc.new_doubleplaceHolder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def name(self, *args):
        """
        name(self, n)

        Parameters
        ----------
        n: std::string

        name(self) -> std::string

        Parameters
        ----------
        self: dnnc::placeHolder< double > const *

        """
        return _dnnc.doubleplaceHolder_name(self, *args)


    def rank(self):
        """
        rank(self) -> dnnc::DIMENSION const

        Parameters
        ----------
        self: dnnc::placeHolder< double > const *

        """
        return _dnnc.doubleplaceHolder_rank(self)


    def shape(self):
        """
        shape(self) -> vectorSizeT

        Parameters
        ----------
        self: dnnc::placeHolder< double > const *

        """
        return _dnnc.doubleplaceHolder_shape(self)


    def length(self):
        """
        length(self) -> dnnc::DIMENSION const

        Parameters
        ----------
        self: dnnc::placeHolder< double > const *

        """
        return _dnnc.doubleplaceHolder_length(self)


    def flatteninplace(self):
        """
        flatteninplace(self)

        Parameters
        ----------
        self: dnnc::placeHolder< double > *

        """
        return _dnnc.doubleplaceHolder_flatteninplace(self)

    __swig_destroy__ = _dnnc.delete_doubleplaceHolder
    __del__ = lambda self: None
doubleplaceHolder_swigregister = _dnnc.doubleplaceHolder_swigregister
doubleplaceHolder_swigregister(doubleplaceHolder)

class boolTensor(boolplaceHolder):
    """Proxy of C++ dnnc::tensor<(bool)> class."""

    __swig_setmethods__ = {}
    for _s in [boolplaceHolder]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, boolTensor, name, value)
    __swig_getmethods__ = {}
    for _s in [boolplaceHolder]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, boolTensor, name)

    def __init__(self, *args):
        """
        __init__(self, dimn, n, fill, init_val=False) -> boolTensor

        Parameters
        ----------
        dimn: std::vector< dnnc::DIMENSION,std::allocator< dnnc::DIMENSION > >
        n: std::string
        fill: enum dnnc::INIT_TYPE
        init_val: bool

        __init__(self, dimn, n, fill) -> boolTensor

        Parameters
        ----------
        dimn: std::vector< dnnc::DIMENSION,std::allocator< dnnc::DIMENSION > >
        n: std::string
        fill: enum dnnc::INIT_TYPE

        __init__(self, dimn, n) -> boolTensor

        Parameters
        ----------
        dimn: std::vector< dnnc::DIMENSION,std::allocator< dnnc::DIMENSION > >
        n: std::string

        __init__(self, dimn) -> boolTensor

        Parameters
        ----------
        dimn: std::vector< dnnc::DIMENSION,std::allocator< dnnc::DIMENSION > >

        __init__(self) -> boolTensor
        __init__(self, data, dimn, n) -> boolTensor

        Parameters
        ----------
        data: bool *
        dimn: std::vector< dnnc::DIMENSION,std::allocator< dnnc::DIMENSION > >
        n: std::string

        __init__(self, data, dimn) -> boolTensor

        Parameters
        ----------
        data: bool *
        dimn: std::vector< dnnc::DIMENSION,std::allocator< dnnc::DIMENSION > >

        __init__(self, other) -> boolTensor

        Parameters
        ----------
        other: dnnc::tensor< bool > const &

        """
        this = _dnnc.new_boolTensor(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _dnnc.delete_boolTensor
    __del__ = lambda self: None

    def __nonzero__(self):
        return _dnnc.boolTensor___nonzero__(self)
    __bool__ = __nonzero__



    def copy(self):
        """
        copy(self) -> boolTensor

        Parameters
        ----------
        self: dnnc::tensor< bool > const *

        """
        return _dnnc.boolTensor_copy(self)


    def negate(self):
        """
        negate(self) -> boolTensor

        Parameters
        ----------
        self: dnnc::tensor< bool > const *

        """
        return _dnnc.boolTensor_negate(self)


    def absolute(self):
        """
        absolute(self) -> boolTensor

        Parameters
        ----------
        self: dnnc::tensor< bool > const *

        """
        return _dnnc.boolTensor_absolute(self)


    def identifier(self):
        """
        identifier(self) -> size_t

        Parameters
        ----------
        self: dnnc::tensor< bool > const *

        """
        return _dnnc.boolTensor_identifier(self)


    def sameas(self, other):
        """
        sameas(self, other) -> bool

        Parameters
        ----------
        other: dnnc::tensor< bool > const &

        """
        return _dnnc.boolTensor_sameas(self, other)


    def asTypeDouble(self):
        """
        asTypeDouble(self) -> doubleTensor

        Parameters
        ----------
        self: dnnc::tensor< bool > *

        """
        return _dnnc.boolTensor_asTypeDouble(self)


    def asTypeFloat(self):
        """
        asTypeFloat(self) -> floatTensor

        Parameters
        ----------
        self: dnnc::tensor< bool > *

        """
        return _dnnc.boolTensor_asTypeFloat(self)


    def asTypeInt(self):
        """
        asTypeInt(self) -> intTensor

        Parameters
        ----------
        self: dnnc::tensor< bool > *

        """
        return _dnnc.boolTensor_asTypeInt(self)


    def asTypeUint8(self):
        """
        asTypeUint8(self) -> dnnc::tensor< uint8_t >

        Parameters
        ----------
        self: dnnc::tensor< bool > *

        """
        return _dnnc.boolTensor_asTypeUint8(self)


    def asTypeLong(self):
        """
        asTypeLong(self) -> dnnc::tensor< long >

        Parameters
        ----------
        self: dnnc::tensor< bool > *

        """
        return _dnnc.boolTensor_asTypeLong(self)


    def asTypeULong(self):
        """
        asTypeULong(self) -> uLongTensor

        Parameters
        ----------
        self: dnnc::tensor< bool > *

        """
        return _dnnc.boolTensor_asTypeULong(self)


    def asTypeBool(self):
        """
        asTypeBool(self) -> boolTensor

        Parameters
        ----------
        self: dnnc::tensor< bool > *

        """
        return _dnnc.boolTensor_asTypeBool(self)


    def load(self, *args):
        """
        load(self, data, indices)

        Parameters
        ----------
        data: bool const &
        indices: std::vector< size_t,std::allocator< size_t > >

        load(self, data, i, j=0, k=0, l=0, m=0)

        Parameters
        ----------
        data: bool const &
        i: size_t
        j: size_t
        k: size_t
        l: size_t
        m: size_t

        load(self, data, i, j=0, k=0, l=0)

        Parameters
        ----------
        data: bool const &
        i: size_t
        j: size_t
        k: size_t
        l: size_t

        load(self, data, i, j=0, k=0)

        Parameters
        ----------
        data: bool const &
        i: size_t
        j: size_t
        k: size_t

        load(self, data, i, j=0)

        Parameters
        ----------
        data: bool const &
        i: size_t
        j: size_t

        load(self, data, i)

        Parameters
        ----------
        data: bool const &
        i: size_t

        load(self, data)

        Parameters
        ----------
        data: std::vector< bool,std::allocator< bool > >

        load(self, data)

        Parameters
        ----------
        data: bool const *

        """
        return _dnnc.boolTensor_load(self, *args)


    def to_string(self, max_el=30):
        """
        to_string(self, max_el=30) -> std::string

        Parameters
        ----------
        max_el: size_t const

        to_string(self) -> std::string

        Parameters
        ----------
        self: dnnc::tensor< bool > const *

        """
        return _dnnc.boolTensor_to_string(self, max_el)


    def data(self):
        """
        data(self) -> vectorBool

        Parameters
        ----------
        self: dnnc::tensor< bool > const *

        """
        return _dnnc.boolTensor_data(self)


    def reshape(self, *args):
      """
        reshape tensor to a new shape permitting same length of old and new shape.
      """
      new_shape = []
      for arg in args:
        if isinstance(arg, int):
          new_shape.append(arg)
        else:
          return _dnnc.boolTensor_reshape (self, vectorSizeT(arg))

      if len(new_shape):
        return _dnnc.boolTensor_reshape (self, vectorSizeT(new_shape))

      return _dnnc.boolTensor_reshape (args)



    def flatten(self):
        """
        flatten(self) -> boolTensor

        Parameters
        ----------
        self: dnnc::tensor< bool > *

        """
        return _dnnc.boolTensor_flatten(self)


    def isnull(self):
        """
        isnull(self) -> bool

        Parameters
        ----------
        self: dnnc::tensor< bool > const *

        """
        return _dnnc.boolTensor_isnull(self)


    def transpose(self):
        """
        transpose(self)

        Parameters
        ----------
        self: dnnc::tensor< bool > *

        """
        return _dnnc.boolTensor_transpose(self)


    def __call__(self, *args):
        """
        __call__(self, indices) -> bool

        Parameters
        ----------
        indices: std::vector< dnnc::INDEX,std::allocator< dnnc::INDEX > > &

        __call__(self, x=0, y=0, z=0, w=0, u=0) -> bool

        Parameters
        ----------
        x: dnnc::INDEX const
        y: dnnc::INDEX const
        z: dnnc::INDEX const
        w: dnnc::INDEX const
        u: dnnc::INDEX const

        __call__(self, x=0, y=0, z=0, w=0) -> bool

        Parameters
        ----------
        x: dnnc::INDEX const
        y: dnnc::INDEX const
        z: dnnc::INDEX const
        w: dnnc::INDEX const

        __call__(self, x=0, y=0, z=0) -> bool

        Parameters
        ----------
        x: dnnc::INDEX const
        y: dnnc::INDEX const
        z: dnnc::INDEX const

        __call__(self, x=0, y=0) -> bool

        Parameters
        ----------
        x: dnnc::INDEX const
        y: dnnc::INDEX const

        __call__(self, x=0) -> bool

        Parameters
        ----------
        x: dnnc::INDEX const

        __call__(self) -> bool &

        Parameters
        ----------
        self: dnnc::tensor< bool > const *

        """
        return _dnnc.boolTensor___call__(self, *args)


    def empty(self):
        """
        empty(self) -> bool

        Parameters
        ----------
        self: dnnc::tensor< bool > *

        """
        return _dnnc.boolTensor_empty(self)


    def dtype(self):
        """
        dtype(self) -> std::string

        Parameters
        ----------
        self: dnnc::tensor< bool > *

        """
        return _dnnc.boolTensor_dtype(self)


    def to_proto(self):
        """
        to_proto(self) -> std::string

        Parameters
        ----------
        self: dnnc::tensor< bool > *

        """
        return _dnnc.boolTensor_to_proto(self)


    def min(self):
        """
        min(self) -> bool

        Parameters
        ----------
        self: dnnc::tensor< bool > const *

        """
        return _dnnc.boolTensor_min(self)


    def max(self):
        """
        max(self) -> bool

        Parameters
        ----------
        self: dnnc::tensor< bool > const *

        """
        return _dnnc.boolTensor_max(self)


    def sum(self):
        """
        sum(self) -> bool

        Parameters
        ----------
        self: dnnc::tensor< bool > const *

        """
        return _dnnc.boolTensor_sum(self)


    def __getitem__(self, indices):
        """
        __getitem__(self, indices) -> bool const &

        Parameters
        ----------
        indices: PyObject *

        """
        return _dnnc.boolTensor___getitem__(self, indices)


    def __setitem__(self, indices, data):
        """
        __setitem__(self, indices, data)

        Parameters
        ----------
        indices: PyObject *
        data: bool const &

        """
        return _dnnc.boolTensor___setitem__(self, indices, data)


    def __str__(self):
        """
        __str__(self) -> std::string

        Parameters
        ----------
        self: dnnc::tensor< bool > *

        """
        return _dnnc.boolTensor___str__(self)


    def __repr__(self):
        """
        __repr__(self) -> std::string

        Parameters
        ----------
        self: dnnc::tensor< bool > *

        """
        return _dnnc.boolTensor___repr__(self)


    def __neg__(self):
        """
        __neg__(self) -> boolTensor

        Parameters
        ----------
        self: dnnc::tensor< bool > *

        """
        return _dnnc.boolTensor___neg__(self)


    def __pos__(self):
        """
        __pos__(self) -> boolTensor

        Parameters
        ----------
        self: dnnc::tensor< bool > *

        """
        return _dnnc.boolTensor___pos__(self)


    def __abs__(self):
        """
        __abs__(self) -> boolTensor

        Parameters
        ----------
        self: dnnc::tensor< bool > *

        """
        return _dnnc.boolTensor___abs__(self)


    def __invert__(self):
        """
        __invert__(self) -> boolTensor

        Parameters
        ----------
        self: dnnc::tensor< bool > *

        """
        return _dnnc.boolTensor___invert__(self)


    def __lshift__(self, *args):
        """
        __lshift__(self, other) -> intTensor

        Parameters
        ----------
        other: dnnc::tensor< int > &

        __lshift__(self, scalar) -> intTensor

        Parameters
        ----------
        scalar: int

        """
        return _dnnc.boolTensor___lshift__(self, *args)


    def __ilshift__(self, *args):
        """
        __ilshift__(self, other) -> intTensor

        Parameters
        ----------
        other: dnnc::tensor< int > &

        __ilshift__(self, scalar) -> intTensor

        Parameters
        ----------
        scalar: int

        """
        return _dnnc.boolTensor___ilshift__(self, *args)


    def __rshift__(self, *args):
        """
        __rshift__(self, other) -> intTensor

        Parameters
        ----------
        other: dnnc::tensor< int > &

        __rshift__(self, scalar) -> intTensor

        Parameters
        ----------
        scalar: int

        """
        return _dnnc.boolTensor___rshift__(self, *args)


    def __irshift__(self, *args):
        """
        __irshift__(self, other) -> intTensor

        Parameters
        ----------
        other: dnnc::tensor< int > &

        __irshift__(self, scalar) -> intTensor

        Parameters
        ----------
        scalar: int

        """
        return _dnnc.boolTensor___irshift__(self, *args)




    def __getitem__(self, index):
      """
         getitem method for tensor.
      """
      def get_item_helper_int(item, axis):
        flag = 0
        start = item
        if (start < 0):
          start += self.shape()[axis]
        stop = start+1
        step = 1
        if(start >= self.shape()[axis]):
          errorMsg = "index value " + str(start) + " along axis " + str(axis) + " is beyond the size " + str(self.shape()[axis]) + " of input tensor along that axis"
          raise ValueError(errorMsg)
          flag = 1
        return start, stop, step, flag

      def get_item_helper_slice(item, axis):
        flag = 0   # to check if all index items are supported or not
        start = 0
        stop = self.shape()[axis]
        step = 1
        if type(item.step) == int:
          step = item.step
          if step == 0:
            errorMsg = "slice step cannot be zero"
            raise TypeError(errorMsg)
            flag = 1
          elif step < 0:
            start = self.shape()[axis] -1
            stop = -1
        elif str(type(item.step)).split("'")[1] == "NoneType":
          pass
        else:
          errorMsg = "step of " + str(type(item.step)) + " not supported!"
          raise TypeError(errorMsg)
          flag = 1
        if type(item.start) == int:
          start = item.start
          if (start < 0):
            start += self.shape()[axis]
        elif str(type(item.start)).split("'")[1] == "NoneType":
          pass
        else:
          errorMsg = "start of " + str(type(item.start)) + " not supported!"
          raise TypeError(errorMsg)
          flag = 1
        if type(item.stop) == int:
          stop = item.stop
          if (stop < 0):
            stop += self.shape()[axis]
        elif str(type(item.stop)).split("'")[1] == "NoneType":
          pass
        else:
          errorMsg = "stop of " + str(type(item.stop)) + " not supported!"
          raise TypeError(errorMsg)
          flag = 1
    # if(start > self.shape()[axis]):
    #   errorMsg = "index value " + str(start) + " along axis " + str(axis) + " is beyond the size " + str(self.shape()[axis]) + " of input tensor along that axis"
    #   raise IndexError(errorMsg)
    #   flag = 1
    # if(stop > self.shape()[axis]):
    #   errorMsg = "index value " + str(stop) + " along axis " + str(axis) + " is beyond the size " + str(self.shape()[axis]) + " of input tensor along that axis"
    #   raise IndexError(errorMsg)
    #   flag = 1
    # if (step < 0) and not (start > stop):
    #   errorMsg = "stop index " + str(stop) + " along axis " + str(axis) + " is greater than start index " + str(start) + " while step is negative"
    #   raise IndexError(errorMsg)
    #   flag = 1
    # elif (step > 0) and not (start < stop):
    #   errorMsg = "stop index " + str(stop) + " along axis " + str(axis) + " is smaller than start index " + str(start) + " while step is positive"
    #   raise IndexError(errorMsg)
    #   flag = 1

        return start, stop, step, flag

      if str(type(index)).split("'")[1] == "int":
        if self.rank() < 1:
          return self.copy()
        axis = 0
        start, stop, step, flag = get_item_helper_int(index, axis)
        if flag:
          return
        start = array([start]).asTypeInt()
        stop = array([stop]).asTypeInt()
        axis = array([axis]).asTypeInt()
        step = array([step]).asTypeInt()
        if (self.rank() == 1):
          return self.data()[index]
        return slice(self, start, stop, axis, step).reshape(self.shape()[1:])

      elif str(type(index)).split("'")[1] == "slice":
        if self.rank() < 1:
          return self.copy()
        axis = 0
        start, stop, step, flag = get_item_helper_slice(index, axis)
        if flag:
          return
        start = array([start]).asTypeInt()
        stop = array([stop]).asTypeInt()
        axis = array([axis]).asTypeInt()
        step = array([step]).asTypeInt()
        return slice(self, start, stop, axis, step)

      elif str(type(index)).split("'")[1] == "ellipsis":
        return self.copy()

      elif str(type(index)).split("'")[1] == "tuple":
        if (len(index) > self.rank()):
          errorMsg = "Takes maximum " + str(self.rank()) + " arguments, " + str(len(index)) + " were given!"
          raise IndexError(errorMsg)
          return
    # elif Ellipsis not in index and (len(index) < self.rank()):
    #   errorMsg = "Takes minimum " + str(self.rank()) + " arguments, " + str(len(index)) + " were given!"
    #   raise IndexError(errorMsg)
    #   return

    # checks if any float or bool or complex is not present
        if any(isinstance(x,(bool,float,complex)) for x in index):
          errorMsg = "Restrict to only integers as a slicing argument!"
          raise ValueError(errorMsg)
          return

        start_list = []
        stop_list = []
        step_list = []
        axis_list = []
        axis = -1   # -1 for starting axis as 0 in the next loops
        reshape_list = []   # reshape list to reshape
        replace_start = replace_stop = 0   # replace ellipsis with slice methods by index

        if Ellipsis in index:
          if (index.count(Ellipsis) > 1):
            errorMsg = str(index.count(Ellipsis)) + " 'Ellipsis' found, maximum 1 is supported!"
            raise IndexError(errorMsg)
            return
          elif (index.count(Ellipsis) == 1):
            non_ellipsis_count = 0
            for item in index:
              if str(type(item)).split("'")[1] == "int" or str(type(item)).split("'")[1] == "slice":
                non_ellipsis_count += 1
    # replace holds start and stop index which will be replaced by slice method in place of ellipsis
            replace_start = index.index(Ellipsis)
            replace_stop = replace_start + self.rank() - non_ellipsis_count
          else:
            errorMsg = "Error occured while handling ellipsis!"
            raise ValueError(errorMsg)
            return

        for item in index:
          axis += 1
          if str(type(item)).split("'")[1] == "ellipsis":
            while (axis >= replace_start and axis < replace_stop):
              start = 0
              stop = self.shape()[axis]
              step = 1
              start_list.append(start)
              stop_list.append(stop)
              step_list.append(step)
              axis_list.append(axis)
              reshape_list.append(1)  # This shape will be taken
              axis += 1
            axis -= 1   # recovering from last axis increment
          elif str(type(item)).split("'")[1] == "int":
            start, stop, step, flag = get_item_helper_int(item, axis)
            if flag:
              return
            start_list.append(start)
            stop_list.append(stop)
            step_list.append(step)
            axis_list.append(axis)
            reshape_list.append(0)  # This shape will not be taken
          elif str(type(item)).split("'")[1] == "slice":
            start, stop, step, flag = get_item_helper_slice(item, axis)
            if flag:
              return
            start_list.append(start)
            stop_list.append(stop)
            step_list.append(step)
            axis_list.append(axis)
            reshape_list.append(1)  # This shape will be taken
          else:
            errorMsg = "Doesn't support " + str(item) + " of " + str(type(item)) + " as a slicing argument!"
            raise TypeError(errorMsg)
            return

        while (axis < self.rank()-1):
          axis += 1
          start = 0
          stop = self.shape()[axis]
          step = 1
          start_list.append(start)
          stop_list.append(stop)
          step_list.append(step)
          axis_list.append(axis)
          reshape_list.append(1)  # This shape will be taken

        start_list = array(start_list).asTypeInt()
        stop_list = array(stop_list).asTypeInt()
        axis_list = array(axis_list).asTypeInt()
        step_list = array(step_list).asTypeInt()

    # print("test start list :  ", start_list)
    # print("test stop list :  ", stop_list)
    # print("test axis list :  ", axis_list)
    # print("test step list :  ", step_list)

        result = slice(self, start_list, stop_list, axis_list, step_list)

        if (result.len() != 0) and (0 in reshape_list):
          if not 1 in reshape_list:
            return result.data()[0]
          return (result.reshape([x for x, y in zip(result.shape(), reshape_list) if y == 1]))

        return result

      else :
        errorMsg = "Doesn't support " + str(index) + " of " + str(type(index)) + " as a slicing argument!"
        raise TypeError(errorMsg)

      return intTensor()



    def __setitem__(self, index, input_tensor):
      """
         setitem method for tensor.
      """

      value_tensor = ""
      if "Tensor" not in str(type(input_tensor)).split("'")[1]:
        if str(type(input_tensor)).split("'")[1] in ("int", "float", "bool"):
          value_tensor = array([input_tensor])  # passing single number as tensor of length 1
        elif str(type(input_tensor)).split("'")[1] in ("list", "tuple"):
          value_tensor = array(input_tensor)  # passing python lists or tuples as tensor
        else:
          errorMsg = "could not convert " + str(input_tensor) + " of type " + str(type(input_tensor)) + " to dnnc tensor"
          raise ValueError(errorMsg)
          return
      else:
          value_tensor = input_tensor

      def set_item_helper_int(item, axis):
        flag = 0
        start = item
        if (start < 0):
          start += self.shape()[axis]
        stop = start+1
        step = 1
        if(start >= self.shape()[axis]):
          errorMsg = "index value " + str(start) + " along axis " + str(axis) + " is beyond the size " + str(self.shape()[axis]) + " of input tensor along that axis"
          raise ValueError(errorMsg)
          flag = 1
        return start, stop, step, flag

      def set_item_helper_slice(item, axis):
        flag = 0   # to check if all index items are supported or not
        start = 0
        stop = self.shape()[axis]
        step = 1
        if type(item.step) == int:
          step = item.step
          if step == 0:
            errorMsg = "slice step cannot be zero"
            raise TypeError(errorMsg)
            flag = 1
          elif step < 0:
            start = self.shape()[axis] -1
            stop = -1
        elif str(type(item.step)).split("'")[1] == "NoneType":
          pass
        else:
          errorMsg = "step of " + str(type(item.step)) + " not supported!"
          raise TypeError(errorMsg)
          flag = 1
        if type(item.start) == int:
          start = item.start
          if (start < 0):
            start += self.shape()[axis]
        elif str(type(item.start)).split("'")[1] == "NoneType":
          pass
        else:
          errorMsg = "start of " + str(type(item.start)) + " not supported!"
          raise TypeError(errorMsg)
          flag = 1
        if type(item.stop) == int:
          stop = item.stop
          if (stop < 0):
            stop += self.shape()[axis]
        elif str(type(item.stop)).split("'")[1] == "NoneType":
          pass
        else:
          errorMsg = "stop of " + str(type(item.stop)) + " not supported!"
          raise TypeError(errorMsg)
          flag = 1
    # if(start > self.shape()[axis]):
    #   errorMsg = "index value " + str(start) + " along axis " + str(axis) + " is beyond the size " + str(self.shape()[axis]) + " of input tensor along that axis"
    #   raise IndexError(errorMsg)
    #   flag = 1
    # if(stop > self.shape()[axis]):
    #   errorMsg = "index value " + str(stop) + " along axis " + str(axis) + " is beyond the size " + str(self.shape()[axis]) + " of input tensor along that axis"
    #   raise IndexError(errorMsg)
    #   flag = 1
    # if (step < 0) and not (start > stop):
    #   errorMsg = "stop index " + str(stop) + " along axis " + str(axis) + " is greater than start index " + str(start) + " while step is negative"
    #   raise IndexError(errorMsg)
    #   flag = 1
    # elif (step > 0) and not (start < stop):
    #   errorMsg = "stop index " + str(stop) + " along axis " + str(axis) + " is smaller than start index " + str(start) + " while step is positive"
    #   raise IndexError(errorMsg)
    #   flag = 1

        return start, stop, step, flag

      if str(type(index)).split("'")[1] == "int":
        if self.rank() < 1:
          errorMsg = "cannot set items to a null tensor"
          raise TypeError(errorMsg)
          return
        axis = 0
        start, stop, step, flag = set_item_helper_int(index, axis)
        if flag:
          return
        start = array([start]).asTypeInt()
        stop = array([stop]).asTypeInt()
        axis = array([axis]).asTypeInt()
        step = array([step]).asTypeInt()

        set_slice(self, value_tensor, start, stop, axis, step)
        return

      elif str(type(index)).split("'")[1] == "slice":
        if self.rank() < 1:
          self = value_tensor
          return
        axis = 0
        start, stop, step, flag = set_item_helper_slice(index, axis)
        if flag:
          return
        start = array([start]).asTypeInt()
        stop = array([stop]).asTypeInt()
        axis = array([axis]).asTypeInt()
        step = array([step]).asTypeInt()

        set_slice(self, value_tensor, start, stop, axis, step)
        return

      elif str(type(index)).split("'")[1] == "ellipsis":
        if self.shape() != value_tensor.shape():
          errorMsg = "could not broadcast input array from shape "+str(value_tensor.shape())+" into shape "+str(self.shape())
          raise ValueError(errorMsg)
          return
        elif (self.rank() < 1) or (self.shape() == value_tensor.shape()):
          self = value_tensor
          return

      elif str(type(index)).split("'")[1] == "tuple":
        if (len(index) > self.rank()):
          errorMsg = "Takes maximum " + str(self.rank()) + " arguments, " + str(len(index)) + " were given!"
          raise IndexError(errorMsg)
          return
    # elif Ellipsis not in index and (len(index) < self.rank()):
    #   errorMsg = "Takes minimum " + str(self.rank()) + " arguments, " + str(len(index)) + " were given!"
    #   raise IndexError(errorMsg)
    #   return

    # checks if any float or bool or complex is not present
        if any(isinstance(x,(bool,float,complex)) for x in index):
          errorMsg = "Restrict to only integers as a slicing argument!"
          raise ValueError(errorMsg)
          return

        start_list = []
        stop_list = []
        step_list = []
        axis_list = []
        axis = -1   # -1 for starting axis as 0 in the next loops
        replace_start = replace_stop = 0   # replace ellipsis with slice methods by index

        if Ellipsis in index:
          if (index.count(Ellipsis) > 1):
            errorMsg = str(index.count(Ellipsis)) + " 'Ellipsis' found, maximum 1 is supported!"
            raise IndexError(errorMsg)
            return
          elif (index.count(Ellipsis) == 1):
            non_ellipsis_count = 0
            for item in index:
              if str(type(item)).split("'")[1] == "int" or str(type(item)).split("'")[1] == "slice":
                non_ellipsis_count += 1
    # replace holds start and stop index which will be replaced by slice method in place of ellipsis
            replace_start = index.index(Ellipsis)
            replace_stop = replace_start + self.rank() - non_ellipsis_count
          else:
            errorMsg = "Error occured while handling ellipsis!"
            raise ValueError(errorMsg)
            return

        for item in index:
          axis += 1
          if str(type(item)).split("'")[1] == "ellipsis":
            while (axis >= replace_start and axis < replace_stop):
              start = 0
              stop = self.shape()[axis]
              step = 1
              start_list.append(start)
              stop_list.append(stop)
              step_list.append(step)
              axis_list.append(axis)
              axis += 1
            axis -= 1   # recovering from last axis increment
          elif str(type(item)).split("'")[1] == "int":
            start, stop, step, flag = set_item_helper_int(item, axis)
            if flag:
              return
            start_list.append(start)
            stop_list.append(stop)
            step_list.append(step)
            axis_list.append(axis)
          elif str(type(item)).split("'")[1] == "slice":
            start, stop, step, flag = set_item_helper_slice(item, axis)
            if flag:
              return
            start_list.append(start)
            stop_list.append(stop)
            step_list.append(step)
            axis_list.append(axis)
          else:
            errorMsg = "Doesn't support " + str(item) + " of " + str(type(item)) + " as a slicing argument!"
            raise TypeError(errorMsg)
            return

        while (axis < self.rank()-1):
          axis += 1
          start = 0
          stop = self.shape()[axis]
          step = 1
          start_list.append(start)
          stop_list.append(stop)
          step_list.append(step)
          axis_list.append(axis)

        start_list = array(start_list).asTypeInt()
        stop_list = array(stop_list).asTypeInt()
        axis_list = array(axis_list).asTypeInt()
        step_list = array(step_list).asTypeInt()

    # print("test start list :  ", start_list)
    # print("test stop list :  ", stop_list)
    # print("test axis list :  ", axis_list)
    # print("test step list :  ", step_list)

        set_slice(self, value_tensor, start_list, stop_list, axis_list, step_list)
        return
      else :
        errorMsg = "Doesn't support " + str(index) + " of " + str(type(index)) + " as a slicing argument!"
        raise TypeError(errorMsg)

      return


    def __add__(self, other):
      return add(self, other)

    def __radd__(self, other):
      return add(other, self)

    def __iadd__(self, other):
      """
        making sure left hand operand is immutable
      """
      dtype_precedence_dict = {'double': 16, 'float': 14, 'size_t': 12, 'long': 10, 'int': 8, 'short': 6, 'bool': 4, 'char': 2}
      left_operand_dtype = right_operand_dtype = ""
      if "Tensor" in str(type(self)):
        left_operand_dtype = str(type(self)).split(".")[-1].split("Tensor")[0]
      else:
        left_operand_dtype = str(type(self)).split("'")[1]
      if "Tensor" in str(type(other)):
        right_operand_dtype = str(type(other)).split(".")[-1].split("Tensor")[0]
      else:
        right_operand_dtype = str(type(other)).split("'")[1]
      if (dtype_precedence_dict[left_operand_dtype] < dtype_precedence_dict[right_operand_dtype]):
        errorMsg = "cannot modify left hand operand datatype."
        raise TypeError(errorMsg)
      return add(self, other)

    def __sub__(self, other):
      return sub(self, other)

    def __rsub__(self, other):
      return sub(other, self)

    def __isub__(self, other):
      """
        making sure left hand operand is immutable
      """
      dtype_precedence_dict = {'double': 16, 'float': 14, 'size_t': 12, 'long': 10, 'int': 8, 'short': 6, 'bool': 4, 'char': 2}
      left_operand_dtype = right_operand_dtype = ""
      if "Tensor" in str(type(self)):
        left_operand_dtype = str(type(self)).split(".")[-1].split("Tensor")[0]
      else:
        left_operand_dtype = str(type(self)).split("'")[1]
      if "Tensor" in str(type(other)):
        right_operand_dtype = str(type(other)).split(".")[-1].split("Tensor")[0]
      else:
        right_operand_dtype = str(type(other)).split("'")[1]
      if (dtype_precedence_dict[left_operand_dtype] < dtype_precedence_dict[right_operand_dtype]):
        errorMsg = "cannot modify left hand operand datatype."
        raise TypeError(errorMsg)
      return sub(self, other)

    def __mul__(self, other):
      return mul(self, other)

    def __rmul__(self, other):
      return mul(other, self)

    def __imul__(self, other):
      """
        making sure left hand operand is immutable
      """
      dtype_precedence_dict = {'double': 16, 'float': 14, 'size_t': 12, 'long': 10, 'int': 8, 'short': 6, 'bool': 4, 'char': 2}
      left_operand_dtype = right_operand_dtype = ""
      if "Tensor" in str(type(self)):
        left_operand_dtype = str(type(self)).split(".")[-1].split("Tensor")[0]
      else:
        left_operand_dtype = str(type(self)).split("'")[1]
      if "Tensor" in str(type(other)):
        right_operand_dtype = str(type(other)).split(".")[-1].split("Tensor")[0]
      else:
        right_operand_dtype = str(type(other)).split("'")[1]
      if (dtype_precedence_dict[left_operand_dtype] < dtype_precedence_dict[right_operand_dtype]):
        errorMsg = "cannot modify left hand operand datatype."
        raise TypeError(errorMsg)
      return mul(self, other)

    def __floordiv__(self, other):
      return floor_div(self, other)

    def __rfloordiv__(self, other):
      return floor_div(other, self)

    def __ifloordiv__(self, other):
      """
        making sure left hand operand is immutable
      """
      dtype_precedence_dict = {'double': 16, 'float': 14, 'size_t': 12, 'long': 10, 'int': 8, 'short': 6, 'bool': 4, 'char': 2}
      left_operand_dtype = right_operand_dtype = ""
      if "Tensor" in str(type(self)):
        left_operand_dtype = str(type(self)).split(".")[-1].split("Tensor")[0]
      else:
        left_operand_dtype = str(type(self)).split("'")[1]
      if "Tensor" in str(type(other)):
        right_operand_dtype = str(type(other)).split(".")[-1].split("Tensor")[0]
      else:
        right_operand_dtype = str(type(other)).split("'")[1]
      if (dtype_precedence_dict[left_operand_dtype] < dtype_precedence_dict[right_operand_dtype]):
        errorMsg = "cannot modify left hand operand datatype."
        raise TypeError(errorMsg)
      return floor_div(self, other)

    def __truediv__(self, other):
      return true_div(self, other)

    def __rtruediv__(self, other):
      return true_div(other, self)

    def __itruediv__(self, other):
      """
        making sure left hand operand is immutable
      """
      dtype_precedence_dict = {'double': 16, 'float': 14, 'size_t': 12, 'long': 10, 'int': 8, 'short': 6, 'bool': 4, 'char': 2}
      left_operand_dtype = right_operand_dtype = ""
      if "Tensor" in str(type(self)):
        left_operand_dtype = str(type(self)).split(".")[-1].split("Tensor")[0]
      else:
        left_operand_dtype = str(type(self)).split("'")[1]
      if "Tensor" in str(type(other)):
        right_operand_dtype = str(type(other)).split(".")[-1].split("Tensor")[0]
      else:
        right_operand_dtype = str(type(other)).split("'")[1]
      if (dtype_precedence_dict[left_operand_dtype] < dtype_precedence_dict[right_operand_dtype]):
        errorMsg = "cannot modify left hand operand datatype."
        raise TypeError(errorMsg)
      return true_div(self, other)

    def __mod__(self, other):
      return remainder(self, other)

    def __rmod__(self, other):
      return remainder(other, self)

    def __imod__(self, other):
      """
        making sure left hand operand is immutable
      """
      dtype_precedence_dict = {'double': 16, 'float': 14, 'size_t': 12, 'long': 10, 'int': 8, 'short': 6, 'bool': 4, 'char': 2}
      left_operand_dtype = right_operand_dtype = ""
      if "Tensor" in str(type(self)):
        left_operand_dtype = str(type(self)).split(".")[-1].split("Tensor")[0]
      else:
        left_operand_dtype = str(type(self)).split("'")[1]
      if "Tensor" in str(type(other)):
        right_operand_dtype = str(type(other)).split(".")[-1].split("Tensor")[0]
      else:
        right_operand_dtype = str(type(other)).split("'")[1]
      if (dtype_precedence_dict[left_operand_dtype] < dtype_precedence_dict[right_operand_dtype]):
        errorMsg = "cannot modify left hand operand datatype."
        raise TypeError(errorMsg)
      return remainder(self, other)

    def __pow__(self, other):
      return power(self, other)

    def __rpow__(self, other):
      return power(other, self)

    def __ipow__(self, other):
      """
        making sure left hand operand is immutable
      """
      dtype_precedence_dict = {'double': 16, 'float': 14, 'size_t': 12, 'long': 10, 'int': 8, 'short': 6, 'bool': 4, 'char': 2}
      left_operand_dtype = right_operand_dtype = ""
      if "Tensor" in str(type(self)):
        left_operand_dtype = str(type(self)).split(".")[-1].split("Tensor")[0]
      else:
        left_operand_dtype = str(type(self)).split("'")[1]
      if "Tensor" in str(type(other)):
        right_operand_dtype = str(type(other)).split(".")[-1].split("Tensor")[0]
      else:
        right_operand_dtype = str(type(other)).split("'")[1]
      if (dtype_precedence_dict[left_operand_dtype] < dtype_precedence_dict[right_operand_dtype]):
        errorMsg = "cannot modify left hand operand datatype."
        raise TypeError(errorMsg)
      return power(self, other)

    def __and__(self, other):
      return bitwise_and(self, other)

    def __rand__(self, other):
      return bitwise_and(other, self)

    def __iand__(self, other):
      """
        making sure left hand operand is immutable
      """
      dtype_precedence_dict = {'double': 16, 'float': 14, 'size_t': 12, 'long': 10, 'int': 8, 'short': 6, 'bool': 4, 'char': 2}
      left_operand_dtype = right_operand_dtype = ""
      if "Tensor" in str(type(self)):
        left_operand_dtype = str(type(self)).split(".")[-1].split("Tensor")[0]
      else:
        left_operand_dtype = str(type(self)).split("'")[1]
      if "Tensor" in str(type(other)):
        right_operand_dtype = str(type(other)).split(".")[-1].split("Tensor")[0]
      else:
        right_operand_dtype = str(type(other)).split("'")[1]
      if (dtype_precedence_dict[left_operand_dtype] < dtype_precedence_dict[right_operand_dtype]):
        errorMsg = "cannot modify left hand operand datatype."
        raise TypeError(errorMsg)
      return bitwise_and(self, other)

    def __or__(self, other):
      return bitwise_or(self, other)

    def __ror__(self, other):
      return bitwise_or(other, self)

    def __ior__(self, other):
      """
        making sure left hand operand is immutable
      """
      dtype_precedence_dict = {'double': 16, 'float': 14, 'size_t': 12, 'long': 10, 'int': 8, 'short': 6, 'bool': 4, 'char': 2}
      left_operand_dtype = right_operand_dtype = ""
      if "Tensor" in str(type(self)):
        left_operand_dtype = str(type(self)).split(".")[-1].split("Tensor")[0]
      else:
        left_operand_dtype = str(type(self)).split("'")[1]
      if "Tensor" in str(type(other)):
        right_operand_dtype = str(type(other)).split(".")[-1].split("Tensor")[0]
      else:
        right_operand_dtype = str(type(other)).split("'")[1]
      if (dtype_precedence_dict[left_operand_dtype] < dtype_precedence_dict[right_operand_dtype]):
        errorMsg = "cannot modify left hand operand datatype."
        raise TypeError(errorMsg)
      return bitwise_or(self, other)

    def __xor__(self, other):
      return bitwise_xor(self, other)

    def __rxor__(self, other):
      return bitwise_xor(other, self)

    def __ixor__(self, other):
      """
        making sure left hand operand is immutable
      """
      dtype_precedence_dict = {'double': 16, 'float': 14, 'size_t': 12, 'long': 10, 'int': 8, 'short': 6, 'bool': 4, 'char': 2}
      left_operand_dtype = right_operand_dtype = ""
      if "Tensor" in str(type(self)):
        left_operand_dtype = str(type(self)).split(".")[-1].split("Tensor")[0]
      else:
        left_operand_dtype = str(type(self)).split("'")[1]
      if "Tensor" in str(type(other)):
        right_operand_dtype = str(type(other)).split(".")[-1].split("Tensor")[0]
      else:
        right_operand_dtype = str(type(other)).split("'")[1]
      if (dtype_precedence_dict[left_operand_dtype] < dtype_precedence_dict[right_operand_dtype]):
        errorMsg = "cannot modify left hand operand datatype."
        raise TypeError(errorMsg)
      return bitwise_xor(self, other)

    def __eq__(self, other):
      return equal(self, other)

    def __lt__(self, other):
      return less(self, other)

    def __gt__(self, other):
      return greater(self, other)

    def __ne__(self, other):
      return not_equal(self, other)

    def __le__(self, other):
      return less_equal(self, other)

    def __ge__(self, other):
      return greater_equal(self, other)



    def numpy(self) :
      """
         convert tensor to numpy array.
      """
      import numpy as np
      if (self.len() == 0):    # this is a deepC tensor bug, this if statement is a bypass for testing
        return np.array(self.data())
      return np.array(self.data()).reshape(self.shape())

    def len(self):
      """
         return length of tensor.
      """
      return self.length()

    def __iter__(self):
      """
         iterates over the tensor.
      """
      axis = 0
      while (axis < self.shape()[0]):
        yield self[axis]
        axis += 1

    def __int__(self):
      """
         convert tensor to int tensor.
      """
      if (self.len() > 1):
        raise TypeError("only length-1 tensor can be converted to Python scalars")
      elif(self.len() == 0):
        return
      return self.asTypeInt()

    def __float__(self):
      """
         convert tensor to float tensor.
      """
      if (self.len() > 1):
        raise TypeError("only length-1 tensor can be converted to Python scalars")
      elif(self.len() == 0):
        return
      return self.asTypeFloat()

    def __bool__(self):
      """
         convert tensor to bool tensor.
      """
      if (self.len() > 1):
        raise ValueError("The truth value of an array with more than one element is ambiguous. Use dc.any() or dc.all()")
      elif(self.len() == 0):
        return False
      return self.asTypeBool()


boolTensor_swigregister = _dnnc.boolTensor_swigregister
boolTensor_swigregister(boolTensor)

class intTensor(intplaceHolder):
    """Proxy of C++ dnnc::tensor<(int)> class."""

    __swig_setmethods__ = {}
    for _s in [intplaceHolder]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, intTensor, name, value)
    __swig_getmethods__ = {}
    for _s in [intplaceHolder]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, intTensor, name)

    def __init__(self, *args):
        """
        __init__(self, dimn, n, fill, init_val=0) -> intTensor

        Parameters
        ----------
        dimn: std::vector< dnnc::DIMENSION,std::allocator< dnnc::DIMENSION > >
        n: std::string
        fill: enum dnnc::INIT_TYPE
        init_val: int

        __init__(self, dimn, n, fill) -> intTensor

        Parameters
        ----------
        dimn: std::vector< dnnc::DIMENSION,std::allocator< dnnc::DIMENSION > >
        n: std::string
        fill: enum dnnc::INIT_TYPE

        __init__(self, dimn, n) -> intTensor

        Parameters
        ----------
        dimn: std::vector< dnnc::DIMENSION,std::allocator< dnnc::DIMENSION > >
        n: std::string

        __init__(self, dimn) -> intTensor

        Parameters
        ----------
        dimn: std::vector< dnnc::DIMENSION,std::allocator< dnnc::DIMENSION > >

        __init__(self) -> intTensor
        __init__(self, data, dimn, n) -> intTensor

        Parameters
        ----------
        data: int *
        dimn: std::vector< dnnc::DIMENSION,std::allocator< dnnc::DIMENSION > >
        n: std::string

        __init__(self, data, dimn) -> intTensor

        Parameters
        ----------
        data: int *
        dimn: std::vector< dnnc::DIMENSION,std::allocator< dnnc::DIMENSION > >

        __init__(self, other) -> intTensor

        Parameters
        ----------
        other: dnnc::tensor< int > const &

        """
        this = _dnnc.new_intTensor(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _dnnc.delete_intTensor
    __del__ = lambda self: None

    def __nonzero__(self):
        return _dnnc.intTensor___nonzero__(self)
    __bool__ = __nonzero__



    def copy(self):
        """
        copy(self) -> intTensor

        Parameters
        ----------
        self: dnnc::tensor< int > const *

        """
        return _dnnc.intTensor_copy(self)


    def negate(self):
        """
        negate(self) -> intTensor

        Parameters
        ----------
        self: dnnc::tensor< int > const *

        """
        return _dnnc.intTensor_negate(self)


    def absolute(self):
        """
        absolute(self) -> intTensor

        Parameters
        ----------
        self: dnnc::tensor< int > const *

        """
        return _dnnc.intTensor_absolute(self)


    def identifier(self):
        """
        identifier(self) -> size_t

        Parameters
        ----------
        self: dnnc::tensor< int > const *

        """
        return _dnnc.intTensor_identifier(self)


    def sameas(self, other):
        """
        sameas(self, other) -> bool

        Parameters
        ----------
        other: dnnc::tensor< int > const &

        """
        return _dnnc.intTensor_sameas(self, other)


    def asTypeDouble(self):
        """
        asTypeDouble(self) -> doubleTensor

        Parameters
        ----------
        self: dnnc::tensor< int > *

        """
        return _dnnc.intTensor_asTypeDouble(self)


    def asTypeFloat(self):
        """
        asTypeFloat(self) -> floatTensor

        Parameters
        ----------
        self: dnnc::tensor< int > *

        """
        return _dnnc.intTensor_asTypeFloat(self)


    def asTypeInt(self):
        """
        asTypeInt(self) -> intTensor

        Parameters
        ----------
        self: dnnc::tensor< int > *

        """
        return _dnnc.intTensor_asTypeInt(self)


    def asTypeUint8(self):
        """
        asTypeUint8(self) -> dnnc::tensor< uint8_t >

        Parameters
        ----------
        self: dnnc::tensor< int > *

        """
        return _dnnc.intTensor_asTypeUint8(self)


    def asTypeLong(self):
        """
        asTypeLong(self) -> dnnc::tensor< long >

        Parameters
        ----------
        self: dnnc::tensor< int > *

        """
        return _dnnc.intTensor_asTypeLong(self)


    def asTypeULong(self):
        """
        asTypeULong(self) -> uLongTensor

        Parameters
        ----------
        self: dnnc::tensor< int > *

        """
        return _dnnc.intTensor_asTypeULong(self)


    def asTypeBool(self):
        """
        asTypeBool(self) -> boolTensor

        Parameters
        ----------
        self: dnnc::tensor< int > *

        """
        return _dnnc.intTensor_asTypeBool(self)


    def load(self, *args):
        """
        load(self, data, indices)

        Parameters
        ----------
        data: int const &
        indices: std::vector< size_t,std::allocator< size_t > >

        load(self, data, i, j=0, k=0, l=0, m=0)

        Parameters
        ----------
        data: int const &
        i: size_t
        j: size_t
        k: size_t
        l: size_t
        m: size_t

        load(self, data, i, j=0, k=0, l=0)

        Parameters
        ----------
        data: int const &
        i: size_t
        j: size_t
        k: size_t
        l: size_t

        load(self, data, i, j=0, k=0)

        Parameters
        ----------
        data: int const &
        i: size_t
        j: size_t
        k: size_t

        load(self, data, i, j=0)

        Parameters
        ----------
        data: int const &
        i: size_t
        j: size_t

        load(self, data, i)

        Parameters
        ----------
        data: int const &
        i: size_t

        load(self, data)

        Parameters
        ----------
        data: std::vector< int,std::allocator< int > >

        load(self, data)

        Parameters
        ----------
        data: int const *

        """
        return _dnnc.intTensor_load(self, *args)


    def to_string(self, max_el=30):
        """
        to_string(self, max_el=30) -> std::string

        Parameters
        ----------
        max_el: size_t const

        to_string(self) -> std::string

        Parameters
        ----------
        self: dnnc::tensor< int > const *

        """
        return _dnnc.intTensor_to_string(self, max_el)


    def data(self):
        """
        data(self) -> vectorInt

        Parameters
        ----------
        self: dnnc::tensor< int > const *

        """
        return _dnnc.intTensor_data(self)


    def reshape(self, *args):
      """
        reshape tensor to a new shape permitting same length of old and new shape.
      """
      new_shape = []
      for arg in args:
        if isinstance(arg, int):
          new_shape.append(arg)
        else:
          return _dnnc.intTensor_reshape (self, vectorSizeT(arg))

      if len(new_shape):
        return _dnnc.intTensor_reshape (self, vectorSizeT(new_shape))

      return _dnnc.intTensor_reshape (args)



    def flatten(self):
        """
        flatten(self) -> intTensor

        Parameters
        ----------
        self: dnnc::tensor< int > *

        """
        return _dnnc.intTensor_flatten(self)


    def isnull(self):
        """
        isnull(self) -> bool

        Parameters
        ----------
        self: dnnc::tensor< int > const *

        """
        return _dnnc.intTensor_isnull(self)


    def transpose(self):
        """
        transpose(self)

        Parameters
        ----------
        self: dnnc::tensor< int > *

        """
        return _dnnc.intTensor_transpose(self)


    def __call__(self, *args):
        """
        __call__(self, indices) -> int

        Parameters
        ----------
        indices: std::vector< dnnc::INDEX,std::allocator< dnnc::INDEX > > &

        __call__(self, x=0, y=0, z=0, w=0, u=0) -> int

        Parameters
        ----------
        x: dnnc::INDEX const
        y: dnnc::INDEX const
        z: dnnc::INDEX const
        w: dnnc::INDEX const
        u: dnnc::INDEX const

        __call__(self, x=0, y=0, z=0, w=0) -> int

        Parameters
        ----------
        x: dnnc::INDEX const
        y: dnnc::INDEX const
        z: dnnc::INDEX const
        w: dnnc::INDEX const

        __call__(self, x=0, y=0, z=0) -> int

        Parameters
        ----------
        x: dnnc::INDEX const
        y: dnnc::INDEX const
        z: dnnc::INDEX const

        __call__(self, x=0, y=0) -> int

        Parameters
        ----------
        x: dnnc::INDEX const
        y: dnnc::INDEX const

        __call__(self, x=0) -> int

        Parameters
        ----------
        x: dnnc::INDEX const

        __call__(self) -> int &

        Parameters
        ----------
        self: dnnc::tensor< int > const *

        """
        return _dnnc.intTensor___call__(self, *args)


    def empty(self):
        """
        empty(self) -> bool

        Parameters
        ----------
        self: dnnc::tensor< int > *

        """
        return _dnnc.intTensor_empty(self)


    def dtype(self):
        """
        dtype(self) -> std::string

        Parameters
        ----------
        self: dnnc::tensor< int > *

        """
        return _dnnc.intTensor_dtype(self)


    def to_proto(self):
        """
        to_proto(self) -> std::string

        Parameters
        ----------
        self: dnnc::tensor< int > *

        """
        return _dnnc.intTensor_to_proto(self)


    def min(self):
        """
        min(self) -> int

        Parameters
        ----------
        self: dnnc::tensor< int > const *

        """
        return _dnnc.intTensor_min(self)


    def max(self):
        """
        max(self) -> int

        Parameters
        ----------
        self: dnnc::tensor< int > const *

        """
        return _dnnc.intTensor_max(self)


    def sum(self):
        """
        sum(self) -> int

        Parameters
        ----------
        self: dnnc::tensor< int > const *

        """
        return _dnnc.intTensor_sum(self)


    def __getitem__(self, indices):
        """
        __getitem__(self, indices) -> int const &

        Parameters
        ----------
        indices: PyObject *

        """
        return _dnnc.intTensor___getitem__(self, indices)


    def __setitem__(self, indices, data):
        """
        __setitem__(self, indices, data)

        Parameters
        ----------
        indices: PyObject *
        data: int const &

        """
        return _dnnc.intTensor___setitem__(self, indices, data)


    def __str__(self):
        """
        __str__(self) -> std::string

        Parameters
        ----------
        self: dnnc::tensor< int > *

        """
        return _dnnc.intTensor___str__(self)


    def __repr__(self):
        """
        __repr__(self) -> std::string

        Parameters
        ----------
        self: dnnc::tensor< int > *

        """
        return _dnnc.intTensor___repr__(self)


    def __neg__(self):
        """
        __neg__(self) -> intTensor

        Parameters
        ----------
        self: dnnc::tensor< int > *

        """
        return _dnnc.intTensor___neg__(self)


    def __pos__(self):
        """
        __pos__(self) -> intTensor

        Parameters
        ----------
        self: dnnc::tensor< int > *

        """
        return _dnnc.intTensor___pos__(self)


    def __abs__(self):
        """
        __abs__(self) -> intTensor

        Parameters
        ----------
        self: dnnc::tensor< int > *

        """
        return _dnnc.intTensor___abs__(self)


    def __invert__(self):
        """
        __invert__(self) -> boolTensor

        Parameters
        ----------
        self: dnnc::tensor< int > *

        """
        return _dnnc.intTensor___invert__(self)


    def __lshift__(self, *args):
        """
        __lshift__(self, other) -> intTensor

        Parameters
        ----------
        other: dnnc::tensor< int > &

        __lshift__(self, scalar) -> intTensor

        Parameters
        ----------
        scalar: int

        """
        return _dnnc.intTensor___lshift__(self, *args)


    def __ilshift__(self, *args):
        """
        __ilshift__(self, other) -> intTensor

        Parameters
        ----------
        other: dnnc::tensor< int > &

        __ilshift__(self, scalar) -> intTensor

        Parameters
        ----------
        scalar: int

        """
        return _dnnc.intTensor___ilshift__(self, *args)


    def __rshift__(self, *args):
        """
        __rshift__(self, other) -> intTensor

        Parameters
        ----------
        other: dnnc::tensor< int > &

        __rshift__(self, scalar) -> intTensor

        Parameters
        ----------
        scalar: int

        """
        return _dnnc.intTensor___rshift__(self, *args)


    def __irshift__(self, *args):
        """
        __irshift__(self, other) -> intTensor

        Parameters
        ----------
        other: dnnc::tensor< int > &

        __irshift__(self, scalar) -> intTensor

        Parameters
        ----------
        scalar: int

        """
        return _dnnc.intTensor___irshift__(self, *args)




    def __getitem__(self, index):
      """
         getitem method for tensor.
      """
      def get_item_helper_int(item, axis):
        flag = 0
        start = item
        if (start < 0):
          start += self.shape()[axis]
        stop = start+1
        step = 1
        if(start >= self.shape()[axis]):
          errorMsg = "index value " + str(start) + " along axis " + str(axis) + " is beyond the size " + str(self.shape()[axis]) + " of input tensor along that axis"
          raise ValueError(errorMsg)
          flag = 1
        return start, stop, step, flag

      def get_item_helper_slice(item, axis):
        flag = 0   # to check if all index items are supported or not
        start = 0
        stop = self.shape()[axis]
        step = 1
        if type(item.step) == int:
          step = item.step
          if step == 0:
            errorMsg = "slice step cannot be zero"
            raise TypeError(errorMsg)
            flag = 1
          elif step < 0:
            start = self.shape()[axis] -1
            stop = -1
        elif str(type(item.step)).split("'")[1] == "NoneType":
          pass
        else:
          errorMsg = "step of " + str(type(item.step)) + " not supported!"
          raise TypeError(errorMsg)
          flag = 1
        if type(item.start) == int:
          start = item.start
          if (start < 0):
            start += self.shape()[axis]
        elif str(type(item.start)).split("'")[1] == "NoneType":
          pass
        else:
          errorMsg = "start of " + str(type(item.start)) + " not supported!"
          raise TypeError(errorMsg)
          flag = 1
        if type(item.stop) == int:
          stop = item.stop
          if (stop < 0):
            stop += self.shape()[axis]
        elif str(type(item.stop)).split("'")[1] == "NoneType":
          pass
        else:
          errorMsg = "stop of " + str(type(item.stop)) + " not supported!"
          raise TypeError(errorMsg)
          flag = 1
    # if(start > self.shape()[axis]):
    #   errorMsg = "index value " + str(start) + " along axis " + str(axis) + " is beyond the size " + str(self.shape()[axis]) + " of input tensor along that axis"
    #   raise IndexError(errorMsg)
    #   flag = 1
    # if(stop > self.shape()[axis]):
    #   errorMsg = "index value " + str(stop) + " along axis " + str(axis) + " is beyond the size " + str(self.shape()[axis]) + " of input tensor along that axis"
    #   raise IndexError(errorMsg)
    #   flag = 1
    # if (step < 0) and not (start > stop):
    #   errorMsg = "stop index " + str(stop) + " along axis " + str(axis) + " is greater than start index " + str(start) + " while step is negative"
    #   raise IndexError(errorMsg)
    #   flag = 1
    # elif (step > 0) and not (start < stop):
    #   errorMsg = "stop index " + str(stop) + " along axis " + str(axis) + " is smaller than start index " + str(start) + " while step is positive"
    #   raise IndexError(errorMsg)
    #   flag = 1

        return start, stop, step, flag

      if str(type(index)).split("'")[1] == "int":
        if self.rank() < 1:
          return self.copy()
        axis = 0
        start, stop, step, flag = get_item_helper_int(index, axis)
        if flag:
          return
        start = array([start]).asTypeInt()
        stop = array([stop]).asTypeInt()
        axis = array([axis]).asTypeInt()
        step = array([step]).asTypeInt()
        if (self.rank() == 1):
          return self.data()[index]
        return slice(self, start, stop, axis, step).reshape(self.shape()[1:])

      elif str(type(index)).split("'")[1] == "slice":
        if self.rank() < 1:
          return self.copy()
        axis = 0
        start, stop, step, flag = get_item_helper_slice(index, axis)
        if flag:
          return
        start = array([start]).asTypeInt()
        stop = array([stop]).asTypeInt()
        axis = array([axis]).asTypeInt()
        step = array([step]).asTypeInt()
        return slice(self, start, stop, axis, step)

      elif str(type(index)).split("'")[1] == "ellipsis":
        return self.copy()

      elif str(type(index)).split("'")[1] == "tuple":
        if (len(index) > self.rank()):
          errorMsg = "Takes maximum " + str(self.rank()) + " arguments, " + str(len(index)) + " were given!"
          raise IndexError(errorMsg)
          return
    # elif Ellipsis not in index and (len(index) < self.rank()):
    #   errorMsg = "Takes minimum " + str(self.rank()) + " arguments, " + str(len(index)) + " were given!"
    #   raise IndexError(errorMsg)
    #   return

    # checks if any float or bool or complex is not present
        if any(isinstance(x,(bool,float,complex)) for x in index):
          errorMsg = "Restrict to only integers as a slicing argument!"
          raise ValueError(errorMsg)
          return

        start_list = []
        stop_list = []
        step_list = []
        axis_list = []
        axis = -1   # -1 for starting axis as 0 in the next loops
        reshape_list = []   # reshape list to reshape
        replace_start = replace_stop = 0   # replace ellipsis with slice methods by index

        if Ellipsis in index:
          if (index.count(Ellipsis) > 1):
            errorMsg = str(index.count(Ellipsis)) + " 'Ellipsis' found, maximum 1 is supported!"
            raise IndexError(errorMsg)
            return
          elif (index.count(Ellipsis) == 1):
            non_ellipsis_count = 0
            for item in index:
              if str(type(item)).split("'")[1] == "int" or str(type(item)).split("'")[1] == "slice":
                non_ellipsis_count += 1
    # replace holds start and stop index which will be replaced by slice method in place of ellipsis
            replace_start = index.index(Ellipsis)
            replace_stop = replace_start + self.rank() - non_ellipsis_count
          else:
            errorMsg = "Error occured while handling ellipsis!"
            raise ValueError(errorMsg)
            return

        for item in index:
          axis += 1
          if str(type(item)).split("'")[1] == "ellipsis":
            while (axis >= replace_start and axis < replace_stop):
              start = 0
              stop = self.shape()[axis]
              step = 1
              start_list.append(start)
              stop_list.append(stop)
              step_list.append(step)
              axis_list.append(axis)
              reshape_list.append(1)  # This shape will be taken
              axis += 1
            axis -= 1   # recovering from last axis increment
          elif str(type(item)).split("'")[1] == "int":
            start, stop, step, flag = get_item_helper_int(item, axis)
            if flag:
              return
            start_list.append(start)
            stop_list.append(stop)
            step_list.append(step)
            axis_list.append(axis)
            reshape_list.append(0)  # This shape will not be taken
          elif str(type(item)).split("'")[1] == "slice":
            start, stop, step, flag = get_item_helper_slice(item, axis)
            if flag:
              return
            start_list.append(start)
            stop_list.append(stop)
            step_list.append(step)
            axis_list.append(axis)
            reshape_list.append(1)  # This shape will be taken
          else:
            errorMsg = "Doesn't support " + str(item) + " of " + str(type(item)) + " as a slicing argument!"
            raise TypeError(errorMsg)
            return

        while (axis < self.rank()-1):
          axis += 1
          start = 0
          stop = self.shape()[axis]
          step = 1
          start_list.append(start)
          stop_list.append(stop)
          step_list.append(step)
          axis_list.append(axis)
          reshape_list.append(1)  # This shape will be taken

        start_list = array(start_list).asTypeInt()
        stop_list = array(stop_list).asTypeInt()
        axis_list = array(axis_list).asTypeInt()
        step_list = array(step_list).asTypeInt()

    # print("test start list :  ", start_list)
    # print("test stop list :  ", stop_list)
    # print("test axis list :  ", axis_list)
    # print("test step list :  ", step_list)

        result = slice(self, start_list, stop_list, axis_list, step_list)

        if (result.len() != 0) and (0 in reshape_list):
          if not 1 in reshape_list:
            return result.data()[0]
          return (result.reshape([x for x, y in zip(result.shape(), reshape_list) if y == 1]))

        return result

      else :
        errorMsg = "Doesn't support " + str(index) + " of " + str(type(index)) + " as a slicing argument!"
        raise TypeError(errorMsg)

      return intTensor()



    def __setitem__(self, index, input_tensor):
      """
         setitem method for tensor.
      """

      value_tensor = ""
      if "Tensor" not in str(type(input_tensor)).split("'")[1]:
        if str(type(input_tensor)).split("'")[1] in ("int", "float", "bool"):
          value_tensor = array([input_tensor])  # passing single number as tensor of length 1
        elif str(type(input_tensor)).split("'")[1] in ("list", "tuple"):
          value_tensor = array(input_tensor)  # passing python lists or tuples as tensor
        else:
          errorMsg = "could not convert " + str(input_tensor) + " of type " + str(type(input_tensor)) + " to dnnc tensor"
          raise ValueError(errorMsg)
          return
      else:
          value_tensor = input_tensor

      def set_item_helper_int(item, axis):
        flag = 0
        start = item
        if (start < 0):
          start += self.shape()[axis]
        stop = start+1
        step = 1
        if(start >= self.shape()[axis]):
          errorMsg = "index value " + str(start) + " along axis " + str(axis) + " is beyond the size " + str(self.shape()[axis]) + " of input tensor along that axis"
          raise ValueError(errorMsg)
          flag = 1
        return start, stop, step, flag

      def set_item_helper_slice(item, axis):
        flag = 0   # to check if all index items are supported or not
        start = 0
        stop = self.shape()[axis]
        step = 1
        if type(item.step) == int:
          step = item.step
          if step == 0:
            errorMsg = "slice step cannot be zero"
            raise TypeError(errorMsg)
            flag = 1
          elif step < 0:
            start = self.shape()[axis] -1
            stop = -1
        elif str(type(item.step)).split("'")[1] == "NoneType":
          pass
        else:
          errorMsg = "step of " + str(type(item.step)) + " not supported!"
          raise TypeError(errorMsg)
          flag = 1
        if type(item.start) == int:
          start = item.start
          if (start < 0):
            start += self.shape()[axis]
        elif str(type(item.start)).split("'")[1] == "NoneType":
          pass
        else:
          errorMsg = "start of " + str(type(item.start)) + " not supported!"
          raise TypeError(errorMsg)
          flag = 1
        if type(item.stop) == int:
          stop = item.stop
          if (stop < 0):
            stop += self.shape()[axis]
        elif str(type(item.stop)).split("'")[1] == "NoneType":
          pass
        else:
          errorMsg = "stop of " + str(type(item.stop)) + " not supported!"
          raise TypeError(errorMsg)
          flag = 1
    # if(start > self.shape()[axis]):
    #   errorMsg = "index value " + str(start) + " along axis " + str(axis) + " is beyond the size " + str(self.shape()[axis]) + " of input tensor along that axis"
    #   raise IndexError(errorMsg)
    #   flag = 1
    # if(stop > self.shape()[axis]):
    #   errorMsg = "index value " + str(stop) + " along axis " + str(axis) + " is beyond the size " + str(self.shape()[axis]) + " of input tensor along that axis"
    #   raise IndexError(errorMsg)
    #   flag = 1
    # if (step < 0) and not (start > stop):
    #   errorMsg = "stop index " + str(stop) + " along axis " + str(axis) + " is greater than start index " + str(start) + " while step is negative"
    #   raise IndexError(errorMsg)
    #   flag = 1
    # elif (step > 0) and not (start < stop):
    #   errorMsg = "stop index " + str(stop) + " along axis " + str(axis) + " is smaller than start index " + str(start) + " while step is positive"
    #   raise IndexError(errorMsg)
    #   flag = 1

        return start, stop, step, flag

      if str(type(index)).split("'")[1] == "int":
        if self.rank() < 1:
          errorMsg = "cannot set items to a null tensor"
          raise TypeError(errorMsg)
          return
        axis = 0
        start, stop, step, flag = set_item_helper_int(index, axis)
        if flag:
          return
        start = array([start]).asTypeInt()
        stop = array([stop]).asTypeInt()
        axis = array([axis]).asTypeInt()
        step = array([step]).asTypeInt()

        set_slice(self, value_tensor, start, stop, axis, step)
        return

      elif str(type(index)).split("'")[1] == "slice":
        if self.rank() < 1:
          self = value_tensor
          return
        axis = 0
        start, stop, step, flag = set_item_helper_slice(index, axis)
        if flag:
          return
        start = array([start]).asTypeInt()
        stop = array([stop]).asTypeInt()
        axis = array([axis]).asTypeInt()
        step = array([step]).asTypeInt()

        set_slice(self, value_tensor, start, stop, axis, step)
        return

      elif str(type(index)).split("'")[1] == "ellipsis":
        if self.shape() != value_tensor.shape():
          errorMsg = "could not broadcast input array from shape "+str(value_tensor.shape())+" into shape "+str(self.shape())
          raise ValueError(errorMsg)
          return
        elif (self.rank() < 1) or (self.shape() == value_tensor.shape()):
          self = value_tensor
          return

      elif str(type(index)).split("'")[1] == "tuple":
        if (len(index) > self.rank()):
          errorMsg = "Takes maximum " + str(self.rank()) + " arguments, " + str(len(index)) + " were given!"
          raise IndexError(errorMsg)
          return
    # elif Ellipsis not in index and (len(index) < self.rank()):
    #   errorMsg = "Takes minimum " + str(self.rank()) + " arguments, " + str(len(index)) + " were given!"
    #   raise IndexError(errorMsg)
    #   return

    # checks if any float or bool or complex is not present
        if any(isinstance(x,(bool,float,complex)) for x in index):
          errorMsg = "Restrict to only integers as a slicing argument!"
          raise ValueError(errorMsg)
          return

        start_list = []
        stop_list = []
        step_list = []
        axis_list = []
        axis = -1   # -1 for starting axis as 0 in the next loops
        replace_start = replace_stop = 0   # replace ellipsis with slice methods by index

        if Ellipsis in index:
          if (index.count(Ellipsis) > 1):
            errorMsg = str(index.count(Ellipsis)) + " 'Ellipsis' found, maximum 1 is supported!"
            raise IndexError(errorMsg)
            return
          elif (index.count(Ellipsis) == 1):
            non_ellipsis_count = 0
            for item in index:
              if str(type(item)).split("'")[1] == "int" or str(type(item)).split("'")[1] == "slice":
                non_ellipsis_count += 1
    # replace holds start and stop index which will be replaced by slice method in place of ellipsis
            replace_start = index.index(Ellipsis)
            replace_stop = replace_start + self.rank() - non_ellipsis_count
          else:
            errorMsg = "Error occured while handling ellipsis!"
            raise ValueError(errorMsg)
            return

        for item in index:
          axis += 1
          if str(type(item)).split("'")[1] == "ellipsis":
            while (axis >= replace_start and axis < replace_stop):
              start = 0
              stop = self.shape()[axis]
              step = 1
              start_list.append(start)
              stop_list.append(stop)
              step_list.append(step)
              axis_list.append(axis)
              axis += 1
            axis -= 1   # recovering from last axis increment
          elif str(type(item)).split("'")[1] == "int":
            start, stop, step, flag = set_item_helper_int(item, axis)
            if flag:
              return
            start_list.append(start)
            stop_list.append(stop)
            step_list.append(step)
            axis_list.append(axis)
          elif str(type(item)).split("'")[1] == "slice":
            start, stop, step, flag = set_item_helper_slice(item, axis)
            if flag:
              return
            start_list.append(start)
            stop_list.append(stop)
            step_list.append(step)
            axis_list.append(axis)
          else:
            errorMsg = "Doesn't support " + str(item) + " of " + str(type(item)) + " as a slicing argument!"
            raise TypeError(errorMsg)
            return

        while (axis < self.rank()-1):
          axis += 1
          start = 0
          stop = self.shape()[axis]
          step = 1
          start_list.append(start)
          stop_list.append(stop)
          step_list.append(step)
          axis_list.append(axis)

        start_list = array(start_list).asTypeInt()
        stop_list = array(stop_list).asTypeInt()
        axis_list = array(axis_list).asTypeInt()
        step_list = array(step_list).asTypeInt()

    # print("test start list :  ", start_list)
    # print("test stop list :  ", stop_list)
    # print("test axis list :  ", axis_list)
    # print("test step list :  ", step_list)

        set_slice(self, value_tensor, start_list, stop_list, axis_list, step_list)
        return
      else :
        errorMsg = "Doesn't support " + str(index) + " of " + str(type(index)) + " as a slicing argument!"
        raise TypeError(errorMsg)

      return


    def __add__(self, other):
      return add(self, other)

    def __radd__(self, other):
      return add(other, self)

    def __iadd__(self, other):
      """
        making sure left hand operand is immutable
      """
      dtype_precedence_dict = {'double': 16, 'float': 14, 'size_t': 12, 'long': 10, 'int': 8, 'short': 6, 'bool': 4, 'char': 2}
      left_operand_dtype = right_operand_dtype = ""
      if "Tensor" in str(type(self)):
        left_operand_dtype = str(type(self)).split(".")[-1].split("Tensor")[0]
      else:
        left_operand_dtype = str(type(self)).split("'")[1]
      if "Tensor" in str(type(other)):
        right_operand_dtype = str(type(other)).split(".")[-1].split("Tensor")[0]
      else:
        right_operand_dtype = str(type(other)).split("'")[1]
      if (dtype_precedence_dict[left_operand_dtype] < dtype_precedence_dict[right_operand_dtype]):
        errorMsg = "cannot modify left hand operand datatype."
        raise TypeError(errorMsg)
      return add(self, other)

    def __sub__(self, other):
      return sub(self, other)

    def __rsub__(self, other):
      return sub(other, self)

    def __isub__(self, other):
      """
        making sure left hand operand is immutable
      """
      dtype_precedence_dict = {'double': 16, 'float': 14, 'size_t': 12, 'long': 10, 'int': 8, 'short': 6, 'bool': 4, 'char': 2}
      left_operand_dtype = right_operand_dtype = ""
      if "Tensor" in str(type(self)):
        left_operand_dtype = str(type(self)).split(".")[-1].split("Tensor")[0]
      else:
        left_operand_dtype = str(type(self)).split("'")[1]
      if "Tensor" in str(type(other)):
        right_operand_dtype = str(type(other)).split(".")[-1].split("Tensor")[0]
      else:
        right_operand_dtype = str(type(other)).split("'")[1]
      if (dtype_precedence_dict[left_operand_dtype] < dtype_precedence_dict[right_operand_dtype]):
        errorMsg = "cannot modify left hand operand datatype."
        raise TypeError(errorMsg)
      return sub(self, other)

    def __mul__(self, other):
      return mul(self, other)

    def __rmul__(self, other):
      return mul(other, self)

    def __imul__(self, other):
      """
        making sure left hand operand is immutable
      """
      dtype_precedence_dict = {'double': 16, 'float': 14, 'size_t': 12, 'long': 10, 'int': 8, 'short': 6, 'bool': 4, 'char': 2}
      left_operand_dtype = right_operand_dtype = ""
      if "Tensor" in str(type(self)):
        left_operand_dtype = str(type(self)).split(".")[-1].split("Tensor")[0]
      else:
        left_operand_dtype = str(type(self)).split("'")[1]
      if "Tensor" in str(type(other)):
        right_operand_dtype = str(type(other)).split(".")[-1].split("Tensor")[0]
      else:
        right_operand_dtype = str(type(other)).split("'")[1]
      if (dtype_precedence_dict[left_operand_dtype] < dtype_precedence_dict[right_operand_dtype]):
        errorMsg = "cannot modify left hand operand datatype."
        raise TypeError(errorMsg)
      return mul(self, other)

    def __floordiv__(self, other):
      return floor_div(self, other)

    def __rfloordiv__(self, other):
      return floor_div(other, self)

    def __ifloordiv__(self, other):
      """
        making sure left hand operand is immutable
      """
      dtype_precedence_dict = {'double': 16, 'float': 14, 'size_t': 12, 'long': 10, 'int': 8, 'short': 6, 'bool': 4, 'char': 2}
      left_operand_dtype = right_operand_dtype = ""
      if "Tensor" in str(type(self)):
        left_operand_dtype = str(type(self)).split(".")[-1].split("Tensor")[0]
      else:
        left_operand_dtype = str(type(self)).split("'")[1]
      if "Tensor" in str(type(other)):
        right_operand_dtype = str(type(other)).split(".")[-1].split("Tensor")[0]
      else:
        right_operand_dtype = str(type(other)).split("'")[1]
      if (dtype_precedence_dict[left_operand_dtype] < dtype_precedence_dict[right_operand_dtype]):
        errorMsg = "cannot modify left hand operand datatype."
        raise TypeError(errorMsg)
      return floor_div(self, other)

    def __truediv__(self, other):
      return true_div(self, other)

    def __rtruediv__(self, other):
      return true_div(other, self)

    def __itruediv__(self, other):
      """
        making sure left hand operand is immutable
      """
      dtype_precedence_dict = {'double': 16, 'float': 14, 'size_t': 12, 'long': 10, 'int': 8, 'short': 6, 'bool': 4, 'char': 2}
      left_operand_dtype = right_operand_dtype = ""
      if "Tensor" in str(type(self)):
        left_operand_dtype = str(type(self)).split(".")[-1].split("Tensor")[0]
      else:
        left_operand_dtype = str(type(self)).split("'")[1]
      if "Tensor" in str(type(other)):
        right_operand_dtype = str(type(other)).split(".")[-1].split("Tensor")[0]
      else:
        right_operand_dtype = str(type(other)).split("'")[1]
      if (dtype_precedence_dict[left_operand_dtype] < dtype_precedence_dict[right_operand_dtype]):
        errorMsg = "cannot modify left hand operand datatype."
        raise TypeError(errorMsg)
      return true_div(self, other)

    def __mod__(self, other):
      return remainder(self, other)

    def __rmod__(self, other):
      return remainder(other, self)

    def __imod__(self, other):
      """
        making sure left hand operand is immutable
      """
      dtype_precedence_dict = {'double': 16, 'float': 14, 'size_t': 12, 'long': 10, 'int': 8, 'short': 6, 'bool': 4, 'char': 2}
      left_operand_dtype = right_operand_dtype = ""
      if "Tensor" in str(type(self)):
        left_operand_dtype = str(type(self)).split(".")[-1].split("Tensor")[0]
      else:
        left_operand_dtype = str(type(self)).split("'")[1]
      if "Tensor" in str(type(other)):
        right_operand_dtype = str(type(other)).split(".")[-1].split("Tensor")[0]
      else:
        right_operand_dtype = str(type(other)).split("'")[1]
      if (dtype_precedence_dict[left_operand_dtype] < dtype_precedence_dict[right_operand_dtype]):
        errorMsg = "cannot modify left hand operand datatype."
        raise TypeError(errorMsg)
      return remainder(self, other)

    def __pow__(self, other):
      return power(self, other)

    def __rpow__(self, other):
      return power(other, self)

    def __ipow__(self, other):
      """
        making sure left hand operand is immutable
      """
      dtype_precedence_dict = {'double': 16, 'float': 14, 'size_t': 12, 'long': 10, 'int': 8, 'short': 6, 'bool': 4, 'char': 2}
      left_operand_dtype = right_operand_dtype = ""
      if "Tensor" in str(type(self)):
        left_operand_dtype = str(type(self)).split(".")[-1].split("Tensor")[0]
      else:
        left_operand_dtype = str(type(self)).split("'")[1]
      if "Tensor" in str(type(other)):
        right_operand_dtype = str(type(other)).split(".")[-1].split("Tensor")[0]
      else:
        right_operand_dtype = str(type(other)).split("'")[1]
      if (dtype_precedence_dict[left_operand_dtype] < dtype_precedence_dict[right_operand_dtype]):
        errorMsg = "cannot modify left hand operand datatype."
        raise TypeError(errorMsg)
      return power(self, other)

    def __and__(self, other):
      return bitwise_and(self, other)

    def __rand__(self, other):
      return bitwise_and(other, self)

    def __iand__(self, other):
      """
        making sure left hand operand is immutable
      """
      dtype_precedence_dict = {'double': 16, 'float': 14, 'size_t': 12, 'long': 10, 'int': 8, 'short': 6, 'bool': 4, 'char': 2}
      left_operand_dtype = right_operand_dtype = ""
      if "Tensor" in str(type(self)):
        left_operand_dtype = str(type(self)).split(".")[-1].split("Tensor")[0]
      else:
        left_operand_dtype = str(type(self)).split("'")[1]
      if "Tensor" in str(type(other)):
        right_operand_dtype = str(type(other)).split(".")[-1].split("Tensor")[0]
      else:
        right_operand_dtype = str(type(other)).split("'")[1]
      if (dtype_precedence_dict[left_operand_dtype] < dtype_precedence_dict[right_operand_dtype]):
        errorMsg = "cannot modify left hand operand datatype."
        raise TypeError(errorMsg)
      return bitwise_and(self, other)

    def __or__(self, other):
      return bitwise_or(self, other)

    def __ror__(self, other):
      return bitwise_or(other, self)

    def __ior__(self, other):
      """
        making sure left hand operand is immutable
      """
      dtype_precedence_dict = {'double': 16, 'float': 14, 'size_t': 12, 'long': 10, 'int': 8, 'short': 6, 'bool': 4, 'char': 2}
      left_operand_dtype = right_operand_dtype = ""
      if "Tensor" in str(type(self)):
        left_operand_dtype = str(type(self)).split(".")[-1].split("Tensor")[0]
      else:
        left_operand_dtype = str(type(self)).split("'")[1]
      if "Tensor" in str(type(other)):
        right_operand_dtype = str(type(other)).split(".")[-1].split("Tensor")[0]
      else:
        right_operand_dtype = str(type(other)).split("'")[1]
      if (dtype_precedence_dict[left_operand_dtype] < dtype_precedence_dict[right_operand_dtype]):
        errorMsg = "cannot modify left hand operand datatype."
        raise TypeError(errorMsg)
      return bitwise_or(self, other)

    def __xor__(self, other):
      return bitwise_xor(self, other)

    def __rxor__(self, other):
      return bitwise_xor(other, self)

    def __ixor__(self, other):
      """
        making sure left hand operand is immutable
      """
      dtype_precedence_dict = {'double': 16, 'float': 14, 'size_t': 12, 'long': 10, 'int': 8, 'short': 6, 'bool': 4, 'char': 2}
      left_operand_dtype = right_operand_dtype = ""
      if "Tensor" in str(type(self)):
        left_operand_dtype = str(type(self)).split(".")[-1].split("Tensor")[0]
      else:
        left_operand_dtype = str(type(self)).split("'")[1]
      if "Tensor" in str(type(other)):
        right_operand_dtype = str(type(other)).split(".")[-1].split("Tensor")[0]
      else:
        right_operand_dtype = str(type(other)).split("'")[1]
      if (dtype_precedence_dict[left_operand_dtype] < dtype_precedence_dict[right_operand_dtype]):
        errorMsg = "cannot modify left hand operand datatype."
        raise TypeError(errorMsg)
      return bitwise_xor(self, other)

    def __eq__(self, other):
      return equal(self, other)

    def __lt__(self, other):
      return less(self, other)

    def __gt__(self, other):
      return greater(self, other)

    def __ne__(self, other):
      return not_equal(self, other)

    def __le__(self, other):
      return less_equal(self, other)

    def __ge__(self, other):
      return greater_equal(self, other)



    def numpy(self) :
      """
         convert tensor to numpy array.
      """
      import numpy as np
      if (self.len() == 0):    # this is a deepC tensor bug, this if statement is a bypass for testing
        return np.array(self.data())
      return np.array(self.data()).reshape(self.shape())

    def len(self):
      """
         return length of tensor.
      """
      return self.length()

    def __iter__(self):
      """
         iterates over the tensor.
      """
      axis = 0
      while (axis < self.shape()[0]):
        yield self[axis]
        axis += 1

    def __int__(self):
      """
         convert tensor to int tensor.
      """
      if (self.len() > 1):
        raise TypeError("only length-1 tensor can be converted to Python scalars")
      elif(self.len() == 0):
        return
      return self.asTypeInt()

    def __float__(self):
      """
         convert tensor to float tensor.
      """
      if (self.len() > 1):
        raise TypeError("only length-1 tensor can be converted to Python scalars")
      elif(self.len() == 0):
        return
      return self.asTypeFloat()

    def __bool__(self):
      """
         convert tensor to bool tensor.
      """
      if (self.len() > 1):
        raise ValueError("The truth value of an array with more than one element is ambiguous. Use dc.any() or dc.all()")
      elif(self.len() == 0):
        return False
      return self.asTypeBool()


intTensor_swigregister = _dnnc.intTensor_swigregister
intTensor_swigregister(intTensor)

class uLongTensor(uLongplaceHolder):
    """Proxy of C++ dnnc::tensor<(size_t)> class."""

    __swig_setmethods__ = {}
    for _s in [uLongplaceHolder]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, uLongTensor, name, value)
    __swig_getmethods__ = {}
    for _s in [uLongplaceHolder]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, uLongTensor, name)

    def __init__(self, *args):
        """
        __init__(self, dimn, n, fill, init_val=0) -> uLongTensor

        Parameters
        ----------
        dimn: std::vector< dnnc::DIMENSION,std::allocator< dnnc::DIMENSION > >
        n: std::string
        fill: enum dnnc::INIT_TYPE
        init_val: size_t

        __init__(self, dimn, n, fill) -> uLongTensor

        Parameters
        ----------
        dimn: std::vector< dnnc::DIMENSION,std::allocator< dnnc::DIMENSION > >
        n: std::string
        fill: enum dnnc::INIT_TYPE

        __init__(self, dimn, n) -> uLongTensor

        Parameters
        ----------
        dimn: std::vector< dnnc::DIMENSION,std::allocator< dnnc::DIMENSION > >
        n: std::string

        __init__(self, dimn) -> uLongTensor

        Parameters
        ----------
        dimn: std::vector< dnnc::DIMENSION,std::allocator< dnnc::DIMENSION > >

        __init__(self) -> uLongTensor
        __init__(self, data, dimn, n) -> uLongTensor

        Parameters
        ----------
        data: size_t *
        dimn: std::vector< dnnc::DIMENSION,std::allocator< dnnc::DIMENSION > >
        n: std::string

        __init__(self, data, dimn) -> uLongTensor

        Parameters
        ----------
        data: size_t *
        dimn: std::vector< dnnc::DIMENSION,std::allocator< dnnc::DIMENSION > >

        __init__(self, other) -> uLongTensor

        Parameters
        ----------
        other: dnnc::tensor< size_t > const &

        """
        this = _dnnc.new_uLongTensor(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _dnnc.delete_uLongTensor
    __del__ = lambda self: None

    def __nonzero__(self):
        return _dnnc.uLongTensor___nonzero__(self)
    __bool__ = __nonzero__



    def copy(self):
        """
        copy(self) -> uLongTensor

        Parameters
        ----------
        self: dnnc::tensor< size_t > const *

        """
        return _dnnc.uLongTensor_copy(self)


    def negate(self):
        """
        negate(self) -> uLongTensor

        Parameters
        ----------
        self: dnnc::tensor< size_t > const *

        """
        return _dnnc.uLongTensor_negate(self)


    def absolute(self):
        """
        absolute(self) -> uLongTensor

        Parameters
        ----------
        self: dnnc::tensor< size_t > const *

        """
        return _dnnc.uLongTensor_absolute(self)


    def identifier(self):
        """
        identifier(self) -> size_t

        Parameters
        ----------
        self: dnnc::tensor< size_t > const *

        """
        return _dnnc.uLongTensor_identifier(self)


    def sameas(self, other):
        """
        sameas(self, other) -> bool

        Parameters
        ----------
        other: dnnc::tensor< size_t > const &

        """
        return _dnnc.uLongTensor_sameas(self, other)


    def asTypeDouble(self):
        """
        asTypeDouble(self) -> doubleTensor

        Parameters
        ----------
        self: dnnc::tensor< size_t > *

        """
        return _dnnc.uLongTensor_asTypeDouble(self)


    def asTypeFloat(self):
        """
        asTypeFloat(self) -> floatTensor

        Parameters
        ----------
        self: dnnc::tensor< size_t > *

        """
        return _dnnc.uLongTensor_asTypeFloat(self)


    def asTypeInt(self):
        """
        asTypeInt(self) -> intTensor

        Parameters
        ----------
        self: dnnc::tensor< size_t > *

        """
        return _dnnc.uLongTensor_asTypeInt(self)


    def asTypeUint8(self):
        """
        asTypeUint8(self) -> dnnc::tensor< uint8_t >

        Parameters
        ----------
        self: dnnc::tensor< size_t > *

        """
        return _dnnc.uLongTensor_asTypeUint8(self)


    def asTypeLong(self):
        """
        asTypeLong(self) -> dnnc::tensor< long >

        Parameters
        ----------
        self: dnnc::tensor< size_t > *

        """
        return _dnnc.uLongTensor_asTypeLong(self)


    def asTypeULong(self):
        """
        asTypeULong(self) -> uLongTensor

        Parameters
        ----------
        self: dnnc::tensor< size_t > *

        """
        return _dnnc.uLongTensor_asTypeULong(self)


    def asTypeBool(self):
        """
        asTypeBool(self) -> boolTensor

        Parameters
        ----------
        self: dnnc::tensor< size_t > *

        """
        return _dnnc.uLongTensor_asTypeBool(self)


    def load(self, *args):
        """
        load(self, data, indices)

        Parameters
        ----------
        data: size_t const &
        indices: std::vector< size_t,std::allocator< size_t > >

        load(self, data, i, j=0, k=0, l=0, m=0)

        Parameters
        ----------
        data: size_t const &
        i: size_t
        j: size_t
        k: size_t
        l: size_t
        m: size_t

        load(self, data, i, j=0, k=0, l=0)

        Parameters
        ----------
        data: size_t const &
        i: size_t
        j: size_t
        k: size_t
        l: size_t

        load(self, data, i, j=0, k=0)

        Parameters
        ----------
        data: size_t const &
        i: size_t
        j: size_t
        k: size_t

        load(self, data, i, j=0)

        Parameters
        ----------
        data: size_t const &
        i: size_t
        j: size_t

        load(self, data, i)

        Parameters
        ----------
        data: size_t const &
        i: size_t

        load(self, data)

        Parameters
        ----------
        data: std::vector< size_t,std::allocator< size_t > >

        load(self, data)

        Parameters
        ----------
        data: size_t const *

        """
        return _dnnc.uLongTensor_load(self, *args)


    def to_string(self, max_el=30):
        """
        to_string(self, max_el=30) -> std::string

        Parameters
        ----------
        max_el: size_t const

        to_string(self) -> std::string

        Parameters
        ----------
        self: dnnc::tensor< size_t > const *

        """
        return _dnnc.uLongTensor_to_string(self, max_el)


    def data(self):
        """
        data(self) -> vectorSizeT

        Parameters
        ----------
        self: dnnc::tensor< size_t > const *

        """
        return _dnnc.uLongTensor_data(self)


    def reshape(self, *args):
      """
        reshape tensor to a new shape permitting same length of old and new shape.
      """
      new_shape = []
      for arg in args:
        if isinstance(arg, int):
          new_shape.append(arg)
        else:
          return _dnnc.uLongTensor_reshape (self, vectorSizeT(arg))

      if len(new_shape):
        return _dnnc.uLongTensor_reshape (self, vectorSizeT(new_shape))

      return _dnnc.uLongTensor_reshape (args)



    def flatten(self):
        """
        flatten(self) -> uLongTensor

        Parameters
        ----------
        self: dnnc::tensor< size_t > *

        """
        return _dnnc.uLongTensor_flatten(self)


    def isnull(self):
        """
        isnull(self) -> bool

        Parameters
        ----------
        self: dnnc::tensor< size_t > const *

        """
        return _dnnc.uLongTensor_isnull(self)


    def transpose(self):
        """
        transpose(self)

        Parameters
        ----------
        self: dnnc::tensor< size_t > *

        """
        return _dnnc.uLongTensor_transpose(self)


    def __call__(self, *args):
        """
        __call__(self, indices) -> size_t

        Parameters
        ----------
        indices: std::vector< dnnc::INDEX,std::allocator< dnnc::INDEX > > &

        __call__(self, x=0, y=0, z=0, w=0, u=0) -> size_t

        Parameters
        ----------
        x: dnnc::INDEX const
        y: dnnc::INDEX const
        z: dnnc::INDEX const
        w: dnnc::INDEX const
        u: dnnc::INDEX const

        __call__(self, x=0, y=0, z=0, w=0) -> size_t

        Parameters
        ----------
        x: dnnc::INDEX const
        y: dnnc::INDEX const
        z: dnnc::INDEX const
        w: dnnc::INDEX const

        __call__(self, x=0, y=0, z=0) -> size_t

        Parameters
        ----------
        x: dnnc::INDEX const
        y: dnnc::INDEX const
        z: dnnc::INDEX const

        __call__(self, x=0, y=0) -> size_t

        Parameters
        ----------
        x: dnnc::INDEX const
        y: dnnc::INDEX const

        __call__(self, x=0) -> size_t

        Parameters
        ----------
        x: dnnc::INDEX const

        __call__(self) -> size_t &

        Parameters
        ----------
        self: dnnc::tensor< size_t > const *

        """
        return _dnnc.uLongTensor___call__(self, *args)


    def empty(self):
        """
        empty(self) -> bool

        Parameters
        ----------
        self: dnnc::tensor< size_t > *

        """
        return _dnnc.uLongTensor_empty(self)


    def dtype(self):
        """
        dtype(self) -> std::string

        Parameters
        ----------
        self: dnnc::tensor< size_t > *

        """
        return _dnnc.uLongTensor_dtype(self)


    def to_proto(self):
        """
        to_proto(self) -> std::string

        Parameters
        ----------
        self: dnnc::tensor< size_t > *

        """
        return _dnnc.uLongTensor_to_proto(self)


    def min(self):
        """
        min(self) -> size_t

        Parameters
        ----------
        self: dnnc::tensor< size_t > const *

        """
        return _dnnc.uLongTensor_min(self)


    def max(self):
        """
        max(self) -> size_t

        Parameters
        ----------
        self: dnnc::tensor< size_t > const *

        """
        return _dnnc.uLongTensor_max(self)


    def sum(self):
        """
        sum(self) -> size_t

        Parameters
        ----------
        self: dnnc::tensor< size_t > const *

        """
        return _dnnc.uLongTensor_sum(self)


    def __getitem__(self, indices):
        """
        __getitem__(self, indices) -> size_t const &

        Parameters
        ----------
        indices: PyObject *

        """
        return _dnnc.uLongTensor___getitem__(self, indices)


    def __setitem__(self, indices, data):
        """
        __setitem__(self, indices, data)

        Parameters
        ----------
        indices: PyObject *
        data: size_t const &

        """
        return _dnnc.uLongTensor___setitem__(self, indices, data)


    def __str__(self):
        """
        __str__(self) -> std::string

        Parameters
        ----------
        self: dnnc::tensor< size_t > *

        """
        return _dnnc.uLongTensor___str__(self)


    def __repr__(self):
        """
        __repr__(self) -> std::string

        Parameters
        ----------
        self: dnnc::tensor< size_t > *

        """
        return _dnnc.uLongTensor___repr__(self)


    def __neg__(self):
        """
        __neg__(self) -> uLongTensor

        Parameters
        ----------
        self: dnnc::tensor< size_t > *

        """
        return _dnnc.uLongTensor___neg__(self)


    def __pos__(self):
        """
        __pos__(self) -> uLongTensor

        Parameters
        ----------
        self: dnnc::tensor< size_t > *

        """
        return _dnnc.uLongTensor___pos__(self)


    def __abs__(self):
        """
        __abs__(self) -> uLongTensor

        Parameters
        ----------
        self: dnnc::tensor< size_t > *

        """
        return _dnnc.uLongTensor___abs__(self)


    def __invert__(self):
        """
        __invert__(self) -> boolTensor

        Parameters
        ----------
        self: dnnc::tensor< size_t > *

        """
        return _dnnc.uLongTensor___invert__(self)


    def __lshift__(self, *args):
        """
        __lshift__(self, other) -> intTensor

        Parameters
        ----------
        other: dnnc::tensor< int > &

        __lshift__(self, scalar) -> intTensor

        Parameters
        ----------
        scalar: int

        """
        return _dnnc.uLongTensor___lshift__(self, *args)


    def __ilshift__(self, *args):
        """
        __ilshift__(self, other) -> intTensor

        Parameters
        ----------
        other: dnnc::tensor< int > &

        __ilshift__(self, scalar) -> intTensor

        Parameters
        ----------
        scalar: int

        """
        return _dnnc.uLongTensor___ilshift__(self, *args)


    def __rshift__(self, *args):
        """
        __rshift__(self, other) -> intTensor

        Parameters
        ----------
        other: dnnc::tensor< int > &

        __rshift__(self, scalar) -> intTensor

        Parameters
        ----------
        scalar: int

        """
        return _dnnc.uLongTensor___rshift__(self, *args)


    def __irshift__(self, *args):
        """
        __irshift__(self, other) -> intTensor

        Parameters
        ----------
        other: dnnc::tensor< int > &

        __irshift__(self, scalar) -> intTensor

        Parameters
        ----------
        scalar: int

        """
        return _dnnc.uLongTensor___irshift__(self, *args)




    def __getitem__(self, index):
      """
         getitem method for tensor.
      """
      def get_item_helper_int(item, axis):
        flag = 0
        start = item
        if (start < 0):
          start += self.shape()[axis]
        stop = start+1
        step = 1
        if(start >= self.shape()[axis]):
          errorMsg = "index value " + str(start) + " along axis " + str(axis) + " is beyond the size " + str(self.shape()[axis]) + " of input tensor along that axis"
          raise ValueError(errorMsg)
          flag = 1
        return start, stop, step, flag

      def get_item_helper_slice(item, axis):
        flag = 0   # to check if all index items are supported or not
        start = 0
        stop = self.shape()[axis]
        step = 1
        if type(item.step) == int:
          step = item.step
          if step == 0:
            errorMsg = "slice step cannot be zero"
            raise TypeError(errorMsg)
            flag = 1
          elif step < 0:
            start = self.shape()[axis] -1
            stop = -1
        elif str(type(item.step)).split("'")[1] == "NoneType":
          pass
        else:
          errorMsg = "step of " + str(type(item.step)) + " not supported!"
          raise TypeError(errorMsg)
          flag = 1
        if type(item.start) == int:
          start = item.start
          if (start < 0):
            start += self.shape()[axis]
        elif str(type(item.start)).split("'")[1] == "NoneType":
          pass
        else:
          errorMsg = "start of " + str(type(item.start)) + " not supported!"
          raise TypeError(errorMsg)
          flag = 1
        if type(item.stop) == int:
          stop = item.stop
          if (stop < 0):
            stop += self.shape()[axis]
        elif str(type(item.stop)).split("'")[1] == "NoneType":
          pass
        else:
          errorMsg = "stop of " + str(type(item.stop)) + " not supported!"
          raise TypeError(errorMsg)
          flag = 1
    # if(start > self.shape()[axis]):
    #   errorMsg = "index value " + str(start) + " along axis " + str(axis) + " is beyond the size " + str(self.shape()[axis]) + " of input tensor along that axis"
    #   raise IndexError(errorMsg)
    #   flag = 1
    # if(stop > self.shape()[axis]):
    #   errorMsg = "index value " + str(stop) + " along axis " + str(axis) + " is beyond the size " + str(self.shape()[axis]) + " of input tensor along that axis"
    #   raise IndexError(errorMsg)
    #   flag = 1
    # if (step < 0) and not (start > stop):
    #   errorMsg = "stop index " + str(stop) + " along axis " + str(axis) + " is greater than start index " + str(start) + " while step is negative"
    #   raise IndexError(errorMsg)
    #   flag = 1
    # elif (step > 0) and not (start < stop):
    #   errorMsg = "stop index " + str(stop) + " along axis " + str(axis) + " is smaller than start index " + str(start) + " while step is positive"
    #   raise IndexError(errorMsg)
    #   flag = 1

        return start, stop, step, flag

      if str(type(index)).split("'")[1] == "int":
        if self.rank() < 1:
          return self.copy()
        axis = 0
        start, stop, step, flag = get_item_helper_int(index, axis)
        if flag:
          return
        start = array([start]).asTypeInt()
        stop = array([stop]).asTypeInt()
        axis = array([axis]).asTypeInt()
        step = array([step]).asTypeInt()
        if (self.rank() == 1):
          return self.data()[index]
        return slice(self, start, stop, axis, step).reshape(self.shape()[1:])

      elif str(type(index)).split("'")[1] == "slice":
        if self.rank() < 1:
          return self.copy()
        axis = 0
        start, stop, step, flag = get_item_helper_slice(index, axis)
        if flag:
          return
        start = array([start]).asTypeInt()
        stop = array([stop]).asTypeInt()
        axis = array([axis]).asTypeInt()
        step = array([step]).asTypeInt()
        return slice(self, start, stop, axis, step)

      elif str(type(index)).split("'")[1] == "ellipsis":
        return self.copy()

      elif str(type(index)).split("'")[1] == "tuple":
        if (len(index) > self.rank()):
          errorMsg = "Takes maximum " + str(self.rank()) + " arguments, " + str(len(index)) + " were given!"
          raise IndexError(errorMsg)
          return
    # elif Ellipsis not in index and (len(index) < self.rank()):
    #   errorMsg = "Takes minimum " + str(self.rank()) + " arguments, " + str(len(index)) + " were given!"
    #   raise IndexError(errorMsg)
    #   return

    # checks if any float or bool or complex is not present
        if any(isinstance(x,(bool,float,complex)) for x in index):
          errorMsg = "Restrict to only integers as a slicing argument!"
          raise ValueError(errorMsg)
          return

        start_list = []
        stop_list = []
        step_list = []
        axis_list = []
        axis = -1   # -1 for starting axis as 0 in the next loops
        reshape_list = []   # reshape list to reshape
        replace_start = replace_stop = 0   # replace ellipsis with slice methods by index

        if Ellipsis in index:
          if (index.count(Ellipsis) > 1):
            errorMsg = str(index.count(Ellipsis)) + " 'Ellipsis' found, maximum 1 is supported!"
            raise IndexError(errorMsg)
            return
          elif (index.count(Ellipsis) == 1):
            non_ellipsis_count = 0
            for item in index:
              if str(type(item)).split("'")[1] == "int" or str(type(item)).split("'")[1] == "slice":
                non_ellipsis_count += 1
    # replace holds start and stop index which will be replaced by slice method in place of ellipsis
            replace_start = index.index(Ellipsis)
            replace_stop = replace_start + self.rank() - non_ellipsis_count
          else:
            errorMsg = "Error occured while handling ellipsis!"
            raise ValueError(errorMsg)
            return

        for item in index:
          axis += 1
          if str(type(item)).split("'")[1] == "ellipsis":
            while (axis >= replace_start and axis < replace_stop):
              start = 0
              stop = self.shape()[axis]
              step = 1
              start_list.append(start)
              stop_list.append(stop)
              step_list.append(step)
              axis_list.append(axis)
              reshape_list.append(1)  # This shape will be taken
              axis += 1
            axis -= 1   # recovering from last axis increment
          elif str(type(item)).split("'")[1] == "int":
            start, stop, step, flag = get_item_helper_int(item, axis)
            if flag:
              return
            start_list.append(start)
            stop_list.append(stop)
            step_list.append(step)
            axis_list.append(axis)
            reshape_list.append(0)  # This shape will not be taken
          elif str(type(item)).split("'")[1] == "slice":
            start, stop, step, flag = get_item_helper_slice(item, axis)
            if flag:
              return
            start_list.append(start)
            stop_list.append(stop)
            step_list.append(step)
            axis_list.append(axis)
            reshape_list.append(1)  # This shape will be taken
          else:
            errorMsg = "Doesn't support " + str(item) + " of " + str(type(item)) + " as a slicing argument!"
            raise TypeError(errorMsg)
            return

        while (axis < self.rank()-1):
          axis += 1
          start = 0
          stop = self.shape()[axis]
          step = 1
          start_list.append(start)
          stop_list.append(stop)
          step_list.append(step)
          axis_list.append(axis)
          reshape_list.append(1)  # This shape will be taken

        start_list = array(start_list).asTypeInt()
        stop_list = array(stop_list).asTypeInt()
        axis_list = array(axis_list).asTypeInt()
        step_list = array(step_list).asTypeInt()

    # print("test start list :  ", start_list)
    # print("test stop list :  ", stop_list)
    # print("test axis list :  ", axis_list)
    # print("test step list :  ", step_list)

        result = slice(self, start_list, stop_list, axis_list, step_list)

        if (result.len() != 0) and (0 in reshape_list):
          if not 1 in reshape_list:
            return result.data()[0]
          return (result.reshape([x for x, y in zip(result.shape(), reshape_list) if y == 1]))

        return result

      else :
        errorMsg = "Doesn't support " + str(index) + " of " + str(type(index)) + " as a slicing argument!"
        raise TypeError(errorMsg)

      return intTensor()



    def __setitem__(self, index, input_tensor):
      """
         setitem method for tensor.
      """

      value_tensor = ""
      if "Tensor" not in str(type(input_tensor)).split("'")[1]:
        if str(type(input_tensor)).split("'")[1] in ("int", "float", "bool"):
          value_tensor = array([input_tensor])  # passing single number as tensor of length 1
        elif str(type(input_tensor)).split("'")[1] in ("list", "tuple"):
          value_tensor = array(input_tensor)  # passing python lists or tuples as tensor
        else:
          errorMsg = "could not convert " + str(input_tensor) + " of type " + str(type(input_tensor)) + " to dnnc tensor"
          raise ValueError(errorMsg)
          return
      else:
          value_tensor = input_tensor

      def set_item_helper_int(item, axis):
        flag = 0
        start = item
        if (start < 0):
          start += self.shape()[axis]
        stop = start+1
        step = 1
        if(start >= self.shape()[axis]):
          errorMsg = "index value " + str(start) + " along axis " + str(axis) + " is beyond the size " + str(self.shape()[axis]) + " of input tensor along that axis"
          raise ValueError(errorMsg)
          flag = 1
        return start, stop, step, flag

      def set_item_helper_slice(item, axis):
        flag = 0   # to check if all index items are supported or not
        start = 0
        stop = self.shape()[axis]
        step = 1
        if type(item.step) == int:
          step = item.step
          if step == 0:
            errorMsg = "slice step cannot be zero"
            raise TypeError(errorMsg)
            flag = 1
          elif step < 0:
            start = self.shape()[axis] -1
            stop = -1
        elif str(type(item.step)).split("'")[1] == "NoneType":
          pass
        else:
          errorMsg = "step of " + str(type(item.step)) + " not supported!"
          raise TypeError(errorMsg)
          flag = 1
        if type(item.start) == int:
          start = item.start
          if (start < 0):
            start += self.shape()[axis]
        elif str(type(item.start)).split("'")[1] == "NoneType":
          pass
        else:
          errorMsg = "start of " + str(type(item.start)) + " not supported!"
          raise TypeError(errorMsg)
          flag = 1
        if type(item.stop) == int:
          stop = item.stop
          if (stop < 0):
            stop += self.shape()[axis]
        elif str(type(item.stop)).split("'")[1] == "NoneType":
          pass
        else:
          errorMsg = "stop of " + str(type(item.stop)) + " not supported!"
          raise TypeError(errorMsg)
          flag = 1
    # if(start > self.shape()[axis]):
    #   errorMsg = "index value " + str(start) + " along axis " + str(axis) + " is beyond the size " + str(self.shape()[axis]) + " of input tensor along that axis"
    #   raise IndexError(errorMsg)
    #   flag = 1
    # if(stop > self.shape()[axis]):
    #   errorMsg = "index value " + str(stop) + " along axis " + str(axis) + " is beyond the size " + str(self.shape()[axis]) + " of input tensor along that axis"
    #   raise IndexError(errorMsg)
    #   flag = 1
    # if (step < 0) and not (start > stop):
    #   errorMsg = "stop index " + str(stop) + " along axis " + str(axis) + " is greater than start index " + str(start) + " while step is negative"
    #   raise IndexError(errorMsg)
    #   flag = 1
    # elif (step > 0) and not (start < stop):
    #   errorMsg = "stop index " + str(stop) + " along axis " + str(axis) + " is smaller than start index " + str(start) + " while step is positive"
    #   raise IndexError(errorMsg)
    #   flag = 1

        return start, stop, step, flag

      if str(type(index)).split("'")[1] == "int":
        if self.rank() < 1:
          errorMsg = "cannot set items to a null tensor"
          raise TypeError(errorMsg)
          return
        axis = 0
        start, stop, step, flag = set_item_helper_int(index, axis)
        if flag:
          return
        start = array([start]).asTypeInt()
        stop = array([stop]).asTypeInt()
        axis = array([axis]).asTypeInt()
        step = array([step]).asTypeInt()

        set_slice(self, value_tensor, start, stop, axis, step)
        return

      elif str(type(index)).split("'")[1] == "slice":
        if self.rank() < 1:
          self = value_tensor
          return
        axis = 0
        start, stop, step, flag = set_item_helper_slice(index, axis)
        if flag:
          return
        start = array([start]).asTypeInt()
        stop = array([stop]).asTypeInt()
        axis = array([axis]).asTypeInt()
        step = array([step]).asTypeInt()

        set_slice(self, value_tensor, start, stop, axis, step)
        return

      elif str(type(index)).split("'")[1] == "ellipsis":
        if self.shape() != value_tensor.shape():
          errorMsg = "could not broadcast input array from shape "+str(value_tensor.shape())+" into shape "+str(self.shape())
          raise ValueError(errorMsg)
          return
        elif (self.rank() < 1) or (self.shape() == value_tensor.shape()):
          self = value_tensor
          return

      elif str(type(index)).split("'")[1] == "tuple":
        if (len(index) > self.rank()):
          errorMsg = "Takes maximum " + str(self.rank()) + " arguments, " + str(len(index)) + " were given!"
          raise IndexError(errorMsg)
          return
    # elif Ellipsis not in index and (len(index) < self.rank()):
    #   errorMsg = "Takes minimum " + str(self.rank()) + " arguments, " + str(len(index)) + " were given!"
    #   raise IndexError(errorMsg)
    #   return

    # checks if any float or bool or complex is not present
        if any(isinstance(x,(bool,float,complex)) for x in index):
          errorMsg = "Restrict to only integers as a slicing argument!"
          raise ValueError(errorMsg)
          return

        start_list = []
        stop_list = []
        step_list = []
        axis_list = []
        axis = -1   # -1 for starting axis as 0 in the next loops
        replace_start = replace_stop = 0   # replace ellipsis with slice methods by index

        if Ellipsis in index:
          if (index.count(Ellipsis) > 1):
            errorMsg = str(index.count(Ellipsis)) + " 'Ellipsis' found, maximum 1 is supported!"
            raise IndexError(errorMsg)
            return
          elif (index.count(Ellipsis) == 1):
            non_ellipsis_count = 0
            for item in index:
              if str(type(item)).split("'")[1] == "int" or str(type(item)).split("'")[1] == "slice":
                non_ellipsis_count += 1
    # replace holds start and stop index which will be replaced by slice method in place of ellipsis
            replace_start = index.index(Ellipsis)
            replace_stop = replace_start + self.rank() - non_ellipsis_count
          else:
            errorMsg = "Error occured while handling ellipsis!"
            raise ValueError(errorMsg)
            return

        for item in index:
          axis += 1
          if str(type(item)).split("'")[1] == "ellipsis":
            while (axis >= replace_start and axis < replace_stop):
              start = 0
              stop = self.shape()[axis]
              step = 1
              start_list.append(start)
              stop_list.append(stop)
              step_list.append(step)
              axis_list.append(axis)
              axis += 1
            axis -= 1   # recovering from last axis increment
          elif str(type(item)).split("'")[1] == "int":
            start, stop, step, flag = set_item_helper_int(item, axis)
            if flag:
              return
            start_list.append(start)
            stop_list.append(stop)
            step_list.append(step)
            axis_list.append(axis)
          elif str(type(item)).split("'")[1] == "slice":
            start, stop, step, flag = set_item_helper_slice(item, axis)
            if flag:
              return
            start_list.append(start)
            stop_list.append(stop)
            step_list.append(step)
            axis_list.append(axis)
          else:
            errorMsg = "Doesn't support " + str(item) + " of " + str(type(item)) + " as a slicing argument!"
            raise TypeError(errorMsg)
            return

        while (axis < self.rank()-1):
          axis += 1
          start = 0
          stop = self.shape()[axis]
          step = 1
          start_list.append(start)
          stop_list.append(stop)
          step_list.append(step)
          axis_list.append(axis)

        start_list = array(start_list).asTypeInt()
        stop_list = array(stop_list).asTypeInt()
        axis_list = array(axis_list).asTypeInt()
        step_list = array(step_list).asTypeInt()

    # print("test start list :  ", start_list)
    # print("test stop list :  ", stop_list)
    # print("test axis list :  ", axis_list)
    # print("test step list :  ", step_list)

        set_slice(self, value_tensor, start_list, stop_list, axis_list, step_list)
        return
      else :
        errorMsg = "Doesn't support " + str(index) + " of " + str(type(index)) + " as a slicing argument!"
        raise TypeError(errorMsg)

      return


    def __add__(self, other):
      return add(self, other)

    def __radd__(self, other):
      return add(other, self)

    def __iadd__(self, other):
      """
        making sure left hand operand is immutable
      """
      dtype_precedence_dict = {'double': 16, 'float': 14, 'size_t': 12, 'long': 10, 'int': 8, 'short': 6, 'bool': 4, 'char': 2}
      left_operand_dtype = right_operand_dtype = ""
      if "Tensor" in str(type(self)):
        left_operand_dtype = str(type(self)).split(".")[-1].split("Tensor")[0]
      else:
        left_operand_dtype = str(type(self)).split("'")[1]
      if "Tensor" in str(type(other)):
        right_operand_dtype = str(type(other)).split(".")[-1].split("Tensor")[0]
      else:
        right_operand_dtype = str(type(other)).split("'")[1]
      if (dtype_precedence_dict[left_operand_dtype] < dtype_precedence_dict[right_operand_dtype]):
        errorMsg = "cannot modify left hand operand datatype."
        raise TypeError(errorMsg)
      return add(self, other)

    def __sub__(self, other):
      return sub(self, other)

    def __rsub__(self, other):
      return sub(other, self)

    def __isub__(self, other):
      """
        making sure left hand operand is immutable
      """
      dtype_precedence_dict = {'double': 16, 'float': 14, 'size_t': 12, 'long': 10, 'int': 8, 'short': 6, 'bool': 4, 'char': 2}
      left_operand_dtype = right_operand_dtype = ""
      if "Tensor" in str(type(self)):
        left_operand_dtype = str(type(self)).split(".")[-1].split("Tensor")[0]
      else:
        left_operand_dtype = str(type(self)).split("'")[1]
      if "Tensor" in str(type(other)):
        right_operand_dtype = str(type(other)).split(".")[-1].split("Tensor")[0]
      else:
        right_operand_dtype = str(type(other)).split("'")[1]
      if (dtype_precedence_dict[left_operand_dtype] < dtype_precedence_dict[right_operand_dtype]):
        errorMsg = "cannot modify left hand operand datatype."
        raise TypeError(errorMsg)
      return sub(self, other)

    def __mul__(self, other):
      return mul(self, other)

    def __rmul__(self, other):
      return mul(other, self)

    def __imul__(self, other):
      """
        making sure left hand operand is immutable
      """
      dtype_precedence_dict = {'double': 16, 'float': 14, 'size_t': 12, 'long': 10, 'int': 8, 'short': 6, 'bool': 4, 'char': 2}
      left_operand_dtype = right_operand_dtype = ""
      if "Tensor" in str(type(self)):
        left_operand_dtype = str(type(self)).split(".")[-1].split("Tensor")[0]
      else:
        left_operand_dtype = str(type(self)).split("'")[1]
      if "Tensor" in str(type(other)):
        right_operand_dtype = str(type(other)).split(".")[-1].split("Tensor")[0]
      else:
        right_operand_dtype = str(type(other)).split("'")[1]
      if (dtype_precedence_dict[left_operand_dtype] < dtype_precedence_dict[right_operand_dtype]):
        errorMsg = "cannot modify left hand operand datatype."
        raise TypeError(errorMsg)
      return mul(self, other)

    def __floordiv__(self, other):
      return floor_div(self, other)

    def __rfloordiv__(self, other):
      return floor_div(other, self)

    def __ifloordiv__(self, other):
      """
        making sure left hand operand is immutable
      """
      dtype_precedence_dict = {'double': 16, 'float': 14, 'size_t': 12, 'long': 10, 'int': 8, 'short': 6, 'bool': 4, 'char': 2}
      left_operand_dtype = right_operand_dtype = ""
      if "Tensor" in str(type(self)):
        left_operand_dtype = str(type(self)).split(".")[-1].split("Tensor")[0]
      else:
        left_operand_dtype = str(type(self)).split("'")[1]
      if "Tensor" in str(type(other)):
        right_operand_dtype = str(type(other)).split(".")[-1].split("Tensor")[0]
      else:
        right_operand_dtype = str(type(other)).split("'")[1]
      if (dtype_precedence_dict[left_operand_dtype] < dtype_precedence_dict[right_operand_dtype]):
        errorMsg = "cannot modify left hand operand datatype."
        raise TypeError(errorMsg)
      return floor_div(self, other)

    def __truediv__(self, other):
      return true_div(self, other)

    def __rtruediv__(self, other):
      return true_div(other, self)

    def __itruediv__(self, other):
      """
        making sure left hand operand is immutable
      """
      dtype_precedence_dict = {'double': 16, 'float': 14, 'size_t': 12, 'long': 10, 'int': 8, 'short': 6, 'bool': 4, 'char': 2}
      left_operand_dtype = right_operand_dtype = ""
      if "Tensor" in str(type(self)):
        left_operand_dtype = str(type(self)).split(".")[-1].split("Tensor")[0]
      else:
        left_operand_dtype = str(type(self)).split("'")[1]
      if "Tensor" in str(type(other)):
        right_operand_dtype = str(type(other)).split(".")[-1].split("Tensor")[0]
      else:
        right_operand_dtype = str(type(other)).split("'")[1]
      if (dtype_precedence_dict[left_operand_dtype] < dtype_precedence_dict[right_operand_dtype]):
        errorMsg = "cannot modify left hand operand datatype."
        raise TypeError(errorMsg)
      return true_div(self, other)

    def __mod__(self, other):
      return remainder(self, other)

    def __rmod__(self, other):
      return remainder(other, self)

    def __imod__(self, other):
      """
        making sure left hand operand is immutable
      """
      dtype_precedence_dict = {'double': 16, 'float': 14, 'size_t': 12, 'long': 10, 'int': 8, 'short': 6, 'bool': 4, 'char': 2}
      left_operand_dtype = right_operand_dtype = ""
      if "Tensor" in str(type(self)):
        left_operand_dtype = str(type(self)).split(".")[-1].split("Tensor")[0]
      else:
        left_operand_dtype = str(type(self)).split("'")[1]
      if "Tensor" in str(type(other)):
        right_operand_dtype = str(type(other)).split(".")[-1].split("Tensor")[0]
      else:
        right_operand_dtype = str(type(other)).split("'")[1]
      if (dtype_precedence_dict[left_operand_dtype] < dtype_precedence_dict[right_operand_dtype]):
        errorMsg = "cannot modify left hand operand datatype."
        raise TypeError(errorMsg)
      return remainder(self, other)

    def __pow__(self, other):
      return power(self, other)

    def __rpow__(self, other):
      return power(other, self)

    def __ipow__(self, other):
      """
        making sure left hand operand is immutable
      """
      dtype_precedence_dict = {'double': 16, 'float': 14, 'size_t': 12, 'long': 10, 'int': 8, 'short': 6, 'bool': 4, 'char': 2}
      left_operand_dtype = right_operand_dtype = ""
      if "Tensor" in str(type(self)):
        left_operand_dtype = str(type(self)).split(".")[-1].split("Tensor")[0]
      else:
        left_operand_dtype = str(type(self)).split("'")[1]
      if "Tensor" in str(type(other)):
        right_operand_dtype = str(type(other)).split(".")[-1].split("Tensor")[0]
      else:
        right_operand_dtype = str(type(other)).split("'")[1]
      if (dtype_precedence_dict[left_operand_dtype] < dtype_precedence_dict[right_operand_dtype]):
        errorMsg = "cannot modify left hand operand datatype."
        raise TypeError(errorMsg)
      return power(self, other)

    def __and__(self, other):
      return bitwise_and(self, other)

    def __rand__(self, other):
      return bitwise_and(other, self)

    def __iand__(self, other):
      """
        making sure left hand operand is immutable
      """
      dtype_precedence_dict = {'double': 16, 'float': 14, 'size_t': 12, 'long': 10, 'int': 8, 'short': 6, 'bool': 4, 'char': 2}
      left_operand_dtype = right_operand_dtype = ""
      if "Tensor" in str(type(self)):
        left_operand_dtype = str(type(self)).split(".")[-1].split("Tensor")[0]
      else:
        left_operand_dtype = str(type(self)).split("'")[1]
      if "Tensor" in str(type(other)):
        right_operand_dtype = str(type(other)).split(".")[-1].split("Tensor")[0]
      else:
        right_operand_dtype = str(type(other)).split("'")[1]
      if (dtype_precedence_dict[left_operand_dtype] < dtype_precedence_dict[right_operand_dtype]):
        errorMsg = "cannot modify left hand operand datatype."
        raise TypeError(errorMsg)
      return bitwise_and(self, other)

    def __or__(self, other):
      return bitwise_or(self, other)

    def __ror__(self, other):
      return bitwise_or(other, self)

    def __ior__(self, other):
      """
        making sure left hand operand is immutable
      """
      dtype_precedence_dict = {'double': 16, 'float': 14, 'size_t': 12, 'long': 10, 'int': 8, 'short': 6, 'bool': 4, 'char': 2}
      left_operand_dtype = right_operand_dtype = ""
      if "Tensor" in str(type(self)):
        left_operand_dtype = str(type(self)).split(".")[-1].split("Tensor")[0]
      else:
        left_operand_dtype = str(type(self)).split("'")[1]
      if "Tensor" in str(type(other)):
        right_operand_dtype = str(type(other)).split(".")[-1].split("Tensor")[0]
      else:
        right_operand_dtype = str(type(other)).split("'")[1]
      if (dtype_precedence_dict[left_operand_dtype] < dtype_precedence_dict[right_operand_dtype]):
        errorMsg = "cannot modify left hand operand datatype."
        raise TypeError(errorMsg)
      return bitwise_or(self, other)

    def __xor__(self, other):
      return bitwise_xor(self, other)

    def __rxor__(self, other):
      return bitwise_xor(other, self)

    def __ixor__(self, other):
      """
        making sure left hand operand is immutable
      """
      dtype_precedence_dict = {'double': 16, 'float': 14, 'size_t': 12, 'long': 10, 'int': 8, 'short': 6, 'bool': 4, 'char': 2}
      left_operand_dtype = right_operand_dtype = ""
      if "Tensor" in str(type(self)):
        left_operand_dtype = str(type(self)).split(".")[-1].split("Tensor")[0]
      else:
        left_operand_dtype = str(type(self)).split("'")[1]
      if "Tensor" in str(type(other)):
        right_operand_dtype = str(type(other)).split(".")[-1].split("Tensor")[0]
      else:
        right_operand_dtype = str(type(other)).split("'")[1]
      if (dtype_precedence_dict[left_operand_dtype] < dtype_precedence_dict[right_operand_dtype]):
        errorMsg = "cannot modify left hand operand datatype."
        raise TypeError(errorMsg)
      return bitwise_xor(self, other)

    def __eq__(self, other):
      return equal(self, other)

    def __lt__(self, other):
      return less(self, other)

    def __gt__(self, other):
      return greater(self, other)

    def __ne__(self, other):
      return not_equal(self, other)

    def __le__(self, other):
      return less_equal(self, other)

    def __ge__(self, other):
      return greater_equal(self, other)



    def numpy(self) :
      """
         convert tensor to numpy array.
      """
      import numpy as np
      if (self.len() == 0):    # this is a deepC tensor bug, this if statement is a bypass for testing
        return np.array(self.data())
      return np.array(self.data()).reshape(self.shape())

    def len(self):
      """
         return length of tensor.
      """
      return self.length()

    def __iter__(self):
      """
         iterates over the tensor.
      """
      axis = 0
      while (axis < self.shape()[0]):
        yield self[axis]
        axis += 1

    def __int__(self):
      """
         convert tensor to int tensor.
      """
      if (self.len() > 1):
        raise TypeError("only length-1 tensor can be converted to Python scalars")
      elif(self.len() == 0):
        return
      return self.asTypeInt()

    def __float__(self):
      """
         convert tensor to float tensor.
      """
      if (self.len() > 1):
        raise TypeError("only length-1 tensor can be converted to Python scalars")
      elif(self.len() == 0):
        return
      return self.asTypeFloat()

    def __bool__(self):
      """
         convert tensor to bool tensor.
      """
      if (self.len() > 1):
        raise ValueError("The truth value of an array with more than one element is ambiguous. Use dc.any() or dc.all()")
      elif(self.len() == 0):
        return False
      return self.asTypeBool()


uLongTensor_swigregister = _dnnc.uLongTensor_swigregister
uLongTensor_swigregister(uLongTensor)

class floatTensor(floatplaceHolder):
    """Proxy of C++ dnnc::tensor<(float)> class."""

    __swig_setmethods__ = {}
    for _s in [floatplaceHolder]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, floatTensor, name, value)
    __swig_getmethods__ = {}
    for _s in [floatplaceHolder]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, floatTensor, name)

    def __init__(self, *args):
        """
        __init__(self, dimn, n, fill, init_val=0) -> floatTensor

        Parameters
        ----------
        dimn: std::vector< dnnc::DIMENSION,std::allocator< dnnc::DIMENSION > >
        n: std::string
        fill: enum dnnc::INIT_TYPE
        init_val: float

        __init__(self, dimn, n, fill) -> floatTensor

        Parameters
        ----------
        dimn: std::vector< dnnc::DIMENSION,std::allocator< dnnc::DIMENSION > >
        n: std::string
        fill: enum dnnc::INIT_TYPE

        __init__(self, dimn, n) -> floatTensor

        Parameters
        ----------
        dimn: std::vector< dnnc::DIMENSION,std::allocator< dnnc::DIMENSION > >
        n: std::string

        __init__(self, dimn) -> floatTensor

        Parameters
        ----------
        dimn: std::vector< dnnc::DIMENSION,std::allocator< dnnc::DIMENSION > >

        __init__(self) -> floatTensor
        __init__(self, data, dimn, n) -> floatTensor

        Parameters
        ----------
        data: float *
        dimn: std::vector< dnnc::DIMENSION,std::allocator< dnnc::DIMENSION > >
        n: std::string

        __init__(self, data, dimn) -> floatTensor

        Parameters
        ----------
        data: float *
        dimn: std::vector< dnnc::DIMENSION,std::allocator< dnnc::DIMENSION > >

        __init__(self, other) -> floatTensor

        Parameters
        ----------
        other: dnnc::tensor< float > const &

        """
        this = _dnnc.new_floatTensor(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _dnnc.delete_floatTensor
    __del__ = lambda self: None

    def __nonzero__(self):
        return _dnnc.floatTensor___nonzero__(self)
    __bool__ = __nonzero__



    def copy(self):
        """
        copy(self) -> floatTensor

        Parameters
        ----------
        self: dnnc::tensor< float > const *

        """
        return _dnnc.floatTensor_copy(self)


    def negate(self):
        """
        negate(self) -> floatTensor

        Parameters
        ----------
        self: dnnc::tensor< float > const *

        """
        return _dnnc.floatTensor_negate(self)


    def absolute(self):
        """
        absolute(self) -> floatTensor

        Parameters
        ----------
        self: dnnc::tensor< float > const *

        """
        return _dnnc.floatTensor_absolute(self)


    def identifier(self):
        """
        identifier(self) -> size_t

        Parameters
        ----------
        self: dnnc::tensor< float > const *

        """
        return _dnnc.floatTensor_identifier(self)


    def sameas(self, other):
        """
        sameas(self, other) -> bool

        Parameters
        ----------
        other: dnnc::tensor< float > const &

        """
        return _dnnc.floatTensor_sameas(self, other)


    def asTypeDouble(self):
        """
        asTypeDouble(self) -> doubleTensor

        Parameters
        ----------
        self: dnnc::tensor< float > *

        """
        return _dnnc.floatTensor_asTypeDouble(self)


    def asTypeFloat(self):
        """
        asTypeFloat(self) -> floatTensor

        Parameters
        ----------
        self: dnnc::tensor< float > *

        """
        return _dnnc.floatTensor_asTypeFloat(self)


    def asTypeInt(self):
        """
        asTypeInt(self) -> intTensor

        Parameters
        ----------
        self: dnnc::tensor< float > *

        """
        return _dnnc.floatTensor_asTypeInt(self)


    def asTypeUint8(self):
        """
        asTypeUint8(self) -> dnnc::tensor< uint8_t >

        Parameters
        ----------
        self: dnnc::tensor< float > *

        """
        return _dnnc.floatTensor_asTypeUint8(self)


    def asTypeLong(self):
        """
        asTypeLong(self) -> dnnc::tensor< long >

        Parameters
        ----------
        self: dnnc::tensor< float > *

        """
        return _dnnc.floatTensor_asTypeLong(self)


    def asTypeULong(self):
        """
        asTypeULong(self) -> uLongTensor

        Parameters
        ----------
        self: dnnc::tensor< float > *

        """
        return _dnnc.floatTensor_asTypeULong(self)


    def asTypeBool(self):
        """
        asTypeBool(self) -> boolTensor

        Parameters
        ----------
        self: dnnc::tensor< float > *

        """
        return _dnnc.floatTensor_asTypeBool(self)


    def load(self, *args):
        """
        load(self, data, indices)

        Parameters
        ----------
        data: float const &
        indices: std::vector< size_t,std::allocator< size_t > >

        load(self, data, i, j=0, k=0, l=0, m=0)

        Parameters
        ----------
        data: float const &
        i: size_t
        j: size_t
        k: size_t
        l: size_t
        m: size_t

        load(self, data, i, j=0, k=0, l=0)

        Parameters
        ----------
        data: float const &
        i: size_t
        j: size_t
        k: size_t
        l: size_t

        load(self, data, i, j=0, k=0)

        Parameters
        ----------
        data: float const &
        i: size_t
        j: size_t
        k: size_t

        load(self, data, i, j=0)

        Parameters
        ----------
        data: float const &
        i: size_t
        j: size_t

        load(self, data, i)

        Parameters
        ----------
        data: float const &
        i: size_t

        load(self, data)

        Parameters
        ----------
        data: std::vector< float,std::allocator< float > >

        load(self, data)

        Parameters
        ----------
        data: float const *

        """
        return _dnnc.floatTensor_load(self, *args)


    def to_string(self, max_el=30):
        """
        to_string(self, max_el=30) -> std::string

        Parameters
        ----------
        max_el: size_t const

        to_string(self) -> std::string

        Parameters
        ----------
        self: dnnc::tensor< float > const *

        """
        return _dnnc.floatTensor_to_string(self, max_el)


    def data(self):
        """
        data(self) -> vectorFloat

        Parameters
        ----------
        self: dnnc::tensor< float > const *

        """
        return _dnnc.floatTensor_data(self)


    def reshape(self, *args):
      """
        reshape tensor to a new shape permitting same length of old and new shape.
      """
      new_shape = []
      for arg in args:
        if isinstance(arg, int):
          new_shape.append(arg)
        else:
          return _dnnc.floatTensor_reshape (self, vectorSizeT(arg))

      if len(new_shape):
        return _dnnc.floatTensor_reshape (self, vectorSizeT(new_shape))

      return _dnnc.floatTensor_reshape (args)



    def flatten(self):
        """
        flatten(self) -> floatTensor

        Parameters
        ----------
        self: dnnc::tensor< float > *

        """
        return _dnnc.floatTensor_flatten(self)


    def isnull(self):
        """
        isnull(self) -> bool

        Parameters
        ----------
        self: dnnc::tensor< float > const *

        """
        return _dnnc.floatTensor_isnull(self)


    def transpose(self):
        """
        transpose(self)

        Parameters
        ----------
        self: dnnc::tensor< float > *

        """
        return _dnnc.floatTensor_transpose(self)


    def __call__(self, *args):
        """
        __call__(self, indices) -> float

        Parameters
        ----------
        indices: std::vector< dnnc::INDEX,std::allocator< dnnc::INDEX > > &

        __call__(self, x=0, y=0, z=0, w=0, u=0) -> float

        Parameters
        ----------
        x: dnnc::INDEX const
        y: dnnc::INDEX const
        z: dnnc::INDEX const
        w: dnnc::INDEX const
        u: dnnc::INDEX const

        __call__(self, x=0, y=0, z=0, w=0) -> float

        Parameters
        ----------
        x: dnnc::INDEX const
        y: dnnc::INDEX const
        z: dnnc::INDEX const
        w: dnnc::INDEX const

        __call__(self, x=0, y=0, z=0) -> float

        Parameters
        ----------
        x: dnnc::INDEX const
        y: dnnc::INDEX const
        z: dnnc::INDEX const

        __call__(self, x=0, y=0) -> float

        Parameters
        ----------
        x: dnnc::INDEX const
        y: dnnc::INDEX const

        __call__(self, x=0) -> float

        Parameters
        ----------
        x: dnnc::INDEX const

        __call__(self) -> float &

        Parameters
        ----------
        self: dnnc::tensor< float > const *

        """
        return _dnnc.floatTensor___call__(self, *args)


    def empty(self):
        """
        empty(self) -> bool

        Parameters
        ----------
        self: dnnc::tensor< float > *

        """
        return _dnnc.floatTensor_empty(self)


    def dtype(self):
        """
        dtype(self) -> std::string

        Parameters
        ----------
        self: dnnc::tensor< float > *

        """
        return _dnnc.floatTensor_dtype(self)


    def to_proto(self):
        """
        to_proto(self) -> std::string

        Parameters
        ----------
        self: dnnc::tensor< float > *

        """
        return _dnnc.floatTensor_to_proto(self)


    def min(self):
        """
        min(self) -> float

        Parameters
        ----------
        self: dnnc::tensor< float > const *

        """
        return _dnnc.floatTensor_min(self)


    def max(self):
        """
        max(self) -> float

        Parameters
        ----------
        self: dnnc::tensor< float > const *

        """
        return _dnnc.floatTensor_max(self)


    def sum(self):
        """
        sum(self) -> float

        Parameters
        ----------
        self: dnnc::tensor< float > const *

        """
        return _dnnc.floatTensor_sum(self)


    def __getitem__(self, indices):
        """
        __getitem__(self, indices) -> float const &

        Parameters
        ----------
        indices: PyObject *

        """
        return _dnnc.floatTensor___getitem__(self, indices)


    def __setitem__(self, indices, data):
        """
        __setitem__(self, indices, data)

        Parameters
        ----------
        indices: PyObject *
        data: float const &

        """
        return _dnnc.floatTensor___setitem__(self, indices, data)


    def __str__(self):
        """
        __str__(self) -> std::string

        Parameters
        ----------
        self: dnnc::tensor< float > *

        """
        return _dnnc.floatTensor___str__(self)


    def __repr__(self):
        """
        __repr__(self) -> std::string

        Parameters
        ----------
        self: dnnc::tensor< float > *

        """
        return _dnnc.floatTensor___repr__(self)


    def __neg__(self):
        """
        __neg__(self) -> floatTensor

        Parameters
        ----------
        self: dnnc::tensor< float > *

        """
        return _dnnc.floatTensor___neg__(self)


    def __pos__(self):
        """
        __pos__(self) -> floatTensor

        Parameters
        ----------
        self: dnnc::tensor< float > *

        """
        return _dnnc.floatTensor___pos__(self)


    def __abs__(self):
        """
        __abs__(self) -> floatTensor

        Parameters
        ----------
        self: dnnc::tensor< float > *

        """
        return _dnnc.floatTensor___abs__(self)


    def __invert__(self):
        """
        __invert__(self) -> boolTensor

        Parameters
        ----------
        self: dnnc::tensor< float > *

        """
        return _dnnc.floatTensor___invert__(self)


    def __lshift__(self, *args):
        """
        __lshift__(self, other) -> intTensor

        Parameters
        ----------
        other: dnnc::tensor< int > &

        __lshift__(self, scalar) -> intTensor

        Parameters
        ----------
        scalar: int

        """
        return _dnnc.floatTensor___lshift__(self, *args)


    def __ilshift__(self, *args):
        """
        __ilshift__(self, other) -> intTensor

        Parameters
        ----------
        other: dnnc::tensor< int > &

        __ilshift__(self, scalar) -> intTensor

        Parameters
        ----------
        scalar: int

        """
        return _dnnc.floatTensor___ilshift__(self, *args)


    def __rshift__(self, *args):
        """
        __rshift__(self, other) -> intTensor

        Parameters
        ----------
        other: dnnc::tensor< int > &

        __rshift__(self, scalar) -> intTensor

        Parameters
        ----------
        scalar: int

        """
        return _dnnc.floatTensor___rshift__(self, *args)


    def __irshift__(self, *args):
        """
        __irshift__(self, other) -> intTensor

        Parameters
        ----------
        other: dnnc::tensor< int > &

        __irshift__(self, scalar) -> intTensor

        Parameters
        ----------
        scalar: int

        """
        return _dnnc.floatTensor___irshift__(self, *args)




    def __getitem__(self, index):
      """
         getitem method for tensor.
      """
      def get_item_helper_int(item, axis):
        flag = 0
        start = item
        if (start < 0):
          start += self.shape()[axis]
        stop = start+1
        step = 1
        if(start >= self.shape()[axis]):
          errorMsg = "index value " + str(start) + " along axis " + str(axis) + " is beyond the size " + str(self.shape()[axis]) + " of input tensor along that axis"
          raise ValueError(errorMsg)
          flag = 1
        return start, stop, step, flag

      def get_item_helper_slice(item, axis):
        flag = 0   # to check if all index items are supported or not
        start = 0
        stop = self.shape()[axis]
        step = 1
        if type(item.step) == int:
          step = item.step
          if step == 0:
            errorMsg = "slice step cannot be zero"
            raise TypeError(errorMsg)
            flag = 1
          elif step < 0:
            start = self.shape()[axis] -1
            stop = -1
        elif str(type(item.step)).split("'")[1] == "NoneType":
          pass
        else:
          errorMsg = "step of " + str(type(item.step)) + " not supported!"
          raise TypeError(errorMsg)
          flag = 1
        if type(item.start) == int:
          start = item.start
          if (start < 0):
            start += self.shape()[axis]
        elif str(type(item.start)).split("'")[1] == "NoneType":
          pass
        else:
          errorMsg = "start of " + str(type(item.start)) + " not supported!"
          raise TypeError(errorMsg)
          flag = 1
        if type(item.stop) == int:
          stop = item.stop
          if (stop < 0):
            stop += self.shape()[axis]
        elif str(type(item.stop)).split("'")[1] == "NoneType":
          pass
        else:
          errorMsg = "stop of " + str(type(item.stop)) + " not supported!"
          raise TypeError(errorMsg)
          flag = 1
    # if(start > self.shape()[axis]):
    #   errorMsg = "index value " + str(start) + " along axis " + str(axis) + " is beyond the size " + str(self.shape()[axis]) + " of input tensor along that axis"
    #   raise IndexError(errorMsg)
    #   flag = 1
    # if(stop > self.shape()[axis]):
    #   errorMsg = "index value " + str(stop) + " along axis " + str(axis) + " is beyond the size " + str(self.shape()[axis]) + " of input tensor along that axis"
    #   raise IndexError(errorMsg)
    #   flag = 1
    # if (step < 0) and not (start > stop):
    #   errorMsg = "stop index " + str(stop) + " along axis " + str(axis) + " is greater than start index " + str(start) + " while step is negative"
    #   raise IndexError(errorMsg)
    #   flag = 1
    # elif (step > 0) and not (start < stop):
    #   errorMsg = "stop index " + str(stop) + " along axis " + str(axis) + " is smaller than start index " + str(start) + " while step is positive"
    #   raise IndexError(errorMsg)
    #   flag = 1

        return start, stop, step, flag

      if str(type(index)).split("'")[1] == "int":
        if self.rank() < 1:
          return self.copy()
        axis = 0
        start, stop, step, flag = get_item_helper_int(index, axis)
        if flag:
          return
        start = array([start]).asTypeInt()
        stop = array([stop]).asTypeInt()
        axis = array([axis]).asTypeInt()
        step = array([step]).asTypeInt()
        if (self.rank() == 1):
          return self.data()[index]
        return slice(self, start, stop, axis, step).reshape(self.shape()[1:])

      elif str(type(index)).split("'")[1] == "slice":
        if self.rank() < 1:
          return self.copy()
        axis = 0
        start, stop, step, flag = get_item_helper_slice(index, axis)
        if flag:
          return
        start = array([start]).asTypeInt()
        stop = array([stop]).asTypeInt()
        axis = array([axis]).asTypeInt()
        step = array([step]).asTypeInt()
        return slice(self, start, stop, axis, step)

      elif str(type(index)).split("'")[1] == "ellipsis":
        return self.copy()

      elif str(type(index)).split("'")[1] == "tuple":
        if (len(index) > self.rank()):
          errorMsg = "Takes maximum " + str(self.rank()) + " arguments, " + str(len(index)) + " were given!"
          raise IndexError(errorMsg)
          return
    # elif Ellipsis not in index and (len(index) < self.rank()):
    #   errorMsg = "Takes minimum " + str(self.rank()) + " arguments, " + str(len(index)) + " were given!"
    #   raise IndexError(errorMsg)
    #   return

    # checks if any float or bool or complex is not present
        if any(isinstance(x,(bool,float,complex)) for x in index):
          errorMsg = "Restrict to only integers as a slicing argument!"
          raise ValueError(errorMsg)
          return

        start_list = []
        stop_list = []
        step_list = []
        axis_list = []
        axis = -1   # -1 for starting axis as 0 in the next loops
        reshape_list = []   # reshape list to reshape
        replace_start = replace_stop = 0   # replace ellipsis with slice methods by index

        if Ellipsis in index:
          if (index.count(Ellipsis) > 1):
            errorMsg = str(index.count(Ellipsis)) + " 'Ellipsis' found, maximum 1 is supported!"
            raise IndexError(errorMsg)
            return
          elif (index.count(Ellipsis) == 1):
            non_ellipsis_count = 0
            for item in index:
              if str(type(item)).split("'")[1] == "int" or str(type(item)).split("'")[1] == "slice":
                non_ellipsis_count += 1
    # replace holds start and stop index which will be replaced by slice method in place of ellipsis
            replace_start = index.index(Ellipsis)
            replace_stop = replace_start + self.rank() - non_ellipsis_count
          else:
            errorMsg = "Error occured while handling ellipsis!"
            raise ValueError(errorMsg)
            return

        for item in index:
          axis += 1
          if str(type(item)).split("'")[1] == "ellipsis":
            while (axis >= replace_start and axis < replace_stop):
              start = 0
              stop = self.shape()[axis]
              step = 1
              start_list.append(start)
              stop_list.append(stop)
              step_list.append(step)
              axis_list.append(axis)
              reshape_list.append(1)  # This shape will be taken
              axis += 1
            axis -= 1   # recovering from last axis increment
          elif str(type(item)).split("'")[1] == "int":
            start, stop, step, flag = get_item_helper_int(item, axis)
            if flag:
              return
            start_list.append(start)
            stop_list.append(stop)
            step_list.append(step)
            axis_list.append(axis)
            reshape_list.append(0)  # This shape will not be taken
          elif str(type(item)).split("'")[1] == "slice":
            start, stop, step, flag = get_item_helper_slice(item, axis)
            if flag:
              return
            start_list.append(start)
            stop_list.append(stop)
            step_list.append(step)
            axis_list.append(axis)
            reshape_list.append(1)  # This shape will be taken
          else:
            errorMsg = "Doesn't support " + str(item) + " of " + str(type(item)) + " as a slicing argument!"
            raise TypeError(errorMsg)
            return

        while (axis < self.rank()-1):
          axis += 1
          start = 0
          stop = self.shape()[axis]
          step = 1
          start_list.append(start)
          stop_list.append(stop)
          step_list.append(step)
          axis_list.append(axis)
          reshape_list.append(1)  # This shape will be taken

        start_list = array(start_list).asTypeInt()
        stop_list = array(stop_list).asTypeInt()
        axis_list = array(axis_list).asTypeInt()
        step_list = array(step_list).asTypeInt()

    # print("test start list :  ", start_list)
    # print("test stop list :  ", stop_list)
    # print("test axis list :  ", axis_list)
    # print("test step list :  ", step_list)

        result = slice(self, start_list, stop_list, axis_list, step_list)

        if (result.len() != 0) and (0 in reshape_list):
          if not 1 in reshape_list:
            return result.data()[0]
          return (result.reshape([x for x, y in zip(result.shape(), reshape_list) if y == 1]))

        return result

      else :
        errorMsg = "Doesn't support " + str(index) + " of " + str(type(index)) + " as a slicing argument!"
        raise TypeError(errorMsg)

      return intTensor()



    def __setitem__(self, index, input_tensor):
      """
         setitem method for tensor.
      """

      value_tensor = ""
      if "Tensor" not in str(type(input_tensor)).split("'")[1]:
        if str(type(input_tensor)).split("'")[1] in ("int", "float", "bool"):
          value_tensor = array([input_tensor])  # passing single number as tensor of length 1
        elif str(type(input_tensor)).split("'")[1] in ("list", "tuple"):
          value_tensor = array(input_tensor)  # passing python lists or tuples as tensor
        else:
          errorMsg = "could not convert " + str(input_tensor) + " of type " + str(type(input_tensor)) + " to dnnc tensor"
          raise ValueError(errorMsg)
          return
      else:
          value_tensor = input_tensor

      def set_item_helper_int(item, axis):
        flag = 0
        start = item
        if (start < 0):
          start += self.shape()[axis]
        stop = start+1
        step = 1
        if(start >= self.shape()[axis]):
          errorMsg = "index value " + str(start) + " along axis " + str(axis) + " is beyond the size " + str(self.shape()[axis]) + " of input tensor along that axis"
          raise ValueError(errorMsg)
          flag = 1
        return start, stop, step, flag

      def set_item_helper_slice(item, axis):
        flag = 0   # to check if all index items are supported or not
        start = 0
        stop = self.shape()[axis]
        step = 1
        if type(item.step) == int:
          step = item.step
          if step == 0:
            errorMsg = "slice step cannot be zero"
            raise TypeError(errorMsg)
            flag = 1
          elif step < 0:
            start = self.shape()[axis] -1
            stop = -1
        elif str(type(item.step)).split("'")[1] == "NoneType":
          pass
        else:
          errorMsg = "step of " + str(type(item.step)) + " not supported!"
          raise TypeError(errorMsg)
          flag = 1
        if type(item.start) == int:
          start = item.start
          if (start < 0):
            start += self.shape()[axis]
        elif str(type(item.start)).split("'")[1] == "NoneType":
          pass
        else:
          errorMsg = "start of " + str(type(item.start)) + " not supported!"
          raise TypeError(errorMsg)
          flag = 1
        if type(item.stop) == int:
          stop = item.stop
          if (stop < 0):
            stop += self.shape()[axis]
        elif str(type(item.stop)).split("'")[1] == "NoneType":
          pass
        else:
          errorMsg = "stop of " + str(type(item.stop)) + " not supported!"
          raise TypeError(errorMsg)
          flag = 1
    # if(start > self.shape()[axis]):
    #   errorMsg = "index value " + str(start) + " along axis " + str(axis) + " is beyond the size " + str(self.shape()[axis]) + " of input tensor along that axis"
    #   raise IndexError(errorMsg)
    #   flag = 1
    # if(stop > self.shape()[axis]):
    #   errorMsg = "index value " + str(stop) + " along axis " + str(axis) + " is beyond the size " + str(self.shape()[axis]) + " of input tensor along that axis"
    #   raise IndexError(errorMsg)
    #   flag = 1
    # if (step < 0) and not (start > stop):
    #   errorMsg = "stop index " + str(stop) + " along axis " + str(axis) + " is greater than start index " + str(start) + " while step is negative"
    #   raise IndexError(errorMsg)
    #   flag = 1
    # elif (step > 0) and not (start < stop):
    #   errorMsg = "stop index " + str(stop) + " along axis " + str(axis) + " is smaller than start index " + str(start) + " while step is positive"
    #   raise IndexError(errorMsg)
    #   flag = 1

        return start, stop, step, flag

      if str(type(index)).split("'")[1] == "int":
        if self.rank() < 1:
          errorMsg = "cannot set items to a null tensor"
          raise TypeError(errorMsg)
          return
        axis = 0
        start, stop, step, flag = set_item_helper_int(index, axis)
        if flag:
          return
        start = array([start]).asTypeInt()
        stop = array([stop]).asTypeInt()
        axis = array([axis]).asTypeInt()
        step = array([step]).asTypeInt()

        set_slice(self, value_tensor, start, stop, axis, step)
        return

      elif str(type(index)).split("'")[1] == "slice":
        if self.rank() < 1:
          self = value_tensor
          return
        axis = 0
        start, stop, step, flag = set_item_helper_slice(index, axis)
        if flag:
          return
        start = array([start]).asTypeInt()
        stop = array([stop]).asTypeInt()
        axis = array([axis]).asTypeInt()
        step = array([step]).asTypeInt()

        set_slice(self, value_tensor, start, stop, axis, step)
        return

      elif str(type(index)).split("'")[1] == "ellipsis":
        if self.shape() != value_tensor.shape():
          errorMsg = "could not broadcast input array from shape "+str(value_tensor.shape())+" into shape "+str(self.shape())
          raise ValueError(errorMsg)
          return
        elif (self.rank() < 1) or (self.shape() == value_tensor.shape()):
          self = value_tensor
          return

      elif str(type(index)).split("'")[1] == "tuple":
        if (len(index) > self.rank()):
          errorMsg = "Takes maximum " + str(self.rank()) + " arguments, " + str(len(index)) + " were given!"
          raise IndexError(errorMsg)
          return
    # elif Ellipsis not in index and (len(index) < self.rank()):
    #   errorMsg = "Takes minimum " + str(self.rank()) + " arguments, " + str(len(index)) + " were given!"
    #   raise IndexError(errorMsg)
    #   return

    # checks if any float or bool or complex is not present
        if any(isinstance(x,(bool,float,complex)) for x in index):
          errorMsg = "Restrict to only integers as a slicing argument!"
          raise ValueError(errorMsg)
          return

        start_list = []
        stop_list = []
        step_list = []
        axis_list = []
        axis = -1   # -1 for starting axis as 0 in the next loops
        replace_start = replace_stop = 0   # replace ellipsis with slice methods by index

        if Ellipsis in index:
          if (index.count(Ellipsis) > 1):
            errorMsg = str(index.count(Ellipsis)) + " 'Ellipsis' found, maximum 1 is supported!"
            raise IndexError(errorMsg)
            return
          elif (index.count(Ellipsis) == 1):
            non_ellipsis_count = 0
            for item in index:
              if str(type(item)).split("'")[1] == "int" or str(type(item)).split("'")[1] == "slice":
                non_ellipsis_count += 1
    # replace holds start and stop index which will be replaced by slice method in place of ellipsis
            replace_start = index.index(Ellipsis)
            replace_stop = replace_start + self.rank() - non_ellipsis_count
          else:
            errorMsg = "Error occured while handling ellipsis!"
            raise ValueError(errorMsg)
            return

        for item in index:
          axis += 1
          if str(type(item)).split("'")[1] == "ellipsis":
            while (axis >= replace_start and axis < replace_stop):
              start = 0
              stop = self.shape()[axis]
              step = 1
              start_list.append(start)
              stop_list.append(stop)
              step_list.append(step)
              axis_list.append(axis)
              axis += 1
            axis -= 1   # recovering from last axis increment
          elif str(type(item)).split("'")[1] == "int":
            start, stop, step, flag = set_item_helper_int(item, axis)
            if flag:
              return
            start_list.append(start)
            stop_list.append(stop)
            step_list.append(step)
            axis_list.append(axis)
          elif str(type(item)).split("'")[1] == "slice":
            start, stop, step, flag = set_item_helper_slice(item, axis)
            if flag:
              return
            start_list.append(start)
            stop_list.append(stop)
            step_list.append(step)
            axis_list.append(axis)
          else:
            errorMsg = "Doesn't support " + str(item) + " of " + str(type(item)) + " as a slicing argument!"
            raise TypeError(errorMsg)
            return

        while (axis < self.rank()-1):
          axis += 1
          start = 0
          stop = self.shape()[axis]
          step = 1
          start_list.append(start)
          stop_list.append(stop)
          step_list.append(step)
          axis_list.append(axis)

        start_list = array(start_list).asTypeInt()
        stop_list = array(stop_list).asTypeInt()
        axis_list = array(axis_list).asTypeInt()
        step_list = array(step_list).asTypeInt()

    # print("test start list :  ", start_list)
    # print("test stop list :  ", stop_list)
    # print("test axis list :  ", axis_list)
    # print("test step list :  ", step_list)

        set_slice(self, value_tensor, start_list, stop_list, axis_list, step_list)
        return
      else :
        errorMsg = "Doesn't support " + str(index) + " of " + str(type(index)) + " as a slicing argument!"
        raise TypeError(errorMsg)

      return


    def __add__(self, other):
      return add(self, other)

    def __radd__(self, other):
      return add(other, self)

    def __iadd__(self, other):
      """
        making sure left hand operand is immutable
      """
      dtype_precedence_dict = {'double': 16, 'float': 14, 'size_t': 12, 'long': 10, 'int': 8, 'short': 6, 'bool': 4, 'char': 2}
      left_operand_dtype = right_operand_dtype = ""
      if "Tensor" in str(type(self)):
        left_operand_dtype = str(type(self)).split(".")[-1].split("Tensor")[0]
      else:
        left_operand_dtype = str(type(self)).split("'")[1]
      if "Tensor" in str(type(other)):
        right_operand_dtype = str(type(other)).split(".")[-1].split("Tensor")[0]
      else:
        right_operand_dtype = str(type(other)).split("'")[1]
      if (dtype_precedence_dict[left_operand_dtype] < dtype_precedence_dict[right_operand_dtype]):
        errorMsg = "cannot modify left hand operand datatype."
        raise TypeError(errorMsg)
      return add(self, other)

    def __sub__(self, other):
      return sub(self, other)

    def __rsub__(self, other):
      return sub(other, self)

    def __isub__(self, other):
      """
        making sure left hand operand is immutable
      """
      dtype_precedence_dict = {'double': 16, 'float': 14, 'size_t': 12, 'long': 10, 'int': 8, 'short': 6, 'bool': 4, 'char': 2}
      left_operand_dtype = right_operand_dtype = ""
      if "Tensor" in str(type(self)):
        left_operand_dtype = str(type(self)).split(".")[-1].split("Tensor")[0]
      else:
        left_operand_dtype = str(type(self)).split("'")[1]
      if "Tensor" in str(type(other)):
        right_operand_dtype = str(type(other)).split(".")[-1].split("Tensor")[0]
      else:
        right_operand_dtype = str(type(other)).split("'")[1]
      if (dtype_precedence_dict[left_operand_dtype] < dtype_precedence_dict[right_operand_dtype]):
        errorMsg = "cannot modify left hand operand datatype."
        raise TypeError(errorMsg)
      return sub(self, other)

    def __mul__(self, other):
      return mul(self, other)

    def __rmul__(self, other):
      return mul(other, self)

    def __imul__(self, other):
      """
        making sure left hand operand is immutable
      """
      dtype_precedence_dict = {'double': 16, 'float': 14, 'size_t': 12, 'long': 10, 'int': 8, 'short': 6, 'bool': 4, 'char': 2}
      left_operand_dtype = right_operand_dtype = ""
      if "Tensor" in str(type(self)):
        left_operand_dtype = str(type(self)).split(".")[-1].split("Tensor")[0]
      else:
        left_operand_dtype = str(type(self)).split("'")[1]
      if "Tensor" in str(type(other)):
        right_operand_dtype = str(type(other)).split(".")[-1].split("Tensor")[0]
      else:
        right_operand_dtype = str(type(other)).split("'")[1]
      if (dtype_precedence_dict[left_operand_dtype] < dtype_precedence_dict[right_operand_dtype]):
        errorMsg = "cannot modify left hand operand datatype."
        raise TypeError(errorMsg)
      return mul(self, other)

    def __floordiv__(self, other):
      return floor_div(self, other)

    def __rfloordiv__(self, other):
      return floor_div(other, self)

    def __ifloordiv__(self, other):
      """
        making sure left hand operand is immutable
      """
      dtype_precedence_dict = {'double': 16, 'float': 14, 'size_t': 12, 'long': 10, 'int': 8, 'short': 6, 'bool': 4, 'char': 2}
      left_operand_dtype = right_operand_dtype = ""
      if "Tensor" in str(type(self)):
        left_operand_dtype = str(type(self)).split(".")[-1].split("Tensor")[0]
      else:
        left_operand_dtype = str(type(self)).split("'")[1]
      if "Tensor" in str(type(other)):
        right_operand_dtype = str(type(other)).split(".")[-1].split("Tensor")[0]
      else:
        right_operand_dtype = str(type(other)).split("'")[1]
      if (dtype_precedence_dict[left_operand_dtype] < dtype_precedence_dict[right_operand_dtype]):
        errorMsg = "cannot modify left hand operand datatype."
        raise TypeError(errorMsg)
      return floor_div(self, other)

    def __truediv__(self, other):
      return true_div(self, other)

    def __rtruediv__(self, other):
      return true_div(other, self)

    def __itruediv__(self, other):
      """
        making sure left hand operand is immutable
      """
      dtype_precedence_dict = {'double': 16, 'float': 14, 'size_t': 12, 'long': 10, 'int': 8, 'short': 6, 'bool': 4, 'char': 2}
      left_operand_dtype = right_operand_dtype = ""
      if "Tensor" in str(type(self)):
        left_operand_dtype = str(type(self)).split(".")[-1].split("Tensor")[0]
      else:
        left_operand_dtype = str(type(self)).split("'")[1]
      if "Tensor" in str(type(other)):
        right_operand_dtype = str(type(other)).split(".")[-1].split("Tensor")[0]
      else:
        right_operand_dtype = str(type(other)).split("'")[1]
      if (dtype_precedence_dict[left_operand_dtype] < dtype_precedence_dict[right_operand_dtype]):
        errorMsg = "cannot modify left hand operand datatype."
        raise TypeError(errorMsg)
      return true_div(self, other)

    def __mod__(self, other):
      return remainder(self, other)

    def __rmod__(self, other):
      return remainder(other, self)

    def __imod__(self, other):
      """
        making sure left hand operand is immutable
      """
      dtype_precedence_dict = {'double': 16, 'float': 14, 'size_t': 12, 'long': 10, 'int': 8, 'short': 6, 'bool': 4, 'char': 2}
      left_operand_dtype = right_operand_dtype = ""
      if "Tensor" in str(type(self)):
        left_operand_dtype = str(type(self)).split(".")[-1].split("Tensor")[0]
      else:
        left_operand_dtype = str(type(self)).split("'")[1]
      if "Tensor" in str(type(other)):
        right_operand_dtype = str(type(other)).split(".")[-1].split("Tensor")[0]
      else:
        right_operand_dtype = str(type(other)).split("'")[1]
      if (dtype_precedence_dict[left_operand_dtype] < dtype_precedence_dict[right_operand_dtype]):
        errorMsg = "cannot modify left hand operand datatype."
        raise TypeError(errorMsg)
      return remainder(self, other)

    def __pow__(self, other):
      return power(self, other)

    def __rpow__(self, other):
      return power(other, self)

    def __ipow__(self, other):
      """
        making sure left hand operand is immutable
      """
      dtype_precedence_dict = {'double': 16, 'float': 14, 'size_t': 12, 'long': 10, 'int': 8, 'short': 6, 'bool': 4, 'char': 2}
      left_operand_dtype = right_operand_dtype = ""
      if "Tensor" in str(type(self)):
        left_operand_dtype = str(type(self)).split(".")[-1].split("Tensor")[0]
      else:
        left_operand_dtype = str(type(self)).split("'")[1]
      if "Tensor" in str(type(other)):
        right_operand_dtype = str(type(other)).split(".")[-1].split("Tensor")[0]
      else:
        right_operand_dtype = str(type(other)).split("'")[1]
      if (dtype_precedence_dict[left_operand_dtype] < dtype_precedence_dict[right_operand_dtype]):
        errorMsg = "cannot modify left hand operand datatype."
        raise TypeError(errorMsg)
      return power(self, other)

    def __and__(self, other):
      return bitwise_and(self, other)

    def __rand__(self, other):
      return bitwise_and(other, self)

    def __iand__(self, other):
      """
        making sure left hand operand is immutable
      """
      dtype_precedence_dict = {'double': 16, 'float': 14, 'size_t': 12, 'long': 10, 'int': 8, 'short': 6, 'bool': 4, 'char': 2}
      left_operand_dtype = right_operand_dtype = ""
      if "Tensor" in str(type(self)):
        left_operand_dtype = str(type(self)).split(".")[-1].split("Tensor")[0]
      else:
        left_operand_dtype = str(type(self)).split("'")[1]
      if "Tensor" in str(type(other)):
        right_operand_dtype = str(type(other)).split(".")[-1].split("Tensor")[0]
      else:
        right_operand_dtype = str(type(other)).split("'")[1]
      if (dtype_precedence_dict[left_operand_dtype] < dtype_precedence_dict[right_operand_dtype]):
        errorMsg = "cannot modify left hand operand datatype."
        raise TypeError(errorMsg)
      return bitwise_and(self, other)

    def __or__(self, other):
      return bitwise_or(self, other)

    def __ror__(self, other):
      return bitwise_or(other, self)

    def __ior__(self, other):
      """
        making sure left hand operand is immutable
      """
      dtype_precedence_dict = {'double': 16, 'float': 14, 'size_t': 12, 'long': 10, 'int': 8, 'short': 6, 'bool': 4, 'char': 2}
      left_operand_dtype = right_operand_dtype = ""
      if "Tensor" in str(type(self)):
        left_operand_dtype = str(type(self)).split(".")[-1].split("Tensor")[0]
      else:
        left_operand_dtype = str(type(self)).split("'")[1]
      if "Tensor" in str(type(other)):
        right_operand_dtype = str(type(other)).split(".")[-1].split("Tensor")[0]
      else:
        right_operand_dtype = str(type(other)).split("'")[1]
      if (dtype_precedence_dict[left_operand_dtype] < dtype_precedence_dict[right_operand_dtype]):
        errorMsg = "cannot modify left hand operand datatype."
        raise TypeError(errorMsg)
      return bitwise_or(self, other)

    def __xor__(self, other):
      return bitwise_xor(self, other)

    def __rxor__(self, other):
      return bitwise_xor(other, self)

    def __ixor__(self, other):
      """
        making sure left hand operand is immutable
      """
      dtype_precedence_dict = {'double': 16, 'float': 14, 'size_t': 12, 'long': 10, 'int': 8, 'short': 6, 'bool': 4, 'char': 2}
      left_operand_dtype = right_operand_dtype = ""
      if "Tensor" in str(type(self)):
        left_operand_dtype = str(type(self)).split(".")[-1].split("Tensor")[0]
      else:
        left_operand_dtype = str(type(self)).split("'")[1]
      if "Tensor" in str(type(other)):
        right_operand_dtype = str(type(other)).split(".")[-1].split("Tensor")[0]
      else:
        right_operand_dtype = str(type(other)).split("'")[1]
      if (dtype_precedence_dict[left_operand_dtype] < dtype_precedence_dict[right_operand_dtype]):
        errorMsg = "cannot modify left hand operand datatype."
        raise TypeError(errorMsg)
      return bitwise_xor(self, other)

    def __eq__(self, other):
      return equal(self, other)

    def __lt__(self, other):
      return less(self, other)

    def __gt__(self, other):
      return greater(self, other)

    def __ne__(self, other):
      return not_equal(self, other)

    def __le__(self, other):
      return less_equal(self, other)

    def __ge__(self, other):
      return greater_equal(self, other)



    def numpy(self) :
      """
         convert tensor to numpy array.
      """
      import numpy as np
      if (self.len() == 0):    # this is a deepC tensor bug, this if statement is a bypass for testing
        return np.array(self.data())
      return np.array(self.data()).reshape(self.shape())

    def len(self):
      """
         return length of tensor.
      """
      return self.length()

    def __iter__(self):
      """
         iterates over the tensor.
      """
      axis = 0
      while (axis < self.shape()[0]):
        yield self[axis]
        axis += 1

    def __int__(self):
      """
         convert tensor to int tensor.
      """
      if (self.len() > 1):
        raise TypeError("only length-1 tensor can be converted to Python scalars")
      elif(self.len() == 0):
        return
      return self.asTypeInt()

    def __float__(self):
      """
         convert tensor to float tensor.
      """
      if (self.len() > 1):
        raise TypeError("only length-1 tensor can be converted to Python scalars")
      elif(self.len() == 0):
        return
      return self.asTypeFloat()

    def __bool__(self):
      """
         convert tensor to bool tensor.
      """
      if (self.len() > 1):
        raise ValueError("The truth value of an array with more than one element is ambiguous. Use dc.any() or dc.all()")
      elif(self.len() == 0):
        return False
      return self.asTypeBool()


floatTensor_swigregister = _dnnc.floatTensor_swigregister
floatTensor_swigregister(floatTensor)

class doubleTensor(doubleplaceHolder):
    """Proxy of C++ dnnc::tensor<(double)> class."""

    __swig_setmethods__ = {}
    for _s in [doubleplaceHolder]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, doubleTensor, name, value)
    __swig_getmethods__ = {}
    for _s in [doubleplaceHolder]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, doubleTensor, name)

    def __init__(self, *args):
        """
        __init__(self, dimn, n, fill, init_val=0) -> doubleTensor

        Parameters
        ----------
        dimn: std::vector< dnnc::DIMENSION,std::allocator< dnnc::DIMENSION > >
        n: std::string
        fill: enum dnnc::INIT_TYPE
        init_val: double

        __init__(self, dimn, n, fill) -> doubleTensor

        Parameters
        ----------
        dimn: std::vector< dnnc::DIMENSION,std::allocator< dnnc::DIMENSION > >
        n: std::string
        fill: enum dnnc::INIT_TYPE

        __init__(self, dimn, n) -> doubleTensor

        Parameters
        ----------
        dimn: std::vector< dnnc::DIMENSION,std::allocator< dnnc::DIMENSION > >
        n: std::string

        __init__(self, dimn) -> doubleTensor

        Parameters
        ----------
        dimn: std::vector< dnnc::DIMENSION,std::allocator< dnnc::DIMENSION > >

        __init__(self) -> doubleTensor
        __init__(self, data, dimn, n) -> doubleTensor

        Parameters
        ----------
        data: double *
        dimn: std::vector< dnnc::DIMENSION,std::allocator< dnnc::DIMENSION > >
        n: std::string

        __init__(self, data, dimn) -> doubleTensor

        Parameters
        ----------
        data: double *
        dimn: std::vector< dnnc::DIMENSION,std::allocator< dnnc::DIMENSION > >

        __init__(self, other) -> doubleTensor

        Parameters
        ----------
        other: dnnc::tensor< double > const &

        """
        this = _dnnc.new_doubleTensor(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _dnnc.delete_doubleTensor
    __del__ = lambda self: None

    def __nonzero__(self):
        return _dnnc.doubleTensor___nonzero__(self)
    __bool__ = __nonzero__



    def copy(self):
        """
        copy(self) -> doubleTensor

        Parameters
        ----------
        self: dnnc::tensor< double > const *

        """
        return _dnnc.doubleTensor_copy(self)


    def negate(self):
        """
        negate(self) -> doubleTensor

        Parameters
        ----------
        self: dnnc::tensor< double > const *

        """
        return _dnnc.doubleTensor_negate(self)


    def absolute(self):
        """
        absolute(self) -> doubleTensor

        Parameters
        ----------
        self: dnnc::tensor< double > const *

        """
        return _dnnc.doubleTensor_absolute(self)


    def identifier(self):
        """
        identifier(self) -> size_t

        Parameters
        ----------
        self: dnnc::tensor< double > const *

        """
        return _dnnc.doubleTensor_identifier(self)


    def sameas(self, other):
        """
        sameas(self, other) -> bool

        Parameters
        ----------
        other: dnnc::tensor< double > const &

        """
        return _dnnc.doubleTensor_sameas(self, other)


    def asTypeDouble(self):
        """
        asTypeDouble(self) -> doubleTensor

        Parameters
        ----------
        self: dnnc::tensor< double > *

        """
        return _dnnc.doubleTensor_asTypeDouble(self)


    def asTypeFloat(self):
        """
        asTypeFloat(self) -> floatTensor

        Parameters
        ----------
        self: dnnc::tensor< double > *

        """
        return _dnnc.doubleTensor_asTypeFloat(self)


    def asTypeInt(self):
        """
        asTypeInt(self) -> intTensor

        Parameters
        ----------
        self: dnnc::tensor< double > *

        """
        return _dnnc.doubleTensor_asTypeInt(self)


    def asTypeUint8(self):
        """
        asTypeUint8(self) -> dnnc::tensor< uint8_t >

        Parameters
        ----------
        self: dnnc::tensor< double > *

        """
        return _dnnc.doubleTensor_asTypeUint8(self)


    def asTypeLong(self):
        """
        asTypeLong(self) -> dnnc::tensor< long >

        Parameters
        ----------
        self: dnnc::tensor< double > *

        """
        return _dnnc.doubleTensor_asTypeLong(self)


    def asTypeULong(self):
        """
        asTypeULong(self) -> uLongTensor

        Parameters
        ----------
        self: dnnc::tensor< double > *

        """
        return _dnnc.doubleTensor_asTypeULong(self)


    def asTypeBool(self):
        """
        asTypeBool(self) -> boolTensor

        Parameters
        ----------
        self: dnnc::tensor< double > *

        """
        return _dnnc.doubleTensor_asTypeBool(self)


    def load(self, *args):
        """
        load(self, data, indices)

        Parameters
        ----------
        data: double const &
        indices: std::vector< size_t,std::allocator< size_t > >

        load(self, data, i, j=0, k=0, l=0, m=0)

        Parameters
        ----------
        data: double const &
        i: size_t
        j: size_t
        k: size_t
        l: size_t
        m: size_t

        load(self, data, i, j=0, k=0, l=0)

        Parameters
        ----------
        data: double const &
        i: size_t
        j: size_t
        k: size_t
        l: size_t

        load(self, data, i, j=0, k=0)

        Parameters
        ----------
        data: double const &
        i: size_t
        j: size_t
        k: size_t

        load(self, data, i, j=0)

        Parameters
        ----------
        data: double const &
        i: size_t
        j: size_t

        load(self, data, i)

        Parameters
        ----------
        data: double const &
        i: size_t

        load(self, data)

        Parameters
        ----------
        data: std::vector< double,std::allocator< double > >

        load(self, data)

        Parameters
        ----------
        data: double const *

        """
        return _dnnc.doubleTensor_load(self, *args)


    def to_string(self, max_el=30):
        """
        to_string(self, max_el=30) -> std::string

        Parameters
        ----------
        max_el: size_t const

        to_string(self) -> std::string

        Parameters
        ----------
        self: dnnc::tensor< double > const *

        """
        return _dnnc.doubleTensor_to_string(self, max_el)


    def data(self):
        """
        data(self) -> std::vector< double,std::allocator< double > > const

        Parameters
        ----------
        self: dnnc::tensor< double > const *

        """
        return _dnnc.doubleTensor_data(self)


    def reshape(self, *args):
      """
        reshape tensor to a new shape permitting same length of old and new shape.
      """
      new_shape = []
      for arg in args:
        if isinstance(arg, int):
          new_shape.append(arg)
        else:
          return _dnnc.doubleTensor_reshape (self, vectorSizeT(arg))

      if len(new_shape):
        return _dnnc.doubleTensor_reshape (self, vectorSizeT(new_shape))

      return _dnnc.doubleTensor_reshape (args)



    def flatten(self):
        """
        flatten(self) -> doubleTensor

        Parameters
        ----------
        self: dnnc::tensor< double > *

        """
        return _dnnc.doubleTensor_flatten(self)


    def isnull(self):
        """
        isnull(self) -> bool

        Parameters
        ----------
        self: dnnc::tensor< double > const *

        """
        return _dnnc.doubleTensor_isnull(self)


    def transpose(self):
        """
        transpose(self)

        Parameters
        ----------
        self: dnnc::tensor< double > *

        """
        return _dnnc.doubleTensor_transpose(self)


    def __call__(self, *args):
        """
        __call__(self, indices) -> double

        Parameters
        ----------
        indices: std::vector< dnnc::INDEX,std::allocator< dnnc::INDEX > > &

        __call__(self, x=0, y=0, z=0, w=0, u=0) -> double

        Parameters
        ----------
        x: dnnc::INDEX const
        y: dnnc::INDEX const
        z: dnnc::INDEX const
        w: dnnc::INDEX const
        u: dnnc::INDEX const

        __call__(self, x=0, y=0, z=0, w=0) -> double

        Parameters
        ----------
        x: dnnc::INDEX const
        y: dnnc::INDEX const
        z: dnnc::INDEX const
        w: dnnc::INDEX const

        __call__(self, x=0, y=0, z=0) -> double

        Parameters
        ----------
        x: dnnc::INDEX const
        y: dnnc::INDEX const
        z: dnnc::INDEX const

        __call__(self, x=0, y=0) -> double

        Parameters
        ----------
        x: dnnc::INDEX const
        y: dnnc::INDEX const

        __call__(self, x=0) -> double

        Parameters
        ----------
        x: dnnc::INDEX const

        __call__(self) -> double &

        Parameters
        ----------
        self: dnnc::tensor< double > const *

        """
        return _dnnc.doubleTensor___call__(self, *args)


    def empty(self):
        """
        empty(self) -> bool

        Parameters
        ----------
        self: dnnc::tensor< double > *

        """
        return _dnnc.doubleTensor_empty(self)


    def dtype(self):
        """
        dtype(self) -> std::string

        Parameters
        ----------
        self: dnnc::tensor< double > *

        """
        return _dnnc.doubleTensor_dtype(self)


    def to_proto(self):
        """
        to_proto(self) -> std::string

        Parameters
        ----------
        self: dnnc::tensor< double > *

        """
        return _dnnc.doubleTensor_to_proto(self)


    def min(self):
        """
        min(self) -> double

        Parameters
        ----------
        self: dnnc::tensor< double > const *

        """
        return _dnnc.doubleTensor_min(self)


    def max(self):
        """
        max(self) -> double

        Parameters
        ----------
        self: dnnc::tensor< double > const *

        """
        return _dnnc.doubleTensor_max(self)


    def sum(self):
        """
        sum(self) -> double

        Parameters
        ----------
        self: dnnc::tensor< double > const *

        """
        return _dnnc.doubleTensor_sum(self)


    def __getitem__(self, indices):
        """
        __getitem__(self, indices) -> double const &

        Parameters
        ----------
        indices: PyObject *

        """
        return _dnnc.doubleTensor___getitem__(self, indices)


    def __setitem__(self, indices, data):
        """
        __setitem__(self, indices, data)

        Parameters
        ----------
        indices: PyObject *
        data: double const &

        """
        return _dnnc.doubleTensor___setitem__(self, indices, data)


    def __str__(self):
        """
        __str__(self) -> std::string

        Parameters
        ----------
        self: dnnc::tensor< double > *

        """
        return _dnnc.doubleTensor___str__(self)


    def __repr__(self):
        """
        __repr__(self) -> std::string

        Parameters
        ----------
        self: dnnc::tensor< double > *

        """
        return _dnnc.doubleTensor___repr__(self)


    def __neg__(self):
        """
        __neg__(self) -> doubleTensor

        Parameters
        ----------
        self: dnnc::tensor< double > *

        """
        return _dnnc.doubleTensor___neg__(self)


    def __pos__(self):
        """
        __pos__(self) -> doubleTensor

        Parameters
        ----------
        self: dnnc::tensor< double > *

        """
        return _dnnc.doubleTensor___pos__(self)


    def __abs__(self):
        """
        __abs__(self) -> doubleTensor

        Parameters
        ----------
        self: dnnc::tensor< double > *

        """
        return _dnnc.doubleTensor___abs__(self)


    def __invert__(self):
        """
        __invert__(self) -> boolTensor

        Parameters
        ----------
        self: dnnc::tensor< double > *

        """
        return _dnnc.doubleTensor___invert__(self)


    def __lshift__(self, *args):
        """
        __lshift__(self, other) -> intTensor

        Parameters
        ----------
        other: dnnc::tensor< int > &

        __lshift__(self, scalar) -> intTensor

        Parameters
        ----------
        scalar: int

        """
        return _dnnc.doubleTensor___lshift__(self, *args)


    def __ilshift__(self, *args):
        """
        __ilshift__(self, other) -> intTensor

        Parameters
        ----------
        other: dnnc::tensor< int > &

        __ilshift__(self, scalar) -> intTensor

        Parameters
        ----------
        scalar: int

        """
        return _dnnc.doubleTensor___ilshift__(self, *args)


    def __rshift__(self, *args):
        """
        __rshift__(self, other) -> intTensor

        Parameters
        ----------
        other: dnnc::tensor< int > &

        __rshift__(self, scalar) -> intTensor

        Parameters
        ----------
        scalar: int

        """
        return _dnnc.doubleTensor___rshift__(self, *args)


    def __irshift__(self, *args):
        """
        __irshift__(self, other) -> intTensor

        Parameters
        ----------
        other: dnnc::tensor< int > &

        __irshift__(self, scalar) -> intTensor

        Parameters
        ----------
        scalar: int

        """
        return _dnnc.doubleTensor___irshift__(self, *args)




    def __getitem__(self, index):
      """
         getitem method for tensor.
      """
      def get_item_helper_int(item, axis):
        flag = 0
        start = item
        if (start < 0):
          start += self.shape()[axis]
        stop = start+1
        step = 1
        if(start >= self.shape()[axis]):
          errorMsg = "index value " + str(start) + " along axis " + str(axis) + " is beyond the size " + str(self.shape()[axis]) + " of input tensor along that axis"
          raise ValueError(errorMsg)
          flag = 1
        return start, stop, step, flag

      def get_item_helper_slice(item, axis):
        flag = 0   # to check if all index items are supported or not
        start = 0
        stop = self.shape()[axis]
        step = 1
        if type(item.step) == int:
          step = item.step
          if step == 0:
            errorMsg = "slice step cannot be zero"
            raise TypeError(errorMsg)
            flag = 1
          elif step < 0:
            start = self.shape()[axis] -1
            stop = -1
        elif str(type(item.step)).split("'")[1] == "NoneType":
          pass
        else:
          errorMsg = "step of " + str(type(item.step)) + " not supported!"
          raise TypeError(errorMsg)
          flag = 1
        if type(item.start) == int:
          start = item.start
          if (start < 0):
            start += self.shape()[axis]
        elif str(type(item.start)).split("'")[1] == "NoneType":
          pass
        else:
          errorMsg = "start of " + str(type(item.start)) + " not supported!"
          raise TypeError(errorMsg)
          flag = 1
        if type(item.stop) == int:
          stop = item.stop
          if (stop < 0):
            stop += self.shape()[axis]
        elif str(type(item.stop)).split("'")[1] == "NoneType":
          pass
        else:
          errorMsg = "stop of " + str(type(item.stop)) + " not supported!"
          raise TypeError(errorMsg)
          flag = 1
    # if(start > self.shape()[axis]):
    #   errorMsg = "index value " + str(start) + " along axis " + str(axis) + " is beyond the size " + str(self.shape()[axis]) + " of input tensor along that axis"
    #   raise IndexError(errorMsg)
    #   flag = 1
    # if(stop > self.shape()[axis]):
    #   errorMsg = "index value " + str(stop) + " along axis " + str(axis) + " is beyond the size " + str(self.shape()[axis]) + " of input tensor along that axis"
    #   raise IndexError(errorMsg)
    #   flag = 1
    # if (step < 0) and not (start > stop):
    #   errorMsg = "stop index " + str(stop) + " along axis " + str(axis) + " is greater than start index " + str(start) + " while step is negative"
    #   raise IndexError(errorMsg)
    #   flag = 1
    # elif (step > 0) and not (start < stop):
    #   errorMsg = "stop index " + str(stop) + " along axis " + str(axis) + " is smaller than start index " + str(start) + " while step is positive"
    #   raise IndexError(errorMsg)
    #   flag = 1

        return start, stop, step, flag

      if str(type(index)).split("'")[1] == "int":
        if self.rank() < 1:
          return self.copy()
        axis = 0
        start, stop, step, flag = get_item_helper_int(index, axis)
        if flag:
          return
        start = array([start]).asTypeInt()
        stop = array([stop]).asTypeInt()
        axis = array([axis]).asTypeInt()
        step = array([step]).asTypeInt()
        if (self.rank() == 1):
          return self.data()[index]
        return slice(self, start, stop, axis, step).reshape(self.shape()[1:])

      elif str(type(index)).split("'")[1] == "slice":
        if self.rank() < 1:
          return self.copy()
        axis = 0
        start, stop, step, flag = get_item_helper_slice(index, axis)
        if flag:
          return
        start = array([start]).asTypeInt()
        stop = array([stop]).asTypeInt()
        axis = array([axis]).asTypeInt()
        step = array([step]).asTypeInt()
        return slice(self, start, stop, axis, step)

      elif str(type(index)).split("'")[1] == "ellipsis":
        return self.copy()

      elif str(type(index)).split("'")[1] == "tuple":
        if (len(index) > self.rank()):
          errorMsg = "Takes maximum " + str(self.rank()) + " arguments, " + str(len(index)) + " were given!"
          raise IndexError(errorMsg)
          return
    # elif Ellipsis not in index and (len(index) < self.rank()):
    #   errorMsg = "Takes minimum " + str(self.rank()) + " arguments, " + str(len(index)) + " were given!"
    #   raise IndexError(errorMsg)
    #   return

    # checks if any float or bool or complex is not present
        if any(isinstance(x,(bool,float,complex)) for x in index):
          errorMsg = "Restrict to only integers as a slicing argument!"
          raise ValueError(errorMsg)
          return

        start_list = []
        stop_list = []
        step_list = []
        axis_list = []
        axis = -1   # -1 for starting axis as 0 in the next loops
        reshape_list = []   # reshape list to reshape
        replace_start = replace_stop = 0   # replace ellipsis with slice methods by index

        if Ellipsis in index:
          if (index.count(Ellipsis) > 1):
            errorMsg = str(index.count(Ellipsis)) + " 'Ellipsis' found, maximum 1 is supported!"
            raise IndexError(errorMsg)
            return
          elif (index.count(Ellipsis) == 1):
            non_ellipsis_count = 0
            for item in index:
              if str(type(item)).split("'")[1] == "int" or str(type(item)).split("'")[1] == "slice":
                non_ellipsis_count += 1
    # replace holds start and stop index which will be replaced by slice method in place of ellipsis
            replace_start = index.index(Ellipsis)
            replace_stop = replace_start + self.rank() - non_ellipsis_count
          else:
            errorMsg = "Error occured while handling ellipsis!"
            raise ValueError(errorMsg)
            return

        for item in index:
          axis += 1
          if str(type(item)).split("'")[1] == "ellipsis":
            while (axis >= replace_start and axis < replace_stop):
              start = 0
              stop = self.shape()[axis]
              step = 1
              start_list.append(start)
              stop_list.append(stop)
              step_list.append(step)
              axis_list.append(axis)
              reshape_list.append(1)  # This shape will be taken
              axis += 1
            axis -= 1   # recovering from last axis increment
          elif str(type(item)).split("'")[1] == "int":
            start, stop, step, flag = get_item_helper_int(item, axis)
            if flag:
              return
            start_list.append(start)
            stop_list.append(stop)
            step_list.append(step)
            axis_list.append(axis)
            reshape_list.append(0)  # This shape will not be taken
          elif str(type(item)).split("'")[1] == "slice":
            start, stop, step, flag = get_item_helper_slice(item, axis)
            if flag:
              return
            start_list.append(start)
            stop_list.append(stop)
            step_list.append(step)
            axis_list.append(axis)
            reshape_list.append(1)  # This shape will be taken
          else:
            errorMsg = "Doesn't support " + str(item) + " of " + str(type(item)) + " as a slicing argument!"
            raise TypeError(errorMsg)
            return

        while (axis < self.rank()-1):
          axis += 1
          start = 0
          stop = self.shape()[axis]
          step = 1
          start_list.append(start)
          stop_list.append(stop)
          step_list.append(step)
          axis_list.append(axis)
          reshape_list.append(1)  # This shape will be taken

        start_list = array(start_list).asTypeInt()
        stop_list = array(stop_list).asTypeInt()
        axis_list = array(axis_list).asTypeInt()
        step_list = array(step_list).asTypeInt()

    # print("test start list :  ", start_list)
    # print("test stop list :  ", stop_list)
    # print("test axis list :  ", axis_list)
    # print("test step list :  ", step_list)

        result = slice(self, start_list, stop_list, axis_list, step_list)

        if (result.len() != 0) and (0 in reshape_list):
          if not 1 in reshape_list:
            return result.data()[0]
          return (result.reshape([x for x, y in zip(result.shape(), reshape_list) if y == 1]))

        return result

      else :
        errorMsg = "Doesn't support " + str(index) + " of " + str(type(index)) + " as a slicing argument!"
        raise TypeError(errorMsg)

      return intTensor()



    def __setitem__(self, index, input_tensor):
      """
         setitem method for tensor.
      """

      value_tensor = ""
      if "Tensor" not in str(type(input_tensor)).split("'")[1]:
        if str(type(input_tensor)).split("'")[1] in ("int", "float", "bool"):
          value_tensor = array([input_tensor])  # passing single number as tensor of length 1
        elif str(type(input_tensor)).split("'")[1] in ("list", "tuple"):
          value_tensor = array(input_tensor)  # passing python lists or tuples as tensor
        else:
          errorMsg = "could not convert " + str(input_tensor) + " of type " + str(type(input_tensor)) + " to dnnc tensor"
          raise ValueError(errorMsg)
          return
      else:
          value_tensor = input_tensor

      def set_item_helper_int(item, axis):
        flag = 0
        start = item
        if (start < 0):
          start += self.shape()[axis]
        stop = start+1
        step = 1
        if(start >= self.shape()[axis]):
          errorMsg = "index value " + str(start) + " along axis " + str(axis) + " is beyond the size " + str(self.shape()[axis]) + " of input tensor along that axis"
          raise ValueError(errorMsg)
          flag = 1
        return start, stop, step, flag

      def set_item_helper_slice(item, axis):
        flag = 0   # to check if all index items are supported or not
        start = 0
        stop = self.shape()[axis]
        step = 1
        if type(item.step) == int:
          step = item.step
          if step == 0:
            errorMsg = "slice step cannot be zero"
            raise TypeError(errorMsg)
            flag = 1
          elif step < 0:
            start = self.shape()[axis] -1
            stop = -1
        elif str(type(item.step)).split("'")[1] == "NoneType":
          pass
        else:
          errorMsg = "step of " + str(type(item.step)) + " not supported!"
          raise TypeError(errorMsg)
          flag = 1
        if type(item.start) == int:
          start = item.start
          if (start < 0):
            start += self.shape()[axis]
        elif str(type(item.start)).split("'")[1] == "NoneType":
          pass
        else:
          errorMsg = "start of " + str(type(item.start)) + " not supported!"
          raise TypeError(errorMsg)
          flag = 1
        if type(item.stop) == int:
          stop = item.stop
          if (stop < 0):
            stop += self.shape()[axis]
        elif str(type(item.stop)).split("'")[1] == "NoneType":
          pass
        else:
          errorMsg = "stop of " + str(type(item.stop)) + " not supported!"
          raise TypeError(errorMsg)
          flag = 1
    # if(start > self.shape()[axis]):
    #   errorMsg = "index value " + str(start) + " along axis " + str(axis) + " is beyond the size " + str(self.shape()[axis]) + " of input tensor along that axis"
    #   raise IndexError(errorMsg)
    #   flag = 1
    # if(stop > self.shape()[axis]):
    #   errorMsg = "index value " + str(stop) + " along axis " + str(axis) + " is beyond the size " + str(self.shape()[axis]) + " of input tensor along that axis"
    #   raise IndexError(errorMsg)
    #   flag = 1
    # if (step < 0) and not (start > stop):
    #   errorMsg = "stop index " + str(stop) + " along axis " + str(axis) + " is greater than start index " + str(start) + " while step is negative"
    #   raise IndexError(errorMsg)
    #   flag = 1
    # elif (step > 0) and not (start < stop):
    #   errorMsg = "stop index " + str(stop) + " along axis " + str(axis) + " is smaller than start index " + str(start) + " while step is positive"
    #   raise IndexError(errorMsg)
    #   flag = 1

        return start, stop, step, flag

      if str(type(index)).split("'")[1] == "int":
        if self.rank() < 1:
          errorMsg = "cannot set items to a null tensor"
          raise TypeError(errorMsg)
          return
        axis = 0
        start, stop, step, flag = set_item_helper_int(index, axis)
        if flag:
          return
        start = array([start]).asTypeInt()
        stop = array([stop]).asTypeInt()
        axis = array([axis]).asTypeInt()
        step = array([step]).asTypeInt()

        set_slice(self, value_tensor, start, stop, axis, step)
        return

      elif str(type(index)).split("'")[1] == "slice":
        if self.rank() < 1:
          self = value_tensor
          return
        axis = 0
        start, stop, step, flag = set_item_helper_slice(index, axis)
        if flag:
          return
        start = array([start]).asTypeInt()
        stop = array([stop]).asTypeInt()
        axis = array([axis]).asTypeInt()
        step = array([step]).asTypeInt()

        set_slice(self, value_tensor, start, stop, axis, step)
        return

      elif str(type(index)).split("'")[1] == "ellipsis":
        if self.shape() != value_tensor.shape():
          errorMsg = "could not broadcast input array from shape "+str(value_tensor.shape())+" into shape "+str(self.shape())
          raise ValueError(errorMsg)
          return
        elif (self.rank() < 1) or (self.shape() == value_tensor.shape()):
          self = value_tensor
          return

      elif str(type(index)).split("'")[1] == "tuple":
        if (len(index) > self.rank()):
          errorMsg = "Takes maximum " + str(self.rank()) + " arguments, " + str(len(index)) + " were given!"
          raise IndexError(errorMsg)
          return
    # elif Ellipsis not in index and (len(index) < self.rank()):
    #   errorMsg = "Takes minimum " + str(self.rank()) + " arguments, " + str(len(index)) + " were given!"
    #   raise IndexError(errorMsg)
    #   return

    # checks if any float or bool or complex is not present
        if any(isinstance(x,(bool,float,complex)) for x in index):
          errorMsg = "Restrict to only integers as a slicing argument!"
          raise ValueError(errorMsg)
          return

        start_list = []
        stop_list = []
        step_list = []
        axis_list = []
        axis = -1   # -1 for starting axis as 0 in the next loops
        replace_start = replace_stop = 0   # replace ellipsis with slice methods by index

        if Ellipsis in index:
          if (index.count(Ellipsis) > 1):
            errorMsg = str(index.count(Ellipsis)) + " 'Ellipsis' found, maximum 1 is supported!"
            raise IndexError(errorMsg)
            return
          elif (index.count(Ellipsis) == 1):
            non_ellipsis_count = 0
            for item in index:
              if str(type(item)).split("'")[1] == "int" or str(type(item)).split("'")[1] == "slice":
                non_ellipsis_count += 1
    # replace holds start and stop index which will be replaced by slice method in place of ellipsis
            replace_start = index.index(Ellipsis)
            replace_stop = replace_start + self.rank() - non_ellipsis_count
          else:
            errorMsg = "Error occured while handling ellipsis!"
            raise ValueError(errorMsg)
            return

        for item in index:
          axis += 1
          if str(type(item)).split("'")[1] == "ellipsis":
            while (axis >= replace_start and axis < replace_stop):
              start = 0
              stop = self.shape()[axis]
              step = 1
              start_list.append(start)
              stop_list.append(stop)
              step_list.append(step)
              axis_list.append(axis)
              axis += 1
            axis -= 1   # recovering from last axis increment
          elif str(type(item)).split("'")[1] == "int":
            start, stop, step, flag = set_item_helper_int(item, axis)
            if flag:
              return
            start_list.append(start)
            stop_list.append(stop)
            step_list.append(step)
            axis_list.append(axis)
          elif str(type(item)).split("'")[1] == "slice":
            start, stop, step, flag = set_item_helper_slice(item, axis)
            if flag:
              return
            start_list.append(start)
            stop_list.append(stop)
            step_list.append(step)
            axis_list.append(axis)
          else:
            errorMsg = "Doesn't support " + str(item) + " of " + str(type(item)) + " as a slicing argument!"
            raise TypeError(errorMsg)
            return

        while (axis < self.rank()-1):
          axis += 1
          start = 0
          stop = self.shape()[axis]
          step = 1
          start_list.append(start)
          stop_list.append(stop)
          step_list.append(step)
          axis_list.append(axis)

        start_list = array(start_list).asTypeInt()
        stop_list = array(stop_list).asTypeInt()
        axis_list = array(axis_list).asTypeInt()
        step_list = array(step_list).asTypeInt()

    # print("test start list :  ", start_list)
    # print("test stop list :  ", stop_list)
    # print("test axis list :  ", axis_list)
    # print("test step list :  ", step_list)

        set_slice(self, value_tensor, start_list, stop_list, axis_list, step_list)
        return
      else :
        errorMsg = "Doesn't support " + str(index) + " of " + str(type(index)) + " as a slicing argument!"
        raise TypeError(errorMsg)

      return


    def __add__(self, other):
      return add(self, other)

    def __radd__(self, other):
      return add(other, self)

    def __iadd__(self, other):
      """
        making sure left hand operand is immutable
      """
      dtype_precedence_dict = {'double': 16, 'float': 14, 'size_t': 12, 'long': 10, 'int': 8, 'short': 6, 'bool': 4, 'char': 2}
      left_operand_dtype = right_operand_dtype = ""
      if "Tensor" in str(type(self)):
        left_operand_dtype = str(type(self)).split(".")[-1].split("Tensor")[0]
      else:
        left_operand_dtype = str(type(self)).split("'")[1]
      if "Tensor" in str(type(other)):
        right_operand_dtype = str(type(other)).split(".")[-1].split("Tensor")[0]
      else:
        right_operand_dtype = str(type(other)).split("'")[1]
      if (dtype_precedence_dict[left_operand_dtype] < dtype_precedence_dict[right_operand_dtype]):
        errorMsg = "cannot modify left hand operand datatype."
        raise TypeError(errorMsg)
      return add(self, other)

    def __sub__(self, other):
      return sub(self, other)

    def __rsub__(self, other):
      return sub(other, self)

    def __isub__(self, other):
      """
        making sure left hand operand is immutable
      """
      dtype_precedence_dict = {'double': 16, 'float': 14, 'size_t': 12, 'long': 10, 'int': 8, 'short': 6, 'bool': 4, 'char': 2}
      left_operand_dtype = right_operand_dtype = ""
      if "Tensor" in str(type(self)):
        left_operand_dtype = str(type(self)).split(".")[-1].split("Tensor")[0]
      else:
        left_operand_dtype = str(type(self)).split("'")[1]
      if "Tensor" in str(type(other)):
        right_operand_dtype = str(type(other)).split(".")[-1].split("Tensor")[0]
      else:
        right_operand_dtype = str(type(other)).split("'")[1]
      if (dtype_precedence_dict[left_operand_dtype] < dtype_precedence_dict[right_operand_dtype]):
        errorMsg = "cannot modify left hand operand datatype."
        raise TypeError(errorMsg)
      return sub(self, other)

    def __mul__(self, other):
      return mul(self, other)

    def __rmul__(self, other):
      return mul(other, self)

    def __imul__(self, other):
      """
        making sure left hand operand is immutable
      """
      dtype_precedence_dict = {'double': 16, 'float': 14, 'size_t': 12, 'long': 10, 'int': 8, 'short': 6, 'bool': 4, 'char': 2}
      left_operand_dtype = right_operand_dtype = ""
      if "Tensor" in str(type(self)):
        left_operand_dtype = str(type(self)).split(".")[-1].split("Tensor")[0]
      else:
        left_operand_dtype = str(type(self)).split("'")[1]
      if "Tensor" in str(type(other)):
        right_operand_dtype = str(type(other)).split(".")[-1].split("Tensor")[0]
      else:
        right_operand_dtype = str(type(other)).split("'")[1]
      if (dtype_precedence_dict[left_operand_dtype] < dtype_precedence_dict[right_operand_dtype]):
        errorMsg = "cannot modify left hand operand datatype."
        raise TypeError(errorMsg)
      return mul(self, other)

    def __floordiv__(self, other):
      return floor_div(self, other)

    def __rfloordiv__(self, other):
      return floor_div(other, self)

    def __ifloordiv__(self, other):
      """
        making sure left hand operand is immutable
      """
      dtype_precedence_dict = {'double': 16, 'float': 14, 'size_t': 12, 'long': 10, 'int': 8, 'short': 6, 'bool': 4, 'char': 2}
      left_operand_dtype = right_operand_dtype = ""
      if "Tensor" in str(type(self)):
        left_operand_dtype = str(type(self)).split(".")[-1].split("Tensor")[0]
      else:
        left_operand_dtype = str(type(self)).split("'")[1]
      if "Tensor" in str(type(other)):
        right_operand_dtype = str(type(other)).split(".")[-1].split("Tensor")[0]
      else:
        right_operand_dtype = str(type(other)).split("'")[1]
      if (dtype_precedence_dict[left_operand_dtype] < dtype_precedence_dict[right_operand_dtype]):
        errorMsg = "cannot modify left hand operand datatype."
        raise TypeError(errorMsg)
      return floor_div(self, other)

    def __truediv__(self, other):
      return true_div(self, other)

    def __rtruediv__(self, other):
      return true_div(other, self)

    def __itruediv__(self, other):
      """
        making sure left hand operand is immutable
      """
      dtype_precedence_dict = {'double': 16, 'float': 14, 'size_t': 12, 'long': 10, 'int': 8, 'short': 6, 'bool': 4, 'char': 2}
      left_operand_dtype = right_operand_dtype = ""
      if "Tensor" in str(type(self)):
        left_operand_dtype = str(type(self)).split(".")[-1].split("Tensor")[0]
      else:
        left_operand_dtype = str(type(self)).split("'")[1]
      if "Tensor" in str(type(other)):
        right_operand_dtype = str(type(other)).split(".")[-1].split("Tensor")[0]
      else:
        right_operand_dtype = str(type(other)).split("'")[1]
      if (dtype_precedence_dict[left_operand_dtype] < dtype_precedence_dict[right_operand_dtype]):
        errorMsg = "cannot modify left hand operand datatype."
        raise TypeError(errorMsg)
      return true_div(self, other)

    def __mod__(self, other):
      return remainder(self, other)

    def __rmod__(self, other):
      return remainder(other, self)

    def __imod__(self, other):
      """
        making sure left hand operand is immutable
      """
      dtype_precedence_dict = {'double': 16, 'float': 14, 'size_t': 12, 'long': 10, 'int': 8, 'short': 6, 'bool': 4, 'char': 2}
      left_operand_dtype = right_operand_dtype = ""
      if "Tensor" in str(type(self)):
        left_operand_dtype = str(type(self)).split(".")[-1].split("Tensor")[0]
      else:
        left_operand_dtype = str(type(self)).split("'")[1]
      if "Tensor" in str(type(other)):
        right_operand_dtype = str(type(other)).split(".")[-1].split("Tensor")[0]
      else:
        right_operand_dtype = str(type(other)).split("'")[1]
      if (dtype_precedence_dict[left_operand_dtype] < dtype_precedence_dict[right_operand_dtype]):
        errorMsg = "cannot modify left hand operand datatype."
        raise TypeError(errorMsg)
      return remainder(self, other)

    def __pow__(self, other):
      return power(self, other)

    def __rpow__(self, other):
      return power(other, self)

    def __ipow__(self, other):
      """
        making sure left hand operand is immutable
      """
      dtype_precedence_dict = {'double': 16, 'float': 14, 'size_t': 12, 'long': 10, 'int': 8, 'short': 6, 'bool': 4, 'char': 2}
      left_operand_dtype = right_operand_dtype = ""
      if "Tensor" in str(type(self)):
        left_operand_dtype = str(type(self)).split(".")[-1].split("Tensor")[0]
      else:
        left_operand_dtype = str(type(self)).split("'")[1]
      if "Tensor" in str(type(other)):
        right_operand_dtype = str(type(other)).split(".")[-1].split("Tensor")[0]
      else:
        right_operand_dtype = str(type(other)).split("'")[1]
      if (dtype_precedence_dict[left_operand_dtype] < dtype_precedence_dict[right_operand_dtype]):
        errorMsg = "cannot modify left hand operand datatype."
        raise TypeError(errorMsg)
      return power(self, other)

    def __and__(self, other):
      return bitwise_and(self, other)

    def __rand__(self, other):
      return bitwise_and(other, self)

    def __iand__(self, other):
      """
        making sure left hand operand is immutable
      """
      dtype_precedence_dict = {'double': 16, 'float': 14, 'size_t': 12, 'long': 10, 'int': 8, 'short': 6, 'bool': 4, 'char': 2}
      left_operand_dtype = right_operand_dtype = ""
      if "Tensor" in str(type(self)):
        left_operand_dtype = str(type(self)).split(".")[-1].split("Tensor")[0]
      else:
        left_operand_dtype = str(type(self)).split("'")[1]
      if "Tensor" in str(type(other)):
        right_operand_dtype = str(type(other)).split(".")[-1].split("Tensor")[0]
      else:
        right_operand_dtype = str(type(other)).split("'")[1]
      if (dtype_precedence_dict[left_operand_dtype] < dtype_precedence_dict[right_operand_dtype]):
        errorMsg = "cannot modify left hand operand datatype."
        raise TypeError(errorMsg)
      return bitwise_and(self, other)

    def __or__(self, other):
      return bitwise_or(self, other)

    def __ror__(self, other):
      return bitwise_or(other, self)

    def __ior__(self, other):
      """
        making sure left hand operand is immutable
      """
      dtype_precedence_dict = {'double': 16, 'float': 14, 'size_t': 12, 'long': 10, 'int': 8, 'short': 6, 'bool': 4, 'char': 2}
      left_operand_dtype = right_operand_dtype = ""
      if "Tensor" in str(type(self)):
        left_operand_dtype = str(type(self)).split(".")[-1].split("Tensor")[0]
      else:
        left_operand_dtype = str(type(self)).split("'")[1]
      if "Tensor" in str(type(other)):
        right_operand_dtype = str(type(other)).split(".")[-1].split("Tensor")[0]
      else:
        right_operand_dtype = str(type(other)).split("'")[1]
      if (dtype_precedence_dict[left_operand_dtype] < dtype_precedence_dict[right_operand_dtype]):
        errorMsg = "cannot modify left hand operand datatype."
        raise TypeError(errorMsg)
      return bitwise_or(self, other)

    def __xor__(self, other):
      return bitwise_xor(self, other)

    def __rxor__(self, other):
      return bitwise_xor(other, self)

    def __ixor__(self, other):
      """
        making sure left hand operand is immutable
      """
      dtype_precedence_dict = {'double': 16, 'float': 14, 'size_t': 12, 'long': 10, 'int': 8, 'short': 6, 'bool': 4, 'char': 2}
      left_operand_dtype = right_operand_dtype = ""
      if "Tensor" in str(type(self)):
        left_operand_dtype = str(type(self)).split(".")[-1].split("Tensor")[0]
      else:
        left_operand_dtype = str(type(self)).split("'")[1]
      if "Tensor" in str(type(other)):
        right_operand_dtype = str(type(other)).split(".")[-1].split("Tensor")[0]
      else:
        right_operand_dtype = str(type(other)).split("'")[1]
      if (dtype_precedence_dict[left_operand_dtype] < dtype_precedence_dict[right_operand_dtype]):
        errorMsg = "cannot modify left hand operand datatype."
        raise TypeError(errorMsg)
      return bitwise_xor(self, other)

    def __eq__(self, other):
      return equal(self, other)

    def __lt__(self, other):
      return less(self, other)

    def __gt__(self, other):
      return greater(self, other)

    def __ne__(self, other):
      return not_equal(self, other)

    def __le__(self, other):
      return less_equal(self, other)

    def __ge__(self, other):
      return greater_equal(self, other)



    def numpy(self) :
      """
         convert tensor to numpy array.
      """
      import numpy as np
      if (self.len() == 0):    # this is a deepC tensor bug, this if statement is a bypass for testing
        return np.array(self.data())
      return np.array(self.data()).reshape(self.shape())

    def len(self):
      """
         return length of tensor.
      """
      return self.length()

    def __iter__(self):
      """
         iterates over the tensor.
      """
      axis = 0
      while (axis < self.shape()[0]):
        yield self[axis]
        axis += 1

    def __int__(self):
      """
         convert tensor to int tensor.
      """
      if (self.len() > 1):
        raise TypeError("only length-1 tensor can be converted to Python scalars")
      elif(self.len() == 0):
        return
      return self.asTypeInt()

    def __float__(self):
      """
         convert tensor to float tensor.
      """
      if (self.len() > 1):
        raise TypeError("only length-1 tensor can be converted to Python scalars")
      elif(self.len() == 0):
        return
      return self.asTypeFloat()

    def __bool__(self):
      """
         convert tensor to bool tensor.
      """
      if (self.len() > 1):
        raise ValueError("The truth value of an array with more than one element is ambiguous. Use dc.any() or dc.all()")
      elif(self.len() == 0):
        return False
      return self.asTypeBool()


doubleTensor_swigregister = _dnnc.doubleTensor_swigregister
doubleTensor_swigregister(doubleTensor)

class vectorTensorBool(_object):
    """Proxy of C++ std::vector<(dnnc::tensor<(bool)>)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectorTensorBool, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectorTensorBool, name)
    __repr__ = _swig_repr

    def iterator(self):
        """
        iterator(self) -> SwigPyIterator

        Parameters
        ----------
        self: std::vector< dnnc::tensor< bool > > *

        """
        return _dnnc.vectorTensorBool_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """
        __nonzero__(self) -> bool

        Parameters
        ----------
        self: std::vector< dnnc::tensor< bool > > const *

        """
        return _dnnc.vectorTensorBool___nonzero__(self)


    def __bool__(self):
        """
        __bool__(self) -> bool

        Parameters
        ----------
        self: std::vector< dnnc::tensor< bool > > const *

        """
        return _dnnc.vectorTensorBool___bool__(self)


    def __len__(self):
        """
        __len__(self) -> std::vector< dnnc::tensor< bool > >::size_type

        Parameters
        ----------
        self: std::vector< dnnc::tensor< bool > > const *

        """
        return _dnnc.vectorTensorBool___len__(self)


    def __getslice__(self, i, j):
        """
        __getslice__(self, i, j) -> vectorTensorBool

        Parameters
        ----------
        i: std::vector< dnnc::tensor< bool > >::difference_type
        j: std::vector< dnnc::tensor< bool > >::difference_type

        """
        return _dnnc.vectorTensorBool___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< dnnc::tensor< bool > >::difference_type
        j: std::vector< dnnc::tensor< bool > >::difference_type

        __setslice__(self, i, j, v)

        Parameters
        ----------
        i: std::vector< dnnc::tensor< bool > >::difference_type
        j: std::vector< dnnc::tensor< bool > >::difference_type
        v: std::vector< dnnc::tensor< bool >,std::allocator< dnnc::tensor< bool > > > const &

        """
        return _dnnc.vectorTensorBool___setslice__(self, *args)


    def __delslice__(self, i, j):
        """
        __delslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< dnnc::tensor< bool > >::difference_type
        j: std::vector< dnnc::tensor< bool > >::difference_type

        """
        return _dnnc.vectorTensorBool___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(self, i)

        Parameters
        ----------
        i: std::vector< dnnc::tensor< bool > >::difference_type

        __delitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        """
        return _dnnc.vectorTensorBool___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(self, slice) -> vectorTensorBool

        Parameters
        ----------
        slice: PySliceObject *

        __getitem__(self, i) -> boolTensor

        Parameters
        ----------
        i: std::vector< dnnc::tensor< bool > >::difference_type

        """
        return _dnnc.vectorTensorBool___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(self, slice, v)

        Parameters
        ----------
        slice: PySliceObject *
        v: std::vector< dnnc::tensor< bool >,std::allocator< dnnc::tensor< bool > > > const &

        __setitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        __setitem__(self, i, x)

        Parameters
        ----------
        i: std::vector< dnnc::tensor< bool > >::difference_type
        x: std::vector< dnnc::tensor< bool > >::value_type const &

        """
        return _dnnc.vectorTensorBool___setitem__(self, *args)


    def pop(self):
        """
        pop(self) -> boolTensor

        Parameters
        ----------
        self: std::vector< dnnc::tensor< bool > > *

        """
        return _dnnc.vectorTensorBool_pop(self)


    def append(self, x):
        """
        append(self, x)

        Parameters
        ----------
        x: std::vector< dnnc::tensor< bool > >::value_type const &

        """
        return _dnnc.vectorTensorBool_append(self, x)


    def empty(self):
        """
        empty(self) -> bool

        Parameters
        ----------
        self: std::vector< dnnc::tensor< bool > > const *

        """
        return _dnnc.vectorTensorBool_empty(self)


    def size(self):
        """
        size(self) -> std::vector< dnnc::tensor< bool > >::size_type

        Parameters
        ----------
        self: std::vector< dnnc::tensor< bool > > const *

        """
        return _dnnc.vectorTensorBool_size(self)


    def swap(self, v):
        """
        swap(self, v)

        Parameters
        ----------
        v: std::vector< dnnc::tensor< bool > > &

        """
        return _dnnc.vectorTensorBool_swap(self, v)


    def begin(self):
        """
        begin(self) -> std::vector< dnnc::tensor< bool > >::iterator

        Parameters
        ----------
        self: std::vector< dnnc::tensor< bool > > *

        """
        return _dnnc.vectorTensorBool_begin(self)


    def end(self):
        """
        end(self) -> std::vector< dnnc::tensor< bool > >::iterator

        Parameters
        ----------
        self: std::vector< dnnc::tensor< bool > > *

        """
        return _dnnc.vectorTensorBool_end(self)


    def rbegin(self):
        """
        rbegin(self) -> std::vector< dnnc::tensor< bool > >::reverse_iterator

        Parameters
        ----------
        self: std::vector< dnnc::tensor< bool > > *

        """
        return _dnnc.vectorTensorBool_rbegin(self)


    def rend(self):
        """
        rend(self) -> std::vector< dnnc::tensor< bool > >::reverse_iterator

        Parameters
        ----------
        self: std::vector< dnnc::tensor< bool > > *

        """
        return _dnnc.vectorTensorBool_rend(self)


    def clear(self):
        """
        clear(self)

        Parameters
        ----------
        self: std::vector< dnnc::tensor< bool > > *

        """
        return _dnnc.vectorTensorBool_clear(self)


    def get_allocator(self):
        """
        get_allocator(self) -> std::vector< dnnc::tensor< bool > >::allocator_type

        Parameters
        ----------
        self: std::vector< dnnc::tensor< bool > > const *

        """
        return _dnnc.vectorTensorBool_get_allocator(self)


    def pop_back(self):
        """
        pop_back(self)

        Parameters
        ----------
        self: std::vector< dnnc::tensor< bool > > *

        """
        return _dnnc.vectorTensorBool_pop_back(self)


    def erase(self, *args):
        """
        erase(self, pos) -> std::vector< dnnc::tensor< bool > >::iterator

        Parameters
        ----------
        pos: std::vector< dnnc::tensor< bool > >::iterator

        erase(self, first, last) -> std::vector< dnnc::tensor< bool > >::iterator

        Parameters
        ----------
        first: std::vector< dnnc::tensor< bool > >::iterator
        last: std::vector< dnnc::tensor< bool > >::iterator

        """
        return _dnnc.vectorTensorBool_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(self) -> vectorTensorBool
        __init__(self, arg2) -> vectorTensorBool

        Parameters
        ----------
        arg2: std::vector< dnnc::tensor< bool > > const &

        __init__(self, size) -> vectorTensorBool

        Parameters
        ----------
        size: std::vector< dnnc::tensor< bool > >::size_type

        __init__(self, size, value) -> vectorTensorBool

        Parameters
        ----------
        size: std::vector< dnnc::tensor< bool > >::size_type
        value: std::vector< dnnc::tensor< bool > >::value_type const &

        """
        this = _dnnc.new_vectorTensorBool(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """
        push_back(self, x)

        Parameters
        ----------
        x: std::vector< dnnc::tensor< bool > >::value_type const &

        """
        return _dnnc.vectorTensorBool_push_back(self, x)


    def front(self):
        """
        front(self) -> boolTensor

        Parameters
        ----------
        self: std::vector< dnnc::tensor< bool > > const *

        """
        return _dnnc.vectorTensorBool_front(self)


    def back(self):
        """
        back(self) -> boolTensor

        Parameters
        ----------
        self: std::vector< dnnc::tensor< bool > > const *

        """
        return _dnnc.vectorTensorBool_back(self)


    def assign(self, n, x):
        """
        assign(self, n, x)

        Parameters
        ----------
        n: std::vector< dnnc::tensor< bool > >::size_type
        x: std::vector< dnnc::tensor< bool > >::value_type const &

        """
        return _dnnc.vectorTensorBool_assign(self, n, x)


    def resize(self, *args):
        """
        resize(self, new_size)

        Parameters
        ----------
        new_size: std::vector< dnnc::tensor< bool > >::size_type

        resize(self, new_size, x)

        Parameters
        ----------
        new_size: std::vector< dnnc::tensor< bool > >::size_type
        x: std::vector< dnnc::tensor< bool > >::value_type const &

        """
        return _dnnc.vectorTensorBool_resize(self, *args)


    def insert(self, *args):
        """
        insert(self, pos, x) -> std::vector< dnnc::tensor< bool > >::iterator

        Parameters
        ----------
        pos: std::vector< dnnc::tensor< bool > >::iterator
        x: std::vector< dnnc::tensor< bool > >::value_type const &

        insert(self, pos, n, x)

        Parameters
        ----------
        pos: std::vector< dnnc::tensor< bool > >::iterator
        n: std::vector< dnnc::tensor< bool > >::size_type
        x: std::vector< dnnc::tensor< bool > >::value_type const &

        """
        return _dnnc.vectorTensorBool_insert(self, *args)


    def reserve(self, n):
        """
        reserve(self, n)

        Parameters
        ----------
        n: std::vector< dnnc::tensor< bool > >::size_type

        """
        return _dnnc.vectorTensorBool_reserve(self, n)


    def capacity(self):
        """
        capacity(self) -> std::vector< dnnc::tensor< bool > >::size_type

        Parameters
        ----------
        self: std::vector< dnnc::tensor< bool > > const *

        """
        return _dnnc.vectorTensorBool_capacity(self)

    __swig_destroy__ = _dnnc.delete_vectorTensorBool
    __del__ = lambda self: None
vectorTensorBool_swigregister = _dnnc.vectorTensorBool_swigregister
vectorTensorBool_swigregister(vectorTensorBool)

class vectorTensorInt(_object):
    """Proxy of C++ std::vector<(dnnc::tensor<(int)>)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectorTensorInt, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectorTensorInt, name)
    __repr__ = _swig_repr

    def iterator(self):
        """
        iterator(self) -> SwigPyIterator

        Parameters
        ----------
        self: std::vector< dnnc::tensor< int > > *

        """
        return _dnnc.vectorTensorInt_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """
        __nonzero__(self) -> bool

        Parameters
        ----------
        self: std::vector< dnnc::tensor< int > > const *

        """
        return _dnnc.vectorTensorInt___nonzero__(self)


    def __bool__(self):
        """
        __bool__(self) -> bool

        Parameters
        ----------
        self: std::vector< dnnc::tensor< int > > const *

        """
        return _dnnc.vectorTensorInt___bool__(self)


    def __len__(self):
        """
        __len__(self) -> std::vector< dnnc::tensor< int > >::size_type

        Parameters
        ----------
        self: std::vector< dnnc::tensor< int > > const *

        """
        return _dnnc.vectorTensorInt___len__(self)


    def __getslice__(self, i, j):
        """
        __getslice__(self, i, j) -> vectorTensorInt

        Parameters
        ----------
        i: std::vector< dnnc::tensor< int > >::difference_type
        j: std::vector< dnnc::tensor< int > >::difference_type

        """
        return _dnnc.vectorTensorInt___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< dnnc::tensor< int > >::difference_type
        j: std::vector< dnnc::tensor< int > >::difference_type

        __setslice__(self, i, j, v)

        Parameters
        ----------
        i: std::vector< dnnc::tensor< int > >::difference_type
        j: std::vector< dnnc::tensor< int > >::difference_type
        v: std::vector< dnnc::tensor< int >,std::allocator< dnnc::tensor< int > > > const &

        """
        return _dnnc.vectorTensorInt___setslice__(self, *args)


    def __delslice__(self, i, j):
        """
        __delslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< dnnc::tensor< int > >::difference_type
        j: std::vector< dnnc::tensor< int > >::difference_type

        """
        return _dnnc.vectorTensorInt___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(self, i)

        Parameters
        ----------
        i: std::vector< dnnc::tensor< int > >::difference_type

        __delitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        """
        return _dnnc.vectorTensorInt___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(self, slice) -> vectorTensorInt

        Parameters
        ----------
        slice: PySliceObject *

        __getitem__(self, i) -> intTensor

        Parameters
        ----------
        i: std::vector< dnnc::tensor< int > >::difference_type

        """
        return _dnnc.vectorTensorInt___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(self, slice, v)

        Parameters
        ----------
        slice: PySliceObject *
        v: std::vector< dnnc::tensor< int >,std::allocator< dnnc::tensor< int > > > const &

        __setitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        __setitem__(self, i, x)

        Parameters
        ----------
        i: std::vector< dnnc::tensor< int > >::difference_type
        x: std::vector< dnnc::tensor< int > >::value_type const &

        """
        return _dnnc.vectorTensorInt___setitem__(self, *args)


    def pop(self):
        """
        pop(self) -> intTensor

        Parameters
        ----------
        self: std::vector< dnnc::tensor< int > > *

        """
        return _dnnc.vectorTensorInt_pop(self)


    def append(self, x):
        """
        append(self, x)

        Parameters
        ----------
        x: std::vector< dnnc::tensor< int > >::value_type const &

        """
        return _dnnc.vectorTensorInt_append(self, x)


    def empty(self):
        """
        empty(self) -> bool

        Parameters
        ----------
        self: std::vector< dnnc::tensor< int > > const *

        """
        return _dnnc.vectorTensorInt_empty(self)


    def size(self):
        """
        size(self) -> std::vector< dnnc::tensor< int > >::size_type

        Parameters
        ----------
        self: std::vector< dnnc::tensor< int > > const *

        """
        return _dnnc.vectorTensorInt_size(self)


    def swap(self, v):
        """
        swap(self, v)

        Parameters
        ----------
        v: std::vector< dnnc::tensor< int > > &

        """
        return _dnnc.vectorTensorInt_swap(self, v)


    def begin(self):
        """
        begin(self) -> std::vector< dnnc::tensor< int > >::iterator

        Parameters
        ----------
        self: std::vector< dnnc::tensor< int > > *

        """
        return _dnnc.vectorTensorInt_begin(self)


    def end(self):
        """
        end(self) -> std::vector< dnnc::tensor< int > >::iterator

        Parameters
        ----------
        self: std::vector< dnnc::tensor< int > > *

        """
        return _dnnc.vectorTensorInt_end(self)


    def rbegin(self):
        """
        rbegin(self) -> std::vector< dnnc::tensor< int > >::reverse_iterator

        Parameters
        ----------
        self: std::vector< dnnc::tensor< int > > *

        """
        return _dnnc.vectorTensorInt_rbegin(self)


    def rend(self):
        """
        rend(self) -> std::vector< dnnc::tensor< int > >::reverse_iterator

        Parameters
        ----------
        self: std::vector< dnnc::tensor< int > > *

        """
        return _dnnc.vectorTensorInt_rend(self)


    def clear(self):
        """
        clear(self)

        Parameters
        ----------
        self: std::vector< dnnc::tensor< int > > *

        """
        return _dnnc.vectorTensorInt_clear(self)


    def get_allocator(self):
        """
        get_allocator(self) -> std::vector< dnnc::tensor< int > >::allocator_type

        Parameters
        ----------
        self: std::vector< dnnc::tensor< int > > const *

        """
        return _dnnc.vectorTensorInt_get_allocator(self)


    def pop_back(self):
        """
        pop_back(self)

        Parameters
        ----------
        self: std::vector< dnnc::tensor< int > > *

        """
        return _dnnc.vectorTensorInt_pop_back(self)


    def erase(self, *args):
        """
        erase(self, pos) -> std::vector< dnnc::tensor< int > >::iterator

        Parameters
        ----------
        pos: std::vector< dnnc::tensor< int > >::iterator

        erase(self, first, last) -> std::vector< dnnc::tensor< int > >::iterator

        Parameters
        ----------
        first: std::vector< dnnc::tensor< int > >::iterator
        last: std::vector< dnnc::tensor< int > >::iterator

        """
        return _dnnc.vectorTensorInt_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(self) -> vectorTensorInt
        __init__(self, arg2) -> vectorTensorInt

        Parameters
        ----------
        arg2: std::vector< dnnc::tensor< int > > const &

        __init__(self, size) -> vectorTensorInt

        Parameters
        ----------
        size: std::vector< dnnc::tensor< int > >::size_type

        __init__(self, size, value) -> vectorTensorInt

        Parameters
        ----------
        size: std::vector< dnnc::tensor< int > >::size_type
        value: std::vector< dnnc::tensor< int > >::value_type const &

        """
        this = _dnnc.new_vectorTensorInt(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """
        push_back(self, x)

        Parameters
        ----------
        x: std::vector< dnnc::tensor< int > >::value_type const &

        """
        return _dnnc.vectorTensorInt_push_back(self, x)


    def front(self):
        """
        front(self) -> intTensor

        Parameters
        ----------
        self: std::vector< dnnc::tensor< int > > const *

        """
        return _dnnc.vectorTensorInt_front(self)


    def back(self):
        """
        back(self) -> intTensor

        Parameters
        ----------
        self: std::vector< dnnc::tensor< int > > const *

        """
        return _dnnc.vectorTensorInt_back(self)


    def assign(self, n, x):
        """
        assign(self, n, x)

        Parameters
        ----------
        n: std::vector< dnnc::tensor< int > >::size_type
        x: std::vector< dnnc::tensor< int > >::value_type const &

        """
        return _dnnc.vectorTensorInt_assign(self, n, x)


    def resize(self, *args):
        """
        resize(self, new_size)

        Parameters
        ----------
        new_size: std::vector< dnnc::tensor< int > >::size_type

        resize(self, new_size, x)

        Parameters
        ----------
        new_size: std::vector< dnnc::tensor< int > >::size_type
        x: std::vector< dnnc::tensor< int > >::value_type const &

        """
        return _dnnc.vectorTensorInt_resize(self, *args)


    def insert(self, *args):
        """
        insert(self, pos, x) -> std::vector< dnnc::tensor< int > >::iterator

        Parameters
        ----------
        pos: std::vector< dnnc::tensor< int > >::iterator
        x: std::vector< dnnc::tensor< int > >::value_type const &

        insert(self, pos, n, x)

        Parameters
        ----------
        pos: std::vector< dnnc::tensor< int > >::iterator
        n: std::vector< dnnc::tensor< int > >::size_type
        x: std::vector< dnnc::tensor< int > >::value_type const &

        """
        return _dnnc.vectorTensorInt_insert(self, *args)


    def reserve(self, n):
        """
        reserve(self, n)

        Parameters
        ----------
        n: std::vector< dnnc::tensor< int > >::size_type

        """
        return _dnnc.vectorTensorInt_reserve(self, n)


    def capacity(self):
        """
        capacity(self) -> std::vector< dnnc::tensor< int > >::size_type

        Parameters
        ----------
        self: std::vector< dnnc::tensor< int > > const *

        """
        return _dnnc.vectorTensorInt_capacity(self)

    __swig_destroy__ = _dnnc.delete_vectorTensorInt
    __del__ = lambda self: None
vectorTensorInt_swigregister = _dnnc.vectorTensorInt_swigregister
vectorTensorInt_swigregister(vectorTensorInt)

class vectorTensorSizeT(_object):
    """Proxy of C++ std::vector<(dnnc::tensor<(size_t)>)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectorTensorSizeT, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectorTensorSizeT, name)
    __repr__ = _swig_repr

    def iterator(self):
        """
        iterator(self) -> SwigPyIterator

        Parameters
        ----------
        self: std::vector< dnnc::tensor< size_t > > *

        """
        return _dnnc.vectorTensorSizeT_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """
        __nonzero__(self) -> bool

        Parameters
        ----------
        self: std::vector< dnnc::tensor< size_t > > const *

        """
        return _dnnc.vectorTensorSizeT___nonzero__(self)


    def __bool__(self):
        """
        __bool__(self) -> bool

        Parameters
        ----------
        self: std::vector< dnnc::tensor< size_t > > const *

        """
        return _dnnc.vectorTensorSizeT___bool__(self)


    def __len__(self):
        """
        __len__(self) -> std::vector< dnnc::tensor< size_t > >::size_type

        Parameters
        ----------
        self: std::vector< dnnc::tensor< size_t > > const *

        """
        return _dnnc.vectorTensorSizeT___len__(self)


    def __getslice__(self, i, j):
        """
        __getslice__(self, i, j) -> vectorTensorSizeT

        Parameters
        ----------
        i: std::vector< dnnc::tensor< size_t > >::difference_type
        j: std::vector< dnnc::tensor< size_t > >::difference_type

        """
        return _dnnc.vectorTensorSizeT___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< dnnc::tensor< size_t > >::difference_type
        j: std::vector< dnnc::tensor< size_t > >::difference_type

        __setslice__(self, i, j, v)

        Parameters
        ----------
        i: std::vector< dnnc::tensor< size_t > >::difference_type
        j: std::vector< dnnc::tensor< size_t > >::difference_type
        v: std::vector< dnnc::tensor< size_t >,std::allocator< dnnc::tensor< size_t > > > const &

        """
        return _dnnc.vectorTensorSizeT___setslice__(self, *args)


    def __delslice__(self, i, j):
        """
        __delslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< dnnc::tensor< size_t > >::difference_type
        j: std::vector< dnnc::tensor< size_t > >::difference_type

        """
        return _dnnc.vectorTensorSizeT___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(self, i)

        Parameters
        ----------
        i: std::vector< dnnc::tensor< size_t > >::difference_type

        __delitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        """
        return _dnnc.vectorTensorSizeT___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(self, slice) -> vectorTensorSizeT

        Parameters
        ----------
        slice: PySliceObject *

        __getitem__(self, i) -> uLongTensor

        Parameters
        ----------
        i: std::vector< dnnc::tensor< size_t > >::difference_type

        """
        return _dnnc.vectorTensorSizeT___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(self, slice, v)

        Parameters
        ----------
        slice: PySliceObject *
        v: std::vector< dnnc::tensor< size_t >,std::allocator< dnnc::tensor< size_t > > > const &

        __setitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        __setitem__(self, i, x)

        Parameters
        ----------
        i: std::vector< dnnc::tensor< size_t > >::difference_type
        x: std::vector< dnnc::tensor< size_t > >::value_type const &

        """
        return _dnnc.vectorTensorSizeT___setitem__(self, *args)


    def pop(self):
        """
        pop(self) -> uLongTensor

        Parameters
        ----------
        self: std::vector< dnnc::tensor< size_t > > *

        """
        return _dnnc.vectorTensorSizeT_pop(self)


    def append(self, x):
        """
        append(self, x)

        Parameters
        ----------
        x: std::vector< dnnc::tensor< size_t > >::value_type const &

        """
        return _dnnc.vectorTensorSizeT_append(self, x)


    def empty(self):
        """
        empty(self) -> bool

        Parameters
        ----------
        self: std::vector< dnnc::tensor< size_t > > const *

        """
        return _dnnc.vectorTensorSizeT_empty(self)


    def size(self):
        """
        size(self) -> std::vector< dnnc::tensor< size_t > >::size_type

        Parameters
        ----------
        self: std::vector< dnnc::tensor< size_t > > const *

        """
        return _dnnc.vectorTensorSizeT_size(self)


    def swap(self, v):
        """
        swap(self, v)

        Parameters
        ----------
        v: std::vector< dnnc::tensor< size_t > > &

        """
        return _dnnc.vectorTensorSizeT_swap(self, v)


    def begin(self):
        """
        begin(self) -> std::vector< dnnc::tensor< size_t > >::iterator

        Parameters
        ----------
        self: std::vector< dnnc::tensor< size_t > > *

        """
        return _dnnc.vectorTensorSizeT_begin(self)


    def end(self):
        """
        end(self) -> std::vector< dnnc::tensor< size_t > >::iterator

        Parameters
        ----------
        self: std::vector< dnnc::tensor< size_t > > *

        """
        return _dnnc.vectorTensorSizeT_end(self)


    def rbegin(self):
        """
        rbegin(self) -> std::vector< dnnc::tensor< size_t > >::reverse_iterator

        Parameters
        ----------
        self: std::vector< dnnc::tensor< size_t > > *

        """
        return _dnnc.vectorTensorSizeT_rbegin(self)


    def rend(self):
        """
        rend(self) -> std::vector< dnnc::tensor< size_t > >::reverse_iterator

        Parameters
        ----------
        self: std::vector< dnnc::tensor< size_t > > *

        """
        return _dnnc.vectorTensorSizeT_rend(self)


    def clear(self):
        """
        clear(self)

        Parameters
        ----------
        self: std::vector< dnnc::tensor< size_t > > *

        """
        return _dnnc.vectorTensorSizeT_clear(self)


    def get_allocator(self):
        """
        get_allocator(self) -> std::vector< dnnc::tensor< size_t > >::allocator_type

        Parameters
        ----------
        self: std::vector< dnnc::tensor< size_t > > const *

        """
        return _dnnc.vectorTensorSizeT_get_allocator(self)


    def pop_back(self):
        """
        pop_back(self)

        Parameters
        ----------
        self: std::vector< dnnc::tensor< size_t > > *

        """
        return _dnnc.vectorTensorSizeT_pop_back(self)


    def erase(self, *args):
        """
        erase(self, pos) -> std::vector< dnnc::tensor< size_t > >::iterator

        Parameters
        ----------
        pos: std::vector< dnnc::tensor< size_t > >::iterator

        erase(self, first, last) -> std::vector< dnnc::tensor< size_t > >::iterator

        Parameters
        ----------
        first: std::vector< dnnc::tensor< size_t > >::iterator
        last: std::vector< dnnc::tensor< size_t > >::iterator

        """
        return _dnnc.vectorTensorSizeT_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(self) -> vectorTensorSizeT
        __init__(self, arg2) -> vectorTensorSizeT

        Parameters
        ----------
        arg2: std::vector< dnnc::tensor< size_t > > const &

        __init__(self, size) -> vectorTensorSizeT

        Parameters
        ----------
        size: std::vector< dnnc::tensor< size_t > >::size_type

        __init__(self, size, value) -> vectorTensorSizeT

        Parameters
        ----------
        size: std::vector< dnnc::tensor< size_t > >::size_type
        value: std::vector< dnnc::tensor< size_t > >::value_type const &

        """
        this = _dnnc.new_vectorTensorSizeT(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """
        push_back(self, x)

        Parameters
        ----------
        x: std::vector< dnnc::tensor< size_t > >::value_type const &

        """
        return _dnnc.vectorTensorSizeT_push_back(self, x)


    def front(self):
        """
        front(self) -> uLongTensor

        Parameters
        ----------
        self: std::vector< dnnc::tensor< size_t > > const *

        """
        return _dnnc.vectorTensorSizeT_front(self)


    def back(self):
        """
        back(self) -> uLongTensor

        Parameters
        ----------
        self: std::vector< dnnc::tensor< size_t > > const *

        """
        return _dnnc.vectorTensorSizeT_back(self)


    def assign(self, n, x):
        """
        assign(self, n, x)

        Parameters
        ----------
        n: std::vector< dnnc::tensor< size_t > >::size_type
        x: std::vector< dnnc::tensor< size_t > >::value_type const &

        """
        return _dnnc.vectorTensorSizeT_assign(self, n, x)


    def resize(self, *args):
        """
        resize(self, new_size)

        Parameters
        ----------
        new_size: std::vector< dnnc::tensor< size_t > >::size_type

        resize(self, new_size, x)

        Parameters
        ----------
        new_size: std::vector< dnnc::tensor< size_t > >::size_type
        x: std::vector< dnnc::tensor< size_t > >::value_type const &

        """
        return _dnnc.vectorTensorSizeT_resize(self, *args)


    def insert(self, *args):
        """
        insert(self, pos, x) -> std::vector< dnnc::tensor< size_t > >::iterator

        Parameters
        ----------
        pos: std::vector< dnnc::tensor< size_t > >::iterator
        x: std::vector< dnnc::tensor< size_t > >::value_type const &

        insert(self, pos, n, x)

        Parameters
        ----------
        pos: std::vector< dnnc::tensor< size_t > >::iterator
        n: std::vector< dnnc::tensor< size_t > >::size_type
        x: std::vector< dnnc::tensor< size_t > >::value_type const &

        """
        return _dnnc.vectorTensorSizeT_insert(self, *args)


    def reserve(self, n):
        """
        reserve(self, n)

        Parameters
        ----------
        n: std::vector< dnnc::tensor< size_t > >::size_type

        """
        return _dnnc.vectorTensorSizeT_reserve(self, n)


    def capacity(self):
        """
        capacity(self) -> std::vector< dnnc::tensor< size_t > >::size_type

        Parameters
        ----------
        self: std::vector< dnnc::tensor< size_t > > const *

        """
        return _dnnc.vectorTensorSizeT_capacity(self)

    __swig_destroy__ = _dnnc.delete_vectorTensorSizeT
    __del__ = lambda self: None
vectorTensorSizeT_swigregister = _dnnc.vectorTensorSizeT_swigregister
vectorTensorSizeT_swigregister(vectorTensorSizeT)

class vectorTensorFloat(_object):
    """Proxy of C++ std::vector<(dnnc::tensor<(float)>)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectorTensorFloat, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectorTensorFloat, name)
    __repr__ = _swig_repr

    def iterator(self):
        """
        iterator(self) -> SwigPyIterator

        Parameters
        ----------
        self: std::vector< dnnc::tensor< float > > *

        """
        return _dnnc.vectorTensorFloat_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """
        __nonzero__(self) -> bool

        Parameters
        ----------
        self: std::vector< dnnc::tensor< float > > const *

        """
        return _dnnc.vectorTensorFloat___nonzero__(self)


    def __bool__(self):
        """
        __bool__(self) -> bool

        Parameters
        ----------
        self: std::vector< dnnc::tensor< float > > const *

        """
        return _dnnc.vectorTensorFloat___bool__(self)


    def __len__(self):
        """
        __len__(self) -> std::vector< dnnc::tensor< float > >::size_type

        Parameters
        ----------
        self: std::vector< dnnc::tensor< float > > const *

        """
        return _dnnc.vectorTensorFloat___len__(self)


    def __getslice__(self, i, j):
        """
        __getslice__(self, i, j) -> vectorTensorFloat

        Parameters
        ----------
        i: std::vector< dnnc::tensor< float > >::difference_type
        j: std::vector< dnnc::tensor< float > >::difference_type

        """
        return _dnnc.vectorTensorFloat___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< dnnc::tensor< float > >::difference_type
        j: std::vector< dnnc::tensor< float > >::difference_type

        __setslice__(self, i, j, v)

        Parameters
        ----------
        i: std::vector< dnnc::tensor< float > >::difference_type
        j: std::vector< dnnc::tensor< float > >::difference_type
        v: std::vector< dnnc::tensor< float >,std::allocator< dnnc::tensor< float > > > const &

        """
        return _dnnc.vectorTensorFloat___setslice__(self, *args)


    def __delslice__(self, i, j):
        """
        __delslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< dnnc::tensor< float > >::difference_type
        j: std::vector< dnnc::tensor< float > >::difference_type

        """
        return _dnnc.vectorTensorFloat___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(self, i)

        Parameters
        ----------
        i: std::vector< dnnc::tensor< float > >::difference_type

        __delitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        """
        return _dnnc.vectorTensorFloat___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(self, slice) -> vectorTensorFloat

        Parameters
        ----------
        slice: PySliceObject *

        __getitem__(self, i) -> floatTensor

        Parameters
        ----------
        i: std::vector< dnnc::tensor< float > >::difference_type

        """
        return _dnnc.vectorTensorFloat___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(self, slice, v)

        Parameters
        ----------
        slice: PySliceObject *
        v: std::vector< dnnc::tensor< float >,std::allocator< dnnc::tensor< float > > > const &

        __setitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        __setitem__(self, i, x)

        Parameters
        ----------
        i: std::vector< dnnc::tensor< float > >::difference_type
        x: std::vector< dnnc::tensor< float > >::value_type const &

        """
        return _dnnc.vectorTensorFloat___setitem__(self, *args)


    def pop(self):
        """
        pop(self) -> floatTensor

        Parameters
        ----------
        self: std::vector< dnnc::tensor< float > > *

        """
        return _dnnc.vectorTensorFloat_pop(self)


    def append(self, x):
        """
        append(self, x)

        Parameters
        ----------
        x: std::vector< dnnc::tensor< float > >::value_type const &

        """
        return _dnnc.vectorTensorFloat_append(self, x)


    def empty(self):
        """
        empty(self) -> bool

        Parameters
        ----------
        self: std::vector< dnnc::tensor< float > > const *

        """
        return _dnnc.vectorTensorFloat_empty(self)


    def size(self):
        """
        size(self) -> std::vector< dnnc::tensor< float > >::size_type

        Parameters
        ----------
        self: std::vector< dnnc::tensor< float > > const *

        """
        return _dnnc.vectorTensorFloat_size(self)


    def swap(self, v):
        """
        swap(self, v)

        Parameters
        ----------
        v: std::vector< dnnc::tensor< float > > &

        """
        return _dnnc.vectorTensorFloat_swap(self, v)


    def begin(self):
        """
        begin(self) -> std::vector< dnnc::tensor< float > >::iterator

        Parameters
        ----------
        self: std::vector< dnnc::tensor< float > > *

        """
        return _dnnc.vectorTensorFloat_begin(self)


    def end(self):
        """
        end(self) -> std::vector< dnnc::tensor< float > >::iterator

        Parameters
        ----------
        self: std::vector< dnnc::tensor< float > > *

        """
        return _dnnc.vectorTensorFloat_end(self)


    def rbegin(self):
        """
        rbegin(self) -> std::vector< dnnc::tensor< float > >::reverse_iterator

        Parameters
        ----------
        self: std::vector< dnnc::tensor< float > > *

        """
        return _dnnc.vectorTensorFloat_rbegin(self)


    def rend(self):
        """
        rend(self) -> std::vector< dnnc::tensor< float > >::reverse_iterator

        Parameters
        ----------
        self: std::vector< dnnc::tensor< float > > *

        """
        return _dnnc.vectorTensorFloat_rend(self)


    def clear(self):
        """
        clear(self)

        Parameters
        ----------
        self: std::vector< dnnc::tensor< float > > *

        """
        return _dnnc.vectorTensorFloat_clear(self)


    def get_allocator(self):
        """
        get_allocator(self) -> std::vector< dnnc::tensor< float > >::allocator_type

        Parameters
        ----------
        self: std::vector< dnnc::tensor< float > > const *

        """
        return _dnnc.vectorTensorFloat_get_allocator(self)


    def pop_back(self):
        """
        pop_back(self)

        Parameters
        ----------
        self: std::vector< dnnc::tensor< float > > *

        """
        return _dnnc.vectorTensorFloat_pop_back(self)


    def erase(self, *args):
        """
        erase(self, pos) -> std::vector< dnnc::tensor< float > >::iterator

        Parameters
        ----------
        pos: std::vector< dnnc::tensor< float > >::iterator

        erase(self, first, last) -> std::vector< dnnc::tensor< float > >::iterator

        Parameters
        ----------
        first: std::vector< dnnc::tensor< float > >::iterator
        last: std::vector< dnnc::tensor< float > >::iterator

        """
        return _dnnc.vectorTensorFloat_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(self) -> vectorTensorFloat
        __init__(self, arg2) -> vectorTensorFloat

        Parameters
        ----------
        arg2: std::vector< dnnc::tensor< float > > const &

        __init__(self, size) -> vectorTensorFloat

        Parameters
        ----------
        size: std::vector< dnnc::tensor< float > >::size_type

        __init__(self, size, value) -> vectorTensorFloat

        Parameters
        ----------
        size: std::vector< dnnc::tensor< float > >::size_type
        value: std::vector< dnnc::tensor< float > >::value_type const &

        """
        this = _dnnc.new_vectorTensorFloat(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """
        push_back(self, x)

        Parameters
        ----------
        x: std::vector< dnnc::tensor< float > >::value_type const &

        """
        return _dnnc.vectorTensorFloat_push_back(self, x)


    def front(self):
        """
        front(self) -> floatTensor

        Parameters
        ----------
        self: std::vector< dnnc::tensor< float > > const *

        """
        return _dnnc.vectorTensorFloat_front(self)


    def back(self):
        """
        back(self) -> floatTensor

        Parameters
        ----------
        self: std::vector< dnnc::tensor< float > > const *

        """
        return _dnnc.vectorTensorFloat_back(self)


    def assign(self, n, x):
        """
        assign(self, n, x)

        Parameters
        ----------
        n: std::vector< dnnc::tensor< float > >::size_type
        x: std::vector< dnnc::tensor< float > >::value_type const &

        """
        return _dnnc.vectorTensorFloat_assign(self, n, x)


    def resize(self, *args):
        """
        resize(self, new_size)

        Parameters
        ----------
        new_size: std::vector< dnnc::tensor< float > >::size_type

        resize(self, new_size, x)

        Parameters
        ----------
        new_size: std::vector< dnnc::tensor< float > >::size_type
        x: std::vector< dnnc::tensor< float > >::value_type const &

        """
        return _dnnc.vectorTensorFloat_resize(self, *args)


    def insert(self, *args):
        """
        insert(self, pos, x) -> std::vector< dnnc::tensor< float > >::iterator

        Parameters
        ----------
        pos: std::vector< dnnc::tensor< float > >::iterator
        x: std::vector< dnnc::tensor< float > >::value_type const &

        insert(self, pos, n, x)

        Parameters
        ----------
        pos: std::vector< dnnc::tensor< float > >::iterator
        n: std::vector< dnnc::tensor< float > >::size_type
        x: std::vector< dnnc::tensor< float > >::value_type const &

        """
        return _dnnc.vectorTensorFloat_insert(self, *args)


    def reserve(self, n):
        """
        reserve(self, n)

        Parameters
        ----------
        n: std::vector< dnnc::tensor< float > >::size_type

        """
        return _dnnc.vectorTensorFloat_reserve(self, n)


    def capacity(self):
        """
        capacity(self) -> std::vector< dnnc::tensor< float > >::size_type

        Parameters
        ----------
        self: std::vector< dnnc::tensor< float > > const *

        """
        return _dnnc.vectorTensorFloat_capacity(self)

    __swig_destroy__ = _dnnc.delete_vectorTensorFloat
    __del__ = lambda self: None
vectorTensorFloat_swigregister = _dnnc.vectorTensorFloat_swigregister
vectorTensorFloat_swigregister(vectorTensorFloat)

class irTypeData(_object):
    """Proxy of C++ dnnc::irTypeData class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, irTypeData, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, irTypeData, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, ty, d) -> irTypeData

        Parameters
        ----------
        ty: enum dnnc::IR_DataType
        d: std::vector< int,std::allocator< int > > &

        __init__(self, ty, d) -> irTypeData

        Parameters
        ----------
        ty: enum dnnc::IR_DataType
        d: std::vector< float,std::allocator< float > > &

        __init__(self, ty, d) -> irTypeData

        Parameters
        ----------
        ty: enum dnnc::IR_DataType
        d: std::vector< std::string,std::allocator< std::string > > &

        __init__(self, ty, d) -> irTypeData

        Parameters
        ----------
        ty: enum dnnc::IR_DataType
        d: std::vector< dnnc::tensor< bool >,std::allocator< dnnc::tensor< bool > > > &

        __init__(self, ty, d) -> irTypeData

        Parameters
        ----------
        ty: enum dnnc::IR_DataType
        d: std::vector< dnnc::tensor< int >,std::allocator< dnnc::tensor< int > > > &

        __init__(self, ty, d) -> irTypeData

        Parameters
        ----------
        ty: enum dnnc::IR_DataType
        d: std::vector< dnnc::tensor< float >,std::allocator< dnnc::tensor< float > > > &

        __init__(self, other) -> irTypeData

        Parameters
        ----------
        other: dnnc::irTypeData const &

        """
        this = _dnnc.new_irTypeData(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _dnnc.delete_irTypeData
    __del__ = lambda self: None

    def type(self):
        """
        type(self) -> dnnc::IR_DataType

        Parameters
        ----------
        self: dnnc::irTypeData *

        """
        return _dnnc.irTypeData_type(self)

irTypeData_swigregister = _dnnc.irTypeData_swigregister
irTypeData_swigregister(irTypeData)

class dnnParameters(_object):
    """Proxy of C++ dnnc::dnnParameters class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, dnnParameters, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, dnnParameters, name)
    __repr__ = _swig_repr

    def __init__(self, n, shape, v):
        """
        __init__(self, n, shape, v) -> dnnParameters

        Parameters
        ----------
        n: std::string
        shape: std::vector< dnnc::DIMENSION,std::allocator< dnnc::DIMENSION > >
        v: dnnc::irTypeData &

        """
        this = _dnnc.new_dnnParameters(n, shape, v)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def name(self):
        """
        name(self) -> std::string

        Parameters
        ----------
        self: dnnc::dnnParameters *

        """
        return _dnnc.dnnParameters_name(self)


    def shape(self):
        """
        shape(self) -> vectorSizeT

        Parameters
        ----------
        self: dnnc::dnnParameters *

        """
        return _dnnc.dnnParameters_shape(self)


    def data(self):
        """
        data(self) -> irTypeData

        Parameters
        ----------
        self: dnnc::dnnParameters *

        """
        return _dnnc.dnnParameters_data(self)

    __swig_destroy__ = _dnnc.delete_dnnParameters
    __del__ = lambda self: None
dnnParameters_swigregister = _dnnc.dnnParameters_swigregister
dnnParameters_swigregister(dnnParameters)

class nodeAttribute(_object):
    """Proxy of C++ dnnc::nodeAttribute class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, nodeAttribute, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, nodeAttribute, name)
    __repr__ = _swig_repr

    def __init__(self, n, v):
        """
        __init__(self, n, v) -> nodeAttribute

        Parameters
        ----------
        n: enum dnnc::OPATTR
        v: dnnc::irTypeData &

        """
        this = _dnnc.new_nodeAttribute(n, v)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def name(self):
        """
        name(self) -> dnnc::OPATTR

        Parameters
        ----------
        self: dnnc::nodeAttribute *

        """
        return _dnnc.nodeAttribute_name(self)


    def data(self):
        """
        data(self) -> irTypeData

        Parameters
        ----------
        self: dnnc::nodeAttribute *

        """
        return _dnnc.nodeAttribute_data(self)

    __swig_destroy__ = _dnnc.delete_nodeAttribute
    __del__ = lambda self: None
nodeAttribute_swigregister = _dnnc.nodeAttribute_swigregister
nodeAttribute_swigregister(nodeAttribute)

class node(_object):
    """Proxy of C++ dnnc::node class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, node, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, node, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    NONE = _dnnc.node_NONE
    INPUT = _dnnc.node_INPUT
    OUTPUT = _dnnc.node_OUTPUT
    OPERATOR = _dnnc.node_OPERATOR
    NOT_VISITED = _dnnc.node_NOT_VISITED
    VISITING = _dnnc.node_VISITING
    VISITED = _dnnc.node_VISITED

    def mark(self, prop):
        """
        mark(self, prop)

        Parameters
        ----------
        prop: short

        """
        return _dnnc.node_mark(self, prop)


    def unmark(self, prop):
        """
        unmark(self, prop)

        Parameters
        ----------
        prop: short

        """
        return _dnnc.node_unmark(self, prop)


    def isMarked(self, prop):
        """
        isMarked(self, prop) -> bool

        Parameters
        ----------
        prop: short

        """
        return _dnnc.node_isMarked(self, prop)


    def resetMarks(self):
        """
        resetMarks(self)

        Parameters
        ----------
        self: dnnc::node *

        """
        return _dnnc.node_resetMarks(self)


    def setName(self, n):
        """
        setName(self, n)

        Parameters
        ----------
        n: std::string

        """
        return _dnnc.node_setName(self, n)


    def name(self):
        """
        name(self) -> std::string

        Parameters
        ----------
        self: dnnc::node *

        """
        return _dnnc.node_name(self)


    def symbol(self):
        """
        symbol(self) -> dnnc::OPCODE

        Parameters
        ----------
        self: dnnc::node *

        """
        return _dnnc.node_symbol(self)


    def ntype(self):
        """
        ntype(self) -> dnnc::node::NODE_TYPE

        Parameters
        ----------
        self: dnnc::node *

        """
        return _dnnc.node_ntype(self)


    def dtype(self):
        """
        dtype(self) -> dnnc::DNNC_DataType

        Parameters
        ----------
        self: dnnc::node *

        """
        return _dnnc.node_dtype(self)


    def inputNodes(self, g, nodes):
        """
        inputNodes(self, g, nodes) -> bool

        Parameters
        ----------
        g: dnnc::graph &
        nodes: std::vector< dnnc::node *,std::allocator< dnnc::node * > > &

        """
        return _dnnc.node_inputNodes(self, g, nodes)


    def outputNodes(self, g, nodes):
        """
        outputNodes(self, g, nodes) -> bool

        Parameters
        ----------
        g: dnnc::graph &
        nodes: std::vector< dnnc::node *,std::allocator< dnnc::node * > > &

        """
        return _dnnc.node_outputNodes(self, g, nodes)

    __swig_destroy__ = _dnnc.delete_node
    __del__ = lambda self: None
node_swigregister = _dnnc.node_swigregister
node_swigregister(node)

class ioNode(node):
    """Proxy of C++ dnnc::ioNode class."""

    __swig_setmethods__ = {}
    for _s in [node]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ioNode, name, value)
    __swig_getmethods__ = {}
    for _s in [node]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ioNode, name)
    __repr__ = _swig_repr

    def __init__(self, n, nt, dt, shp):
        """
        __init__(self, n, nt, dt, shp) -> ioNode

        Parameters
        ----------
        n: std::string
        nt: enum dnnc::node::NODE_TYPE
        dt: enum dnnc::DNNC_DataType
        shp: std::vector< size_t,std::allocator< size_t > >

        """
        this = _dnnc.new_ioNode(n, nt, dt, shp)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def dtype(self):
        """
        dtype(self) -> dnnc::DNNC_DataType

        Parameters
        ----------
        self: dnnc::ioNode *

        """
        return _dnnc.ioNode_dtype(self)


    def ntype(self):
        """
        ntype(self) -> dnnc::node::NODE_TYPE

        Parameters
        ----------
        self: dnnc::ioNode *

        """
        return _dnnc.ioNode_ntype(self)


    def shape(self):
        """
        shape(self) -> vectorSizeT

        Parameters
        ----------
        self: dnnc::ioNode *

        """
        return _dnnc.ioNode_shape(self)


    def outputNodes(self, g, nodes):
        """
        outputNodes(self, g, nodes) -> bool

        Parameters
        ----------
        g: dnnc::graph &
        nodes: std::vector< dnnc::node *,std::allocator< dnnc::node * > > &

        """
        return _dnnc.ioNode_outputNodes(self, g, nodes)


    def inputNodes(self, g, nodes):
        """
        inputNodes(self, g, nodes) -> bool

        Parameters
        ----------
        g: dnnc::graph &
        nodes: std::vector< dnnc::node *,std::allocator< dnnc::node * > > &

        """
        return _dnnc.ioNode_inputNodes(self, g, nodes)

    __swig_destroy__ = _dnnc.delete_ioNode
    __del__ = lambda self: None
ioNode_swigregister = _dnnc.ioNode_swigregister
ioNode_swigregister(ioNode)

class opNode(node):
    """Proxy of C++ dnnc::opNode class."""

    __swig_setmethods__ = {}
    for _s in [node]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, opNode, name, value)
    __swig_getmethods__ = {}
    for _s in [node]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, opNode, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(self, sym, n) -> opNode

        Parameters
        ----------
        sym: enum dnnc::OPCODE
        n: std::string

        __init__(self, sym) -> opNode

        Parameters
        ----------
        sym: enum dnnc::OPCODE

        """
        this = _dnnc.new_opNode(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _dnnc.delete_opNode
    __del__ = lambda self: None

    def addInput(self, n):
        """
        addInput(self, n)

        Parameters
        ----------
        n: std::string

        """
        return _dnnc.opNode_addInput(self, n)


    def addOutput(self, n):
        """
        addOutput(self, n)

        Parameters
        ----------
        n: std::string

        """
        return _dnnc.opNode_addOutput(self, n)


    def addAttribute(self, attr):
        """
        addAttribute(self, attr)

        Parameters
        ----------
        attr: dnnc::nodeAttribute &

        """
        return _dnnc.opNode_addAttribute(self, attr)


    def symbol(self):
        """
        symbol(self) -> dnnc::OPCODE

        Parameters
        ----------
        self: dnnc::opNode *

        """
        return _dnnc.opNode_symbol(self)


    def ntype(self):
        """
        ntype(self) -> dnnc::node::NODE_TYPE

        Parameters
        ----------
        self: dnnc::opNode *

        """
        return _dnnc.opNode_ntype(self)


    def dtype(self, *args):
        """
        dtype(self, dtype)

        Parameters
        ----------
        dtype: enum dnnc::DNNC_DataType

        dtype(self) -> dnnc::DNNC_DataType

        Parameters
        ----------
        self: dnnc::opNode *

        """
        return _dnnc.opNode_dtype(self, *args)


    def inputs(self):
        """
        inputs(self) -> vectorStr

        Parameters
        ----------
        self: dnnc::opNode *

        """
        return _dnnc.opNode_inputs(self)


    def outputs(self):
        """
        outputs(self) -> vectorStr

        Parameters
        ----------
        self: dnnc::opNode *

        """
        return _dnnc.opNode_outputs(self)


    def inputNodes(self, g, nodes):
        """
        inputNodes(self, g, nodes) -> bool

        Parameters
        ----------
        g: dnnc::graph &
        nodes: std::vector< dnnc::node *,std::allocator< dnnc::node * > > &

        """
        return _dnnc.opNode_inputNodes(self, g, nodes)


    def outputNodes(self, g, nodes):
        """
        outputNodes(self, g, nodes) -> bool

        Parameters
        ----------
        g: dnnc::graph &
        nodes: std::vector< dnnc::node *,std::allocator< dnnc::node * > > &

        """
        return _dnnc.opNode_outputNodes(self, g, nodes)

opNode_swigregister = _dnnc.opNode_swigregister
opNode_swigregister(opNode)

class graph(_object):
    """Proxy of C++ dnnc::graph class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, graph, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, graph, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def singleton():
        """singleton() -> graph"""
        return _dnnc.graph_singleton()

    singleton = staticmethod(singleton)

    def subgraph(self):
        """
        subgraph(self) -> graph

        Parameters
        ----------
        self: dnnc::graph *

        """
        return _dnnc.graph_subgraph(self)


    def destroy(self):
        """
        destroy(self)

        Parameters
        ----------
        self: dnnc::graph *

        """
        return _dnnc.graph_destroy(self)

    __swig_destroy__ = _dnnc.delete_graph
    __del__ = lambda self: None

    def setName(self, name):
        """
        setName(self, name)

        Parameters
        ----------
        name: std::string

        """
        return _dnnc.graph_setName(self, name)


    def nNodes(self):
        """
        nNodes(self) -> size_t

        Parameters
        ----------
        self: dnnc::graph *

        """
        return _dnnc.graph_nNodes(self)


    def resetNodeMarks(self):
        """
        resetNodeMarks(self)

        Parameters
        ----------
        self: dnnc::graph *

        """
        return _dnnc.graph_resetNodeMarks(self)


    def addOPNode(self, name, symbol):
        """
        addOPNode(self, name, symbol) -> opNode

        Parameters
        ----------
        name: std::string
        symbol: enum dnnc::OPCODE

        """
        return _dnnc.graph_addOPNode(self, name, symbol)


    def addInput(self, name, type, shape):
        """
        addInput(self, name, type, shape) -> ioNode

        Parameters
        ----------
        name: std::string
        type: enum dnnc::DNNC_DataType
        shape: std::vector< size_t,std::allocator< size_t > >

        """
        return _dnnc.graph_addInput(self, name, type, shape)


    def addOutput(self, name, type, shape):
        """
        addOutput(self, name, type, shape) -> ioNode

        Parameters
        ----------
        name: std::string
        type: enum dnnc::DNNC_DataType
        shape: std::vector< size_t,std::allocator< size_t > >

        """
        return _dnnc.graph_addOutput(self, name, type, shape)


    def inputs(self):
        """
        inputs(self) -> std::vector< dnnc::ioNode *,std::allocator< dnnc::ioNode * > >

        Parameters
        ----------
        self: dnnc::graph *

        """
        return _dnnc.graph_inputs(self)


    def outputs(self):
        """
        outputs(self) -> std::vector< dnnc::ioNode *,std::allocator< dnnc::ioNode * > >

        Parameters
        ----------
        self: dnnc::graph *

        """
        return _dnnc.graph_outputs(self)


    def isOutput(self, name):
        """
        isOutput(self, name) -> bool

        Parameters
        ----------
        name: std::string

        """
        return _dnnc.graph_isOutput(self, name)


    def addParameters(self, param):
        """
        addParameters(self, param)

        Parameters
        ----------
        param: dnnc::dnnParameters

        """
        return _dnnc.graph_addParameters(self, param)


    def parameters(self):
        """
        parameters(self) -> std::vector< dnnc::dnnParameters,std::allocator< dnnc::dnnParameters > >

        Parameters
        ----------
        self: dnnc::graph *

        """
        return _dnnc.graph_parameters(self)


    def findNodesWithIO(self, name, arg3=True):
        """
        findNodesWithIO(self, name, arg3=True) -> std::vector< dnnc::node *,std::allocator< dnnc::node * > >

        Parameters
        ----------
        name: std::string
        in: bool

        findNodesWithIO(self, name) -> std::vector< dnnc::node *,std::allocator< dnnc::node * > >

        Parameters
        ----------
        name: std::string

        """
        return _dnnc.graph_findNodesWithIO(self, name, arg3)


    def findNodeByName(self, name, n):
        """
        findNodeByName(self, name, n) -> bool

        Parameters
        ----------
        name: std::string
        n: dnnc::node *&

        """
        return _dnnc.graph_findNodeByName(self, name, n)


    def sanityCheck(self):
        """
        sanityCheck(self) -> bool

        Parameters
        ----------
        self: dnnc::graph *

        """
        return _dnnc.graph_sanityCheck(self)

graph_swigregister = _dnnc.graph_swigregister
graph_swigregister(graph)

def graph_singleton():
    """graph_singleton() -> graph"""
    return _dnnc.graph_singleton()


def Graph():
    """Graph() -> graph"""
    return _dnnc.Graph()
class cppCodeGen(_object):
    """Proxy of C++ dnnc::cppCodeGen class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cppCodeGen, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cppCodeGen, name)
    __repr__ = _swig_repr

    def __init__(self, graph, bundleDir, outFile):
        """
        __init__(self, graph, bundleDir, outFile) -> cppCodeGen

        Parameters
        ----------
        graph: dnnc::graph &
        bundleDir: std::string
        outFile: std::string

        """
        this = _dnnc.new_cppCodeGen(graph, bundleDir, outFile)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def write(self):
        """
        write(self) -> bool

        Parameters
        ----------
        self: dnnc::cppCodeGen *

        """
        return _dnnc.cppCodeGen_write(self)

    __swig_destroy__ = _dnnc.delete_cppCodeGen
    __del__ = lambda self: None
cppCodeGen_swigregister = _dnnc.cppCodeGen_swigregister
cppCodeGen_swigregister(cppCodeGen)

# This file is compatible with both classic and new-style classes.


