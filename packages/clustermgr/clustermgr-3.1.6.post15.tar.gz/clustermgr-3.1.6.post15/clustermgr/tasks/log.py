import json

from celery.utils.log import get_task_logger
from flask import current_app
from flask import render_template
from influxdb import InfluxDBClient

from ..core.remote import RemoteClient
from ..extensions import celery
from ..extensions import db
from ..extensions import wlogger
from ..models import AppConfiguration
from ..models import Server

task_logger = get_task_logger(__name__)


_ELASTIC_YUM_REPO = """[elastic-6.x]
name=Elastic repository for 6.x packages
baseurl=https://artifacts.elastic.co/packages/6.x/yum
gpgcheck=1
gpgkey=https://artifacts.elastic.co/GPG-KEY-elasticsearch
enabled=1
autorefresh=1
type=rpm-md
"""

DEBCONF = "DEBIAN_FRONTEND=noninteractive"


def _filebeat_to_influx(log, hostname=""):
    """Formats log generated by filebeat to conform to influxdb format.

    :params log: A ``dict`` of log.
    :params hostname: Hostname of the server; if left blank, will use
                      value generated by filebeat.
    :returns: A ``dict`` of formatted log.
    """
    # Example:
    #
    #     {
    #         u'beat': {u'hostname': u'gluu-elk', u'name': u'gluu-elk', u'version': u'5.6.3'},
    #         u'fields': {u'ip': u'172.40.40.40', u'gluu': {u'chroot': True, u'version': u'3.1.1'}, u'os': u'Ubuntu 14.04', u'type': u'httpd'},
    #         u'@timestamp': u'2018-01-19T15:09:12.096Z',
    #         u'source': u'/var/log/apache2/access.log',
    #         u'offset': 972,
    #         u'input_type': u'log',
    #         u'message': u'::1 - - [19/Jan/2018:15:09:11 +0000] "GET /g HTTP/1.1" 404 433 "-" "curl/7.35.0"',
    #     }
    _log = {}
    _log["time"] = log["@timestamp"]
    _log["measurement"] = "logs"
    _log["tags"] = {
        "hostname": hostname or log["beat"]["hostname"],
        "chroot": log["fields"]["gluu"]["chroot"],
        "gluu_version": log["fields"]["gluu"]["version"],
        "ip": log["fields"]["ip"],
        "os": log["fields"]["os"],
        "type": log["fields"]["type"],
    }
    _log["fields"] = {k: v for k, v in log.iteritems() if k in ("message", "source")}
    return _log


def parse_log(log, influx_fmt=True, hostname=""):
    """Parses log.

    :params log: A plain-text log message.
    :params influx_fmt: Whether to use influxdb format or not.
    :params hostname: Hostname of the server where log is collected from.
    :returns: A ``dict`` of formatted log or ``None``
    """
    json_log = None

    try:
        json_log = json.loads(log)
        if influx_fmt:
            json_log = _filebeat_to_influx(json_log, hostname)
    except ValueError as exc:
        # something is wrong when converting string into dict
        task_logger.warn("unable to parse the log; reason={}".format(exc))
    return json_log


@celery.task
def collect_logs(host, ip, path, influx_fmt=True):
    """Collects logs from a server.

    :params host: Hostname of the server.
    :params ip: IP address of the server.
    :params path: Absolute path to file contains logs.
    :params influx_fmt: Whether to use influxdb format or not.
    :returns: A boolean whether logs are saved successfully to database or not.
    """
    dbname = current_app.config["INFLUXDB_LOGGING_DB"]
    logs = []
    rc = RemoteClient(host, ip)

    try:
        rc.startup()
        task_logger.warn("Collecting logs from remote server {}/{}".format(host, ip))
        _, stdout, stderr = rc.run("cat {}".format(path))
        if not stderr:
            logs = filter(
                None,
                [parse_log(log, hostname=host) for log in stdout.splitlines()],
            )
        else:
            task_logger.warn("Unable to collect logs from remote server {}/{}; "
                             "reason={}".format(host, ip, stderr))
    except Exception as exc:
        task_logger.warn("Unable to collect logs from remote server {}/{}; "
                         "reason={}".format(host, ip, exc))
    finally:
        rc.close()

    logs_collected = False

    influx = InfluxDBClient(database=dbname)
    try:
        influx.create_database(dbname)
        if influx.write_points(logs):
            logs_collected = True
    except Exception as exc:
        task_logger.warn(
            "An error occured while trying to connect to InfluxDB; "
            "reason={}".format(exc))
    return logs_collected


def _install_filebeat(task_id, server, rc):
    """Installs filebeat.

    Docs at https://www.elastic.co/guide/en/beats/filebeat/current/setup-repositories.html.
    """
    stdout = ""
    stderr = ""
    opsys = (server.os or "").lower()

    if opsys.startswith("ubuntu"):
        cmd_list = [
            "{} apt-get install -y apt-transport-https".format(DEBCONF),
            "wget -qO - https://artifacts.elastic.co/GPG-KEY-elasticsearch | apt-key add -",
            "echo 'deb https://artifacts.elastic.co/packages/6.x/apt stable main' | tee /etc/apt/sources.list.d/elastic-6.x.list",
            "{} apt-get update".format(DEBCONF),
            "{} apt-get install -y filebeat".format(DEBCONF),
            "update-rc.d filebeat defaults 95 10",
        ]
    elif opsys.startswith("centos") or opsys.startswith("rhel"):
        cmd_list = [
            "rpm --import https://packages.elastic.co/GPG-KEY-elasticsearch",
            "echo '{}' > /etc/yum.repos.d/elastic.repo".format(_ELASTIC_YUM_REPO),
            "yum install -y filebeat",
            "chkconfig --add filebeat",
        ]
    else:
        cmd_list = []
        task_logger.warn("Unable to determine underlying OS")

    for cmd in cmd_list:
        wlogger.log(task_id, cmd, "info", server_id=server.id)
        _, stdout, stderr = rc.run(cmd)

        if stderr:
            return stdout, stderr
    return stdout, stderr


def _render_filebeat_config(task_id, server, rc):
    """Renders filebeat config and upload to a server.
    """
    # render filebeat.yml and upload to server
    appconf = AppConfiguration.query.first()

    with current_app.app_context():
        ctx = {
            "ip": server.ip,
            "os": server.os,
            "chroot": "true" if server.gluu_server is True else "",
            "chroot_path": "/opt/gluu-server-{}".format(appconf.gluu_version) if server.gluu_server else "",
            "gluu_version": appconf.gluu_version,
        }

        src = "filebeat.yml"
        opsys = (server.os or "").lower()
        if opsys.startswith("centos") or opsys.startswith("rhel"):
            src += ".centos"

        txt = render_template("filebeat/{}".format(src), **ctx)
        wlogger.log(task_id, "uploading filebeat.yml to remote server", "info", server_id=server.id)
        status, maybe_err = rc.put_file("/etc/filebeat/filebeat.yml", txt)
        return status, maybe_err


def _restart_filebeat(task_id, server, rc):
    """Restarts filebeat service.
    """
    opsys = (server.os or "").lower()

    if opsys in ("centos 6", "ubuntu 14", "rhel 6"):
        cmd = "service filebeat restart"
    elif opsys in ("centos 7", "ubuntu 16", "rhel 7"):
        cmd = "systemctl enable filebeat && systemctl restart filebeat"
    else:
        task_logger.warn("Unable to determine underlying OS")
        return "", ""

    wlogger.log(task_id, cmd, "info", server_id=server.id)
    _, stdout, stderr = rc.run(cmd)
    return stdout, stderr


@celery.task(bind=True)
def setup_filebeat(self, force_install=False):
    """Setup filebeat to collect logs.
    """
    tid = self.request.id
    servers = Server.query.all()
    appconf = AppConfiguration.query.first()


    for server in servers:

        # establishes SSH connection
        wlogger.log(
            tid,
            "Making SSH connection to the server {}.".format(server.hostname),
            "info",
            server_id=server.id,
        )

        rc = RemoteClient(server.hostname, server.ip)
        try:
            rc.startup()

            fb_installed = rc.exists('/usr/bin/filebeat')

            if appconf.offline:
                if not fb_installed:
                    wlogger.log(
                            tid, 
                            "Filebeat was not installed on this server. Please"
                            " install and retry", "error", server_id=server.id)
                    return False

            else:
                if fb_installed:
                    # installs filebeat
                    _, stderr = _install_filebeat(tid, server, rc)
                    if stderr:
                        wlogger.log(tid, stderr, "warning", server_id=server.id)
                        return False
                else:
                    wlogger.log(tid, "Filebeat was allready installed.", 
                                server_id=server.id)
    
            # renders filebeat config
            uploaded, maybe_err = _render_filebeat_config(tid, server, rc)
            if not uploaded:
                wlogger.log(
                    tid,
                    "Cannot render/upload filebeat.yml; reason={}".format(maybe_err),
                    "warning",
                    server_id=server.id,
                )
                return False

            # restarts filebeat service
            # note, restarting filebeat service may gives unwanted output,
            # hence we skip checking the result of running command
            _restart_filebeat(tid, server, rc)

            # update the model
            server.filebeat = True
            db.session.add(server)
            db.session.commit()
        except Exception as exc:
            wlogger.log(
                tid,
                "Cannot establish SSH connection {}".format(exc),
                "warning",
                server_id=server.id,
            )
            wlogger.log(
                tid,
                "Ending server setup process.",
                "error",
                server_id=server.id,
            )
            return False
        finally:
            rc.close()
    return True


# @celery.task(bind=True)
def setup_influxdb(self):
    """Setup influxdb database.
    """
    tid = self.request.id

    # @TODO: do we need to install influxdb locally?
    dbname = current_app.config["INFLUXDB_LOGGING_DB"]

    wlogger.log(
        tid,
        "Creating InfluxDB database {}".format(dbname),
        "info",
    )

    influx = InfluxDBClient(database=dbname)
    influx.create_database(dbname)
    return True


def _uninstall_filebeat(task_id, server, rc):
    stdout = ""
    stderr = ""
    opsys = (server.os or "").lower()

    if opsys.startswith("ubuntu"):
        cmd_list = [
            "apt-get remove -y --purge filebeat",
        ]
    elif opsys.startswith("centos") or opsys.startswith("rhel"):
        cmd_list = [
            "yum remove -y filebeat",
        ]
    else:
        cmd_list = []
        task_logger.warn("Unable to determine underlying OS")

    for cmd in cmd_list:
        wlogger.log(task_id, cmd, "info", server_id=server.id)
        _, stdout, stderr = rc.run(cmd)
        if stderr:
            return stdout, stderr
    return stdout, stderr


@celery.task(bind=True)
def remove_filebeat(self):
    """Removes filebeat.
    """
    tid = self.request.id
    servers = Server.query.all()

    for server in servers:
        # establishes SSH connection
        wlogger.log(
            tid,
            "Making SSH connection to the server {}.".format(server.hostname),
            "info",
            server_id=server.id,
        )

        rc = RemoteClient(server.hostname, server.ip)
        try:
            rc.startup()

            # installs filebeat
            _, stderr = _uninstall_filebeat(tid, server, rc)
            if stderr:
                wlogger.log(tid, stderr, "warning", server_id=server.id)

            # remove log used to collect all components logs
            rc.run("rm -f /tmp/gluu-filebeat*")

            # update the model
            server.filebeat = False
            db.session.add(server)
            db.session.commit()
        except Exception as exc:
            wlogger.log(
                tid,
                "Cannot establish SSH connection {}".format(exc),
                "warning",
                server_id=server.id,
            )
            wlogger.log(
                tid,
                "Ending server setup process.",
                "error",
                server_id=server.id,
            )
            return False
        finally:
            rc.close()
    return True
