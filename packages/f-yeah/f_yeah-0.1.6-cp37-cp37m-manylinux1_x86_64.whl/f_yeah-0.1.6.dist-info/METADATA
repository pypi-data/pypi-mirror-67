Metadata-Version: 2.1
Name: f-yeah
Version: 0.1.6
Summary: Reusable f-strings
Home-page: https://github.com/ucodery/fyeah
Author: Jeremiah Paige
Author-email: ucodery@gmail.com
License: BSD
Platform: UNKNOWN
Classifier: Programming Language :: Python :: 3.6
Classifier: Programming Language :: Python :: 3.7
Classifier: Programming Language :: Python :: 3.8
Classifier: License :: OSI Approved :: BSD License
Classifier: Operating System :: OS Independent
Requires-Python: >=3.6, <3.9
Description-Content-Type: text/markdown
Provides-Extra: dev
Requires-Dist: tox ; extra == 'dev'

[![fyeah - reusable f-strings](https://raw.githubusercontent.com/ucodery/fyeah/master/art/logo.png)](https://ucodery.github.io/fyeah/)
------

#### Reusable f-strings
Unify on one format sytle.
With F-yeah Just add parentheses and be on your way.

## Usage
Keep using f-string formatting, but when you need to re-use a template, use the
`f` function instead of the `f` listeral

These two lines are equivalent
```python
print(f'about to put {os.getpid()} to sleep')
print(f('about to put {os.getpid()} to sleep'))
# "about to put 421 to sleep"
```

No longer choose between copying around f-string literals or continuing to use
old-style format() calls.

Instead of this
```python
def mul(value):
    assert isinstance(value, int), 'Expected value to be an integer, got {type(value)} instead'
    return value * value

def pow(value):
    assert isinstance(value, int), 'Expected value to be an integer, got {type(value)} instead'
    return value ** value
```
Or this
```python
bad_check = 'expected value to be an integer, got {type(value)} instead'

def mul(value):
    assert isinstance(value, int), bad_check.format(value=value)
    return value * value

def pow(value):
    assert isinstance(value, int), bad_check.format(value=value)
    return value ** value
```
Just write the template once to get consistent strings that stay in sync.
```python
from fyeah import f
bad_check = 'Expected value to be an integer, got {type(value)} instead'

def mul(value):
    assert isinstance(value, int), f(bad_check)
    return value * value

def pow(value):
    assert isinstance(value, int), f(bad_check)
    return value ** value
```

#### Why would I use a function over the literal?
f-string literals are evaluated when they are created. This makes situations like the
following impossible.
```python
class BaseListRunner:
    command = ['ls']
    args = []
    notify_running = '{self.__class__.__name__} is executing {self.command} with "{" ".join(self.args)}"'

    def run(self):
        log.debug(f(self.notify_running))
        subprocess.call(self.command + args)

class AllListRunner:
    def __init__(self):
        self.args.append('-A')

AllListRunner().run()
# DEBUG: AllListRunnner is executing ls with "-A"
```

#### Why would I use F-yeah instead of the format() builtin?
Although the format mini-language and f-strings share a lot of syntax, they have
divered somewhat. You could use only format() for all your strings, but format()
is more verbose and less flexible as compared to f-strings; enough so that f-strings
were adopted into the language. Using F-yeah makes the following possible.
```python
G_COUNT = 0
count_tracker = '{G_COUNT=} at {datetime.datetime.utcnow():%H:%M:%S}'

def aquire():
    G_COUNT += 1
    log.debug(f(count_tracker))

def release():
    G_COUNT -= 1
    log.debug(f(count_tracker))

def check():
    log.debug(f(count_tracker))
    return G_COUNT
```


