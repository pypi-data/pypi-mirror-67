# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.8
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _itkPyBufferPython.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_itkPyBufferPython', [dirname(__file__)])
        except ImportError:
            import _itkPyBufferPython
            return _itkPyBufferPython
        if fp is not None:
            try:
                _mod = imp.load_module('_itkPyBufferPython', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _itkPyBufferPython = swig_import_helper()
    del swig_import_helper
else:
    import _itkPyBufferPython
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0



def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


import vnl_matrixPython
import vnl_vectorPython
import stdcomplexPython
import pyBasePython
import itkVectorImagePython
import ITKCommonBasePython
import itkVariableLengthVectorPython
import itkIndexPython
import itkOffsetPython
import itkSizePython
import itkImagePython
import itkSymmetricSecondRankTensorPython
import itkFixedArrayPython
import itkMatrixPython
import itkPointPython
import vnl_vector_refPython
import itkVectorPython
import itkCovariantVectorPython
import vnl_matrix_fixedPython
import itkRGBAPixelPython
import itkImageRegionPython
import itkRGBPixelPython


HAVE_NUMPY = True
try:
  import numpy as np
  class NDArrayITKBase(np.ndarray):
      """A numpy array that provides a view on the data associated with an optional itk "base" object."""

      def __new__(cls, input_array, itk_base=None):
          obj = np.asarray(input_array).view(cls)
          obj.itk_base = itk_base
          return obj

      def __array_finalize__(self, obj):
          if obj is None: return
          self.itk_base = getattr(obj, 'itk_base', None)

except ImportError:
  HAVE_NUMPY = False

def _get_numpy_pixelid(itk_Image_type):
    """Returns a ITK PixelID given a numpy array."""

    if not HAVE_NUMPY:
        raise ImportError('Numpy not available.')
# This is a Mapping from numpy array types to itk pixel types.
    _np_itk = {"UC":np.uint8,
               "US":np.uint16,
               "UI":np.uint32,
               "UL":np.uint64,
               "SC":np.int8,
               "SS":np.int16,
               "SI":np.int32,
               "SL":np.int64,
               "F":np.float32,
               "D":np.float64,
                }
    import os
    if os.name == 'nt':
        _np_itk['UL'] = np.uint32
        _np_itk['SL'] = np.int32
    try:
        return _np_itk[itk_Image_type]
    except KeyError as e:
        raise e

from itkImageDuplicatorPython import *

class itkPyBufferICVD22(object):
    """


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package.

    C++ includes: itkPyBuffer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageCVD22') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageCVD22 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferICVD22__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageCVD22_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageCVD22_Pointer const"""
        return _itkPyBufferPython.itkPyBufferICVD22__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferICVD22 self) -> itkPyBufferICVD22
        __init__(itkPyBufferICVD22 self, itkPyBufferICVD22 arg0) -> itkPyBufferICVD22



        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package.

        C++ includes: itkPyBuffer.h 
        """
        _itkPyBufferPython.itkPyBufferICVD22_swiginit(self, _itkPyBufferPython.new_itkPyBufferICVD22(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferICVD22


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferICVD22._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferICVD22.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferICVD22._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferICVD22._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferICVD22._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferICVD22.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorICVD22.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferICVD22_swigregister = _itkPyBufferPython.itkPyBufferICVD22_swigregister
itkPyBufferICVD22_swigregister(itkPyBufferICVD22)

def itkPyBufferICVD22__GetArrayViewFromImage(image: 'itkImageCVD22') -> "PyObject *":
    """itkPyBufferICVD22__GetArrayViewFromImage(itkImageCVD22 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferICVD22__GetArrayViewFromImage(image)

def itkPyBufferICVD22__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageCVD22_Pointer const":
    """itkPyBufferICVD22__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageCVD22_Pointer const"""
    return _itkPyBufferPython.itkPyBufferICVD22__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferICVD23(object):
    """


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package.

    C++ includes: itkPyBuffer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageCVD23') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageCVD23 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferICVD23__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageCVD23_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageCVD23_Pointer const"""
        return _itkPyBufferPython.itkPyBufferICVD23__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferICVD23 self) -> itkPyBufferICVD23
        __init__(itkPyBufferICVD23 self, itkPyBufferICVD23 arg0) -> itkPyBufferICVD23



        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package.

        C++ includes: itkPyBuffer.h 
        """
        _itkPyBufferPython.itkPyBufferICVD23_swiginit(self, _itkPyBufferPython.new_itkPyBufferICVD23(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferICVD23


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferICVD23._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferICVD23.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferICVD23._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferICVD23._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferICVD23._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferICVD23.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorICVD23.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferICVD23_swigregister = _itkPyBufferPython.itkPyBufferICVD23_swigregister
itkPyBufferICVD23_swigregister(itkPyBufferICVD23)

def itkPyBufferICVD23__GetArrayViewFromImage(image: 'itkImageCVD23') -> "PyObject *":
    """itkPyBufferICVD23__GetArrayViewFromImage(itkImageCVD23 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferICVD23__GetArrayViewFromImage(image)

def itkPyBufferICVD23__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageCVD23_Pointer const":
    """itkPyBufferICVD23__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageCVD23_Pointer const"""
    return _itkPyBufferPython.itkPyBufferICVD23__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferICVD32(object):
    """


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package.

    C++ includes: itkPyBuffer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageCVD32') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageCVD32 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferICVD32__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageCVD32_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageCVD32_Pointer const"""
        return _itkPyBufferPython.itkPyBufferICVD32__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferICVD32 self) -> itkPyBufferICVD32
        __init__(itkPyBufferICVD32 self, itkPyBufferICVD32 arg0) -> itkPyBufferICVD32



        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package.

        C++ includes: itkPyBuffer.h 
        """
        _itkPyBufferPython.itkPyBufferICVD32_swiginit(self, _itkPyBufferPython.new_itkPyBufferICVD32(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferICVD32


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferICVD32._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferICVD32.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferICVD32._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferICVD32._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferICVD32._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferICVD32.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorICVD32.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferICVD32_swigregister = _itkPyBufferPython.itkPyBufferICVD32_swigregister
itkPyBufferICVD32_swigregister(itkPyBufferICVD32)

def itkPyBufferICVD32__GetArrayViewFromImage(image: 'itkImageCVD32') -> "PyObject *":
    """itkPyBufferICVD32__GetArrayViewFromImage(itkImageCVD32 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferICVD32__GetArrayViewFromImage(image)

def itkPyBufferICVD32__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageCVD32_Pointer const":
    """itkPyBufferICVD32__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageCVD32_Pointer const"""
    return _itkPyBufferPython.itkPyBufferICVD32__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferICVD33(object):
    """


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package.

    C++ includes: itkPyBuffer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageCVD33') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageCVD33 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferICVD33__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageCVD33_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageCVD33_Pointer const"""
        return _itkPyBufferPython.itkPyBufferICVD33__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferICVD33 self) -> itkPyBufferICVD33
        __init__(itkPyBufferICVD33 self, itkPyBufferICVD33 arg0) -> itkPyBufferICVD33



        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package.

        C++ includes: itkPyBuffer.h 
        """
        _itkPyBufferPython.itkPyBufferICVD33_swiginit(self, _itkPyBufferPython.new_itkPyBufferICVD33(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferICVD33


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferICVD33._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferICVD33.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferICVD33._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferICVD33._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferICVD33._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferICVD33.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorICVD33.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferICVD33_swigregister = _itkPyBufferPython.itkPyBufferICVD33_swigregister
itkPyBufferICVD33_swigregister(itkPyBufferICVD33)

def itkPyBufferICVD33__GetArrayViewFromImage(image: 'itkImageCVD33') -> "PyObject *":
    """itkPyBufferICVD33__GetArrayViewFromImage(itkImageCVD33 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferICVD33__GetArrayViewFromImage(image)

def itkPyBufferICVD33__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageCVD33_Pointer const":
    """itkPyBufferICVD33__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageCVD33_Pointer const"""
    return _itkPyBufferPython.itkPyBufferICVD33__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferICVD42(object):
    """


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package.

    C++ includes: itkPyBuffer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageCVD42') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageCVD42 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferICVD42__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageCVD42_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageCVD42_Pointer const"""
        return _itkPyBufferPython.itkPyBufferICVD42__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferICVD42 self) -> itkPyBufferICVD42
        __init__(itkPyBufferICVD42 self, itkPyBufferICVD42 arg0) -> itkPyBufferICVD42



        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package.

        C++ includes: itkPyBuffer.h 
        """
        _itkPyBufferPython.itkPyBufferICVD42_swiginit(self, _itkPyBufferPython.new_itkPyBufferICVD42(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferICVD42


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferICVD42._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferICVD42.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferICVD42._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferICVD42._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferICVD42._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferICVD42.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorICVD42.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferICVD42_swigregister = _itkPyBufferPython.itkPyBufferICVD42_swigregister
itkPyBufferICVD42_swigregister(itkPyBufferICVD42)

def itkPyBufferICVD42__GetArrayViewFromImage(image: 'itkImageCVD42') -> "PyObject *":
    """itkPyBufferICVD42__GetArrayViewFromImage(itkImageCVD42 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferICVD42__GetArrayViewFromImage(image)

def itkPyBufferICVD42__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageCVD42_Pointer const":
    """itkPyBufferICVD42__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageCVD42_Pointer const"""
    return _itkPyBufferPython.itkPyBufferICVD42__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferICVD43(object):
    """


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package.

    C++ includes: itkPyBuffer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageCVD43') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageCVD43 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferICVD43__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageCVD43_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageCVD43_Pointer const"""
        return _itkPyBufferPython.itkPyBufferICVD43__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferICVD43 self) -> itkPyBufferICVD43
        __init__(itkPyBufferICVD43 self, itkPyBufferICVD43 arg0) -> itkPyBufferICVD43



        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package.

        C++ includes: itkPyBuffer.h 
        """
        _itkPyBufferPython.itkPyBufferICVD43_swiginit(self, _itkPyBufferPython.new_itkPyBufferICVD43(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferICVD43


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferICVD43._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferICVD43.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferICVD43._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferICVD43._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferICVD43._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferICVD43.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorICVD43.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferICVD43_swigregister = _itkPyBufferPython.itkPyBufferICVD43_swigregister
itkPyBufferICVD43_swigregister(itkPyBufferICVD43)

def itkPyBufferICVD43__GetArrayViewFromImage(image: 'itkImageCVD43') -> "PyObject *":
    """itkPyBufferICVD43__GetArrayViewFromImage(itkImageCVD43 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferICVD43__GetArrayViewFromImage(image)

def itkPyBufferICVD43__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageCVD43_Pointer const":
    """itkPyBufferICVD43__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageCVD43_Pointer const"""
    return _itkPyBufferPython.itkPyBufferICVD43__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferICVF22(object):
    """


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package.

    C++ includes: itkPyBuffer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageCVF22') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageCVF22 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferICVF22__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageCVF22_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageCVF22_Pointer const"""
        return _itkPyBufferPython.itkPyBufferICVF22__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferICVF22 self) -> itkPyBufferICVF22
        __init__(itkPyBufferICVF22 self, itkPyBufferICVF22 arg0) -> itkPyBufferICVF22



        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package.

        C++ includes: itkPyBuffer.h 
        """
        _itkPyBufferPython.itkPyBufferICVF22_swiginit(self, _itkPyBufferPython.new_itkPyBufferICVF22(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferICVF22


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferICVF22._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferICVF22.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferICVF22._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferICVF22._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferICVF22._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferICVF22.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorICVF22.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferICVF22_swigregister = _itkPyBufferPython.itkPyBufferICVF22_swigregister
itkPyBufferICVF22_swigregister(itkPyBufferICVF22)

def itkPyBufferICVF22__GetArrayViewFromImage(image: 'itkImageCVF22') -> "PyObject *":
    """itkPyBufferICVF22__GetArrayViewFromImage(itkImageCVF22 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferICVF22__GetArrayViewFromImage(image)

def itkPyBufferICVF22__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageCVF22_Pointer const":
    """itkPyBufferICVF22__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageCVF22_Pointer const"""
    return _itkPyBufferPython.itkPyBufferICVF22__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferICVF23(object):
    """


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package.

    C++ includes: itkPyBuffer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageCVF23') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageCVF23 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferICVF23__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageCVF23_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageCVF23_Pointer const"""
        return _itkPyBufferPython.itkPyBufferICVF23__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferICVF23 self) -> itkPyBufferICVF23
        __init__(itkPyBufferICVF23 self, itkPyBufferICVF23 arg0) -> itkPyBufferICVF23



        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package.

        C++ includes: itkPyBuffer.h 
        """
        _itkPyBufferPython.itkPyBufferICVF23_swiginit(self, _itkPyBufferPython.new_itkPyBufferICVF23(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferICVF23


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferICVF23._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferICVF23.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferICVF23._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferICVF23._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferICVF23._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferICVF23.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorICVF23.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferICVF23_swigregister = _itkPyBufferPython.itkPyBufferICVF23_swigregister
itkPyBufferICVF23_swigregister(itkPyBufferICVF23)

def itkPyBufferICVF23__GetArrayViewFromImage(image: 'itkImageCVF23') -> "PyObject *":
    """itkPyBufferICVF23__GetArrayViewFromImage(itkImageCVF23 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferICVF23__GetArrayViewFromImage(image)

def itkPyBufferICVF23__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageCVF23_Pointer const":
    """itkPyBufferICVF23__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageCVF23_Pointer const"""
    return _itkPyBufferPython.itkPyBufferICVF23__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferICVF32(object):
    """


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package.

    C++ includes: itkPyBuffer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageCVF32') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageCVF32 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferICVF32__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageCVF32_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageCVF32_Pointer const"""
        return _itkPyBufferPython.itkPyBufferICVF32__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferICVF32 self) -> itkPyBufferICVF32
        __init__(itkPyBufferICVF32 self, itkPyBufferICVF32 arg0) -> itkPyBufferICVF32



        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package.

        C++ includes: itkPyBuffer.h 
        """
        _itkPyBufferPython.itkPyBufferICVF32_swiginit(self, _itkPyBufferPython.new_itkPyBufferICVF32(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferICVF32


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferICVF32._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferICVF32.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferICVF32._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferICVF32._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferICVF32._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferICVF32.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorICVF32.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferICVF32_swigregister = _itkPyBufferPython.itkPyBufferICVF32_swigregister
itkPyBufferICVF32_swigregister(itkPyBufferICVF32)

def itkPyBufferICVF32__GetArrayViewFromImage(image: 'itkImageCVF32') -> "PyObject *":
    """itkPyBufferICVF32__GetArrayViewFromImage(itkImageCVF32 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferICVF32__GetArrayViewFromImage(image)

def itkPyBufferICVF32__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageCVF32_Pointer const":
    """itkPyBufferICVF32__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageCVF32_Pointer const"""
    return _itkPyBufferPython.itkPyBufferICVF32__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferICVF33(object):
    """


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package.

    C++ includes: itkPyBuffer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageCVF33') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageCVF33 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferICVF33__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageCVF33_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageCVF33_Pointer const"""
        return _itkPyBufferPython.itkPyBufferICVF33__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferICVF33 self) -> itkPyBufferICVF33
        __init__(itkPyBufferICVF33 self, itkPyBufferICVF33 arg0) -> itkPyBufferICVF33



        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package.

        C++ includes: itkPyBuffer.h 
        """
        _itkPyBufferPython.itkPyBufferICVF33_swiginit(self, _itkPyBufferPython.new_itkPyBufferICVF33(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferICVF33


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferICVF33._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferICVF33.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferICVF33._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferICVF33._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferICVF33._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferICVF33.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorICVF33.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferICVF33_swigregister = _itkPyBufferPython.itkPyBufferICVF33_swigregister
itkPyBufferICVF33_swigregister(itkPyBufferICVF33)

def itkPyBufferICVF33__GetArrayViewFromImage(image: 'itkImageCVF33') -> "PyObject *":
    """itkPyBufferICVF33__GetArrayViewFromImage(itkImageCVF33 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferICVF33__GetArrayViewFromImage(image)

def itkPyBufferICVF33__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageCVF33_Pointer const":
    """itkPyBufferICVF33__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageCVF33_Pointer const"""
    return _itkPyBufferPython.itkPyBufferICVF33__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferICVF42(object):
    """


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package.

    C++ includes: itkPyBuffer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageCVF42') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageCVF42 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferICVF42__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageCVF42_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageCVF42_Pointer const"""
        return _itkPyBufferPython.itkPyBufferICVF42__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferICVF42 self) -> itkPyBufferICVF42
        __init__(itkPyBufferICVF42 self, itkPyBufferICVF42 arg0) -> itkPyBufferICVF42



        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package.

        C++ includes: itkPyBuffer.h 
        """
        _itkPyBufferPython.itkPyBufferICVF42_swiginit(self, _itkPyBufferPython.new_itkPyBufferICVF42(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferICVF42


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferICVF42._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferICVF42.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferICVF42._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferICVF42._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferICVF42._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferICVF42.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorICVF42.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferICVF42_swigregister = _itkPyBufferPython.itkPyBufferICVF42_swigregister
itkPyBufferICVF42_swigregister(itkPyBufferICVF42)

def itkPyBufferICVF42__GetArrayViewFromImage(image: 'itkImageCVF42') -> "PyObject *":
    """itkPyBufferICVF42__GetArrayViewFromImage(itkImageCVF42 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferICVF42__GetArrayViewFromImage(image)

def itkPyBufferICVF42__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageCVF42_Pointer const":
    """itkPyBufferICVF42__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageCVF42_Pointer const"""
    return _itkPyBufferPython.itkPyBufferICVF42__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferICVF43(object):
    """


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package.

    C++ includes: itkPyBuffer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageCVF43') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageCVF43 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferICVF43__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageCVF43_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageCVF43_Pointer const"""
        return _itkPyBufferPython.itkPyBufferICVF43__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferICVF43 self) -> itkPyBufferICVF43
        __init__(itkPyBufferICVF43 self, itkPyBufferICVF43 arg0) -> itkPyBufferICVF43



        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package.

        C++ includes: itkPyBuffer.h 
        """
        _itkPyBufferPython.itkPyBufferICVF43_swiginit(self, _itkPyBufferPython.new_itkPyBufferICVF43(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferICVF43


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferICVF43._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferICVF43.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferICVF43._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferICVF43._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferICVF43._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferICVF43.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorICVF43.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferICVF43_swigregister = _itkPyBufferPython.itkPyBufferICVF43_swigregister
itkPyBufferICVF43_swigregister(itkPyBufferICVF43)

def itkPyBufferICVF43__GetArrayViewFromImage(image: 'itkImageCVF43') -> "PyObject *":
    """itkPyBufferICVF43__GetArrayViewFromImage(itkImageCVF43 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferICVF43__GetArrayViewFromImage(image)

def itkPyBufferICVF43__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageCVF43_Pointer const":
    """itkPyBufferICVF43__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageCVF43_Pointer const"""
    return _itkPyBufferPython.itkPyBufferICVF43__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferID2(object):
    """


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package.

    C++ includes: itkPyBuffer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageD2') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageD2 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferID2__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageD2_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageD2_Pointer const"""
        return _itkPyBufferPython.itkPyBufferID2__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferID2 self) -> itkPyBufferID2
        __init__(itkPyBufferID2 self, itkPyBufferID2 arg0) -> itkPyBufferID2



        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package.

        C++ includes: itkPyBuffer.h 
        """
        _itkPyBufferPython.itkPyBufferID2_swiginit(self, _itkPyBufferPython.new_itkPyBufferID2(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferID2


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferID2._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferID2.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferID2._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferID2._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferID2._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferID2.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorID2.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferID2_swigregister = _itkPyBufferPython.itkPyBufferID2_swigregister
itkPyBufferID2_swigregister(itkPyBufferID2)

def itkPyBufferID2__GetArrayViewFromImage(image: 'itkImageD2') -> "PyObject *":
    """itkPyBufferID2__GetArrayViewFromImage(itkImageD2 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferID2__GetArrayViewFromImage(image)

def itkPyBufferID2__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageD2_Pointer const":
    """itkPyBufferID2__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageD2_Pointer const"""
    return _itkPyBufferPython.itkPyBufferID2__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferID3(object):
    """


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package.

    C++ includes: itkPyBuffer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageD3') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageD3 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferID3__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageD3_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageD3_Pointer const"""
        return _itkPyBufferPython.itkPyBufferID3__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferID3 self) -> itkPyBufferID3
        __init__(itkPyBufferID3 self, itkPyBufferID3 arg0) -> itkPyBufferID3



        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package.

        C++ includes: itkPyBuffer.h 
        """
        _itkPyBufferPython.itkPyBufferID3_swiginit(self, _itkPyBufferPython.new_itkPyBufferID3(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferID3


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferID3._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferID3.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferID3._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferID3._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferID3._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferID3.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorID3.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferID3_swigregister = _itkPyBufferPython.itkPyBufferID3_swigregister
itkPyBufferID3_swigregister(itkPyBufferID3)

def itkPyBufferID3__GetArrayViewFromImage(image: 'itkImageD3') -> "PyObject *":
    """itkPyBufferID3__GetArrayViewFromImage(itkImageD3 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferID3__GetArrayViewFromImage(image)

def itkPyBufferID3__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageD3_Pointer const":
    """itkPyBufferID3__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageD3_Pointer const"""
    return _itkPyBufferPython.itkPyBufferID3__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferIF2(object):
    """


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package.

    C++ includes: itkPyBuffer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageF2') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageF2 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferIF2__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageF2_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageF2_Pointer const"""
        return _itkPyBufferPython.itkPyBufferIF2__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferIF2 self) -> itkPyBufferIF2
        __init__(itkPyBufferIF2 self, itkPyBufferIF2 arg0) -> itkPyBufferIF2



        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package.

        C++ includes: itkPyBuffer.h 
        """
        _itkPyBufferPython.itkPyBufferIF2_swiginit(self, _itkPyBufferPython.new_itkPyBufferIF2(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIF2


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIF2._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIF2.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIF2._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIF2._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferIF2._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIF2.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorIF2.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferIF2_swigregister = _itkPyBufferPython.itkPyBufferIF2_swigregister
itkPyBufferIF2_swigregister(itkPyBufferIF2)

def itkPyBufferIF2__GetArrayViewFromImage(image: 'itkImageF2') -> "PyObject *":
    """itkPyBufferIF2__GetArrayViewFromImage(itkImageF2 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferIF2__GetArrayViewFromImage(image)

def itkPyBufferIF2__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageF2_Pointer const":
    """itkPyBufferIF2__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageF2_Pointer const"""
    return _itkPyBufferPython.itkPyBufferIF2__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferIF3(object):
    """


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package.

    C++ includes: itkPyBuffer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageF3') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageF3 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferIF3__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageF3_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageF3_Pointer const"""
        return _itkPyBufferPython.itkPyBufferIF3__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferIF3 self) -> itkPyBufferIF3
        __init__(itkPyBufferIF3 self, itkPyBufferIF3 arg0) -> itkPyBufferIF3



        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package.

        C++ includes: itkPyBuffer.h 
        """
        _itkPyBufferPython.itkPyBufferIF3_swiginit(self, _itkPyBufferPython.new_itkPyBufferIF3(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIF3


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIF3._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIF3.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIF3._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIF3._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferIF3._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIF3.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorIF3.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferIF3_swigregister = _itkPyBufferPython.itkPyBufferIF3_swigregister
itkPyBufferIF3_swigregister(itkPyBufferIF3)

def itkPyBufferIF3__GetArrayViewFromImage(image: 'itkImageF3') -> "PyObject *":
    """itkPyBufferIF3__GetArrayViewFromImage(itkImageF3 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferIF3__GetArrayViewFromImage(image)

def itkPyBufferIF3__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageF3_Pointer const":
    """itkPyBufferIF3__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageF3_Pointer const"""
    return _itkPyBufferPython.itkPyBufferIF3__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferIRGBAUC2(object):
    """


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package.

    C++ includes: itkPyBuffer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageRGBAUC2') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageRGBAUC2 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferIRGBAUC2__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageRGBAUC2_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageRGBAUC2_Pointer const"""
        return _itkPyBufferPython.itkPyBufferIRGBAUC2__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferIRGBAUC2 self) -> itkPyBufferIRGBAUC2
        __init__(itkPyBufferIRGBAUC2 self, itkPyBufferIRGBAUC2 arg0) -> itkPyBufferIRGBAUC2



        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package.

        C++ includes: itkPyBuffer.h 
        """
        _itkPyBufferPython.itkPyBufferIRGBAUC2_swiginit(self, _itkPyBufferPython.new_itkPyBufferIRGBAUC2(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIRGBAUC2


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "UC"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIRGBAUC2._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIRGBAUC2.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIRGBAUC2._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIRGBAUC2._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferIRGBAUC2._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIRGBAUC2.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorIRGBAUC2.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferIRGBAUC2_swigregister = _itkPyBufferPython.itkPyBufferIRGBAUC2_swigregister
itkPyBufferIRGBAUC2_swigregister(itkPyBufferIRGBAUC2)

def itkPyBufferIRGBAUC2__GetArrayViewFromImage(image: 'itkImageRGBAUC2') -> "PyObject *":
    """itkPyBufferIRGBAUC2__GetArrayViewFromImage(itkImageRGBAUC2 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferIRGBAUC2__GetArrayViewFromImage(image)

def itkPyBufferIRGBAUC2__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageRGBAUC2_Pointer const":
    """itkPyBufferIRGBAUC2__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageRGBAUC2_Pointer const"""
    return _itkPyBufferPython.itkPyBufferIRGBAUC2__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferIRGBAUC3(object):
    """


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package.

    C++ includes: itkPyBuffer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageRGBAUC3') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageRGBAUC3 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferIRGBAUC3__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageRGBAUC3_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageRGBAUC3_Pointer const"""
        return _itkPyBufferPython.itkPyBufferIRGBAUC3__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferIRGBAUC3 self) -> itkPyBufferIRGBAUC3
        __init__(itkPyBufferIRGBAUC3 self, itkPyBufferIRGBAUC3 arg0) -> itkPyBufferIRGBAUC3



        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package.

        C++ includes: itkPyBuffer.h 
        """
        _itkPyBufferPython.itkPyBufferIRGBAUC3_swiginit(self, _itkPyBufferPython.new_itkPyBufferIRGBAUC3(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIRGBAUC3


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "UC"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIRGBAUC3._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIRGBAUC3.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIRGBAUC3._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIRGBAUC3._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferIRGBAUC3._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIRGBAUC3.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorIRGBAUC3.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferIRGBAUC3_swigregister = _itkPyBufferPython.itkPyBufferIRGBAUC3_swigregister
itkPyBufferIRGBAUC3_swigregister(itkPyBufferIRGBAUC3)

def itkPyBufferIRGBAUC3__GetArrayViewFromImage(image: 'itkImageRGBAUC3') -> "PyObject *":
    """itkPyBufferIRGBAUC3__GetArrayViewFromImage(itkImageRGBAUC3 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferIRGBAUC3__GetArrayViewFromImage(image)

def itkPyBufferIRGBAUC3__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageRGBAUC3_Pointer const":
    """itkPyBufferIRGBAUC3__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageRGBAUC3_Pointer const"""
    return _itkPyBufferPython.itkPyBufferIRGBAUC3__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferIRGBUC2(object):
    """


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package.

    C++ includes: itkPyBuffer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageRGBUC2') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageRGBUC2 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferIRGBUC2__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageRGBUC2_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageRGBUC2_Pointer const"""
        return _itkPyBufferPython.itkPyBufferIRGBUC2__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferIRGBUC2 self) -> itkPyBufferIRGBUC2
        __init__(itkPyBufferIRGBUC2 self, itkPyBufferIRGBUC2 arg0) -> itkPyBufferIRGBUC2



        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package.

        C++ includes: itkPyBuffer.h 
        """
        _itkPyBufferPython.itkPyBufferIRGBUC2_swiginit(self, _itkPyBufferPython.new_itkPyBufferIRGBUC2(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIRGBUC2


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "UC"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIRGBUC2._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIRGBUC2.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIRGBUC2._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIRGBUC2._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferIRGBUC2._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIRGBUC2.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorIRGBUC2.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferIRGBUC2_swigregister = _itkPyBufferPython.itkPyBufferIRGBUC2_swigregister
itkPyBufferIRGBUC2_swigregister(itkPyBufferIRGBUC2)

def itkPyBufferIRGBUC2__GetArrayViewFromImage(image: 'itkImageRGBUC2') -> "PyObject *":
    """itkPyBufferIRGBUC2__GetArrayViewFromImage(itkImageRGBUC2 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferIRGBUC2__GetArrayViewFromImage(image)

def itkPyBufferIRGBUC2__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageRGBUC2_Pointer const":
    """itkPyBufferIRGBUC2__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageRGBUC2_Pointer const"""
    return _itkPyBufferPython.itkPyBufferIRGBUC2__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferIRGBUC3(object):
    """


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package.

    C++ includes: itkPyBuffer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageRGBUC3') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageRGBUC3 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferIRGBUC3__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageRGBUC3_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageRGBUC3_Pointer const"""
        return _itkPyBufferPython.itkPyBufferIRGBUC3__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferIRGBUC3 self) -> itkPyBufferIRGBUC3
        __init__(itkPyBufferIRGBUC3 self, itkPyBufferIRGBUC3 arg0) -> itkPyBufferIRGBUC3



        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package.

        C++ includes: itkPyBuffer.h 
        """
        _itkPyBufferPython.itkPyBufferIRGBUC3_swiginit(self, _itkPyBufferPython.new_itkPyBufferIRGBUC3(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIRGBUC3


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "UC"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIRGBUC3._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIRGBUC3.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIRGBUC3._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIRGBUC3._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferIRGBUC3._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIRGBUC3.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorIRGBUC3.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferIRGBUC3_swigregister = _itkPyBufferPython.itkPyBufferIRGBUC3_swigregister
itkPyBufferIRGBUC3_swigregister(itkPyBufferIRGBUC3)

def itkPyBufferIRGBUC3__GetArrayViewFromImage(image: 'itkImageRGBUC3') -> "PyObject *":
    """itkPyBufferIRGBUC3__GetArrayViewFromImage(itkImageRGBUC3 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferIRGBUC3__GetArrayViewFromImage(image)

def itkPyBufferIRGBUC3__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageRGBUC3_Pointer const":
    """itkPyBufferIRGBUC3__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageRGBUC3_Pointer const"""
    return _itkPyBufferPython.itkPyBufferIRGBUC3__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferISS2(object):
    """


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package.

    C++ includes: itkPyBuffer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageSS2') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageSS2 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferISS2__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageSS2_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageSS2_Pointer const"""
        return _itkPyBufferPython.itkPyBufferISS2__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferISS2 self) -> itkPyBufferISS2
        __init__(itkPyBufferISS2 self, itkPyBufferISS2 arg0) -> itkPyBufferISS2



        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package.

        C++ includes: itkPyBuffer.h 
        """
        _itkPyBufferPython.itkPyBufferISS2_swiginit(self, _itkPyBufferPython.new_itkPyBufferISS2(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferISS2


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "SS"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferISS2._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferISS2.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferISS2._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferISS2._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferISS2._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferISS2.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorISS2.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferISS2_swigregister = _itkPyBufferPython.itkPyBufferISS2_swigregister
itkPyBufferISS2_swigregister(itkPyBufferISS2)

def itkPyBufferISS2__GetArrayViewFromImage(image: 'itkImageSS2') -> "PyObject *":
    """itkPyBufferISS2__GetArrayViewFromImage(itkImageSS2 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferISS2__GetArrayViewFromImage(image)

def itkPyBufferISS2__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageSS2_Pointer const":
    """itkPyBufferISS2__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageSS2_Pointer const"""
    return _itkPyBufferPython.itkPyBufferISS2__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferISS3(object):
    """


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package.

    C++ includes: itkPyBuffer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageSS3') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageSS3 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferISS3__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageSS3_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageSS3_Pointer const"""
        return _itkPyBufferPython.itkPyBufferISS3__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferISS3 self) -> itkPyBufferISS3
        __init__(itkPyBufferISS3 self, itkPyBufferISS3 arg0) -> itkPyBufferISS3



        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package.

        C++ includes: itkPyBuffer.h 
        """
        _itkPyBufferPython.itkPyBufferISS3_swiginit(self, _itkPyBufferPython.new_itkPyBufferISS3(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferISS3


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "SS"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferISS3._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferISS3.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferISS3._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferISS3._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferISS3._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferISS3.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorISS3.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferISS3_swigregister = _itkPyBufferPython.itkPyBufferISS3_swigregister
itkPyBufferISS3_swigregister(itkPyBufferISS3)

def itkPyBufferISS3__GetArrayViewFromImage(image: 'itkImageSS3') -> "PyObject *":
    """itkPyBufferISS3__GetArrayViewFromImage(itkImageSS3 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferISS3__GetArrayViewFromImage(image)

def itkPyBufferISS3__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageSS3_Pointer const":
    """itkPyBufferISS3__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageSS3_Pointer const"""
    return _itkPyBufferPython.itkPyBufferISS3__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferISSRTD22(object):
    """


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package.

    C++ includes: itkPyBuffer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageSSRTD22') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageSSRTD22 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferISSRTD22__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageSSRTD22_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageSSRTD22_Pointer const"""
        return _itkPyBufferPython.itkPyBufferISSRTD22__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferISSRTD22 self) -> itkPyBufferISSRTD22
        __init__(itkPyBufferISSRTD22 self, itkPyBufferISSRTD22 arg0) -> itkPyBufferISSRTD22



        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package.

        C++ includes: itkPyBuffer.h 
        """
        _itkPyBufferPython.itkPyBufferISSRTD22_swiginit(self, _itkPyBufferPython.new_itkPyBufferISSRTD22(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferISSRTD22


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferISSRTD22._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferISSRTD22.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferISSRTD22._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferISSRTD22._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferISSRTD22._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferISSRTD22.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorISSRTD22.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferISSRTD22_swigregister = _itkPyBufferPython.itkPyBufferISSRTD22_swigregister
itkPyBufferISSRTD22_swigregister(itkPyBufferISSRTD22)

def itkPyBufferISSRTD22__GetArrayViewFromImage(image: 'itkImageSSRTD22') -> "PyObject *":
    """itkPyBufferISSRTD22__GetArrayViewFromImage(itkImageSSRTD22 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferISSRTD22__GetArrayViewFromImage(image)

def itkPyBufferISSRTD22__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageSSRTD22_Pointer const":
    """itkPyBufferISSRTD22__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageSSRTD22_Pointer const"""
    return _itkPyBufferPython.itkPyBufferISSRTD22__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferISSRTD33(object):
    """


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package.

    C++ includes: itkPyBuffer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageSSRTD33') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageSSRTD33 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferISSRTD33__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageSSRTD33_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageSSRTD33_Pointer const"""
        return _itkPyBufferPython.itkPyBufferISSRTD33__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferISSRTD33 self) -> itkPyBufferISSRTD33
        __init__(itkPyBufferISSRTD33 self, itkPyBufferISSRTD33 arg0) -> itkPyBufferISSRTD33



        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package.

        C++ includes: itkPyBuffer.h 
        """
        _itkPyBufferPython.itkPyBufferISSRTD33_swiginit(self, _itkPyBufferPython.new_itkPyBufferISSRTD33(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferISSRTD33


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferISSRTD33._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferISSRTD33.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferISSRTD33._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferISSRTD33._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferISSRTD33._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferISSRTD33.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorISSRTD33.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferISSRTD33_swigregister = _itkPyBufferPython.itkPyBufferISSRTD33_swigregister
itkPyBufferISSRTD33_swigregister(itkPyBufferISSRTD33)

def itkPyBufferISSRTD33__GetArrayViewFromImage(image: 'itkImageSSRTD33') -> "PyObject *":
    """itkPyBufferISSRTD33__GetArrayViewFromImage(itkImageSSRTD33 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferISSRTD33__GetArrayViewFromImage(image)

def itkPyBufferISSRTD33__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageSSRTD33_Pointer const":
    """itkPyBufferISSRTD33__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageSSRTD33_Pointer const"""
    return _itkPyBufferPython.itkPyBufferISSRTD33__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferIUC2(object):
    """


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package.

    C++ includes: itkPyBuffer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageUC2') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageUC2 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferIUC2__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageUC2_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageUC2_Pointer const"""
        return _itkPyBufferPython.itkPyBufferIUC2__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferIUC2 self) -> itkPyBufferIUC2
        __init__(itkPyBufferIUC2 self, itkPyBufferIUC2 arg0) -> itkPyBufferIUC2



        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package.

        C++ includes: itkPyBuffer.h 
        """
        _itkPyBufferPython.itkPyBufferIUC2_swiginit(self, _itkPyBufferPython.new_itkPyBufferIUC2(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIUC2


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "UC"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIUC2._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIUC2.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIUC2._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIUC2._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferIUC2._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIUC2.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorIUC2.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferIUC2_swigregister = _itkPyBufferPython.itkPyBufferIUC2_swigregister
itkPyBufferIUC2_swigregister(itkPyBufferIUC2)

def itkPyBufferIUC2__GetArrayViewFromImage(image: 'itkImageUC2') -> "PyObject *":
    """itkPyBufferIUC2__GetArrayViewFromImage(itkImageUC2 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferIUC2__GetArrayViewFromImage(image)

def itkPyBufferIUC2__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageUC2_Pointer const":
    """itkPyBufferIUC2__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageUC2_Pointer const"""
    return _itkPyBufferPython.itkPyBufferIUC2__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferIUC3(object):
    """


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package.

    C++ includes: itkPyBuffer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageUC3') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageUC3 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferIUC3__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageUC3_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageUC3_Pointer const"""
        return _itkPyBufferPython.itkPyBufferIUC3__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferIUC3 self) -> itkPyBufferIUC3
        __init__(itkPyBufferIUC3 self, itkPyBufferIUC3 arg0) -> itkPyBufferIUC3



        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package.

        C++ includes: itkPyBuffer.h 
        """
        _itkPyBufferPython.itkPyBufferIUC3_swiginit(self, _itkPyBufferPython.new_itkPyBufferIUC3(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIUC3


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "UC"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIUC3._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIUC3.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIUC3._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIUC3._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferIUC3._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIUC3.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorIUC3.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferIUC3_swigregister = _itkPyBufferPython.itkPyBufferIUC3_swigregister
itkPyBufferIUC3_swigregister(itkPyBufferIUC3)

def itkPyBufferIUC3__GetArrayViewFromImage(image: 'itkImageUC3') -> "PyObject *":
    """itkPyBufferIUC3__GetArrayViewFromImage(itkImageUC3 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferIUC3__GetArrayViewFromImage(image)

def itkPyBufferIUC3__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageUC3_Pointer const":
    """itkPyBufferIUC3__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageUC3_Pointer const"""
    return _itkPyBufferPython.itkPyBufferIUC3__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferIUL2(object):
    """


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package.

    C++ includes: itkPyBuffer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageUL2') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageUL2 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferIUL2__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageUL2_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageUL2_Pointer const"""
        return _itkPyBufferPython.itkPyBufferIUL2__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferIUL2 self) -> itkPyBufferIUL2
        __init__(itkPyBufferIUL2 self, itkPyBufferIUL2 arg0) -> itkPyBufferIUL2



        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package.

        C++ includes: itkPyBuffer.h 
        """
        _itkPyBufferPython.itkPyBufferIUL2_swiginit(self, _itkPyBufferPython.new_itkPyBufferIUL2(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIUL2


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "UL"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIUL2._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIUL2.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIUL2._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIUL2._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferIUL2._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIUL2.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorIUL2.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferIUL2_swigregister = _itkPyBufferPython.itkPyBufferIUL2_swigregister
itkPyBufferIUL2_swigregister(itkPyBufferIUL2)

def itkPyBufferIUL2__GetArrayViewFromImage(image: 'itkImageUL2') -> "PyObject *":
    """itkPyBufferIUL2__GetArrayViewFromImage(itkImageUL2 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferIUL2__GetArrayViewFromImage(image)

def itkPyBufferIUL2__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageUL2_Pointer const":
    """itkPyBufferIUL2__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageUL2_Pointer const"""
    return _itkPyBufferPython.itkPyBufferIUL2__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferIUL3(object):
    """


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package.

    C++ includes: itkPyBuffer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageUL3') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageUL3 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferIUL3__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageUL3_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageUL3_Pointer const"""
        return _itkPyBufferPython.itkPyBufferIUL3__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferIUL3 self) -> itkPyBufferIUL3
        __init__(itkPyBufferIUL3 self, itkPyBufferIUL3 arg0) -> itkPyBufferIUL3



        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package.

        C++ includes: itkPyBuffer.h 
        """
        _itkPyBufferPython.itkPyBufferIUL3_swiginit(self, _itkPyBufferPython.new_itkPyBufferIUL3(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIUL3


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "UL"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIUL3._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIUL3.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIUL3._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIUL3._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferIUL3._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIUL3.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorIUL3.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferIUL3_swigregister = _itkPyBufferPython.itkPyBufferIUL3_swigregister
itkPyBufferIUL3_swigregister(itkPyBufferIUL3)

def itkPyBufferIUL3__GetArrayViewFromImage(image: 'itkImageUL3') -> "PyObject *":
    """itkPyBufferIUL3__GetArrayViewFromImage(itkImageUL3 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferIUL3__GetArrayViewFromImage(image)

def itkPyBufferIUL3__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageUL3_Pointer const":
    """itkPyBufferIUL3__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageUL3_Pointer const"""
    return _itkPyBufferPython.itkPyBufferIUL3__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferIUS2(object):
    """


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package.

    C++ includes: itkPyBuffer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageUS2') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageUS2 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferIUS2__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageUS2_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageUS2_Pointer const"""
        return _itkPyBufferPython.itkPyBufferIUS2__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferIUS2 self) -> itkPyBufferIUS2
        __init__(itkPyBufferIUS2 self, itkPyBufferIUS2 arg0) -> itkPyBufferIUS2



        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package.

        C++ includes: itkPyBuffer.h 
        """
        _itkPyBufferPython.itkPyBufferIUS2_swiginit(self, _itkPyBufferPython.new_itkPyBufferIUS2(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIUS2


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "US"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIUS2._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIUS2.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIUS2._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIUS2._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferIUS2._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIUS2.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorIUS2.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferIUS2_swigregister = _itkPyBufferPython.itkPyBufferIUS2_swigregister
itkPyBufferIUS2_swigregister(itkPyBufferIUS2)

def itkPyBufferIUS2__GetArrayViewFromImage(image: 'itkImageUS2') -> "PyObject *":
    """itkPyBufferIUS2__GetArrayViewFromImage(itkImageUS2 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferIUS2__GetArrayViewFromImage(image)

def itkPyBufferIUS2__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageUS2_Pointer const":
    """itkPyBufferIUS2__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageUS2_Pointer const"""
    return _itkPyBufferPython.itkPyBufferIUS2__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferIUS3(object):
    """


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package.

    C++ includes: itkPyBuffer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageUS3') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageUS3 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferIUS3__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageUS3_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageUS3_Pointer const"""
        return _itkPyBufferPython.itkPyBufferIUS3__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferIUS3 self) -> itkPyBufferIUS3
        __init__(itkPyBufferIUS3 self, itkPyBufferIUS3 arg0) -> itkPyBufferIUS3



        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package.

        C++ includes: itkPyBuffer.h 
        """
        _itkPyBufferPython.itkPyBufferIUS3_swiginit(self, _itkPyBufferPython.new_itkPyBufferIUS3(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIUS3


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "US"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIUS3._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIUS3.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIUS3._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIUS3._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferIUS3._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIUS3.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorIUS3.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferIUS3_swigregister = _itkPyBufferPython.itkPyBufferIUS3_swigregister
itkPyBufferIUS3_swigregister(itkPyBufferIUS3)

def itkPyBufferIUS3__GetArrayViewFromImage(image: 'itkImageUS3') -> "PyObject *":
    """itkPyBufferIUS3__GetArrayViewFromImage(itkImageUS3 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferIUS3__GetArrayViewFromImage(image)

def itkPyBufferIUS3__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageUS3_Pointer const":
    """itkPyBufferIUS3__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageUS3_Pointer const"""
    return _itkPyBufferPython.itkPyBufferIUS3__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferIVD22(object):
    """


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package.

    C++ includes: itkPyBuffer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageVD22') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageVD22 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferIVD22__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageVD22_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageVD22_Pointer const"""
        return _itkPyBufferPython.itkPyBufferIVD22__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferIVD22 self) -> itkPyBufferIVD22
        __init__(itkPyBufferIVD22 self, itkPyBufferIVD22 arg0) -> itkPyBufferIVD22



        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package.

        C++ includes: itkPyBuffer.h 
        """
        _itkPyBufferPython.itkPyBufferIVD22_swiginit(self, _itkPyBufferPython.new_itkPyBufferIVD22(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIVD22


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIVD22._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIVD22.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIVD22._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIVD22._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferIVD22._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIVD22.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorIVD22.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferIVD22_swigregister = _itkPyBufferPython.itkPyBufferIVD22_swigregister
itkPyBufferIVD22_swigregister(itkPyBufferIVD22)

def itkPyBufferIVD22__GetArrayViewFromImage(image: 'itkImageVD22') -> "PyObject *":
    """itkPyBufferIVD22__GetArrayViewFromImage(itkImageVD22 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferIVD22__GetArrayViewFromImage(image)

def itkPyBufferIVD22__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageVD22_Pointer const":
    """itkPyBufferIVD22__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageVD22_Pointer const"""
    return _itkPyBufferPython.itkPyBufferIVD22__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferIVD23(object):
    """


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package.

    C++ includes: itkPyBuffer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageVD23') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageVD23 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferIVD23__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageVD23_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageVD23_Pointer const"""
        return _itkPyBufferPython.itkPyBufferIVD23__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferIVD23 self) -> itkPyBufferIVD23
        __init__(itkPyBufferIVD23 self, itkPyBufferIVD23 arg0) -> itkPyBufferIVD23



        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package.

        C++ includes: itkPyBuffer.h 
        """
        _itkPyBufferPython.itkPyBufferIVD23_swiginit(self, _itkPyBufferPython.new_itkPyBufferIVD23(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIVD23


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIVD23._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIVD23.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIVD23._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIVD23._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferIVD23._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIVD23.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorIVD23.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferIVD23_swigregister = _itkPyBufferPython.itkPyBufferIVD23_swigregister
itkPyBufferIVD23_swigregister(itkPyBufferIVD23)

def itkPyBufferIVD23__GetArrayViewFromImage(image: 'itkImageVD23') -> "PyObject *":
    """itkPyBufferIVD23__GetArrayViewFromImage(itkImageVD23 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferIVD23__GetArrayViewFromImage(image)

def itkPyBufferIVD23__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageVD23_Pointer const":
    """itkPyBufferIVD23__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageVD23_Pointer const"""
    return _itkPyBufferPython.itkPyBufferIVD23__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferIVD32(object):
    """


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package.

    C++ includes: itkPyBuffer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageVD32') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageVD32 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferIVD32__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageVD32_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageVD32_Pointer const"""
        return _itkPyBufferPython.itkPyBufferIVD32__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferIVD32 self) -> itkPyBufferIVD32
        __init__(itkPyBufferIVD32 self, itkPyBufferIVD32 arg0) -> itkPyBufferIVD32



        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package.

        C++ includes: itkPyBuffer.h 
        """
        _itkPyBufferPython.itkPyBufferIVD32_swiginit(self, _itkPyBufferPython.new_itkPyBufferIVD32(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIVD32


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIVD32._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIVD32.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIVD32._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIVD32._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferIVD32._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIVD32.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorIVD32.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferIVD32_swigregister = _itkPyBufferPython.itkPyBufferIVD32_swigregister
itkPyBufferIVD32_swigregister(itkPyBufferIVD32)

def itkPyBufferIVD32__GetArrayViewFromImage(image: 'itkImageVD32') -> "PyObject *":
    """itkPyBufferIVD32__GetArrayViewFromImage(itkImageVD32 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferIVD32__GetArrayViewFromImage(image)

def itkPyBufferIVD32__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageVD32_Pointer const":
    """itkPyBufferIVD32__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageVD32_Pointer const"""
    return _itkPyBufferPython.itkPyBufferIVD32__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferIVD33(object):
    """


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package.

    C++ includes: itkPyBuffer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageVD33') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageVD33 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferIVD33__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageVD33_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageVD33_Pointer const"""
        return _itkPyBufferPython.itkPyBufferIVD33__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferIVD33 self) -> itkPyBufferIVD33
        __init__(itkPyBufferIVD33 self, itkPyBufferIVD33 arg0) -> itkPyBufferIVD33



        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package.

        C++ includes: itkPyBuffer.h 
        """
        _itkPyBufferPython.itkPyBufferIVD33_swiginit(self, _itkPyBufferPython.new_itkPyBufferIVD33(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIVD33


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIVD33._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIVD33.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIVD33._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIVD33._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferIVD33._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIVD33.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorIVD33.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferIVD33_swigregister = _itkPyBufferPython.itkPyBufferIVD33_swigregister
itkPyBufferIVD33_swigregister(itkPyBufferIVD33)

def itkPyBufferIVD33__GetArrayViewFromImage(image: 'itkImageVD33') -> "PyObject *":
    """itkPyBufferIVD33__GetArrayViewFromImage(itkImageVD33 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferIVD33__GetArrayViewFromImage(image)

def itkPyBufferIVD33__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageVD33_Pointer const":
    """itkPyBufferIVD33__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageVD33_Pointer const"""
    return _itkPyBufferPython.itkPyBufferIVD33__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferIVD42(object):
    """


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package.

    C++ includes: itkPyBuffer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageVD42') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageVD42 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferIVD42__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageVD42_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageVD42_Pointer const"""
        return _itkPyBufferPython.itkPyBufferIVD42__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferIVD42 self) -> itkPyBufferIVD42
        __init__(itkPyBufferIVD42 self, itkPyBufferIVD42 arg0) -> itkPyBufferIVD42



        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package.

        C++ includes: itkPyBuffer.h 
        """
        _itkPyBufferPython.itkPyBufferIVD42_swiginit(self, _itkPyBufferPython.new_itkPyBufferIVD42(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIVD42


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIVD42._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIVD42.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIVD42._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIVD42._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferIVD42._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIVD42.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorIVD42.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferIVD42_swigregister = _itkPyBufferPython.itkPyBufferIVD42_swigregister
itkPyBufferIVD42_swigregister(itkPyBufferIVD42)

def itkPyBufferIVD42__GetArrayViewFromImage(image: 'itkImageVD42') -> "PyObject *":
    """itkPyBufferIVD42__GetArrayViewFromImage(itkImageVD42 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferIVD42__GetArrayViewFromImage(image)

def itkPyBufferIVD42__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageVD42_Pointer const":
    """itkPyBufferIVD42__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageVD42_Pointer const"""
    return _itkPyBufferPython.itkPyBufferIVD42__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferIVD43(object):
    """


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package.

    C++ includes: itkPyBuffer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageVD43') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageVD43 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferIVD43__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageVD43_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageVD43_Pointer const"""
        return _itkPyBufferPython.itkPyBufferIVD43__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferIVD43 self) -> itkPyBufferIVD43
        __init__(itkPyBufferIVD43 self, itkPyBufferIVD43 arg0) -> itkPyBufferIVD43



        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package.

        C++ includes: itkPyBuffer.h 
        """
        _itkPyBufferPython.itkPyBufferIVD43_swiginit(self, _itkPyBufferPython.new_itkPyBufferIVD43(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIVD43


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIVD43._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIVD43.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIVD43._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIVD43._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferIVD43._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIVD43.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorIVD43.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferIVD43_swigregister = _itkPyBufferPython.itkPyBufferIVD43_swigregister
itkPyBufferIVD43_swigregister(itkPyBufferIVD43)

def itkPyBufferIVD43__GetArrayViewFromImage(image: 'itkImageVD43') -> "PyObject *":
    """itkPyBufferIVD43__GetArrayViewFromImage(itkImageVD43 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferIVD43__GetArrayViewFromImage(image)

def itkPyBufferIVD43__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageVD43_Pointer const":
    """itkPyBufferIVD43__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageVD43_Pointer const"""
    return _itkPyBufferPython.itkPyBufferIVD43__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferIVF22(object):
    """


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package.

    C++ includes: itkPyBuffer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageVF22') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageVF22 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferIVF22__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageVF22_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageVF22_Pointer const"""
        return _itkPyBufferPython.itkPyBufferIVF22__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferIVF22 self) -> itkPyBufferIVF22
        __init__(itkPyBufferIVF22 self, itkPyBufferIVF22 arg0) -> itkPyBufferIVF22



        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package.

        C++ includes: itkPyBuffer.h 
        """
        _itkPyBufferPython.itkPyBufferIVF22_swiginit(self, _itkPyBufferPython.new_itkPyBufferIVF22(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIVF22


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIVF22._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIVF22.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIVF22._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIVF22._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferIVF22._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIVF22.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorIVF22.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferIVF22_swigregister = _itkPyBufferPython.itkPyBufferIVF22_swigregister
itkPyBufferIVF22_swigregister(itkPyBufferIVF22)

def itkPyBufferIVF22__GetArrayViewFromImage(image: 'itkImageVF22') -> "PyObject *":
    """itkPyBufferIVF22__GetArrayViewFromImage(itkImageVF22 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferIVF22__GetArrayViewFromImage(image)

def itkPyBufferIVF22__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageVF22_Pointer const":
    """itkPyBufferIVF22__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageVF22_Pointer const"""
    return _itkPyBufferPython.itkPyBufferIVF22__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferIVF23(object):
    """


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package.

    C++ includes: itkPyBuffer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageVF23') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageVF23 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferIVF23__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageVF23_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageVF23_Pointer const"""
        return _itkPyBufferPython.itkPyBufferIVF23__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferIVF23 self) -> itkPyBufferIVF23
        __init__(itkPyBufferIVF23 self, itkPyBufferIVF23 arg0) -> itkPyBufferIVF23



        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package.

        C++ includes: itkPyBuffer.h 
        """
        _itkPyBufferPython.itkPyBufferIVF23_swiginit(self, _itkPyBufferPython.new_itkPyBufferIVF23(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIVF23


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIVF23._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIVF23.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIVF23._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIVF23._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferIVF23._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIVF23.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorIVF23.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferIVF23_swigregister = _itkPyBufferPython.itkPyBufferIVF23_swigregister
itkPyBufferIVF23_swigregister(itkPyBufferIVF23)

def itkPyBufferIVF23__GetArrayViewFromImage(image: 'itkImageVF23') -> "PyObject *":
    """itkPyBufferIVF23__GetArrayViewFromImage(itkImageVF23 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferIVF23__GetArrayViewFromImage(image)

def itkPyBufferIVF23__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageVF23_Pointer const":
    """itkPyBufferIVF23__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageVF23_Pointer const"""
    return _itkPyBufferPython.itkPyBufferIVF23__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferIVF32(object):
    """


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package.

    C++ includes: itkPyBuffer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageVF32') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageVF32 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferIVF32__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageVF32_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageVF32_Pointer const"""
        return _itkPyBufferPython.itkPyBufferIVF32__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferIVF32 self) -> itkPyBufferIVF32
        __init__(itkPyBufferIVF32 self, itkPyBufferIVF32 arg0) -> itkPyBufferIVF32



        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package.

        C++ includes: itkPyBuffer.h 
        """
        _itkPyBufferPython.itkPyBufferIVF32_swiginit(self, _itkPyBufferPython.new_itkPyBufferIVF32(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIVF32


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIVF32._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIVF32.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIVF32._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIVF32._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferIVF32._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIVF32.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorIVF32.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferIVF32_swigregister = _itkPyBufferPython.itkPyBufferIVF32_swigregister
itkPyBufferIVF32_swigregister(itkPyBufferIVF32)

def itkPyBufferIVF32__GetArrayViewFromImage(image: 'itkImageVF32') -> "PyObject *":
    """itkPyBufferIVF32__GetArrayViewFromImage(itkImageVF32 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferIVF32__GetArrayViewFromImage(image)

def itkPyBufferIVF32__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageVF32_Pointer const":
    """itkPyBufferIVF32__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageVF32_Pointer const"""
    return _itkPyBufferPython.itkPyBufferIVF32__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferIVF33(object):
    """


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package.

    C++ includes: itkPyBuffer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageVF33') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageVF33 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferIVF33__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageVF33_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageVF33_Pointer const"""
        return _itkPyBufferPython.itkPyBufferIVF33__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferIVF33 self) -> itkPyBufferIVF33
        __init__(itkPyBufferIVF33 self, itkPyBufferIVF33 arg0) -> itkPyBufferIVF33



        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package.

        C++ includes: itkPyBuffer.h 
        """
        _itkPyBufferPython.itkPyBufferIVF33_swiginit(self, _itkPyBufferPython.new_itkPyBufferIVF33(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIVF33


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIVF33._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIVF33.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIVF33._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIVF33._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferIVF33._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIVF33.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorIVF33.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferIVF33_swigregister = _itkPyBufferPython.itkPyBufferIVF33_swigregister
itkPyBufferIVF33_swigregister(itkPyBufferIVF33)

def itkPyBufferIVF33__GetArrayViewFromImage(image: 'itkImageVF33') -> "PyObject *":
    """itkPyBufferIVF33__GetArrayViewFromImage(itkImageVF33 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferIVF33__GetArrayViewFromImage(image)

def itkPyBufferIVF33__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageVF33_Pointer const":
    """itkPyBufferIVF33__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageVF33_Pointer const"""
    return _itkPyBufferPython.itkPyBufferIVF33__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferIVF42(object):
    """


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package.

    C++ includes: itkPyBuffer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageVF42') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageVF42 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferIVF42__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageVF42_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageVF42_Pointer const"""
        return _itkPyBufferPython.itkPyBufferIVF42__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferIVF42 self) -> itkPyBufferIVF42
        __init__(itkPyBufferIVF42 self, itkPyBufferIVF42 arg0) -> itkPyBufferIVF42



        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package.

        C++ includes: itkPyBuffer.h 
        """
        _itkPyBufferPython.itkPyBufferIVF42_swiginit(self, _itkPyBufferPython.new_itkPyBufferIVF42(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIVF42


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIVF42._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIVF42.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIVF42._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIVF42._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferIVF42._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIVF42.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorIVF42.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferIVF42_swigregister = _itkPyBufferPython.itkPyBufferIVF42_swigregister
itkPyBufferIVF42_swigregister(itkPyBufferIVF42)

def itkPyBufferIVF42__GetArrayViewFromImage(image: 'itkImageVF42') -> "PyObject *":
    """itkPyBufferIVF42__GetArrayViewFromImage(itkImageVF42 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferIVF42__GetArrayViewFromImage(image)

def itkPyBufferIVF42__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageVF42_Pointer const":
    """itkPyBufferIVF42__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageVF42_Pointer const"""
    return _itkPyBufferPython.itkPyBufferIVF42__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferIVF43(object):
    """


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package.

    C++ includes: itkPyBuffer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkImageVF43') -> "PyObject *":
        """_GetArrayViewFromImage(itkImageVF43 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferIVF43__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageVF43_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageVF43_Pointer const"""
        return _itkPyBufferPython.itkPyBufferIVF43__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferIVF43 self) -> itkPyBufferIVF43
        __init__(itkPyBufferIVF43 self, itkPyBufferIVF43 arg0) -> itkPyBufferIVF43



        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package.

        C++ includes: itkPyBuffer.h 
        """
        _itkPyBufferPython.itkPyBufferIVF43_swiginit(self, _itkPyBufferPython.new_itkPyBufferIVF43(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIVF43


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIVF43._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIVF43.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIVF43._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIVF43._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferIVF43._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIVF43.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorIVF43.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferIVF43_swigregister = _itkPyBufferPython.itkPyBufferIVF43_swigregister
itkPyBufferIVF43_swigregister(itkPyBufferIVF43)

def itkPyBufferIVF43__GetArrayViewFromImage(image: 'itkImageVF43') -> "PyObject *":
    """itkPyBufferIVF43__GetArrayViewFromImage(itkImageVF43 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferIVF43__GetArrayViewFromImage(image)

def itkPyBufferIVF43__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkImageVF43_Pointer const":
    """itkPyBufferIVF43__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkImageVF43_Pointer const"""
    return _itkPyBufferPython.itkPyBufferIVF43__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferVID2(object):
    """


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package.

    C++ includes: itkPyBuffer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkVectorImageD2') -> "PyObject *":
        """_GetArrayViewFromImage(itkVectorImageD2 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferVID2__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkVectorImageD2_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkVectorImageD2_Pointer const"""
        return _itkPyBufferPython.itkPyBufferVID2__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferVID2 self) -> itkPyBufferVID2
        __init__(itkPyBufferVID2 self, itkPyBufferVID2 arg0) -> itkPyBufferVID2



        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package.

        C++ includes: itkPyBuffer.h 
        """
        _itkPyBufferPython.itkPyBufferVID2_swiginit(self, _itkPyBufferPython.new_itkPyBufferVID2(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferVID2


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferVID2._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferVID2.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferVID2._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferVID2._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferVID2._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferVID2.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorVID2.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferVID2_swigregister = _itkPyBufferPython.itkPyBufferVID2_swigregister
itkPyBufferVID2_swigregister(itkPyBufferVID2)

def itkPyBufferVID2__GetArrayViewFromImage(image: 'itkVectorImageD2') -> "PyObject *":
    """itkPyBufferVID2__GetArrayViewFromImage(itkVectorImageD2 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferVID2__GetArrayViewFromImage(image)

def itkPyBufferVID2__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkVectorImageD2_Pointer const":
    """itkPyBufferVID2__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkVectorImageD2_Pointer const"""
    return _itkPyBufferPython.itkPyBufferVID2__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferVID3(object):
    """


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package.

    C++ includes: itkPyBuffer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkVectorImageD3') -> "PyObject *":
        """_GetArrayViewFromImage(itkVectorImageD3 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferVID3__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkVectorImageD3_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkVectorImageD3_Pointer const"""
        return _itkPyBufferPython.itkPyBufferVID3__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferVID3 self) -> itkPyBufferVID3
        __init__(itkPyBufferVID3 self, itkPyBufferVID3 arg0) -> itkPyBufferVID3



        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package.

        C++ includes: itkPyBuffer.h 
        """
        _itkPyBufferPython.itkPyBufferVID3_swiginit(self, _itkPyBufferPython.new_itkPyBufferVID3(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferVID3


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferVID3._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferVID3.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferVID3._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferVID3._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferVID3._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferVID3.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorVID3.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferVID3_swigregister = _itkPyBufferPython.itkPyBufferVID3_swigregister
itkPyBufferVID3_swigregister(itkPyBufferVID3)

def itkPyBufferVID3__GetArrayViewFromImage(image: 'itkVectorImageD3') -> "PyObject *":
    """itkPyBufferVID3__GetArrayViewFromImage(itkVectorImageD3 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferVID3__GetArrayViewFromImage(image)

def itkPyBufferVID3__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkVectorImageD3_Pointer const":
    """itkPyBufferVID3__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkVectorImageD3_Pointer const"""
    return _itkPyBufferPython.itkPyBufferVID3__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferVIF2(object):
    """


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package.

    C++ includes: itkPyBuffer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkVectorImageF2') -> "PyObject *":
        """_GetArrayViewFromImage(itkVectorImageF2 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferVIF2__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkVectorImageF2_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkVectorImageF2_Pointer const"""
        return _itkPyBufferPython.itkPyBufferVIF2__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferVIF2 self) -> itkPyBufferVIF2
        __init__(itkPyBufferVIF2 self, itkPyBufferVIF2 arg0) -> itkPyBufferVIF2



        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package.

        C++ includes: itkPyBuffer.h 
        """
        _itkPyBufferPython.itkPyBufferVIF2_swiginit(self, _itkPyBufferPython.new_itkPyBufferVIF2(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferVIF2


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferVIF2._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferVIF2.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferVIF2._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferVIF2._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferVIF2._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferVIF2.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorVIF2.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferVIF2_swigregister = _itkPyBufferPython.itkPyBufferVIF2_swigregister
itkPyBufferVIF2_swigregister(itkPyBufferVIF2)

def itkPyBufferVIF2__GetArrayViewFromImage(image: 'itkVectorImageF2') -> "PyObject *":
    """itkPyBufferVIF2__GetArrayViewFromImage(itkVectorImageF2 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferVIF2__GetArrayViewFromImage(image)

def itkPyBufferVIF2__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkVectorImageF2_Pointer const":
    """itkPyBufferVIF2__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkVectorImageF2_Pointer const"""
    return _itkPyBufferPython.itkPyBufferVIF2__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferVIF3(object):
    """


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package.

    C++ includes: itkPyBuffer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkVectorImageF3') -> "PyObject *":
        """_GetArrayViewFromImage(itkVectorImageF3 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferVIF3__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkVectorImageF3_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkVectorImageF3_Pointer const"""
        return _itkPyBufferPython.itkPyBufferVIF3__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferVIF3 self) -> itkPyBufferVIF3
        __init__(itkPyBufferVIF3 self, itkPyBufferVIF3 arg0) -> itkPyBufferVIF3



        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package.

        C++ includes: itkPyBuffer.h 
        """
        _itkPyBufferPython.itkPyBufferVIF3_swiginit(self, _itkPyBufferPython.new_itkPyBufferVIF3(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferVIF3


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferVIF3._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferVIF3.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferVIF3._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferVIF3._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferVIF3._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferVIF3.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorVIF3.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferVIF3_swigregister = _itkPyBufferPython.itkPyBufferVIF3_swigregister
itkPyBufferVIF3_swigregister(itkPyBufferVIF3)

def itkPyBufferVIF3__GetArrayViewFromImage(image: 'itkVectorImageF3') -> "PyObject *":
    """itkPyBufferVIF3__GetArrayViewFromImage(itkVectorImageF3 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferVIF3__GetArrayViewFromImage(image)

def itkPyBufferVIF3__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkVectorImageF3_Pointer const":
    """itkPyBufferVIF3__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkVectorImageF3_Pointer const"""
    return _itkPyBufferPython.itkPyBufferVIF3__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferVISS2(object):
    """


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package.

    C++ includes: itkPyBuffer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkVectorImageSS2') -> "PyObject *":
        """_GetArrayViewFromImage(itkVectorImageSS2 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferVISS2__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkVectorImageSS2_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkVectorImageSS2_Pointer const"""
        return _itkPyBufferPython.itkPyBufferVISS2__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferVISS2 self) -> itkPyBufferVISS2
        __init__(itkPyBufferVISS2 self, itkPyBufferVISS2 arg0) -> itkPyBufferVISS2



        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package.

        C++ includes: itkPyBuffer.h 
        """
        _itkPyBufferPython.itkPyBufferVISS2_swiginit(self, _itkPyBufferPython.new_itkPyBufferVISS2(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferVISS2


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "SS"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferVISS2._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferVISS2.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferVISS2._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferVISS2._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferVISS2._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferVISS2.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorVISS2.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferVISS2_swigregister = _itkPyBufferPython.itkPyBufferVISS2_swigregister
itkPyBufferVISS2_swigregister(itkPyBufferVISS2)

def itkPyBufferVISS2__GetArrayViewFromImage(image: 'itkVectorImageSS2') -> "PyObject *":
    """itkPyBufferVISS2__GetArrayViewFromImage(itkVectorImageSS2 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferVISS2__GetArrayViewFromImage(image)

def itkPyBufferVISS2__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkVectorImageSS2_Pointer const":
    """itkPyBufferVISS2__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkVectorImageSS2_Pointer const"""
    return _itkPyBufferPython.itkPyBufferVISS2__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferVISS3(object):
    """


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package.

    C++ includes: itkPyBuffer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkVectorImageSS3') -> "PyObject *":
        """_GetArrayViewFromImage(itkVectorImageSS3 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferVISS3__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkVectorImageSS3_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkVectorImageSS3_Pointer const"""
        return _itkPyBufferPython.itkPyBufferVISS3__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferVISS3 self) -> itkPyBufferVISS3
        __init__(itkPyBufferVISS3 self, itkPyBufferVISS3 arg0) -> itkPyBufferVISS3



        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package.

        C++ includes: itkPyBuffer.h 
        """
        _itkPyBufferPython.itkPyBufferVISS3_swiginit(self, _itkPyBufferPython.new_itkPyBufferVISS3(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferVISS3


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "SS"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferVISS3._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferVISS3.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferVISS3._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferVISS3._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferVISS3._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferVISS3.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorVISS3.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferVISS3_swigregister = _itkPyBufferPython.itkPyBufferVISS3_swigregister
itkPyBufferVISS3_swigregister(itkPyBufferVISS3)

def itkPyBufferVISS3__GetArrayViewFromImage(image: 'itkVectorImageSS3') -> "PyObject *":
    """itkPyBufferVISS3__GetArrayViewFromImage(itkVectorImageSS3 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferVISS3__GetArrayViewFromImage(image)

def itkPyBufferVISS3__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkVectorImageSS3_Pointer const":
    """itkPyBufferVISS3__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkVectorImageSS3_Pointer const"""
    return _itkPyBufferPython.itkPyBufferVISS3__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferVIUC2(object):
    """


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package.

    C++ includes: itkPyBuffer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkVectorImageUC2') -> "PyObject *":
        """_GetArrayViewFromImage(itkVectorImageUC2 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferVIUC2__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkVectorImageUC2_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkVectorImageUC2_Pointer const"""
        return _itkPyBufferPython.itkPyBufferVIUC2__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferVIUC2 self) -> itkPyBufferVIUC2
        __init__(itkPyBufferVIUC2 self, itkPyBufferVIUC2 arg0) -> itkPyBufferVIUC2



        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package.

        C++ includes: itkPyBuffer.h 
        """
        _itkPyBufferPython.itkPyBufferVIUC2_swiginit(self, _itkPyBufferPython.new_itkPyBufferVIUC2(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferVIUC2


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "UC"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferVIUC2._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferVIUC2.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferVIUC2._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferVIUC2._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferVIUC2._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferVIUC2.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorVIUC2.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferVIUC2_swigregister = _itkPyBufferPython.itkPyBufferVIUC2_swigregister
itkPyBufferVIUC2_swigregister(itkPyBufferVIUC2)

def itkPyBufferVIUC2__GetArrayViewFromImage(image: 'itkVectorImageUC2') -> "PyObject *":
    """itkPyBufferVIUC2__GetArrayViewFromImage(itkVectorImageUC2 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferVIUC2__GetArrayViewFromImage(image)

def itkPyBufferVIUC2__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkVectorImageUC2_Pointer const":
    """itkPyBufferVIUC2__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkVectorImageUC2_Pointer const"""
    return _itkPyBufferPython.itkPyBufferVIUC2__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferVIUC3(object):
    """


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package.

    C++ includes: itkPyBuffer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkVectorImageUC3') -> "PyObject *":
        """_GetArrayViewFromImage(itkVectorImageUC3 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferVIUC3__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkVectorImageUC3_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkVectorImageUC3_Pointer const"""
        return _itkPyBufferPython.itkPyBufferVIUC3__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferVIUC3 self) -> itkPyBufferVIUC3
        __init__(itkPyBufferVIUC3 self, itkPyBufferVIUC3 arg0) -> itkPyBufferVIUC3



        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package.

        C++ includes: itkPyBuffer.h 
        """
        _itkPyBufferPython.itkPyBufferVIUC3_swiginit(self, _itkPyBufferPython.new_itkPyBufferVIUC3(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferVIUC3


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "UC"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferVIUC3._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferVIUC3.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferVIUC3._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferVIUC3._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferVIUC3._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferVIUC3.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorVIUC3.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferVIUC3_swigregister = _itkPyBufferPython.itkPyBufferVIUC3_swigregister
itkPyBufferVIUC3_swigregister(itkPyBufferVIUC3)

def itkPyBufferVIUC3__GetArrayViewFromImage(image: 'itkVectorImageUC3') -> "PyObject *":
    """itkPyBufferVIUC3__GetArrayViewFromImage(itkVectorImageUC3 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferVIUC3__GetArrayViewFromImage(image)

def itkPyBufferVIUC3__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkVectorImageUC3_Pointer const":
    """itkPyBufferVIUC3__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkVectorImageUC3_Pointer const"""
    return _itkPyBufferPython.itkPyBufferVIUC3__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferVIUS2(object):
    """


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package.

    C++ includes: itkPyBuffer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkVectorImageUS2') -> "PyObject *":
        """_GetArrayViewFromImage(itkVectorImageUS2 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferVIUS2__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkVectorImageUS2_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkVectorImageUS2_Pointer const"""
        return _itkPyBufferPython.itkPyBufferVIUS2__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferVIUS2 self) -> itkPyBufferVIUS2
        __init__(itkPyBufferVIUS2 self, itkPyBufferVIUS2 arg0) -> itkPyBufferVIUS2



        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package.

        C++ includes: itkPyBuffer.h 
        """
        _itkPyBufferPython.itkPyBufferVIUS2_swiginit(self, _itkPyBufferPython.new_itkPyBufferVIUS2(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferVIUS2


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "US"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferVIUS2._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferVIUS2.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferVIUS2._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferVIUS2._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferVIUS2._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferVIUS2.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorVIUS2.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferVIUS2_swigregister = _itkPyBufferPython.itkPyBufferVIUS2_swigregister
itkPyBufferVIUS2_swigregister(itkPyBufferVIUS2)

def itkPyBufferVIUS2__GetArrayViewFromImage(image: 'itkVectorImageUS2') -> "PyObject *":
    """itkPyBufferVIUS2__GetArrayViewFromImage(itkVectorImageUS2 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferVIUS2__GetArrayViewFromImage(image)

def itkPyBufferVIUS2__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkVectorImageUS2_Pointer const":
    """itkPyBufferVIUS2__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkVectorImageUS2_Pointer const"""
    return _itkPyBufferPython.itkPyBufferVIUS2__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyBufferVIUS3(object):
    """


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package.

    C++ includes: itkPyBuffer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromImage(image: 'itkVectorImageUS3') -> "PyObject *":
        """_GetArrayViewFromImage(itkVectorImageUS3 image) -> PyObject *"""
        return _itkPyBufferPython.itkPyBufferVIUS3__GetArrayViewFromImage(image)

    _GetArrayViewFromImage = staticmethod(_GetArrayViewFromImage)

    def _GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkVectorImageUS3_Pointer const":
        """_GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkVectorImageUS3_Pointer const"""
        return _itkPyBufferPython.itkPyBufferVIUS3__GetImageViewFromArray(arr, shape, numOfComponent)

    _GetImageViewFromArray = staticmethod(_GetImageViewFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyBufferVIUS3 self) -> itkPyBufferVIUS3
        __init__(itkPyBufferVIUS3 self, itkPyBufferVIUS3 arg0) -> itkPyBufferVIUS3



        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package.

        C++ includes: itkPyBuffer.h 
        """
        _itkPyBufferPython.itkPyBufferVIUS3_swiginit(self, _itkPyBufferPython.new_itkPyBufferVIUS3(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferVIUS3


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "US"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferVIUS3._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferVIUS3.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 2, 3, 4 ), \
            "Only arrays of 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferVIUS3._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferVIUS3._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 2, 3 ):
            imgview = itkPyBufferVIUS3._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferVIUS3.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        duplicator = itkImageDuplicatorVIUS3.New()
        duplicator.SetInputImage(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)


itkPyBufferVIUS3_swigregister = _itkPyBufferPython.itkPyBufferVIUS3_swigregister
itkPyBufferVIUS3_swigregister(itkPyBufferVIUS3)

def itkPyBufferVIUS3__GetArrayViewFromImage(image: 'itkVectorImageUS3') -> "PyObject *":
    """itkPyBufferVIUS3__GetArrayViewFromImage(itkVectorImageUS3 image) -> PyObject *"""
    return _itkPyBufferPython.itkPyBufferVIUS3__GetArrayViewFromImage(image)

def itkPyBufferVIUS3__GetImageViewFromArray(arr: 'PyObject *', shape: 'PyObject *', numOfComponent: 'PyObject *') -> "itkVectorImageUS3_Pointer const":
    """itkPyBufferVIUS3__GetImageViewFromArray(PyObject * arr, PyObject * shape, PyObject * numOfComponent) -> itkVectorImageUS3_Pointer const"""
    return _itkPyBufferPython.itkPyBufferVIUS3__GetImageViewFromArray(arr, shape, numOfComponent)

class itkPyVnlD(object):
    """


    Helper class get views of VNL data buffers in python arrays and back.

    This class will either receive a VNL data structure and create the
    equivalent Python array view or will receive a Python array and create
    a copy of it in a VNL data structure. This permits passing VNL data
    structures into python arrays from the NumPy python package.

    C++ includes: itkPyVnl.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromVnlVector(vector: 'vnl_vectorD') -> "PyObject *":
        """_GetArrayViewFromVnlVector(vnl_vectorD vector) -> PyObject *"""
        return _itkPyBufferPython.itkPyVnlD__GetArrayViewFromVnlVector(vector)

    _GetArrayViewFromVnlVector = staticmethod(_GetArrayViewFromVnlVector)

    def _GetVnlVectorFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_vectorD const":
        """_GetVnlVectorFromArray(PyObject * arr, PyObject * shape) -> vnl_vectorD"""
        return _itkPyBufferPython.itkPyVnlD__GetVnlVectorFromArray(arr, shape)

    _GetVnlVectorFromArray = staticmethod(_GetVnlVectorFromArray)

    def _GetArrayViewFromVnlMatrix(matrix: 'vnl_matrixD') -> "PyObject *":
        """_GetArrayViewFromVnlMatrix(vnl_matrixD matrix) -> PyObject *"""
        return _itkPyBufferPython.itkPyVnlD__GetArrayViewFromVnlMatrix(matrix)

    _GetArrayViewFromVnlMatrix = staticmethod(_GetArrayViewFromVnlMatrix)

    def _GetVnlMatrixFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_matrixD const":
        """_GetVnlMatrixFromArray(PyObject * arr, PyObject * shape) -> vnl_matrixD"""
        return _itkPyBufferPython.itkPyVnlD__GetVnlMatrixFromArray(arr, shape)

    _GetVnlMatrixFromArray = staticmethod(_GetVnlMatrixFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyVnlD self) -> itkPyVnlD
        __init__(itkPyVnlD self, itkPyVnlD arg0) -> itkPyVnlD



        Helper class get views of VNL data buffers in python arrays and back.

        This class will either receive a VNL data structure and create the
        equivalent Python array view or will receive a Python array and create
        a copy of it in a VNL data structure. This permits passing VNL data
        structures into python arrays from the NumPy python package.

        C++ includes: itkPyVnl.h 
        """
        _itkPyBufferPython.itkPyVnlD_swiginit(self, _itkPyBufferPython.new_itkPyVnlD(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyVnlD


    def GetArrayViewFromVnlVector(vnl_vector):
        """Get a NumPy array view of a VNL vector."""

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        itksize = vnl_vector.size()
        shape   = [itksize]

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlD._GetArrayViewFromVnlVector(vnl_vector)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, vnl_vector)

        return itk_view

    GetArrayViewFromVnlVector = staticmethod(GetArrayViewFromVnlVector)

    def GetArrayFromVnlVector(vnl_vector):
        """Get a NumPy ndarray from VNL Vector.

        This is a deep copy of the VNL vector and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlD.GetArrayViewFromVnlVector(vnl_vector)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlVector = staticmethod(GetArrayFromVnlVector)

    def GetVnlVectorFromArray(ndarr):
        """Get a VNL vector from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.  It is not possible to have a view of a numpy array in a VNL vector since
        there is no VNL vector constructor that allows sharing data.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim == 1 , \
            "Only arrays of 1 dimension are supported."

        ndarr = np.ascontiguousarray(ndarr)
        vec = itkPyVnlD._GetVnlVectorFromArray( ndarr, ndarr.shape)

        return vec

    GetVnlVectorFromArray = staticmethod(GetVnlVectorFromArray)

    def GetArrayViewFromVnlMatrix(vnl_matrix):
        """Get a NumPy array view of a VNL matrix."""

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        cols = vnl_matrix.columns()
        rows = vnl_matrix.rows()
        dim     = 2
        shape   = [rows,cols]

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlD._GetArrayViewFromVnlMatrix(vnl_matrix)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)

        itk_view = NDArrayITKBase(ndarr_view, vnl_matrix)

        return itk_view

    GetArrayViewFromVnlMatrix = staticmethod(GetArrayViewFromVnlMatrix)

    def GetArrayFromVnlMatrix(vnl_matrix):
        """Get a NumPy ndarray from VNL matrix.

        This is a deep copy of the VNL matrix and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlD.GetArrayViewFromVnlMatrix(vnl_matrix)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlMatrix = staticmethod(GetArrayFromVnlMatrix)


    def GetVnlMatrixFromArray(ndarr):
        """Get a VNL Matrix from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects. It is not possible to have a view of a numpy array in a VNL matrix since there is no
        VNL matrix constructor that allows sharing data.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim == 2 , \
            "Only arrays of 2 dimensions are supported."

        ndarr = np.ascontiguousarray(ndarr)
        mat = itkPyVnlD._GetVnlMatrixFromArray( ndarr, ndarr.shape)

        return mat

    GetVnlMatrixFromArray = staticmethod(GetVnlMatrixFromArray)


itkPyVnlD_swigregister = _itkPyBufferPython.itkPyVnlD_swigregister
itkPyVnlD_swigregister(itkPyVnlD)

def itkPyVnlD__GetArrayViewFromVnlVector(vector: 'vnl_vectorD') -> "PyObject *":
    """itkPyVnlD__GetArrayViewFromVnlVector(vnl_vectorD vector) -> PyObject *"""
    return _itkPyBufferPython.itkPyVnlD__GetArrayViewFromVnlVector(vector)

def itkPyVnlD__GetVnlVectorFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_vectorD const":
    """itkPyVnlD__GetVnlVectorFromArray(PyObject * arr, PyObject * shape) -> vnl_vectorD"""
    return _itkPyBufferPython.itkPyVnlD__GetVnlVectorFromArray(arr, shape)

def itkPyVnlD__GetArrayViewFromVnlMatrix(matrix: 'vnl_matrixD') -> "PyObject *":
    """itkPyVnlD__GetArrayViewFromVnlMatrix(vnl_matrixD matrix) -> PyObject *"""
    return _itkPyBufferPython.itkPyVnlD__GetArrayViewFromVnlMatrix(matrix)

def itkPyVnlD__GetVnlMatrixFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_matrixD const":
    """itkPyVnlD__GetVnlMatrixFromArray(PyObject * arr, PyObject * shape) -> vnl_matrixD"""
    return _itkPyBufferPython.itkPyVnlD__GetVnlMatrixFromArray(arr, shape)

class itkPyVnlF(object):
    """


    Helper class get views of VNL data buffers in python arrays and back.

    This class will either receive a VNL data structure and create the
    equivalent Python array view or will receive a Python array and create
    a copy of it in a VNL data structure. This permits passing VNL data
    structures into python arrays from the NumPy python package.

    C++ includes: itkPyVnl.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromVnlVector(vector: 'vnl_vectorF') -> "PyObject *":
        """_GetArrayViewFromVnlVector(vnl_vectorF vector) -> PyObject *"""
        return _itkPyBufferPython.itkPyVnlF__GetArrayViewFromVnlVector(vector)

    _GetArrayViewFromVnlVector = staticmethod(_GetArrayViewFromVnlVector)

    def _GetVnlVectorFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_vectorF const":
        """_GetVnlVectorFromArray(PyObject * arr, PyObject * shape) -> vnl_vectorF"""
        return _itkPyBufferPython.itkPyVnlF__GetVnlVectorFromArray(arr, shape)

    _GetVnlVectorFromArray = staticmethod(_GetVnlVectorFromArray)

    def _GetArrayViewFromVnlMatrix(matrix: 'vnl_matrixF') -> "PyObject *":
        """_GetArrayViewFromVnlMatrix(vnl_matrixF matrix) -> PyObject *"""
        return _itkPyBufferPython.itkPyVnlF__GetArrayViewFromVnlMatrix(matrix)

    _GetArrayViewFromVnlMatrix = staticmethod(_GetArrayViewFromVnlMatrix)

    def _GetVnlMatrixFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_matrixF const":
        """_GetVnlMatrixFromArray(PyObject * arr, PyObject * shape) -> vnl_matrixF"""
        return _itkPyBufferPython.itkPyVnlF__GetVnlMatrixFromArray(arr, shape)

    _GetVnlMatrixFromArray = staticmethod(_GetVnlMatrixFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyVnlF self) -> itkPyVnlF
        __init__(itkPyVnlF self, itkPyVnlF arg0) -> itkPyVnlF



        Helper class get views of VNL data buffers in python arrays and back.

        This class will either receive a VNL data structure and create the
        equivalent Python array view or will receive a Python array and create
        a copy of it in a VNL data structure. This permits passing VNL data
        structures into python arrays from the NumPy python package.

        C++ includes: itkPyVnl.h 
        """
        _itkPyBufferPython.itkPyVnlF_swiginit(self, _itkPyBufferPython.new_itkPyVnlF(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyVnlF


    def GetArrayViewFromVnlVector(vnl_vector):
        """Get a NumPy array view of a VNL vector."""

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        itksize = vnl_vector.size()
        shape   = [itksize]

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlF._GetArrayViewFromVnlVector(vnl_vector)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, vnl_vector)

        return itk_view

    GetArrayViewFromVnlVector = staticmethod(GetArrayViewFromVnlVector)

    def GetArrayFromVnlVector(vnl_vector):
        """Get a NumPy ndarray from VNL Vector.

        This is a deep copy of the VNL vector and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlF.GetArrayViewFromVnlVector(vnl_vector)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlVector = staticmethod(GetArrayFromVnlVector)

    def GetVnlVectorFromArray(ndarr):
        """Get a VNL vector from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.  It is not possible to have a view of a numpy array in a VNL vector since
        there is no VNL vector constructor that allows sharing data.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim == 1 , \
            "Only arrays of 1 dimension are supported."

        ndarr = np.ascontiguousarray(ndarr)
        vec = itkPyVnlF._GetVnlVectorFromArray( ndarr, ndarr.shape)

        return vec

    GetVnlVectorFromArray = staticmethod(GetVnlVectorFromArray)

    def GetArrayViewFromVnlMatrix(vnl_matrix):
        """Get a NumPy array view of a VNL matrix."""

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        cols = vnl_matrix.columns()
        rows = vnl_matrix.rows()
        dim     = 2
        shape   = [rows,cols]

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlF._GetArrayViewFromVnlMatrix(vnl_matrix)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)

        itk_view = NDArrayITKBase(ndarr_view, vnl_matrix)

        return itk_view

    GetArrayViewFromVnlMatrix = staticmethod(GetArrayViewFromVnlMatrix)

    def GetArrayFromVnlMatrix(vnl_matrix):
        """Get a NumPy ndarray from VNL matrix.

        This is a deep copy of the VNL matrix and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlF.GetArrayViewFromVnlMatrix(vnl_matrix)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlMatrix = staticmethod(GetArrayFromVnlMatrix)


    def GetVnlMatrixFromArray(ndarr):
        """Get a VNL Matrix from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects. It is not possible to have a view of a numpy array in a VNL matrix since there is no
        VNL matrix constructor that allows sharing data.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim == 2 , \
            "Only arrays of 2 dimensions are supported."

        ndarr = np.ascontiguousarray(ndarr)
        mat = itkPyVnlF._GetVnlMatrixFromArray( ndarr, ndarr.shape)

        return mat

    GetVnlMatrixFromArray = staticmethod(GetVnlMatrixFromArray)


itkPyVnlF_swigregister = _itkPyBufferPython.itkPyVnlF_swigregister
itkPyVnlF_swigregister(itkPyVnlF)

def itkPyVnlF__GetArrayViewFromVnlVector(vector: 'vnl_vectorF') -> "PyObject *":
    """itkPyVnlF__GetArrayViewFromVnlVector(vnl_vectorF vector) -> PyObject *"""
    return _itkPyBufferPython.itkPyVnlF__GetArrayViewFromVnlVector(vector)

def itkPyVnlF__GetVnlVectorFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_vectorF const":
    """itkPyVnlF__GetVnlVectorFromArray(PyObject * arr, PyObject * shape) -> vnl_vectorF"""
    return _itkPyBufferPython.itkPyVnlF__GetVnlVectorFromArray(arr, shape)

def itkPyVnlF__GetArrayViewFromVnlMatrix(matrix: 'vnl_matrixF') -> "PyObject *":
    """itkPyVnlF__GetArrayViewFromVnlMatrix(vnl_matrixF matrix) -> PyObject *"""
    return _itkPyBufferPython.itkPyVnlF__GetArrayViewFromVnlMatrix(matrix)

def itkPyVnlF__GetVnlMatrixFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_matrixF const":
    """itkPyVnlF__GetVnlMatrixFromArray(PyObject * arr, PyObject * shape) -> vnl_matrixF"""
    return _itkPyBufferPython.itkPyVnlF__GetVnlMatrixFromArray(arr, shape)

class itkPyVnlSC(object):
    """


    Helper class get views of VNL data buffers in python arrays and back.

    This class will either receive a VNL data structure and create the
    equivalent Python array view or will receive a Python array and create
    a copy of it in a VNL data structure. This permits passing VNL data
    structures into python arrays from the NumPy python package.

    C++ includes: itkPyVnl.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromVnlVector(vector: 'vnl_vectorSC') -> "PyObject *":
        """_GetArrayViewFromVnlVector(vnl_vectorSC vector) -> PyObject *"""
        return _itkPyBufferPython.itkPyVnlSC__GetArrayViewFromVnlVector(vector)

    _GetArrayViewFromVnlVector = staticmethod(_GetArrayViewFromVnlVector)

    def _GetVnlVectorFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_vectorSC const":
        """_GetVnlVectorFromArray(PyObject * arr, PyObject * shape) -> vnl_vectorSC"""
        return _itkPyBufferPython.itkPyVnlSC__GetVnlVectorFromArray(arr, shape)

    _GetVnlVectorFromArray = staticmethod(_GetVnlVectorFromArray)

    def _GetArrayViewFromVnlMatrix(matrix: 'vnl_matrixSC') -> "PyObject *":
        """_GetArrayViewFromVnlMatrix(vnl_matrixSC matrix) -> PyObject *"""
        return _itkPyBufferPython.itkPyVnlSC__GetArrayViewFromVnlMatrix(matrix)

    _GetArrayViewFromVnlMatrix = staticmethod(_GetArrayViewFromVnlMatrix)

    def _GetVnlMatrixFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_matrixSC const":
        """_GetVnlMatrixFromArray(PyObject * arr, PyObject * shape) -> vnl_matrixSC"""
        return _itkPyBufferPython.itkPyVnlSC__GetVnlMatrixFromArray(arr, shape)

    _GetVnlMatrixFromArray = staticmethod(_GetVnlMatrixFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyVnlSC self) -> itkPyVnlSC
        __init__(itkPyVnlSC self, itkPyVnlSC arg0) -> itkPyVnlSC



        Helper class get views of VNL data buffers in python arrays and back.

        This class will either receive a VNL data structure and create the
        equivalent Python array view or will receive a Python array and create
        a copy of it in a VNL data structure. This permits passing VNL data
        structures into python arrays from the NumPy python package.

        C++ includes: itkPyVnl.h 
        """
        _itkPyBufferPython.itkPyVnlSC_swiginit(self, _itkPyBufferPython.new_itkPyVnlSC(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyVnlSC


    def GetArrayViewFromVnlVector(vnl_vector):
        """Get a NumPy array view of a VNL vector."""

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        itksize = vnl_vector.size()
        shape   = [itksize]

        pixelType     = "SC"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlSC._GetArrayViewFromVnlVector(vnl_vector)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, vnl_vector)

        return itk_view

    GetArrayViewFromVnlVector = staticmethod(GetArrayViewFromVnlVector)

    def GetArrayFromVnlVector(vnl_vector):
        """Get a NumPy ndarray from VNL Vector.

        This is a deep copy of the VNL vector and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlSC.GetArrayViewFromVnlVector(vnl_vector)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlVector = staticmethod(GetArrayFromVnlVector)

    def GetVnlVectorFromArray(ndarr):
        """Get a VNL vector from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.  It is not possible to have a view of a numpy array in a VNL vector since
        there is no VNL vector constructor that allows sharing data.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim == 1 , \
            "Only arrays of 1 dimension are supported."

        ndarr = np.ascontiguousarray(ndarr)
        vec = itkPyVnlSC._GetVnlVectorFromArray( ndarr, ndarr.shape)

        return vec

    GetVnlVectorFromArray = staticmethod(GetVnlVectorFromArray)

    def GetArrayViewFromVnlMatrix(vnl_matrix):
        """Get a NumPy array view of a VNL matrix."""

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        cols = vnl_matrix.columns()
        rows = vnl_matrix.rows()
        dim     = 2
        shape   = [rows,cols]

        pixelType     = "SC"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlSC._GetArrayViewFromVnlMatrix(vnl_matrix)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)

        itk_view = NDArrayITKBase(ndarr_view, vnl_matrix)

        return itk_view

    GetArrayViewFromVnlMatrix = staticmethod(GetArrayViewFromVnlMatrix)

    def GetArrayFromVnlMatrix(vnl_matrix):
        """Get a NumPy ndarray from VNL matrix.

        This is a deep copy of the VNL matrix and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlSC.GetArrayViewFromVnlMatrix(vnl_matrix)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlMatrix = staticmethod(GetArrayFromVnlMatrix)


    def GetVnlMatrixFromArray(ndarr):
        """Get a VNL Matrix from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects. It is not possible to have a view of a numpy array in a VNL matrix since there is no
        VNL matrix constructor that allows sharing data.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim == 2 , \
            "Only arrays of 2 dimensions are supported."

        ndarr = np.ascontiguousarray(ndarr)
        mat = itkPyVnlSC._GetVnlMatrixFromArray( ndarr, ndarr.shape)

        return mat

    GetVnlMatrixFromArray = staticmethod(GetVnlMatrixFromArray)


itkPyVnlSC_swigregister = _itkPyBufferPython.itkPyVnlSC_swigregister
itkPyVnlSC_swigregister(itkPyVnlSC)

def itkPyVnlSC__GetArrayViewFromVnlVector(vector: 'vnl_vectorSC') -> "PyObject *":
    """itkPyVnlSC__GetArrayViewFromVnlVector(vnl_vectorSC vector) -> PyObject *"""
    return _itkPyBufferPython.itkPyVnlSC__GetArrayViewFromVnlVector(vector)

def itkPyVnlSC__GetVnlVectorFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_vectorSC const":
    """itkPyVnlSC__GetVnlVectorFromArray(PyObject * arr, PyObject * shape) -> vnl_vectorSC"""
    return _itkPyBufferPython.itkPyVnlSC__GetVnlVectorFromArray(arr, shape)

def itkPyVnlSC__GetArrayViewFromVnlMatrix(matrix: 'vnl_matrixSC') -> "PyObject *":
    """itkPyVnlSC__GetArrayViewFromVnlMatrix(vnl_matrixSC matrix) -> PyObject *"""
    return _itkPyBufferPython.itkPyVnlSC__GetArrayViewFromVnlMatrix(matrix)

def itkPyVnlSC__GetVnlMatrixFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_matrixSC const":
    """itkPyVnlSC__GetVnlMatrixFromArray(PyObject * arr, PyObject * shape) -> vnl_matrixSC"""
    return _itkPyBufferPython.itkPyVnlSC__GetVnlMatrixFromArray(arr, shape)

class itkPyVnlSI(object):
    """


    Helper class get views of VNL data buffers in python arrays and back.

    This class will either receive a VNL data structure and create the
    equivalent Python array view or will receive a Python array and create
    a copy of it in a VNL data structure. This permits passing VNL data
    structures into python arrays from the NumPy python package.

    C++ includes: itkPyVnl.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromVnlVector(vector: 'vnl_vectorSI') -> "PyObject *":
        """_GetArrayViewFromVnlVector(vnl_vectorSI vector) -> PyObject *"""
        return _itkPyBufferPython.itkPyVnlSI__GetArrayViewFromVnlVector(vector)

    _GetArrayViewFromVnlVector = staticmethod(_GetArrayViewFromVnlVector)

    def _GetVnlVectorFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_vectorSI const":
        """_GetVnlVectorFromArray(PyObject * arr, PyObject * shape) -> vnl_vectorSI"""
        return _itkPyBufferPython.itkPyVnlSI__GetVnlVectorFromArray(arr, shape)

    _GetVnlVectorFromArray = staticmethod(_GetVnlVectorFromArray)

    def _GetArrayViewFromVnlMatrix(matrix: 'vnl_matrixSI') -> "PyObject *":
        """_GetArrayViewFromVnlMatrix(vnl_matrixSI matrix) -> PyObject *"""
        return _itkPyBufferPython.itkPyVnlSI__GetArrayViewFromVnlMatrix(matrix)

    _GetArrayViewFromVnlMatrix = staticmethod(_GetArrayViewFromVnlMatrix)

    def _GetVnlMatrixFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_matrixSI const":
        """_GetVnlMatrixFromArray(PyObject * arr, PyObject * shape) -> vnl_matrixSI"""
        return _itkPyBufferPython.itkPyVnlSI__GetVnlMatrixFromArray(arr, shape)

    _GetVnlMatrixFromArray = staticmethod(_GetVnlMatrixFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyVnlSI self) -> itkPyVnlSI
        __init__(itkPyVnlSI self, itkPyVnlSI arg0) -> itkPyVnlSI



        Helper class get views of VNL data buffers in python arrays and back.

        This class will either receive a VNL data structure and create the
        equivalent Python array view or will receive a Python array and create
        a copy of it in a VNL data structure. This permits passing VNL data
        structures into python arrays from the NumPy python package.

        C++ includes: itkPyVnl.h 
        """
        _itkPyBufferPython.itkPyVnlSI_swiginit(self, _itkPyBufferPython.new_itkPyVnlSI(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyVnlSI


    def GetArrayViewFromVnlVector(vnl_vector):
        """Get a NumPy array view of a VNL vector."""

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        itksize = vnl_vector.size()
        shape   = [itksize]

        pixelType     = "SI"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlSI._GetArrayViewFromVnlVector(vnl_vector)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, vnl_vector)

        return itk_view

    GetArrayViewFromVnlVector = staticmethod(GetArrayViewFromVnlVector)

    def GetArrayFromVnlVector(vnl_vector):
        """Get a NumPy ndarray from VNL Vector.

        This is a deep copy of the VNL vector and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlSI.GetArrayViewFromVnlVector(vnl_vector)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlVector = staticmethod(GetArrayFromVnlVector)

    def GetVnlVectorFromArray(ndarr):
        """Get a VNL vector from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.  It is not possible to have a view of a numpy array in a VNL vector since
        there is no VNL vector constructor that allows sharing data.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim == 1 , \
            "Only arrays of 1 dimension are supported."

        ndarr = np.ascontiguousarray(ndarr)
        vec = itkPyVnlSI._GetVnlVectorFromArray( ndarr, ndarr.shape)

        return vec

    GetVnlVectorFromArray = staticmethod(GetVnlVectorFromArray)

    def GetArrayViewFromVnlMatrix(vnl_matrix):
        """Get a NumPy array view of a VNL matrix."""

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        cols = vnl_matrix.columns()
        rows = vnl_matrix.rows()
        dim     = 2
        shape   = [rows,cols]

        pixelType     = "SI"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlSI._GetArrayViewFromVnlMatrix(vnl_matrix)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)

        itk_view = NDArrayITKBase(ndarr_view, vnl_matrix)

        return itk_view

    GetArrayViewFromVnlMatrix = staticmethod(GetArrayViewFromVnlMatrix)

    def GetArrayFromVnlMatrix(vnl_matrix):
        """Get a NumPy ndarray from VNL matrix.

        This is a deep copy of the VNL matrix and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlSI.GetArrayViewFromVnlMatrix(vnl_matrix)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlMatrix = staticmethod(GetArrayFromVnlMatrix)


    def GetVnlMatrixFromArray(ndarr):
        """Get a VNL Matrix from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects. It is not possible to have a view of a numpy array in a VNL matrix since there is no
        VNL matrix constructor that allows sharing data.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim == 2 , \
            "Only arrays of 2 dimensions are supported."

        ndarr = np.ascontiguousarray(ndarr)
        mat = itkPyVnlSI._GetVnlMatrixFromArray( ndarr, ndarr.shape)

        return mat

    GetVnlMatrixFromArray = staticmethod(GetVnlMatrixFromArray)


itkPyVnlSI_swigregister = _itkPyBufferPython.itkPyVnlSI_swigregister
itkPyVnlSI_swigregister(itkPyVnlSI)

def itkPyVnlSI__GetArrayViewFromVnlVector(vector: 'vnl_vectorSI') -> "PyObject *":
    """itkPyVnlSI__GetArrayViewFromVnlVector(vnl_vectorSI vector) -> PyObject *"""
    return _itkPyBufferPython.itkPyVnlSI__GetArrayViewFromVnlVector(vector)

def itkPyVnlSI__GetVnlVectorFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_vectorSI const":
    """itkPyVnlSI__GetVnlVectorFromArray(PyObject * arr, PyObject * shape) -> vnl_vectorSI"""
    return _itkPyBufferPython.itkPyVnlSI__GetVnlVectorFromArray(arr, shape)

def itkPyVnlSI__GetArrayViewFromVnlMatrix(matrix: 'vnl_matrixSI') -> "PyObject *":
    """itkPyVnlSI__GetArrayViewFromVnlMatrix(vnl_matrixSI matrix) -> PyObject *"""
    return _itkPyBufferPython.itkPyVnlSI__GetArrayViewFromVnlMatrix(matrix)

def itkPyVnlSI__GetVnlMatrixFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_matrixSI const":
    """itkPyVnlSI__GetVnlMatrixFromArray(PyObject * arr, PyObject * shape) -> vnl_matrixSI"""
    return _itkPyBufferPython.itkPyVnlSI__GetVnlMatrixFromArray(arr, shape)

class itkPyVnlSL(object):
    """


    Helper class get views of VNL data buffers in python arrays and back.

    This class will either receive a VNL data structure and create the
    equivalent Python array view or will receive a Python array and create
    a copy of it in a VNL data structure. This permits passing VNL data
    structures into python arrays from the NumPy python package.

    C++ includes: itkPyVnl.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromVnlVector(vector: 'vnl_vectorSL') -> "PyObject *":
        """_GetArrayViewFromVnlVector(vnl_vectorSL vector) -> PyObject *"""
        return _itkPyBufferPython.itkPyVnlSL__GetArrayViewFromVnlVector(vector)

    _GetArrayViewFromVnlVector = staticmethod(_GetArrayViewFromVnlVector)

    def _GetVnlVectorFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_vectorSL const":
        """_GetVnlVectorFromArray(PyObject * arr, PyObject * shape) -> vnl_vectorSL"""
        return _itkPyBufferPython.itkPyVnlSL__GetVnlVectorFromArray(arr, shape)

    _GetVnlVectorFromArray = staticmethod(_GetVnlVectorFromArray)

    def _GetArrayViewFromVnlMatrix(matrix: 'vnl_matrixSL') -> "PyObject *":
        """_GetArrayViewFromVnlMatrix(vnl_matrixSL matrix) -> PyObject *"""
        return _itkPyBufferPython.itkPyVnlSL__GetArrayViewFromVnlMatrix(matrix)

    _GetArrayViewFromVnlMatrix = staticmethod(_GetArrayViewFromVnlMatrix)

    def _GetVnlMatrixFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_matrixSL const":
        """_GetVnlMatrixFromArray(PyObject * arr, PyObject * shape) -> vnl_matrixSL"""
        return _itkPyBufferPython.itkPyVnlSL__GetVnlMatrixFromArray(arr, shape)

    _GetVnlMatrixFromArray = staticmethod(_GetVnlMatrixFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyVnlSL self) -> itkPyVnlSL
        __init__(itkPyVnlSL self, itkPyVnlSL arg0) -> itkPyVnlSL



        Helper class get views of VNL data buffers in python arrays and back.

        This class will either receive a VNL data structure and create the
        equivalent Python array view or will receive a Python array and create
        a copy of it in a VNL data structure. This permits passing VNL data
        structures into python arrays from the NumPy python package.

        C++ includes: itkPyVnl.h 
        """
        _itkPyBufferPython.itkPyVnlSL_swiginit(self, _itkPyBufferPython.new_itkPyVnlSL(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyVnlSL


    def GetArrayViewFromVnlVector(vnl_vector):
        """Get a NumPy array view of a VNL vector."""

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        itksize = vnl_vector.size()
        shape   = [itksize]

        pixelType     = "SL"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlSL._GetArrayViewFromVnlVector(vnl_vector)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, vnl_vector)

        return itk_view

    GetArrayViewFromVnlVector = staticmethod(GetArrayViewFromVnlVector)

    def GetArrayFromVnlVector(vnl_vector):
        """Get a NumPy ndarray from VNL Vector.

        This is a deep copy of the VNL vector and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlSL.GetArrayViewFromVnlVector(vnl_vector)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlVector = staticmethod(GetArrayFromVnlVector)

    def GetVnlVectorFromArray(ndarr):
        """Get a VNL vector from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.  It is not possible to have a view of a numpy array in a VNL vector since
        there is no VNL vector constructor that allows sharing data.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim == 1 , \
            "Only arrays of 1 dimension are supported."

        ndarr = np.ascontiguousarray(ndarr)
        vec = itkPyVnlSL._GetVnlVectorFromArray( ndarr, ndarr.shape)

        return vec

    GetVnlVectorFromArray = staticmethod(GetVnlVectorFromArray)

    def GetArrayViewFromVnlMatrix(vnl_matrix):
        """Get a NumPy array view of a VNL matrix."""

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        cols = vnl_matrix.columns()
        rows = vnl_matrix.rows()
        dim     = 2
        shape   = [rows,cols]

        pixelType     = "SL"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlSL._GetArrayViewFromVnlMatrix(vnl_matrix)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)

        itk_view = NDArrayITKBase(ndarr_view, vnl_matrix)

        return itk_view

    GetArrayViewFromVnlMatrix = staticmethod(GetArrayViewFromVnlMatrix)

    def GetArrayFromVnlMatrix(vnl_matrix):
        """Get a NumPy ndarray from VNL matrix.

        This is a deep copy of the VNL matrix and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlSL.GetArrayViewFromVnlMatrix(vnl_matrix)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlMatrix = staticmethod(GetArrayFromVnlMatrix)


    def GetVnlMatrixFromArray(ndarr):
        """Get a VNL Matrix from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects. It is not possible to have a view of a numpy array in a VNL matrix since there is no
        VNL matrix constructor that allows sharing data.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim == 2 , \
            "Only arrays of 2 dimensions are supported."

        ndarr = np.ascontiguousarray(ndarr)
        mat = itkPyVnlSL._GetVnlMatrixFromArray( ndarr, ndarr.shape)

        return mat

    GetVnlMatrixFromArray = staticmethod(GetVnlMatrixFromArray)


itkPyVnlSL_swigregister = _itkPyBufferPython.itkPyVnlSL_swigregister
itkPyVnlSL_swigregister(itkPyVnlSL)

def itkPyVnlSL__GetArrayViewFromVnlVector(vector: 'vnl_vectorSL') -> "PyObject *":
    """itkPyVnlSL__GetArrayViewFromVnlVector(vnl_vectorSL vector) -> PyObject *"""
    return _itkPyBufferPython.itkPyVnlSL__GetArrayViewFromVnlVector(vector)

def itkPyVnlSL__GetVnlVectorFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_vectorSL const":
    """itkPyVnlSL__GetVnlVectorFromArray(PyObject * arr, PyObject * shape) -> vnl_vectorSL"""
    return _itkPyBufferPython.itkPyVnlSL__GetVnlVectorFromArray(arr, shape)

def itkPyVnlSL__GetArrayViewFromVnlMatrix(matrix: 'vnl_matrixSL') -> "PyObject *":
    """itkPyVnlSL__GetArrayViewFromVnlMatrix(vnl_matrixSL matrix) -> PyObject *"""
    return _itkPyBufferPython.itkPyVnlSL__GetArrayViewFromVnlMatrix(matrix)

def itkPyVnlSL__GetVnlMatrixFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_matrixSL const":
    """itkPyVnlSL__GetVnlMatrixFromArray(PyObject * arr, PyObject * shape) -> vnl_matrixSL"""
    return _itkPyBufferPython.itkPyVnlSL__GetVnlMatrixFromArray(arr, shape)

class itkPyVnlSS(object):
    """


    Helper class get views of VNL data buffers in python arrays and back.

    This class will either receive a VNL data structure and create the
    equivalent Python array view or will receive a Python array and create
    a copy of it in a VNL data structure. This permits passing VNL data
    structures into python arrays from the NumPy python package.

    C++ includes: itkPyVnl.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromVnlVector(vector: 'vnl_vectorSS') -> "PyObject *":
        """_GetArrayViewFromVnlVector(vnl_vectorSS vector) -> PyObject *"""
        return _itkPyBufferPython.itkPyVnlSS__GetArrayViewFromVnlVector(vector)

    _GetArrayViewFromVnlVector = staticmethod(_GetArrayViewFromVnlVector)

    def _GetVnlVectorFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_vectorSS const":
        """_GetVnlVectorFromArray(PyObject * arr, PyObject * shape) -> vnl_vectorSS"""
        return _itkPyBufferPython.itkPyVnlSS__GetVnlVectorFromArray(arr, shape)

    _GetVnlVectorFromArray = staticmethod(_GetVnlVectorFromArray)

    def _GetArrayViewFromVnlMatrix(matrix: 'vnl_matrixSS') -> "PyObject *":
        """_GetArrayViewFromVnlMatrix(vnl_matrixSS matrix) -> PyObject *"""
        return _itkPyBufferPython.itkPyVnlSS__GetArrayViewFromVnlMatrix(matrix)

    _GetArrayViewFromVnlMatrix = staticmethod(_GetArrayViewFromVnlMatrix)

    def _GetVnlMatrixFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_matrixSS const":
        """_GetVnlMatrixFromArray(PyObject * arr, PyObject * shape) -> vnl_matrixSS"""
        return _itkPyBufferPython.itkPyVnlSS__GetVnlMatrixFromArray(arr, shape)

    _GetVnlMatrixFromArray = staticmethod(_GetVnlMatrixFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyVnlSS self) -> itkPyVnlSS
        __init__(itkPyVnlSS self, itkPyVnlSS arg0) -> itkPyVnlSS



        Helper class get views of VNL data buffers in python arrays and back.

        This class will either receive a VNL data structure and create the
        equivalent Python array view or will receive a Python array and create
        a copy of it in a VNL data structure. This permits passing VNL data
        structures into python arrays from the NumPy python package.

        C++ includes: itkPyVnl.h 
        """
        _itkPyBufferPython.itkPyVnlSS_swiginit(self, _itkPyBufferPython.new_itkPyVnlSS(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyVnlSS


    def GetArrayViewFromVnlVector(vnl_vector):
        """Get a NumPy array view of a VNL vector."""

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        itksize = vnl_vector.size()
        shape   = [itksize]

        pixelType     = "SS"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlSS._GetArrayViewFromVnlVector(vnl_vector)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, vnl_vector)

        return itk_view

    GetArrayViewFromVnlVector = staticmethod(GetArrayViewFromVnlVector)

    def GetArrayFromVnlVector(vnl_vector):
        """Get a NumPy ndarray from VNL Vector.

        This is a deep copy of the VNL vector and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlSS.GetArrayViewFromVnlVector(vnl_vector)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlVector = staticmethod(GetArrayFromVnlVector)

    def GetVnlVectorFromArray(ndarr):
        """Get a VNL vector from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.  It is not possible to have a view of a numpy array in a VNL vector since
        there is no VNL vector constructor that allows sharing data.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim == 1 , \
            "Only arrays of 1 dimension are supported."

        ndarr = np.ascontiguousarray(ndarr)
        vec = itkPyVnlSS._GetVnlVectorFromArray( ndarr, ndarr.shape)

        return vec

    GetVnlVectorFromArray = staticmethod(GetVnlVectorFromArray)

    def GetArrayViewFromVnlMatrix(vnl_matrix):
        """Get a NumPy array view of a VNL matrix."""

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        cols = vnl_matrix.columns()
        rows = vnl_matrix.rows()
        dim     = 2
        shape   = [rows,cols]

        pixelType     = "SS"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlSS._GetArrayViewFromVnlMatrix(vnl_matrix)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)

        itk_view = NDArrayITKBase(ndarr_view, vnl_matrix)

        return itk_view

    GetArrayViewFromVnlMatrix = staticmethod(GetArrayViewFromVnlMatrix)

    def GetArrayFromVnlMatrix(vnl_matrix):
        """Get a NumPy ndarray from VNL matrix.

        This is a deep copy of the VNL matrix and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlSS.GetArrayViewFromVnlMatrix(vnl_matrix)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlMatrix = staticmethod(GetArrayFromVnlMatrix)


    def GetVnlMatrixFromArray(ndarr):
        """Get a VNL Matrix from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects. It is not possible to have a view of a numpy array in a VNL matrix since there is no
        VNL matrix constructor that allows sharing data.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim == 2 , \
            "Only arrays of 2 dimensions are supported."

        ndarr = np.ascontiguousarray(ndarr)
        mat = itkPyVnlSS._GetVnlMatrixFromArray( ndarr, ndarr.shape)

        return mat

    GetVnlMatrixFromArray = staticmethod(GetVnlMatrixFromArray)


itkPyVnlSS_swigregister = _itkPyBufferPython.itkPyVnlSS_swigregister
itkPyVnlSS_swigregister(itkPyVnlSS)

def itkPyVnlSS__GetArrayViewFromVnlVector(vector: 'vnl_vectorSS') -> "PyObject *":
    """itkPyVnlSS__GetArrayViewFromVnlVector(vnl_vectorSS vector) -> PyObject *"""
    return _itkPyBufferPython.itkPyVnlSS__GetArrayViewFromVnlVector(vector)

def itkPyVnlSS__GetVnlVectorFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_vectorSS const":
    """itkPyVnlSS__GetVnlVectorFromArray(PyObject * arr, PyObject * shape) -> vnl_vectorSS"""
    return _itkPyBufferPython.itkPyVnlSS__GetVnlVectorFromArray(arr, shape)

def itkPyVnlSS__GetArrayViewFromVnlMatrix(matrix: 'vnl_matrixSS') -> "PyObject *":
    """itkPyVnlSS__GetArrayViewFromVnlMatrix(vnl_matrixSS matrix) -> PyObject *"""
    return _itkPyBufferPython.itkPyVnlSS__GetArrayViewFromVnlMatrix(matrix)

def itkPyVnlSS__GetVnlMatrixFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_matrixSS const":
    """itkPyVnlSS__GetVnlMatrixFromArray(PyObject * arr, PyObject * shape) -> vnl_matrixSS"""
    return _itkPyBufferPython.itkPyVnlSS__GetVnlMatrixFromArray(arr, shape)

class itkPyVnlUC(object):
    """


    Helper class get views of VNL data buffers in python arrays and back.

    This class will either receive a VNL data structure and create the
    equivalent Python array view or will receive a Python array and create
    a copy of it in a VNL data structure. This permits passing VNL data
    structures into python arrays from the NumPy python package.

    C++ includes: itkPyVnl.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromVnlVector(vector: 'vnl_vectorUC') -> "PyObject *":
        """_GetArrayViewFromVnlVector(vnl_vectorUC vector) -> PyObject *"""
        return _itkPyBufferPython.itkPyVnlUC__GetArrayViewFromVnlVector(vector)

    _GetArrayViewFromVnlVector = staticmethod(_GetArrayViewFromVnlVector)

    def _GetVnlVectorFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_vectorUC const":
        """_GetVnlVectorFromArray(PyObject * arr, PyObject * shape) -> vnl_vectorUC"""
        return _itkPyBufferPython.itkPyVnlUC__GetVnlVectorFromArray(arr, shape)

    _GetVnlVectorFromArray = staticmethod(_GetVnlVectorFromArray)

    def _GetArrayViewFromVnlMatrix(matrix: 'vnl_matrixUC') -> "PyObject *":
        """_GetArrayViewFromVnlMatrix(vnl_matrixUC matrix) -> PyObject *"""
        return _itkPyBufferPython.itkPyVnlUC__GetArrayViewFromVnlMatrix(matrix)

    _GetArrayViewFromVnlMatrix = staticmethod(_GetArrayViewFromVnlMatrix)

    def _GetVnlMatrixFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_matrixUC const":
        """_GetVnlMatrixFromArray(PyObject * arr, PyObject * shape) -> vnl_matrixUC"""
        return _itkPyBufferPython.itkPyVnlUC__GetVnlMatrixFromArray(arr, shape)

    _GetVnlMatrixFromArray = staticmethod(_GetVnlMatrixFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyVnlUC self) -> itkPyVnlUC
        __init__(itkPyVnlUC self, itkPyVnlUC arg0) -> itkPyVnlUC



        Helper class get views of VNL data buffers in python arrays and back.

        This class will either receive a VNL data structure and create the
        equivalent Python array view or will receive a Python array and create
        a copy of it in a VNL data structure. This permits passing VNL data
        structures into python arrays from the NumPy python package.

        C++ includes: itkPyVnl.h 
        """
        _itkPyBufferPython.itkPyVnlUC_swiginit(self, _itkPyBufferPython.new_itkPyVnlUC(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyVnlUC


    def GetArrayViewFromVnlVector(vnl_vector):
        """Get a NumPy array view of a VNL vector."""

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        itksize = vnl_vector.size()
        shape   = [itksize]

        pixelType     = "UC"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlUC._GetArrayViewFromVnlVector(vnl_vector)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, vnl_vector)

        return itk_view

    GetArrayViewFromVnlVector = staticmethod(GetArrayViewFromVnlVector)

    def GetArrayFromVnlVector(vnl_vector):
        """Get a NumPy ndarray from VNL Vector.

        This is a deep copy of the VNL vector and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlUC.GetArrayViewFromVnlVector(vnl_vector)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlVector = staticmethod(GetArrayFromVnlVector)

    def GetVnlVectorFromArray(ndarr):
        """Get a VNL vector from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.  It is not possible to have a view of a numpy array in a VNL vector since
        there is no VNL vector constructor that allows sharing data.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim == 1 , \
            "Only arrays of 1 dimension are supported."

        ndarr = np.ascontiguousarray(ndarr)
        vec = itkPyVnlUC._GetVnlVectorFromArray( ndarr, ndarr.shape)

        return vec

    GetVnlVectorFromArray = staticmethod(GetVnlVectorFromArray)

    def GetArrayViewFromVnlMatrix(vnl_matrix):
        """Get a NumPy array view of a VNL matrix."""

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        cols = vnl_matrix.columns()
        rows = vnl_matrix.rows()
        dim     = 2
        shape   = [rows,cols]

        pixelType     = "UC"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlUC._GetArrayViewFromVnlMatrix(vnl_matrix)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)

        itk_view = NDArrayITKBase(ndarr_view, vnl_matrix)

        return itk_view

    GetArrayViewFromVnlMatrix = staticmethod(GetArrayViewFromVnlMatrix)

    def GetArrayFromVnlMatrix(vnl_matrix):
        """Get a NumPy ndarray from VNL matrix.

        This is a deep copy of the VNL matrix and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlUC.GetArrayViewFromVnlMatrix(vnl_matrix)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlMatrix = staticmethod(GetArrayFromVnlMatrix)


    def GetVnlMatrixFromArray(ndarr):
        """Get a VNL Matrix from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects. It is not possible to have a view of a numpy array in a VNL matrix since there is no
        VNL matrix constructor that allows sharing data.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim == 2 , \
            "Only arrays of 2 dimensions are supported."

        ndarr = np.ascontiguousarray(ndarr)
        mat = itkPyVnlUC._GetVnlMatrixFromArray( ndarr, ndarr.shape)

        return mat

    GetVnlMatrixFromArray = staticmethod(GetVnlMatrixFromArray)


itkPyVnlUC_swigregister = _itkPyBufferPython.itkPyVnlUC_swigregister
itkPyVnlUC_swigregister(itkPyVnlUC)

def itkPyVnlUC__GetArrayViewFromVnlVector(vector: 'vnl_vectorUC') -> "PyObject *":
    """itkPyVnlUC__GetArrayViewFromVnlVector(vnl_vectorUC vector) -> PyObject *"""
    return _itkPyBufferPython.itkPyVnlUC__GetArrayViewFromVnlVector(vector)

def itkPyVnlUC__GetVnlVectorFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_vectorUC const":
    """itkPyVnlUC__GetVnlVectorFromArray(PyObject * arr, PyObject * shape) -> vnl_vectorUC"""
    return _itkPyBufferPython.itkPyVnlUC__GetVnlVectorFromArray(arr, shape)

def itkPyVnlUC__GetArrayViewFromVnlMatrix(matrix: 'vnl_matrixUC') -> "PyObject *":
    """itkPyVnlUC__GetArrayViewFromVnlMatrix(vnl_matrixUC matrix) -> PyObject *"""
    return _itkPyBufferPython.itkPyVnlUC__GetArrayViewFromVnlMatrix(matrix)

def itkPyVnlUC__GetVnlMatrixFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_matrixUC const":
    """itkPyVnlUC__GetVnlMatrixFromArray(PyObject * arr, PyObject * shape) -> vnl_matrixUC"""
    return _itkPyBufferPython.itkPyVnlUC__GetVnlMatrixFromArray(arr, shape)

class itkPyVnlUI(object):
    """


    Helper class get views of VNL data buffers in python arrays and back.

    This class will either receive a VNL data structure and create the
    equivalent Python array view or will receive a Python array and create
    a copy of it in a VNL data structure. This permits passing VNL data
    structures into python arrays from the NumPy python package.

    C++ includes: itkPyVnl.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromVnlVector(vector: 'vnl_vectorUI') -> "PyObject *":
        """_GetArrayViewFromVnlVector(vnl_vectorUI vector) -> PyObject *"""
        return _itkPyBufferPython.itkPyVnlUI__GetArrayViewFromVnlVector(vector)

    _GetArrayViewFromVnlVector = staticmethod(_GetArrayViewFromVnlVector)

    def _GetVnlVectorFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_vectorUI const":
        """_GetVnlVectorFromArray(PyObject * arr, PyObject * shape) -> vnl_vectorUI"""
        return _itkPyBufferPython.itkPyVnlUI__GetVnlVectorFromArray(arr, shape)

    _GetVnlVectorFromArray = staticmethod(_GetVnlVectorFromArray)

    def _GetArrayViewFromVnlMatrix(matrix: 'vnl_matrixUI') -> "PyObject *":
        """_GetArrayViewFromVnlMatrix(vnl_matrixUI matrix) -> PyObject *"""
        return _itkPyBufferPython.itkPyVnlUI__GetArrayViewFromVnlMatrix(matrix)

    _GetArrayViewFromVnlMatrix = staticmethod(_GetArrayViewFromVnlMatrix)

    def _GetVnlMatrixFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_matrixUI const":
        """_GetVnlMatrixFromArray(PyObject * arr, PyObject * shape) -> vnl_matrixUI"""
        return _itkPyBufferPython.itkPyVnlUI__GetVnlMatrixFromArray(arr, shape)

    _GetVnlMatrixFromArray = staticmethod(_GetVnlMatrixFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyVnlUI self) -> itkPyVnlUI
        __init__(itkPyVnlUI self, itkPyVnlUI arg0) -> itkPyVnlUI



        Helper class get views of VNL data buffers in python arrays and back.

        This class will either receive a VNL data structure and create the
        equivalent Python array view or will receive a Python array and create
        a copy of it in a VNL data structure. This permits passing VNL data
        structures into python arrays from the NumPy python package.

        C++ includes: itkPyVnl.h 
        """
        _itkPyBufferPython.itkPyVnlUI_swiginit(self, _itkPyBufferPython.new_itkPyVnlUI(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyVnlUI


    def GetArrayViewFromVnlVector(vnl_vector):
        """Get a NumPy array view of a VNL vector."""

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        itksize = vnl_vector.size()
        shape   = [itksize]

        pixelType     = "UI"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlUI._GetArrayViewFromVnlVector(vnl_vector)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, vnl_vector)

        return itk_view

    GetArrayViewFromVnlVector = staticmethod(GetArrayViewFromVnlVector)

    def GetArrayFromVnlVector(vnl_vector):
        """Get a NumPy ndarray from VNL Vector.

        This is a deep copy of the VNL vector and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlUI.GetArrayViewFromVnlVector(vnl_vector)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlVector = staticmethod(GetArrayFromVnlVector)

    def GetVnlVectorFromArray(ndarr):
        """Get a VNL vector from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.  It is not possible to have a view of a numpy array in a VNL vector since
        there is no VNL vector constructor that allows sharing data.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim == 1 , \
            "Only arrays of 1 dimension are supported."

        ndarr = np.ascontiguousarray(ndarr)
        vec = itkPyVnlUI._GetVnlVectorFromArray( ndarr, ndarr.shape)

        return vec

    GetVnlVectorFromArray = staticmethod(GetVnlVectorFromArray)

    def GetArrayViewFromVnlMatrix(vnl_matrix):
        """Get a NumPy array view of a VNL matrix."""

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        cols = vnl_matrix.columns()
        rows = vnl_matrix.rows()
        dim     = 2
        shape   = [rows,cols]

        pixelType     = "UI"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlUI._GetArrayViewFromVnlMatrix(vnl_matrix)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)

        itk_view = NDArrayITKBase(ndarr_view, vnl_matrix)

        return itk_view

    GetArrayViewFromVnlMatrix = staticmethod(GetArrayViewFromVnlMatrix)

    def GetArrayFromVnlMatrix(vnl_matrix):
        """Get a NumPy ndarray from VNL matrix.

        This is a deep copy of the VNL matrix and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlUI.GetArrayViewFromVnlMatrix(vnl_matrix)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlMatrix = staticmethod(GetArrayFromVnlMatrix)


    def GetVnlMatrixFromArray(ndarr):
        """Get a VNL Matrix from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects. It is not possible to have a view of a numpy array in a VNL matrix since there is no
        VNL matrix constructor that allows sharing data.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim == 2 , \
            "Only arrays of 2 dimensions are supported."

        ndarr = np.ascontiguousarray(ndarr)
        mat = itkPyVnlUI._GetVnlMatrixFromArray( ndarr, ndarr.shape)

        return mat

    GetVnlMatrixFromArray = staticmethod(GetVnlMatrixFromArray)


itkPyVnlUI_swigregister = _itkPyBufferPython.itkPyVnlUI_swigregister
itkPyVnlUI_swigregister(itkPyVnlUI)

def itkPyVnlUI__GetArrayViewFromVnlVector(vector: 'vnl_vectorUI') -> "PyObject *":
    """itkPyVnlUI__GetArrayViewFromVnlVector(vnl_vectorUI vector) -> PyObject *"""
    return _itkPyBufferPython.itkPyVnlUI__GetArrayViewFromVnlVector(vector)

def itkPyVnlUI__GetVnlVectorFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_vectorUI const":
    """itkPyVnlUI__GetVnlVectorFromArray(PyObject * arr, PyObject * shape) -> vnl_vectorUI"""
    return _itkPyBufferPython.itkPyVnlUI__GetVnlVectorFromArray(arr, shape)

def itkPyVnlUI__GetArrayViewFromVnlMatrix(matrix: 'vnl_matrixUI') -> "PyObject *":
    """itkPyVnlUI__GetArrayViewFromVnlMatrix(vnl_matrixUI matrix) -> PyObject *"""
    return _itkPyBufferPython.itkPyVnlUI__GetArrayViewFromVnlMatrix(matrix)

def itkPyVnlUI__GetVnlMatrixFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_matrixUI const":
    """itkPyVnlUI__GetVnlMatrixFromArray(PyObject * arr, PyObject * shape) -> vnl_matrixUI"""
    return _itkPyBufferPython.itkPyVnlUI__GetVnlMatrixFromArray(arr, shape)

class itkPyVnlUL(object):
    """


    Helper class get views of VNL data buffers in python arrays and back.

    This class will either receive a VNL data structure and create the
    equivalent Python array view or will receive a Python array and create
    a copy of it in a VNL data structure. This permits passing VNL data
    structures into python arrays from the NumPy python package.

    C++ includes: itkPyVnl.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromVnlVector(vector: 'vnl_vectorUL') -> "PyObject *":
        """_GetArrayViewFromVnlVector(vnl_vectorUL vector) -> PyObject *"""
        return _itkPyBufferPython.itkPyVnlUL__GetArrayViewFromVnlVector(vector)

    _GetArrayViewFromVnlVector = staticmethod(_GetArrayViewFromVnlVector)

    def _GetVnlVectorFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_vectorUL const":
        """_GetVnlVectorFromArray(PyObject * arr, PyObject * shape) -> vnl_vectorUL"""
        return _itkPyBufferPython.itkPyVnlUL__GetVnlVectorFromArray(arr, shape)

    _GetVnlVectorFromArray = staticmethod(_GetVnlVectorFromArray)

    def _GetArrayViewFromVnlMatrix(matrix: 'vnl_matrixUL') -> "PyObject *":
        """_GetArrayViewFromVnlMatrix(vnl_matrixUL matrix) -> PyObject *"""
        return _itkPyBufferPython.itkPyVnlUL__GetArrayViewFromVnlMatrix(matrix)

    _GetArrayViewFromVnlMatrix = staticmethod(_GetArrayViewFromVnlMatrix)

    def _GetVnlMatrixFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_matrixUL const":
        """_GetVnlMatrixFromArray(PyObject * arr, PyObject * shape) -> vnl_matrixUL"""
        return _itkPyBufferPython.itkPyVnlUL__GetVnlMatrixFromArray(arr, shape)

    _GetVnlMatrixFromArray = staticmethod(_GetVnlMatrixFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyVnlUL self) -> itkPyVnlUL
        __init__(itkPyVnlUL self, itkPyVnlUL arg0) -> itkPyVnlUL



        Helper class get views of VNL data buffers in python arrays and back.

        This class will either receive a VNL data structure and create the
        equivalent Python array view or will receive a Python array and create
        a copy of it in a VNL data structure. This permits passing VNL data
        structures into python arrays from the NumPy python package.

        C++ includes: itkPyVnl.h 
        """
        _itkPyBufferPython.itkPyVnlUL_swiginit(self, _itkPyBufferPython.new_itkPyVnlUL(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyVnlUL


    def GetArrayViewFromVnlVector(vnl_vector):
        """Get a NumPy array view of a VNL vector."""

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        itksize = vnl_vector.size()
        shape   = [itksize]

        pixelType     = "UL"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlUL._GetArrayViewFromVnlVector(vnl_vector)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, vnl_vector)

        return itk_view

    GetArrayViewFromVnlVector = staticmethod(GetArrayViewFromVnlVector)

    def GetArrayFromVnlVector(vnl_vector):
        """Get a NumPy ndarray from VNL Vector.

        This is a deep copy of the VNL vector and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlUL.GetArrayViewFromVnlVector(vnl_vector)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlVector = staticmethod(GetArrayFromVnlVector)

    def GetVnlVectorFromArray(ndarr):
        """Get a VNL vector from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.  It is not possible to have a view of a numpy array in a VNL vector since
        there is no VNL vector constructor that allows sharing data.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim == 1 , \
            "Only arrays of 1 dimension are supported."

        ndarr = np.ascontiguousarray(ndarr)
        vec = itkPyVnlUL._GetVnlVectorFromArray( ndarr, ndarr.shape)

        return vec

    GetVnlVectorFromArray = staticmethod(GetVnlVectorFromArray)

    def GetArrayViewFromVnlMatrix(vnl_matrix):
        """Get a NumPy array view of a VNL matrix."""

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        cols = vnl_matrix.columns()
        rows = vnl_matrix.rows()
        dim     = 2
        shape   = [rows,cols]

        pixelType     = "UL"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlUL._GetArrayViewFromVnlMatrix(vnl_matrix)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)

        itk_view = NDArrayITKBase(ndarr_view, vnl_matrix)

        return itk_view

    GetArrayViewFromVnlMatrix = staticmethod(GetArrayViewFromVnlMatrix)

    def GetArrayFromVnlMatrix(vnl_matrix):
        """Get a NumPy ndarray from VNL matrix.

        This is a deep copy of the VNL matrix and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlUL.GetArrayViewFromVnlMatrix(vnl_matrix)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlMatrix = staticmethod(GetArrayFromVnlMatrix)


    def GetVnlMatrixFromArray(ndarr):
        """Get a VNL Matrix from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects. It is not possible to have a view of a numpy array in a VNL matrix since there is no
        VNL matrix constructor that allows sharing data.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim == 2 , \
            "Only arrays of 2 dimensions are supported."

        ndarr = np.ascontiguousarray(ndarr)
        mat = itkPyVnlUL._GetVnlMatrixFromArray( ndarr, ndarr.shape)

        return mat

    GetVnlMatrixFromArray = staticmethod(GetVnlMatrixFromArray)


itkPyVnlUL_swigregister = _itkPyBufferPython.itkPyVnlUL_swigregister
itkPyVnlUL_swigregister(itkPyVnlUL)

def itkPyVnlUL__GetArrayViewFromVnlVector(vector: 'vnl_vectorUL') -> "PyObject *":
    """itkPyVnlUL__GetArrayViewFromVnlVector(vnl_vectorUL vector) -> PyObject *"""
    return _itkPyBufferPython.itkPyVnlUL__GetArrayViewFromVnlVector(vector)

def itkPyVnlUL__GetVnlVectorFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_vectorUL const":
    """itkPyVnlUL__GetVnlVectorFromArray(PyObject * arr, PyObject * shape) -> vnl_vectorUL"""
    return _itkPyBufferPython.itkPyVnlUL__GetVnlVectorFromArray(arr, shape)

def itkPyVnlUL__GetArrayViewFromVnlMatrix(matrix: 'vnl_matrixUL') -> "PyObject *":
    """itkPyVnlUL__GetArrayViewFromVnlMatrix(vnl_matrixUL matrix) -> PyObject *"""
    return _itkPyBufferPython.itkPyVnlUL__GetArrayViewFromVnlMatrix(matrix)

def itkPyVnlUL__GetVnlMatrixFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_matrixUL const":
    """itkPyVnlUL__GetVnlMatrixFromArray(PyObject * arr, PyObject * shape) -> vnl_matrixUL"""
    return _itkPyBufferPython.itkPyVnlUL__GetVnlMatrixFromArray(arr, shape)

class itkPyVnlUS(object):
    """


    Helper class get views of VNL data buffers in python arrays and back.

    This class will either receive a VNL data structure and create the
    equivalent Python array view or will receive a Python array and create
    a copy of it in a VNL data structure. This permits passing VNL data
    structures into python arrays from the NumPy python package.

    C++ includes: itkPyVnl.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def _GetArrayViewFromVnlVector(vector: 'vnl_vectorUS') -> "PyObject *":
        """_GetArrayViewFromVnlVector(vnl_vectorUS vector) -> PyObject *"""
        return _itkPyBufferPython.itkPyVnlUS__GetArrayViewFromVnlVector(vector)

    _GetArrayViewFromVnlVector = staticmethod(_GetArrayViewFromVnlVector)

    def _GetVnlVectorFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_vectorUS const":
        """_GetVnlVectorFromArray(PyObject * arr, PyObject * shape) -> vnl_vectorUS"""
        return _itkPyBufferPython.itkPyVnlUS__GetVnlVectorFromArray(arr, shape)

    _GetVnlVectorFromArray = staticmethod(_GetVnlVectorFromArray)

    def _GetArrayViewFromVnlMatrix(matrix: 'vnl_matrixUS') -> "PyObject *":
        """_GetArrayViewFromVnlMatrix(vnl_matrixUS matrix) -> PyObject *"""
        return _itkPyBufferPython.itkPyVnlUS__GetArrayViewFromVnlMatrix(matrix)

    _GetArrayViewFromVnlMatrix = staticmethod(_GetArrayViewFromVnlMatrix)

    def _GetVnlMatrixFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_matrixUS const":
        """_GetVnlMatrixFromArray(PyObject * arr, PyObject * shape) -> vnl_matrixUS"""
        return _itkPyBufferPython.itkPyVnlUS__GetVnlMatrixFromArray(arr, shape)

    _GetVnlMatrixFromArray = staticmethod(_GetVnlMatrixFromArray)

    def __init__(self, *args):
        """
        __init__(itkPyVnlUS self) -> itkPyVnlUS
        __init__(itkPyVnlUS self, itkPyVnlUS arg0) -> itkPyVnlUS



        Helper class get views of VNL data buffers in python arrays and back.

        This class will either receive a VNL data structure and create the
        equivalent Python array view or will receive a Python array and create
        a copy of it in a VNL data structure. This permits passing VNL data
        structures into python arrays from the NumPy python package.

        C++ includes: itkPyVnl.h 
        """
        _itkPyBufferPython.itkPyVnlUS_swiginit(self, _itkPyBufferPython.new_itkPyVnlUS(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyVnlUS


    def GetArrayViewFromVnlVector(vnl_vector):
        """Get a NumPy array view of a VNL vector."""

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        itksize = vnl_vector.size()
        shape   = [itksize]

        pixelType     = "US"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlUS._GetArrayViewFromVnlVector(vnl_vector)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, vnl_vector)

        return itk_view

    GetArrayViewFromVnlVector = staticmethod(GetArrayViewFromVnlVector)

    def GetArrayFromVnlVector(vnl_vector):
        """Get a NumPy ndarray from VNL Vector.

        This is a deep copy of the VNL vector and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlUS.GetArrayViewFromVnlVector(vnl_vector)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlVector = staticmethod(GetArrayFromVnlVector)

    def GetVnlVectorFromArray(ndarr):
        """Get a VNL vector from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.  It is not possible to have a view of a numpy array in a VNL vector since
        there is no VNL vector constructor that allows sharing data.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim == 1 , \
            "Only arrays of 1 dimension are supported."

        ndarr = np.ascontiguousarray(ndarr)
        vec = itkPyVnlUS._GetVnlVectorFromArray( ndarr, ndarr.shape)

        return vec

    GetVnlVectorFromArray = staticmethod(GetVnlVectorFromArray)

    def GetArrayViewFromVnlMatrix(vnl_matrix):
        """Get a NumPy array view of a VNL matrix."""

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        cols = vnl_matrix.columns()
        rows = vnl_matrix.rows()
        dim     = 2
        shape   = [rows,cols]

        pixelType     = "US"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlUS._GetArrayViewFromVnlMatrix(vnl_matrix)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)

        itk_view = NDArrayITKBase(ndarr_view, vnl_matrix)

        return itk_view

    GetArrayViewFromVnlMatrix = staticmethod(GetArrayViewFromVnlMatrix)

    def GetArrayFromVnlMatrix(vnl_matrix):
        """Get a NumPy ndarray from VNL matrix.

        This is a deep copy of the VNL matrix and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlUS.GetArrayViewFromVnlMatrix(vnl_matrix)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlMatrix = staticmethod(GetArrayFromVnlMatrix)


    def GetVnlMatrixFromArray(ndarr):
        """Get a VNL Matrix from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects. It is not possible to have a view of a numpy array in a VNL matrix since there is no
        VNL matrix constructor that allows sharing data.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim == 2 , \
            "Only arrays of 2 dimensions are supported."

        ndarr = np.ascontiguousarray(ndarr)
        mat = itkPyVnlUS._GetVnlMatrixFromArray( ndarr, ndarr.shape)

        return mat

    GetVnlMatrixFromArray = staticmethod(GetVnlMatrixFromArray)


itkPyVnlUS_swigregister = _itkPyBufferPython.itkPyVnlUS_swigregister
itkPyVnlUS_swigregister(itkPyVnlUS)

def itkPyVnlUS__GetArrayViewFromVnlVector(vector: 'vnl_vectorUS') -> "PyObject *":
    """itkPyVnlUS__GetArrayViewFromVnlVector(vnl_vectorUS vector) -> PyObject *"""
    return _itkPyBufferPython.itkPyVnlUS__GetArrayViewFromVnlVector(vector)

def itkPyVnlUS__GetVnlVectorFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_vectorUS const":
    """itkPyVnlUS__GetVnlVectorFromArray(PyObject * arr, PyObject * shape) -> vnl_vectorUS"""
    return _itkPyBufferPython.itkPyVnlUS__GetVnlVectorFromArray(arr, shape)

def itkPyVnlUS__GetArrayViewFromVnlMatrix(matrix: 'vnl_matrixUS') -> "PyObject *":
    """itkPyVnlUS__GetArrayViewFromVnlMatrix(vnl_matrixUS matrix) -> PyObject *"""
    return _itkPyBufferPython.itkPyVnlUS__GetArrayViewFromVnlMatrix(matrix)

def itkPyVnlUS__GetVnlMatrixFromArray(arr: 'PyObject *', shape: 'PyObject *') -> "vnl_matrixUS const":
    """itkPyVnlUS__GetVnlMatrixFromArray(PyObject * arr, PyObject * shape) -> vnl_matrixUS"""
    return _itkPyBufferPython.itkPyVnlUS__GetVnlMatrixFromArray(arr, shape)



