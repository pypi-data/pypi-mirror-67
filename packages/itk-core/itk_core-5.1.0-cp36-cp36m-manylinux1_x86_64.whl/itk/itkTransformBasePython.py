# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.8
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _itkTransformBasePython.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_itkTransformBasePython', [dirname(__file__)])
        except ImportError:
            import _itkTransformBasePython
            return _itkTransformBasePython
        if fp is not None:
            try:
                _mod = imp.load_module('_itkTransformBasePython', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _itkTransformBasePython = swig_import_helper()
    del swig_import_helper
else:
    import _itkTransformBasePython
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0



def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


import ITKCommonBasePython
import pyBasePython
import itkDiffusionTensor3DPython
import itkSymmetricSecondRankTensorPython
import itkFixedArrayPython
import itkMatrixPython
import vnl_matrixPython
import vnl_vectorPython
import stdcomplexPython
import itkVectorPython
import vnl_vector_refPython
import vnl_matrix_fixedPython
import itkCovariantVectorPython
import itkPointPython
import itkVariableLengthVectorPython
import itkOptimizerParametersPython
import itkArrayPython
import itkArray2DPython

def itkDataObjectDecoratorTF33_New():
  return itkDataObjectDecoratorTF33.New()


def itkDataObjectDecoratorTD33_New():
  return itkDataObjectDecoratorTD33.New()


def itkDataObjectDecoratorTF32_New():
  return itkDataObjectDecoratorTF32.New()


def itkDataObjectDecoratorTD32_New():
  return itkDataObjectDecoratorTD32.New()


def itkDataObjectDecoratorTF23_New():
  return itkDataObjectDecoratorTF23.New()


def itkDataObjectDecoratorTD23_New():
  return itkDataObjectDecoratorTD23.New()


def itkDataObjectDecoratorTF22_New():
  return itkDataObjectDecoratorTF22.New()


def itkDataObjectDecoratorTD22_New():
  return itkDataObjectDecoratorTD22.New()


def itkTransformF3_New():
  return itkTransformF3.New()


def itkTransformD3_New():
  return itkTransformD3.New()


def itkTransformF2_New():
  return itkTransformF2.New()


def itkTransformD2_New():
  return itkTransformD2.New()


def itkTransformF33_New():
  return itkTransformF33.New()


def itkTransformD33_New():
  return itkTransformD33.New()


def itkTransformF32_New():
  return itkTransformF32.New()


def itkTransformD32_New():
  return itkTransformD32.New()


def itkTransformF23_New():
  return itkTransformF23.New()


def itkTransformD23_New():
  return itkTransformD23.New()


def itkTransformF22_New():
  return itkTransformF22.New()


def itkTransformD22_New():
  return itkTransformD22.New()


def itkTransformBaseTemplateF_New():
  return itkTransformBaseTemplateF.New()


def itkTransformBaseTemplateD_New():
  return itkTransformBaseTemplateD.New()

class listitkTransformBaseTemplateD_Pointer(object):
    """Proxy of C++ std::list<(itkTransformBaseTemplateD_Pointer)> class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(listitkTransformBaseTemplateD_Pointer self) -> SwigPyIterator"""
        return _itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(listitkTransformBaseTemplateD_Pointer self) -> bool"""
        return _itkTransformBasePython.listitkTransformBaseTemplateD_Pointer___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(listitkTransformBaseTemplateD_Pointer self) -> bool"""
        return _itkTransformBasePython.listitkTransformBaseTemplateD_Pointer___bool__(self)


    def __len__(self) -> "std::list< itkTransformBaseTemplateD_Pointer >::size_type":
        """__len__(listitkTransformBaseTemplateD_Pointer self) -> std::list< itkTransformBaseTemplateD_Pointer >::size_type"""
        return _itkTransformBasePython.listitkTransformBaseTemplateD_Pointer___len__(self)


    def __getslice__(self, i: 'std::list< itkTransformBaseTemplateD_Pointer >::difference_type', j: 'std::list< itkTransformBaseTemplateD_Pointer >::difference_type') -> "std::list< itkTransformBaseTemplateD_Pointer,std::allocator< itkTransformBaseTemplateD_Pointer > > *":
        """__getslice__(listitkTransformBaseTemplateD_Pointer self, std::list< itkTransformBaseTemplateD_Pointer >::difference_type i, std::list< itkTransformBaseTemplateD_Pointer >::difference_type j) -> listitkTransformBaseTemplateD_Pointer"""
        return _itkTransformBasePython.listitkTransformBaseTemplateD_Pointer___getslice__(self, i, j)


    def __setslice__(self, *args) -> "void":
        """
        __setslice__(listitkTransformBaseTemplateD_Pointer self, std::list< itkTransformBaseTemplateD_Pointer >::difference_type i, std::list< itkTransformBaseTemplateD_Pointer >::difference_type j)
        __setslice__(listitkTransformBaseTemplateD_Pointer self, std::list< itkTransformBaseTemplateD_Pointer >::difference_type i, std::list< itkTransformBaseTemplateD_Pointer >::difference_type j, listitkTransformBaseTemplateD_Pointer v)
        """
        return _itkTransformBasePython.listitkTransformBaseTemplateD_Pointer___setslice__(self, *args)


    def __delslice__(self, i: 'std::list< itkTransformBaseTemplateD_Pointer >::difference_type', j: 'std::list< itkTransformBaseTemplateD_Pointer >::difference_type') -> "void":
        """__delslice__(listitkTransformBaseTemplateD_Pointer self, std::list< itkTransformBaseTemplateD_Pointer >::difference_type i, std::list< itkTransformBaseTemplateD_Pointer >::difference_type j)"""
        return _itkTransformBasePython.listitkTransformBaseTemplateD_Pointer___delslice__(self, i, j)


    def __delitem__(self, *args) -> "void":
        """
        __delitem__(listitkTransformBaseTemplateD_Pointer self, std::list< itkTransformBaseTemplateD_Pointer >::difference_type i)
        __delitem__(listitkTransformBaseTemplateD_Pointer self, PySliceObject * slice)
        """
        return _itkTransformBasePython.listitkTransformBaseTemplateD_Pointer___delitem__(self, *args)


    def __getitem__(self, *args) -> "std::list< itkTransformBaseTemplateD_Pointer >::value_type const &":
        """
        __getitem__(listitkTransformBaseTemplateD_Pointer self, PySliceObject * slice) -> listitkTransformBaseTemplateD_Pointer
        __getitem__(listitkTransformBaseTemplateD_Pointer self, std::list< itkTransformBaseTemplateD_Pointer >::difference_type i) -> std::list< itkTransformBaseTemplateD_Pointer >::value_type const &
        """
        return _itkTransformBasePython.listitkTransformBaseTemplateD_Pointer___getitem__(self, *args)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(listitkTransformBaseTemplateD_Pointer self, PySliceObject * slice, listitkTransformBaseTemplateD_Pointer v)
        __setitem__(listitkTransformBaseTemplateD_Pointer self, PySliceObject * slice)
        __setitem__(listitkTransformBaseTemplateD_Pointer self, std::list< itkTransformBaseTemplateD_Pointer >::difference_type i, std::list< itkTransformBaseTemplateD_Pointer >::value_type const & x)
        """
        return _itkTransformBasePython.listitkTransformBaseTemplateD_Pointer___setitem__(self, *args)


    def pop(self) -> "std::list< itkTransformBaseTemplateD_Pointer >::value_type":
        """pop(listitkTransformBaseTemplateD_Pointer self) -> std::list< itkTransformBaseTemplateD_Pointer >::value_type"""
        return _itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_pop(self)


    def append(self, x: 'std::list< itkTransformBaseTemplateD_Pointer >::value_type const &') -> "void":
        """append(listitkTransformBaseTemplateD_Pointer self, std::list< itkTransformBaseTemplateD_Pointer >::value_type const & x)"""
        return _itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_append(self, x)


    def empty(self) -> "bool":
        """empty(listitkTransformBaseTemplateD_Pointer self) -> bool"""
        return _itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_empty(self)


    def size(self) -> "std::list< itkTransformBaseTemplateD_Pointer >::size_type":
        """size(listitkTransformBaseTemplateD_Pointer self) -> std::list< itkTransformBaseTemplateD_Pointer >::size_type"""
        return _itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_size(self)


    def swap(self, v: 'listitkTransformBaseTemplateD_Pointer') -> "void":
        """swap(listitkTransformBaseTemplateD_Pointer self, listitkTransformBaseTemplateD_Pointer v)"""
        return _itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_swap(self, v)


    def begin(self) -> "std::list< itkTransformBaseTemplateD_Pointer >::iterator":
        """begin(listitkTransformBaseTemplateD_Pointer self) -> std::list< itkTransformBaseTemplateD_Pointer >::iterator"""
        return _itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_begin(self)


    def end(self) -> "std::list< itkTransformBaseTemplateD_Pointer >::iterator":
        """end(listitkTransformBaseTemplateD_Pointer self) -> std::list< itkTransformBaseTemplateD_Pointer >::iterator"""
        return _itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_end(self)


    def rbegin(self) -> "std::list< itkTransformBaseTemplateD_Pointer >::reverse_iterator":
        """rbegin(listitkTransformBaseTemplateD_Pointer self) -> std::list< itkTransformBaseTemplateD_Pointer >::reverse_iterator"""
        return _itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_rbegin(self)


    def rend(self) -> "std::list< itkTransformBaseTemplateD_Pointer >::reverse_iterator":
        """rend(listitkTransformBaseTemplateD_Pointer self) -> std::list< itkTransformBaseTemplateD_Pointer >::reverse_iterator"""
        return _itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_rend(self)


    def clear(self) -> "void":
        """clear(listitkTransformBaseTemplateD_Pointer self)"""
        return _itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_clear(self)


    def get_allocator(self) -> "std::list< itkTransformBaseTemplateD_Pointer >::allocator_type":
        """get_allocator(listitkTransformBaseTemplateD_Pointer self) -> std::list< itkTransformBaseTemplateD_Pointer >::allocator_type"""
        return _itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_get_allocator(self)


    def pop_back(self) -> "void":
        """pop_back(listitkTransformBaseTemplateD_Pointer self)"""
        return _itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_pop_back(self)


    def erase(self, *args) -> "std::list< itkTransformBaseTemplateD_Pointer >::iterator":
        """
        erase(listitkTransformBaseTemplateD_Pointer self, std::list< itkTransformBaseTemplateD_Pointer >::iterator pos) -> std::list< itkTransformBaseTemplateD_Pointer >::iterator
        erase(listitkTransformBaseTemplateD_Pointer self, std::list< itkTransformBaseTemplateD_Pointer >::iterator first, std::list< itkTransformBaseTemplateD_Pointer >::iterator last) -> std::list< itkTransformBaseTemplateD_Pointer >::iterator
        """
        return _itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::list<(itkTransformBaseTemplateD_Pointer)> self) -> listitkTransformBaseTemplateD_Pointer
        __init__(std::list<(itkTransformBaseTemplateD_Pointer)> self, listitkTransformBaseTemplateD_Pointer arg2) -> listitkTransformBaseTemplateD_Pointer
        __init__(std::list<(itkTransformBaseTemplateD_Pointer)> self, std::list< itkTransformBaseTemplateD_Pointer >::size_type size) -> listitkTransformBaseTemplateD_Pointer
        __init__(std::list<(itkTransformBaseTemplateD_Pointer)> self, std::list< itkTransformBaseTemplateD_Pointer >::size_type size, std::list< itkTransformBaseTemplateD_Pointer >::value_type const & value) -> listitkTransformBaseTemplateD_Pointer
        """
        _itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_swiginit(self, _itkTransformBasePython.new_listitkTransformBaseTemplateD_Pointer(*args))

    def push_back(self, x: 'std::list< itkTransformBaseTemplateD_Pointer >::value_type const &') -> "void":
        """push_back(listitkTransformBaseTemplateD_Pointer self, std::list< itkTransformBaseTemplateD_Pointer >::value_type const & x)"""
        return _itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_push_back(self, x)


    def front(self) -> "std::list< itkTransformBaseTemplateD_Pointer >::value_type const &":
        """front(listitkTransformBaseTemplateD_Pointer self) -> std::list< itkTransformBaseTemplateD_Pointer >::value_type const &"""
        return _itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_front(self)


    def back(self) -> "std::list< itkTransformBaseTemplateD_Pointer >::value_type const &":
        """back(listitkTransformBaseTemplateD_Pointer self) -> std::list< itkTransformBaseTemplateD_Pointer >::value_type const &"""
        return _itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_back(self)


    def assign(self, n: 'std::list< itkTransformBaseTemplateD_Pointer >::size_type', x: 'std::list< itkTransformBaseTemplateD_Pointer >::value_type const &') -> "void":
        """assign(listitkTransformBaseTemplateD_Pointer self, std::list< itkTransformBaseTemplateD_Pointer >::size_type n, std::list< itkTransformBaseTemplateD_Pointer >::value_type const & x)"""
        return _itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_assign(self, n, x)


    def resize(self, *args) -> "void":
        """
        resize(listitkTransformBaseTemplateD_Pointer self, std::list< itkTransformBaseTemplateD_Pointer >::size_type new_size)
        resize(listitkTransformBaseTemplateD_Pointer self, std::list< itkTransformBaseTemplateD_Pointer >::size_type new_size, std::list< itkTransformBaseTemplateD_Pointer >::value_type const & x)
        """
        return _itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_resize(self, *args)


    def insert(self, *args) -> "void":
        """
        insert(listitkTransformBaseTemplateD_Pointer self, std::list< itkTransformBaseTemplateD_Pointer >::iterator pos, std::list< itkTransformBaseTemplateD_Pointer >::value_type const & x) -> std::list< itkTransformBaseTemplateD_Pointer >::iterator
        insert(listitkTransformBaseTemplateD_Pointer self, std::list< itkTransformBaseTemplateD_Pointer >::iterator pos, std::list< itkTransformBaseTemplateD_Pointer >::size_type n, std::list< itkTransformBaseTemplateD_Pointer >::value_type const & x)
        """
        return _itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_insert(self, *args)


    def pop_front(self) -> "void":
        """pop_front(listitkTransformBaseTemplateD_Pointer self)"""
        return _itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_pop_front(self)


    def push_front(self, x: 'std::list< itkTransformBaseTemplateD_Pointer >::value_type const &') -> "void":
        """push_front(listitkTransformBaseTemplateD_Pointer self, std::list< itkTransformBaseTemplateD_Pointer >::value_type const & x)"""
        return _itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_push_front(self, x)


    def reverse(self) -> "void":
        """reverse(listitkTransformBaseTemplateD_Pointer self)"""
        return _itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_reverse(self)

    __swig_destroy__ = _itkTransformBasePython.delete_listitkTransformBaseTemplateD_Pointer
listitkTransformBaseTemplateD_Pointer.iterator = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_iterator, None, listitkTransformBaseTemplateD_Pointer)
listitkTransformBaseTemplateD_Pointer.__nonzero__ = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer___nonzero__, None, listitkTransformBaseTemplateD_Pointer)
listitkTransformBaseTemplateD_Pointer.__bool__ = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer___bool__, None, listitkTransformBaseTemplateD_Pointer)
listitkTransformBaseTemplateD_Pointer.__len__ = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer___len__, None, listitkTransformBaseTemplateD_Pointer)
listitkTransformBaseTemplateD_Pointer.__getslice__ = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer___getslice__, None, listitkTransformBaseTemplateD_Pointer)
listitkTransformBaseTemplateD_Pointer.__setslice__ = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer___setslice__, None, listitkTransformBaseTemplateD_Pointer)
listitkTransformBaseTemplateD_Pointer.__delslice__ = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer___delslice__, None, listitkTransformBaseTemplateD_Pointer)
listitkTransformBaseTemplateD_Pointer.__delitem__ = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer___delitem__, None, listitkTransformBaseTemplateD_Pointer)
listitkTransformBaseTemplateD_Pointer.__getitem__ = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer___getitem__, None, listitkTransformBaseTemplateD_Pointer)
listitkTransformBaseTemplateD_Pointer.__setitem__ = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer___setitem__, None, listitkTransformBaseTemplateD_Pointer)
listitkTransformBaseTemplateD_Pointer.pop = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_pop, None, listitkTransformBaseTemplateD_Pointer)
listitkTransformBaseTemplateD_Pointer.append = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_append, None, listitkTransformBaseTemplateD_Pointer)
listitkTransformBaseTemplateD_Pointer.empty = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_empty, None, listitkTransformBaseTemplateD_Pointer)
listitkTransformBaseTemplateD_Pointer.size = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_size, None, listitkTransformBaseTemplateD_Pointer)
listitkTransformBaseTemplateD_Pointer.swap = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_swap, None, listitkTransformBaseTemplateD_Pointer)
listitkTransformBaseTemplateD_Pointer.begin = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_begin, None, listitkTransformBaseTemplateD_Pointer)
listitkTransformBaseTemplateD_Pointer.end = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_end, None, listitkTransformBaseTemplateD_Pointer)
listitkTransformBaseTemplateD_Pointer.rbegin = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_rbegin, None, listitkTransformBaseTemplateD_Pointer)
listitkTransformBaseTemplateD_Pointer.rend = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_rend, None, listitkTransformBaseTemplateD_Pointer)
listitkTransformBaseTemplateD_Pointer.clear = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_clear, None, listitkTransformBaseTemplateD_Pointer)
listitkTransformBaseTemplateD_Pointer.get_allocator = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_get_allocator, None, listitkTransformBaseTemplateD_Pointer)
listitkTransformBaseTemplateD_Pointer.pop_back = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_pop_back, None, listitkTransformBaseTemplateD_Pointer)
listitkTransformBaseTemplateD_Pointer.erase = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_erase, None, listitkTransformBaseTemplateD_Pointer)
listitkTransformBaseTemplateD_Pointer.push_back = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_push_back, None, listitkTransformBaseTemplateD_Pointer)
listitkTransformBaseTemplateD_Pointer.front = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_front, None, listitkTransformBaseTemplateD_Pointer)
listitkTransformBaseTemplateD_Pointer.back = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_back, None, listitkTransformBaseTemplateD_Pointer)
listitkTransformBaseTemplateD_Pointer.assign = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_assign, None, listitkTransformBaseTemplateD_Pointer)
listitkTransformBaseTemplateD_Pointer.resize = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_resize, None, listitkTransformBaseTemplateD_Pointer)
listitkTransformBaseTemplateD_Pointer.insert = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_insert, None, listitkTransformBaseTemplateD_Pointer)
listitkTransformBaseTemplateD_Pointer.pop_front = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_pop_front, None, listitkTransformBaseTemplateD_Pointer)
listitkTransformBaseTemplateD_Pointer.push_front = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_push_front, None, listitkTransformBaseTemplateD_Pointer)
listitkTransformBaseTemplateD_Pointer.reverse = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_reverse, None, listitkTransformBaseTemplateD_Pointer)
listitkTransformBaseTemplateD_Pointer_swigregister = _itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_swigregister
listitkTransformBaseTemplateD_Pointer_swigregister(listitkTransformBaseTemplateD_Pointer)

class listitkTransformBaseTemplateF_Pointer(object):
    """Proxy of C++ std::list<(itkTransformBaseTemplateF_Pointer)> class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        """iterator(listitkTransformBaseTemplateF_Pointer self) -> SwigPyIterator"""
        return _itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        """__nonzero__(listitkTransformBaseTemplateF_Pointer self) -> bool"""
        return _itkTransformBasePython.listitkTransformBaseTemplateF_Pointer___nonzero__(self)


    def __bool__(self) -> "bool":
        """__bool__(listitkTransformBaseTemplateF_Pointer self) -> bool"""
        return _itkTransformBasePython.listitkTransformBaseTemplateF_Pointer___bool__(self)


    def __len__(self) -> "std::list< itkTransformBaseTemplateF_Pointer >::size_type":
        """__len__(listitkTransformBaseTemplateF_Pointer self) -> std::list< itkTransformBaseTemplateF_Pointer >::size_type"""
        return _itkTransformBasePython.listitkTransformBaseTemplateF_Pointer___len__(self)


    def __getslice__(self, i: 'std::list< itkTransformBaseTemplateF_Pointer >::difference_type', j: 'std::list< itkTransformBaseTemplateF_Pointer >::difference_type') -> "std::list< itkTransformBaseTemplateF_Pointer,std::allocator< itkTransformBaseTemplateF_Pointer > > *":
        """__getslice__(listitkTransformBaseTemplateF_Pointer self, std::list< itkTransformBaseTemplateF_Pointer >::difference_type i, std::list< itkTransformBaseTemplateF_Pointer >::difference_type j) -> listitkTransformBaseTemplateF_Pointer"""
        return _itkTransformBasePython.listitkTransformBaseTemplateF_Pointer___getslice__(self, i, j)


    def __setslice__(self, *args) -> "void":
        """
        __setslice__(listitkTransformBaseTemplateF_Pointer self, std::list< itkTransformBaseTemplateF_Pointer >::difference_type i, std::list< itkTransformBaseTemplateF_Pointer >::difference_type j)
        __setslice__(listitkTransformBaseTemplateF_Pointer self, std::list< itkTransformBaseTemplateF_Pointer >::difference_type i, std::list< itkTransformBaseTemplateF_Pointer >::difference_type j, listitkTransformBaseTemplateF_Pointer v)
        """
        return _itkTransformBasePython.listitkTransformBaseTemplateF_Pointer___setslice__(self, *args)


    def __delslice__(self, i: 'std::list< itkTransformBaseTemplateF_Pointer >::difference_type', j: 'std::list< itkTransformBaseTemplateF_Pointer >::difference_type') -> "void":
        """__delslice__(listitkTransformBaseTemplateF_Pointer self, std::list< itkTransformBaseTemplateF_Pointer >::difference_type i, std::list< itkTransformBaseTemplateF_Pointer >::difference_type j)"""
        return _itkTransformBasePython.listitkTransformBaseTemplateF_Pointer___delslice__(self, i, j)


    def __delitem__(self, *args) -> "void":
        """
        __delitem__(listitkTransformBaseTemplateF_Pointer self, std::list< itkTransformBaseTemplateF_Pointer >::difference_type i)
        __delitem__(listitkTransformBaseTemplateF_Pointer self, PySliceObject * slice)
        """
        return _itkTransformBasePython.listitkTransformBaseTemplateF_Pointer___delitem__(self, *args)


    def __getitem__(self, *args) -> "std::list< itkTransformBaseTemplateF_Pointer >::value_type const &":
        """
        __getitem__(listitkTransformBaseTemplateF_Pointer self, PySliceObject * slice) -> listitkTransformBaseTemplateF_Pointer
        __getitem__(listitkTransformBaseTemplateF_Pointer self, std::list< itkTransformBaseTemplateF_Pointer >::difference_type i) -> std::list< itkTransformBaseTemplateF_Pointer >::value_type const &
        """
        return _itkTransformBasePython.listitkTransformBaseTemplateF_Pointer___getitem__(self, *args)


    def __setitem__(self, *args) -> "void":
        """
        __setitem__(listitkTransformBaseTemplateF_Pointer self, PySliceObject * slice, listitkTransformBaseTemplateF_Pointer v)
        __setitem__(listitkTransformBaseTemplateF_Pointer self, PySliceObject * slice)
        __setitem__(listitkTransformBaseTemplateF_Pointer self, std::list< itkTransformBaseTemplateF_Pointer >::difference_type i, std::list< itkTransformBaseTemplateF_Pointer >::value_type const & x)
        """
        return _itkTransformBasePython.listitkTransformBaseTemplateF_Pointer___setitem__(self, *args)


    def pop(self) -> "std::list< itkTransformBaseTemplateF_Pointer >::value_type":
        """pop(listitkTransformBaseTemplateF_Pointer self) -> std::list< itkTransformBaseTemplateF_Pointer >::value_type"""
        return _itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_pop(self)


    def append(self, x: 'std::list< itkTransformBaseTemplateF_Pointer >::value_type const &') -> "void":
        """append(listitkTransformBaseTemplateF_Pointer self, std::list< itkTransformBaseTemplateF_Pointer >::value_type const & x)"""
        return _itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_append(self, x)


    def empty(self) -> "bool":
        """empty(listitkTransformBaseTemplateF_Pointer self) -> bool"""
        return _itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_empty(self)


    def size(self) -> "std::list< itkTransformBaseTemplateF_Pointer >::size_type":
        """size(listitkTransformBaseTemplateF_Pointer self) -> std::list< itkTransformBaseTemplateF_Pointer >::size_type"""
        return _itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_size(self)


    def swap(self, v: 'listitkTransformBaseTemplateF_Pointer') -> "void":
        """swap(listitkTransformBaseTemplateF_Pointer self, listitkTransformBaseTemplateF_Pointer v)"""
        return _itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_swap(self, v)


    def begin(self) -> "std::list< itkTransformBaseTemplateF_Pointer >::iterator":
        """begin(listitkTransformBaseTemplateF_Pointer self) -> std::list< itkTransformBaseTemplateF_Pointer >::iterator"""
        return _itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_begin(self)


    def end(self) -> "std::list< itkTransformBaseTemplateF_Pointer >::iterator":
        """end(listitkTransformBaseTemplateF_Pointer self) -> std::list< itkTransformBaseTemplateF_Pointer >::iterator"""
        return _itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_end(self)


    def rbegin(self) -> "std::list< itkTransformBaseTemplateF_Pointer >::reverse_iterator":
        """rbegin(listitkTransformBaseTemplateF_Pointer self) -> std::list< itkTransformBaseTemplateF_Pointer >::reverse_iterator"""
        return _itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_rbegin(self)


    def rend(self) -> "std::list< itkTransformBaseTemplateF_Pointer >::reverse_iterator":
        """rend(listitkTransformBaseTemplateF_Pointer self) -> std::list< itkTransformBaseTemplateF_Pointer >::reverse_iterator"""
        return _itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_rend(self)


    def clear(self) -> "void":
        """clear(listitkTransformBaseTemplateF_Pointer self)"""
        return _itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_clear(self)


    def get_allocator(self) -> "std::list< itkTransformBaseTemplateF_Pointer >::allocator_type":
        """get_allocator(listitkTransformBaseTemplateF_Pointer self) -> std::list< itkTransformBaseTemplateF_Pointer >::allocator_type"""
        return _itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_get_allocator(self)


    def pop_back(self) -> "void":
        """pop_back(listitkTransformBaseTemplateF_Pointer self)"""
        return _itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_pop_back(self)


    def erase(self, *args) -> "std::list< itkTransformBaseTemplateF_Pointer >::iterator":
        """
        erase(listitkTransformBaseTemplateF_Pointer self, std::list< itkTransformBaseTemplateF_Pointer >::iterator pos) -> std::list< itkTransformBaseTemplateF_Pointer >::iterator
        erase(listitkTransformBaseTemplateF_Pointer self, std::list< itkTransformBaseTemplateF_Pointer >::iterator first, std::list< itkTransformBaseTemplateF_Pointer >::iterator last) -> std::list< itkTransformBaseTemplateF_Pointer >::iterator
        """
        return _itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::list<(itkTransformBaseTemplateF_Pointer)> self) -> listitkTransformBaseTemplateF_Pointer
        __init__(std::list<(itkTransformBaseTemplateF_Pointer)> self, listitkTransformBaseTemplateF_Pointer arg2) -> listitkTransformBaseTemplateF_Pointer
        __init__(std::list<(itkTransformBaseTemplateF_Pointer)> self, std::list< itkTransformBaseTemplateF_Pointer >::size_type size) -> listitkTransformBaseTemplateF_Pointer
        __init__(std::list<(itkTransformBaseTemplateF_Pointer)> self, std::list< itkTransformBaseTemplateF_Pointer >::size_type size, std::list< itkTransformBaseTemplateF_Pointer >::value_type const & value) -> listitkTransformBaseTemplateF_Pointer
        """
        _itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_swiginit(self, _itkTransformBasePython.new_listitkTransformBaseTemplateF_Pointer(*args))

    def push_back(self, x: 'std::list< itkTransformBaseTemplateF_Pointer >::value_type const &') -> "void":
        """push_back(listitkTransformBaseTemplateF_Pointer self, std::list< itkTransformBaseTemplateF_Pointer >::value_type const & x)"""
        return _itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_push_back(self, x)


    def front(self) -> "std::list< itkTransformBaseTemplateF_Pointer >::value_type const &":
        """front(listitkTransformBaseTemplateF_Pointer self) -> std::list< itkTransformBaseTemplateF_Pointer >::value_type const &"""
        return _itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_front(self)


    def back(self) -> "std::list< itkTransformBaseTemplateF_Pointer >::value_type const &":
        """back(listitkTransformBaseTemplateF_Pointer self) -> std::list< itkTransformBaseTemplateF_Pointer >::value_type const &"""
        return _itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_back(self)


    def assign(self, n: 'std::list< itkTransformBaseTemplateF_Pointer >::size_type', x: 'std::list< itkTransformBaseTemplateF_Pointer >::value_type const &') -> "void":
        """assign(listitkTransformBaseTemplateF_Pointer self, std::list< itkTransformBaseTemplateF_Pointer >::size_type n, std::list< itkTransformBaseTemplateF_Pointer >::value_type const & x)"""
        return _itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_assign(self, n, x)


    def resize(self, *args) -> "void":
        """
        resize(listitkTransformBaseTemplateF_Pointer self, std::list< itkTransformBaseTemplateF_Pointer >::size_type new_size)
        resize(listitkTransformBaseTemplateF_Pointer self, std::list< itkTransformBaseTemplateF_Pointer >::size_type new_size, std::list< itkTransformBaseTemplateF_Pointer >::value_type const & x)
        """
        return _itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_resize(self, *args)


    def insert(self, *args) -> "void":
        """
        insert(listitkTransformBaseTemplateF_Pointer self, std::list< itkTransformBaseTemplateF_Pointer >::iterator pos, std::list< itkTransformBaseTemplateF_Pointer >::value_type const & x) -> std::list< itkTransformBaseTemplateF_Pointer >::iterator
        insert(listitkTransformBaseTemplateF_Pointer self, std::list< itkTransformBaseTemplateF_Pointer >::iterator pos, std::list< itkTransformBaseTemplateF_Pointer >::size_type n, std::list< itkTransformBaseTemplateF_Pointer >::value_type const & x)
        """
        return _itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_insert(self, *args)


    def pop_front(self) -> "void":
        """pop_front(listitkTransformBaseTemplateF_Pointer self)"""
        return _itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_pop_front(self)


    def push_front(self, x: 'std::list< itkTransformBaseTemplateF_Pointer >::value_type const &') -> "void":
        """push_front(listitkTransformBaseTemplateF_Pointer self, std::list< itkTransformBaseTemplateF_Pointer >::value_type const & x)"""
        return _itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_push_front(self, x)


    def reverse(self) -> "void":
        """reverse(listitkTransformBaseTemplateF_Pointer self)"""
        return _itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_reverse(self)

    __swig_destroy__ = _itkTransformBasePython.delete_listitkTransformBaseTemplateF_Pointer
listitkTransformBaseTemplateF_Pointer.iterator = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_iterator, None, listitkTransformBaseTemplateF_Pointer)
listitkTransformBaseTemplateF_Pointer.__nonzero__ = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer___nonzero__, None, listitkTransformBaseTemplateF_Pointer)
listitkTransformBaseTemplateF_Pointer.__bool__ = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer___bool__, None, listitkTransformBaseTemplateF_Pointer)
listitkTransformBaseTemplateF_Pointer.__len__ = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer___len__, None, listitkTransformBaseTemplateF_Pointer)
listitkTransformBaseTemplateF_Pointer.__getslice__ = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer___getslice__, None, listitkTransformBaseTemplateF_Pointer)
listitkTransformBaseTemplateF_Pointer.__setslice__ = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer___setslice__, None, listitkTransformBaseTemplateF_Pointer)
listitkTransformBaseTemplateF_Pointer.__delslice__ = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer___delslice__, None, listitkTransformBaseTemplateF_Pointer)
listitkTransformBaseTemplateF_Pointer.__delitem__ = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer___delitem__, None, listitkTransformBaseTemplateF_Pointer)
listitkTransformBaseTemplateF_Pointer.__getitem__ = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer___getitem__, None, listitkTransformBaseTemplateF_Pointer)
listitkTransformBaseTemplateF_Pointer.__setitem__ = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer___setitem__, None, listitkTransformBaseTemplateF_Pointer)
listitkTransformBaseTemplateF_Pointer.pop = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_pop, None, listitkTransformBaseTemplateF_Pointer)
listitkTransformBaseTemplateF_Pointer.append = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_append, None, listitkTransformBaseTemplateF_Pointer)
listitkTransformBaseTemplateF_Pointer.empty = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_empty, None, listitkTransformBaseTemplateF_Pointer)
listitkTransformBaseTemplateF_Pointer.size = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_size, None, listitkTransformBaseTemplateF_Pointer)
listitkTransformBaseTemplateF_Pointer.swap = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_swap, None, listitkTransformBaseTemplateF_Pointer)
listitkTransformBaseTemplateF_Pointer.begin = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_begin, None, listitkTransformBaseTemplateF_Pointer)
listitkTransformBaseTemplateF_Pointer.end = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_end, None, listitkTransformBaseTemplateF_Pointer)
listitkTransformBaseTemplateF_Pointer.rbegin = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_rbegin, None, listitkTransformBaseTemplateF_Pointer)
listitkTransformBaseTemplateF_Pointer.rend = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_rend, None, listitkTransformBaseTemplateF_Pointer)
listitkTransformBaseTemplateF_Pointer.clear = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_clear, None, listitkTransformBaseTemplateF_Pointer)
listitkTransformBaseTemplateF_Pointer.get_allocator = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_get_allocator, None, listitkTransformBaseTemplateF_Pointer)
listitkTransformBaseTemplateF_Pointer.pop_back = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_pop_back, None, listitkTransformBaseTemplateF_Pointer)
listitkTransformBaseTemplateF_Pointer.erase = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_erase, None, listitkTransformBaseTemplateF_Pointer)
listitkTransformBaseTemplateF_Pointer.push_back = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_push_back, None, listitkTransformBaseTemplateF_Pointer)
listitkTransformBaseTemplateF_Pointer.front = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_front, None, listitkTransformBaseTemplateF_Pointer)
listitkTransformBaseTemplateF_Pointer.back = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_back, None, listitkTransformBaseTemplateF_Pointer)
listitkTransformBaseTemplateF_Pointer.assign = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_assign, None, listitkTransformBaseTemplateF_Pointer)
listitkTransformBaseTemplateF_Pointer.resize = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_resize, None, listitkTransformBaseTemplateF_Pointer)
listitkTransformBaseTemplateF_Pointer.insert = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_insert, None, listitkTransformBaseTemplateF_Pointer)
listitkTransformBaseTemplateF_Pointer.pop_front = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_pop_front, None, listitkTransformBaseTemplateF_Pointer)
listitkTransformBaseTemplateF_Pointer.push_front = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_push_front, None, listitkTransformBaseTemplateF_Pointer)
listitkTransformBaseTemplateF_Pointer.reverse = new_instancemethod(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_reverse, None, listitkTransformBaseTemplateF_Pointer)
listitkTransformBaseTemplateF_Pointer_swigregister = _itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_swigregister
listitkTransformBaseTemplateF_Pointer_swigregister(listitkTransformBaseTemplateF_Pointer)

class itkDataObjectDecoratorTD22(ITKCommonBasePython.itkDataObject):
    """


    Decorates any subclass of itkObject with a DataObject API.

    DataObjectDecorator decorates an instance of a subclass of itkObject
    with a DataObject API. This allows any itkObject to be encapsulated
    into a DataObject that can be passed down the pipeline. To decorate
    simple types (float, int, std::vector) see SimpleDataObjectDecorator.

    The decorator provides two methods Set() and Get() to access the
    decorated object (referred internally as the component).

    Note that when an instance of DataObjectDecorator is created, the
    component is initialized with its default constructor (in this case a
    null pointer).

    DataObjectDecorator can decorate any subclass of itkObject. Two other
    decorators are provided. SimpleDataObjectDecorator can encapsulate
    simple types (float, int, std::vector). AutoPointerDataObjectDecorator
    will decorate any pointer type (for objects other than subclasses of
    itkObject) and manage the memory deallocating of the component.

    See:  SimpleDataObjectDecorator

    See:  AutoPointerDataObjectDecorator

    C++ includes: itkDataObjectDecorator.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkDataObjectDecoratorTD22_Pointer":
        """__New_orig__() -> itkDataObjectDecoratorTD22_Pointer"""
        return _itkTransformBasePython.itkDataObjectDecoratorTD22___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkDataObjectDecoratorTD22_Pointer":
        """Clone(itkDataObjectDecoratorTD22 self) -> itkDataObjectDecoratorTD22_Pointer"""
        return _itkTransformBasePython.itkDataObjectDecoratorTD22_Clone(self)


    def Set(self, val: 'itkTransformD22') -> "void":
        """
        Set(itkDataObjectDecoratorTD22 self, itkTransformD22 val)

        Set the contained object 
        """
        return _itkTransformBasePython.itkDataObjectDecoratorTD22_Set(self, val)


    def Get(self) -> "itkTransformD22 const *":
        """Get(itkDataObjectDecoratorTD22 self) -> itkTransformD22"""
        return _itkTransformBasePython.itkDataObjectDecoratorTD22_Get(self)


    def GetModifiable(self) -> "itkTransformD22 *":
        """GetModifiable(itkDataObjectDecoratorTD22 self) -> itkTransformD22"""
        return _itkTransformBasePython.itkDataObjectDecoratorTD22_GetModifiable(self)


    def Graft(self, *args) -> "void":
        """
        Graft(itkDataObjectDecoratorTD22 self, itkDataObject arg0)
        Graft(itkDataObjectDecoratorTD22 self, itkDataObjectDecoratorTD22 decorator)

        Method to aid in dynamic
        Graft of polymorphic types.

        To this method by default a raw pointer must be used or explicit
        template parameter must be provided. 
        """
        return _itkTransformBasePython.itkDataObjectDecoratorTD22_Graft(self, *args)

    __swig_destroy__ = _itkTransformBasePython.delete_itkDataObjectDecoratorTD22

    def cast(obj: 'itkLightObject') -> "itkDataObjectDecoratorTD22 *":
        """cast(itkLightObject obj) -> itkDataObjectDecoratorTD22"""
        return _itkTransformBasePython.itkDataObjectDecoratorTD22_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkDataObjectDecoratorTD22

        Create a new object of the class itkDataObjectDecoratorTD22 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkDataObjectDecoratorTD22.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkDataObjectDecoratorTD22.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkDataObjectDecoratorTD22.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkDataObjectDecoratorTD22.Clone = new_instancemethod(_itkTransformBasePython.itkDataObjectDecoratorTD22_Clone, None, itkDataObjectDecoratorTD22)
itkDataObjectDecoratorTD22.Set = new_instancemethod(_itkTransformBasePython.itkDataObjectDecoratorTD22_Set, None, itkDataObjectDecoratorTD22)
itkDataObjectDecoratorTD22.Get = new_instancemethod(_itkTransformBasePython.itkDataObjectDecoratorTD22_Get, None, itkDataObjectDecoratorTD22)
itkDataObjectDecoratorTD22.GetModifiable = new_instancemethod(_itkTransformBasePython.itkDataObjectDecoratorTD22_GetModifiable, None, itkDataObjectDecoratorTD22)
itkDataObjectDecoratorTD22.Graft = new_instancemethod(_itkTransformBasePython.itkDataObjectDecoratorTD22_Graft, None, itkDataObjectDecoratorTD22)
itkDataObjectDecoratorTD22_swigregister = _itkTransformBasePython.itkDataObjectDecoratorTD22_swigregister
itkDataObjectDecoratorTD22_swigregister(itkDataObjectDecoratorTD22)

def itkDataObjectDecoratorTD22___New_orig__() -> "itkDataObjectDecoratorTD22_Pointer":
    """itkDataObjectDecoratorTD22___New_orig__() -> itkDataObjectDecoratorTD22_Pointer"""
    return _itkTransformBasePython.itkDataObjectDecoratorTD22___New_orig__()

def itkDataObjectDecoratorTD22_cast(obj: 'itkLightObject') -> "itkDataObjectDecoratorTD22 *":
    """itkDataObjectDecoratorTD22_cast(itkLightObject obj) -> itkDataObjectDecoratorTD22"""
    return _itkTransformBasePython.itkDataObjectDecoratorTD22_cast(obj)

class itkDataObjectDecoratorTD23(ITKCommonBasePython.itkDataObject):
    """


    Decorates any subclass of itkObject with a DataObject API.

    DataObjectDecorator decorates an instance of a subclass of itkObject
    with a DataObject API. This allows any itkObject to be encapsulated
    into a DataObject that can be passed down the pipeline. To decorate
    simple types (float, int, std::vector) see SimpleDataObjectDecorator.

    The decorator provides two methods Set() and Get() to access the
    decorated object (referred internally as the component).

    Note that when an instance of DataObjectDecorator is created, the
    component is initialized with its default constructor (in this case a
    null pointer).

    DataObjectDecorator can decorate any subclass of itkObject. Two other
    decorators are provided. SimpleDataObjectDecorator can encapsulate
    simple types (float, int, std::vector). AutoPointerDataObjectDecorator
    will decorate any pointer type (for objects other than subclasses of
    itkObject) and manage the memory deallocating of the component.

    See:  SimpleDataObjectDecorator

    See:  AutoPointerDataObjectDecorator

    C++ includes: itkDataObjectDecorator.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkDataObjectDecoratorTD23_Pointer":
        """__New_orig__() -> itkDataObjectDecoratorTD23_Pointer"""
        return _itkTransformBasePython.itkDataObjectDecoratorTD23___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkDataObjectDecoratorTD23_Pointer":
        """Clone(itkDataObjectDecoratorTD23 self) -> itkDataObjectDecoratorTD23_Pointer"""
        return _itkTransformBasePython.itkDataObjectDecoratorTD23_Clone(self)


    def Set(self, val: 'itkTransformD23') -> "void":
        """
        Set(itkDataObjectDecoratorTD23 self, itkTransformD23 val)

        Set the contained object 
        """
        return _itkTransformBasePython.itkDataObjectDecoratorTD23_Set(self, val)


    def Get(self) -> "itkTransformD23 const *":
        """Get(itkDataObjectDecoratorTD23 self) -> itkTransformD23"""
        return _itkTransformBasePython.itkDataObjectDecoratorTD23_Get(self)


    def GetModifiable(self) -> "itkTransformD23 *":
        """GetModifiable(itkDataObjectDecoratorTD23 self) -> itkTransformD23"""
        return _itkTransformBasePython.itkDataObjectDecoratorTD23_GetModifiable(self)


    def Graft(self, *args) -> "void":
        """
        Graft(itkDataObjectDecoratorTD23 self, itkDataObject arg0)
        Graft(itkDataObjectDecoratorTD23 self, itkDataObjectDecoratorTD23 decorator)

        Method to aid in dynamic
        Graft of polymorphic types.

        To this method by default a raw pointer must be used or explicit
        template parameter must be provided. 
        """
        return _itkTransformBasePython.itkDataObjectDecoratorTD23_Graft(self, *args)

    __swig_destroy__ = _itkTransformBasePython.delete_itkDataObjectDecoratorTD23

    def cast(obj: 'itkLightObject') -> "itkDataObjectDecoratorTD23 *":
        """cast(itkLightObject obj) -> itkDataObjectDecoratorTD23"""
        return _itkTransformBasePython.itkDataObjectDecoratorTD23_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkDataObjectDecoratorTD23

        Create a new object of the class itkDataObjectDecoratorTD23 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkDataObjectDecoratorTD23.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkDataObjectDecoratorTD23.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkDataObjectDecoratorTD23.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkDataObjectDecoratorTD23.Clone = new_instancemethod(_itkTransformBasePython.itkDataObjectDecoratorTD23_Clone, None, itkDataObjectDecoratorTD23)
itkDataObjectDecoratorTD23.Set = new_instancemethod(_itkTransformBasePython.itkDataObjectDecoratorTD23_Set, None, itkDataObjectDecoratorTD23)
itkDataObjectDecoratorTD23.Get = new_instancemethod(_itkTransformBasePython.itkDataObjectDecoratorTD23_Get, None, itkDataObjectDecoratorTD23)
itkDataObjectDecoratorTD23.GetModifiable = new_instancemethod(_itkTransformBasePython.itkDataObjectDecoratorTD23_GetModifiable, None, itkDataObjectDecoratorTD23)
itkDataObjectDecoratorTD23.Graft = new_instancemethod(_itkTransformBasePython.itkDataObjectDecoratorTD23_Graft, None, itkDataObjectDecoratorTD23)
itkDataObjectDecoratorTD23_swigregister = _itkTransformBasePython.itkDataObjectDecoratorTD23_swigregister
itkDataObjectDecoratorTD23_swigregister(itkDataObjectDecoratorTD23)

def itkDataObjectDecoratorTD23___New_orig__() -> "itkDataObjectDecoratorTD23_Pointer":
    """itkDataObjectDecoratorTD23___New_orig__() -> itkDataObjectDecoratorTD23_Pointer"""
    return _itkTransformBasePython.itkDataObjectDecoratorTD23___New_orig__()

def itkDataObjectDecoratorTD23_cast(obj: 'itkLightObject') -> "itkDataObjectDecoratorTD23 *":
    """itkDataObjectDecoratorTD23_cast(itkLightObject obj) -> itkDataObjectDecoratorTD23"""
    return _itkTransformBasePython.itkDataObjectDecoratorTD23_cast(obj)

class itkDataObjectDecoratorTD32(ITKCommonBasePython.itkDataObject):
    """


    Decorates any subclass of itkObject with a DataObject API.

    DataObjectDecorator decorates an instance of a subclass of itkObject
    with a DataObject API. This allows any itkObject to be encapsulated
    into a DataObject that can be passed down the pipeline. To decorate
    simple types (float, int, std::vector) see SimpleDataObjectDecorator.

    The decorator provides two methods Set() and Get() to access the
    decorated object (referred internally as the component).

    Note that when an instance of DataObjectDecorator is created, the
    component is initialized with its default constructor (in this case a
    null pointer).

    DataObjectDecorator can decorate any subclass of itkObject. Two other
    decorators are provided. SimpleDataObjectDecorator can encapsulate
    simple types (float, int, std::vector). AutoPointerDataObjectDecorator
    will decorate any pointer type (for objects other than subclasses of
    itkObject) and manage the memory deallocating of the component.

    See:  SimpleDataObjectDecorator

    See:  AutoPointerDataObjectDecorator

    C++ includes: itkDataObjectDecorator.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkDataObjectDecoratorTD32_Pointer":
        """__New_orig__() -> itkDataObjectDecoratorTD32_Pointer"""
        return _itkTransformBasePython.itkDataObjectDecoratorTD32___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkDataObjectDecoratorTD32_Pointer":
        """Clone(itkDataObjectDecoratorTD32 self) -> itkDataObjectDecoratorTD32_Pointer"""
        return _itkTransformBasePython.itkDataObjectDecoratorTD32_Clone(self)


    def Set(self, val: 'itkTransformD32') -> "void":
        """
        Set(itkDataObjectDecoratorTD32 self, itkTransformD32 val)

        Set the contained object 
        """
        return _itkTransformBasePython.itkDataObjectDecoratorTD32_Set(self, val)


    def Get(self) -> "itkTransformD32 const *":
        """Get(itkDataObjectDecoratorTD32 self) -> itkTransformD32"""
        return _itkTransformBasePython.itkDataObjectDecoratorTD32_Get(self)


    def GetModifiable(self) -> "itkTransformD32 *":
        """GetModifiable(itkDataObjectDecoratorTD32 self) -> itkTransformD32"""
        return _itkTransformBasePython.itkDataObjectDecoratorTD32_GetModifiable(self)


    def Graft(self, *args) -> "void":
        """
        Graft(itkDataObjectDecoratorTD32 self, itkDataObject arg0)
        Graft(itkDataObjectDecoratorTD32 self, itkDataObjectDecoratorTD32 decorator)

        Method to aid in dynamic
        Graft of polymorphic types.

        To this method by default a raw pointer must be used or explicit
        template parameter must be provided. 
        """
        return _itkTransformBasePython.itkDataObjectDecoratorTD32_Graft(self, *args)

    __swig_destroy__ = _itkTransformBasePython.delete_itkDataObjectDecoratorTD32

    def cast(obj: 'itkLightObject') -> "itkDataObjectDecoratorTD32 *":
        """cast(itkLightObject obj) -> itkDataObjectDecoratorTD32"""
        return _itkTransformBasePython.itkDataObjectDecoratorTD32_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkDataObjectDecoratorTD32

        Create a new object of the class itkDataObjectDecoratorTD32 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkDataObjectDecoratorTD32.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkDataObjectDecoratorTD32.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkDataObjectDecoratorTD32.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkDataObjectDecoratorTD32.Clone = new_instancemethod(_itkTransformBasePython.itkDataObjectDecoratorTD32_Clone, None, itkDataObjectDecoratorTD32)
itkDataObjectDecoratorTD32.Set = new_instancemethod(_itkTransformBasePython.itkDataObjectDecoratorTD32_Set, None, itkDataObjectDecoratorTD32)
itkDataObjectDecoratorTD32.Get = new_instancemethod(_itkTransformBasePython.itkDataObjectDecoratorTD32_Get, None, itkDataObjectDecoratorTD32)
itkDataObjectDecoratorTD32.GetModifiable = new_instancemethod(_itkTransformBasePython.itkDataObjectDecoratorTD32_GetModifiable, None, itkDataObjectDecoratorTD32)
itkDataObjectDecoratorTD32.Graft = new_instancemethod(_itkTransformBasePython.itkDataObjectDecoratorTD32_Graft, None, itkDataObjectDecoratorTD32)
itkDataObjectDecoratorTD32_swigregister = _itkTransformBasePython.itkDataObjectDecoratorTD32_swigregister
itkDataObjectDecoratorTD32_swigregister(itkDataObjectDecoratorTD32)

def itkDataObjectDecoratorTD32___New_orig__() -> "itkDataObjectDecoratorTD32_Pointer":
    """itkDataObjectDecoratorTD32___New_orig__() -> itkDataObjectDecoratorTD32_Pointer"""
    return _itkTransformBasePython.itkDataObjectDecoratorTD32___New_orig__()

def itkDataObjectDecoratorTD32_cast(obj: 'itkLightObject') -> "itkDataObjectDecoratorTD32 *":
    """itkDataObjectDecoratorTD32_cast(itkLightObject obj) -> itkDataObjectDecoratorTD32"""
    return _itkTransformBasePython.itkDataObjectDecoratorTD32_cast(obj)

class itkDataObjectDecoratorTD33(ITKCommonBasePython.itkDataObject):
    """


    Decorates any subclass of itkObject with a DataObject API.

    DataObjectDecorator decorates an instance of a subclass of itkObject
    with a DataObject API. This allows any itkObject to be encapsulated
    into a DataObject that can be passed down the pipeline. To decorate
    simple types (float, int, std::vector) see SimpleDataObjectDecorator.

    The decorator provides two methods Set() and Get() to access the
    decorated object (referred internally as the component).

    Note that when an instance of DataObjectDecorator is created, the
    component is initialized with its default constructor (in this case a
    null pointer).

    DataObjectDecorator can decorate any subclass of itkObject. Two other
    decorators are provided. SimpleDataObjectDecorator can encapsulate
    simple types (float, int, std::vector). AutoPointerDataObjectDecorator
    will decorate any pointer type (for objects other than subclasses of
    itkObject) and manage the memory deallocating of the component.

    See:  SimpleDataObjectDecorator

    See:  AutoPointerDataObjectDecorator

    C++ includes: itkDataObjectDecorator.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkDataObjectDecoratorTD33_Pointer":
        """__New_orig__() -> itkDataObjectDecoratorTD33_Pointer"""
        return _itkTransformBasePython.itkDataObjectDecoratorTD33___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkDataObjectDecoratorTD33_Pointer":
        """Clone(itkDataObjectDecoratorTD33 self) -> itkDataObjectDecoratorTD33_Pointer"""
        return _itkTransformBasePython.itkDataObjectDecoratorTD33_Clone(self)


    def Set(self, val: 'itkTransformD33') -> "void":
        """
        Set(itkDataObjectDecoratorTD33 self, itkTransformD33 val)

        Set the contained object 
        """
        return _itkTransformBasePython.itkDataObjectDecoratorTD33_Set(self, val)


    def Get(self) -> "itkTransformD33 const *":
        """Get(itkDataObjectDecoratorTD33 self) -> itkTransformD33"""
        return _itkTransformBasePython.itkDataObjectDecoratorTD33_Get(self)


    def GetModifiable(self) -> "itkTransformD33 *":
        """GetModifiable(itkDataObjectDecoratorTD33 self) -> itkTransformD33"""
        return _itkTransformBasePython.itkDataObjectDecoratorTD33_GetModifiable(self)


    def Graft(self, *args) -> "void":
        """
        Graft(itkDataObjectDecoratorTD33 self, itkDataObject arg0)
        Graft(itkDataObjectDecoratorTD33 self, itkDataObjectDecoratorTD33 decorator)

        Method to aid in dynamic
        Graft of polymorphic types.

        To this method by default a raw pointer must be used or explicit
        template parameter must be provided. 
        """
        return _itkTransformBasePython.itkDataObjectDecoratorTD33_Graft(self, *args)

    __swig_destroy__ = _itkTransformBasePython.delete_itkDataObjectDecoratorTD33

    def cast(obj: 'itkLightObject') -> "itkDataObjectDecoratorTD33 *":
        """cast(itkLightObject obj) -> itkDataObjectDecoratorTD33"""
        return _itkTransformBasePython.itkDataObjectDecoratorTD33_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkDataObjectDecoratorTD33

        Create a new object of the class itkDataObjectDecoratorTD33 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkDataObjectDecoratorTD33.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkDataObjectDecoratorTD33.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkDataObjectDecoratorTD33.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkDataObjectDecoratorTD33.Clone = new_instancemethod(_itkTransformBasePython.itkDataObjectDecoratorTD33_Clone, None, itkDataObjectDecoratorTD33)
itkDataObjectDecoratorTD33.Set = new_instancemethod(_itkTransformBasePython.itkDataObjectDecoratorTD33_Set, None, itkDataObjectDecoratorTD33)
itkDataObjectDecoratorTD33.Get = new_instancemethod(_itkTransformBasePython.itkDataObjectDecoratorTD33_Get, None, itkDataObjectDecoratorTD33)
itkDataObjectDecoratorTD33.GetModifiable = new_instancemethod(_itkTransformBasePython.itkDataObjectDecoratorTD33_GetModifiable, None, itkDataObjectDecoratorTD33)
itkDataObjectDecoratorTD33.Graft = new_instancemethod(_itkTransformBasePython.itkDataObjectDecoratorTD33_Graft, None, itkDataObjectDecoratorTD33)
itkDataObjectDecoratorTD33_swigregister = _itkTransformBasePython.itkDataObjectDecoratorTD33_swigregister
itkDataObjectDecoratorTD33_swigregister(itkDataObjectDecoratorTD33)

def itkDataObjectDecoratorTD33___New_orig__() -> "itkDataObjectDecoratorTD33_Pointer":
    """itkDataObjectDecoratorTD33___New_orig__() -> itkDataObjectDecoratorTD33_Pointer"""
    return _itkTransformBasePython.itkDataObjectDecoratorTD33___New_orig__()

def itkDataObjectDecoratorTD33_cast(obj: 'itkLightObject') -> "itkDataObjectDecoratorTD33 *":
    """itkDataObjectDecoratorTD33_cast(itkLightObject obj) -> itkDataObjectDecoratorTD33"""
    return _itkTransformBasePython.itkDataObjectDecoratorTD33_cast(obj)

class itkDataObjectDecoratorTF22(ITKCommonBasePython.itkDataObject):
    """


    Decorates any subclass of itkObject with a DataObject API.

    DataObjectDecorator decorates an instance of a subclass of itkObject
    with a DataObject API. This allows any itkObject to be encapsulated
    into a DataObject that can be passed down the pipeline. To decorate
    simple types (float, int, std::vector) see SimpleDataObjectDecorator.

    The decorator provides two methods Set() and Get() to access the
    decorated object (referred internally as the component).

    Note that when an instance of DataObjectDecorator is created, the
    component is initialized with its default constructor (in this case a
    null pointer).

    DataObjectDecorator can decorate any subclass of itkObject. Two other
    decorators are provided. SimpleDataObjectDecorator can encapsulate
    simple types (float, int, std::vector). AutoPointerDataObjectDecorator
    will decorate any pointer type (for objects other than subclasses of
    itkObject) and manage the memory deallocating of the component.

    See:  SimpleDataObjectDecorator

    See:  AutoPointerDataObjectDecorator

    C++ includes: itkDataObjectDecorator.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkDataObjectDecoratorTF22_Pointer":
        """__New_orig__() -> itkDataObjectDecoratorTF22_Pointer"""
        return _itkTransformBasePython.itkDataObjectDecoratorTF22___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkDataObjectDecoratorTF22_Pointer":
        """Clone(itkDataObjectDecoratorTF22 self) -> itkDataObjectDecoratorTF22_Pointer"""
        return _itkTransformBasePython.itkDataObjectDecoratorTF22_Clone(self)


    def Set(self, val: 'itkTransformF22') -> "void":
        """
        Set(itkDataObjectDecoratorTF22 self, itkTransformF22 val)

        Set the contained object 
        """
        return _itkTransformBasePython.itkDataObjectDecoratorTF22_Set(self, val)


    def Get(self) -> "itkTransformF22 const *":
        """Get(itkDataObjectDecoratorTF22 self) -> itkTransformF22"""
        return _itkTransformBasePython.itkDataObjectDecoratorTF22_Get(self)


    def GetModifiable(self) -> "itkTransformF22 *":
        """GetModifiable(itkDataObjectDecoratorTF22 self) -> itkTransformF22"""
        return _itkTransformBasePython.itkDataObjectDecoratorTF22_GetModifiable(self)


    def Graft(self, *args) -> "void":
        """
        Graft(itkDataObjectDecoratorTF22 self, itkDataObject arg0)
        Graft(itkDataObjectDecoratorTF22 self, itkDataObjectDecoratorTF22 decorator)

        Method to aid in dynamic
        Graft of polymorphic types.

        To this method by default a raw pointer must be used or explicit
        template parameter must be provided. 
        """
        return _itkTransformBasePython.itkDataObjectDecoratorTF22_Graft(self, *args)

    __swig_destroy__ = _itkTransformBasePython.delete_itkDataObjectDecoratorTF22

    def cast(obj: 'itkLightObject') -> "itkDataObjectDecoratorTF22 *":
        """cast(itkLightObject obj) -> itkDataObjectDecoratorTF22"""
        return _itkTransformBasePython.itkDataObjectDecoratorTF22_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkDataObjectDecoratorTF22

        Create a new object of the class itkDataObjectDecoratorTF22 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkDataObjectDecoratorTF22.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkDataObjectDecoratorTF22.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkDataObjectDecoratorTF22.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkDataObjectDecoratorTF22.Clone = new_instancemethod(_itkTransformBasePython.itkDataObjectDecoratorTF22_Clone, None, itkDataObjectDecoratorTF22)
itkDataObjectDecoratorTF22.Set = new_instancemethod(_itkTransformBasePython.itkDataObjectDecoratorTF22_Set, None, itkDataObjectDecoratorTF22)
itkDataObjectDecoratorTF22.Get = new_instancemethod(_itkTransformBasePython.itkDataObjectDecoratorTF22_Get, None, itkDataObjectDecoratorTF22)
itkDataObjectDecoratorTF22.GetModifiable = new_instancemethod(_itkTransformBasePython.itkDataObjectDecoratorTF22_GetModifiable, None, itkDataObjectDecoratorTF22)
itkDataObjectDecoratorTF22.Graft = new_instancemethod(_itkTransformBasePython.itkDataObjectDecoratorTF22_Graft, None, itkDataObjectDecoratorTF22)
itkDataObjectDecoratorTF22_swigregister = _itkTransformBasePython.itkDataObjectDecoratorTF22_swigregister
itkDataObjectDecoratorTF22_swigregister(itkDataObjectDecoratorTF22)

def itkDataObjectDecoratorTF22___New_orig__() -> "itkDataObjectDecoratorTF22_Pointer":
    """itkDataObjectDecoratorTF22___New_orig__() -> itkDataObjectDecoratorTF22_Pointer"""
    return _itkTransformBasePython.itkDataObjectDecoratorTF22___New_orig__()

def itkDataObjectDecoratorTF22_cast(obj: 'itkLightObject') -> "itkDataObjectDecoratorTF22 *":
    """itkDataObjectDecoratorTF22_cast(itkLightObject obj) -> itkDataObjectDecoratorTF22"""
    return _itkTransformBasePython.itkDataObjectDecoratorTF22_cast(obj)

class itkDataObjectDecoratorTF23(ITKCommonBasePython.itkDataObject):
    """


    Decorates any subclass of itkObject with a DataObject API.

    DataObjectDecorator decorates an instance of a subclass of itkObject
    with a DataObject API. This allows any itkObject to be encapsulated
    into a DataObject that can be passed down the pipeline. To decorate
    simple types (float, int, std::vector) see SimpleDataObjectDecorator.

    The decorator provides two methods Set() and Get() to access the
    decorated object (referred internally as the component).

    Note that when an instance of DataObjectDecorator is created, the
    component is initialized with its default constructor (in this case a
    null pointer).

    DataObjectDecorator can decorate any subclass of itkObject. Two other
    decorators are provided. SimpleDataObjectDecorator can encapsulate
    simple types (float, int, std::vector). AutoPointerDataObjectDecorator
    will decorate any pointer type (for objects other than subclasses of
    itkObject) and manage the memory deallocating of the component.

    See:  SimpleDataObjectDecorator

    See:  AutoPointerDataObjectDecorator

    C++ includes: itkDataObjectDecorator.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkDataObjectDecoratorTF23_Pointer":
        """__New_orig__() -> itkDataObjectDecoratorTF23_Pointer"""
        return _itkTransformBasePython.itkDataObjectDecoratorTF23___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkDataObjectDecoratorTF23_Pointer":
        """Clone(itkDataObjectDecoratorTF23 self) -> itkDataObjectDecoratorTF23_Pointer"""
        return _itkTransformBasePython.itkDataObjectDecoratorTF23_Clone(self)


    def Set(self, val: 'itkTransformF23') -> "void":
        """
        Set(itkDataObjectDecoratorTF23 self, itkTransformF23 val)

        Set the contained object 
        """
        return _itkTransformBasePython.itkDataObjectDecoratorTF23_Set(self, val)


    def Get(self) -> "itkTransformF23 const *":
        """Get(itkDataObjectDecoratorTF23 self) -> itkTransformF23"""
        return _itkTransformBasePython.itkDataObjectDecoratorTF23_Get(self)


    def GetModifiable(self) -> "itkTransformF23 *":
        """GetModifiable(itkDataObjectDecoratorTF23 self) -> itkTransformF23"""
        return _itkTransformBasePython.itkDataObjectDecoratorTF23_GetModifiable(self)


    def Graft(self, *args) -> "void":
        """
        Graft(itkDataObjectDecoratorTF23 self, itkDataObject arg0)
        Graft(itkDataObjectDecoratorTF23 self, itkDataObjectDecoratorTF23 decorator)

        Method to aid in dynamic
        Graft of polymorphic types.

        To this method by default a raw pointer must be used or explicit
        template parameter must be provided. 
        """
        return _itkTransformBasePython.itkDataObjectDecoratorTF23_Graft(self, *args)

    __swig_destroy__ = _itkTransformBasePython.delete_itkDataObjectDecoratorTF23

    def cast(obj: 'itkLightObject') -> "itkDataObjectDecoratorTF23 *":
        """cast(itkLightObject obj) -> itkDataObjectDecoratorTF23"""
        return _itkTransformBasePython.itkDataObjectDecoratorTF23_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkDataObjectDecoratorTF23

        Create a new object of the class itkDataObjectDecoratorTF23 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkDataObjectDecoratorTF23.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkDataObjectDecoratorTF23.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkDataObjectDecoratorTF23.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkDataObjectDecoratorTF23.Clone = new_instancemethod(_itkTransformBasePython.itkDataObjectDecoratorTF23_Clone, None, itkDataObjectDecoratorTF23)
itkDataObjectDecoratorTF23.Set = new_instancemethod(_itkTransformBasePython.itkDataObjectDecoratorTF23_Set, None, itkDataObjectDecoratorTF23)
itkDataObjectDecoratorTF23.Get = new_instancemethod(_itkTransformBasePython.itkDataObjectDecoratorTF23_Get, None, itkDataObjectDecoratorTF23)
itkDataObjectDecoratorTF23.GetModifiable = new_instancemethod(_itkTransformBasePython.itkDataObjectDecoratorTF23_GetModifiable, None, itkDataObjectDecoratorTF23)
itkDataObjectDecoratorTF23.Graft = new_instancemethod(_itkTransformBasePython.itkDataObjectDecoratorTF23_Graft, None, itkDataObjectDecoratorTF23)
itkDataObjectDecoratorTF23_swigregister = _itkTransformBasePython.itkDataObjectDecoratorTF23_swigregister
itkDataObjectDecoratorTF23_swigregister(itkDataObjectDecoratorTF23)

def itkDataObjectDecoratorTF23___New_orig__() -> "itkDataObjectDecoratorTF23_Pointer":
    """itkDataObjectDecoratorTF23___New_orig__() -> itkDataObjectDecoratorTF23_Pointer"""
    return _itkTransformBasePython.itkDataObjectDecoratorTF23___New_orig__()

def itkDataObjectDecoratorTF23_cast(obj: 'itkLightObject') -> "itkDataObjectDecoratorTF23 *":
    """itkDataObjectDecoratorTF23_cast(itkLightObject obj) -> itkDataObjectDecoratorTF23"""
    return _itkTransformBasePython.itkDataObjectDecoratorTF23_cast(obj)

class itkDataObjectDecoratorTF32(ITKCommonBasePython.itkDataObject):
    """


    Decorates any subclass of itkObject with a DataObject API.

    DataObjectDecorator decorates an instance of a subclass of itkObject
    with a DataObject API. This allows any itkObject to be encapsulated
    into a DataObject that can be passed down the pipeline. To decorate
    simple types (float, int, std::vector) see SimpleDataObjectDecorator.

    The decorator provides two methods Set() and Get() to access the
    decorated object (referred internally as the component).

    Note that when an instance of DataObjectDecorator is created, the
    component is initialized with its default constructor (in this case a
    null pointer).

    DataObjectDecorator can decorate any subclass of itkObject. Two other
    decorators are provided. SimpleDataObjectDecorator can encapsulate
    simple types (float, int, std::vector). AutoPointerDataObjectDecorator
    will decorate any pointer type (for objects other than subclasses of
    itkObject) and manage the memory deallocating of the component.

    See:  SimpleDataObjectDecorator

    See:  AutoPointerDataObjectDecorator

    C++ includes: itkDataObjectDecorator.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkDataObjectDecoratorTF32_Pointer":
        """__New_orig__() -> itkDataObjectDecoratorTF32_Pointer"""
        return _itkTransformBasePython.itkDataObjectDecoratorTF32___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkDataObjectDecoratorTF32_Pointer":
        """Clone(itkDataObjectDecoratorTF32 self) -> itkDataObjectDecoratorTF32_Pointer"""
        return _itkTransformBasePython.itkDataObjectDecoratorTF32_Clone(self)


    def Set(self, val: 'itkTransformF32') -> "void":
        """
        Set(itkDataObjectDecoratorTF32 self, itkTransformF32 val)

        Set the contained object 
        """
        return _itkTransformBasePython.itkDataObjectDecoratorTF32_Set(self, val)


    def Get(self) -> "itkTransformF32 const *":
        """Get(itkDataObjectDecoratorTF32 self) -> itkTransformF32"""
        return _itkTransformBasePython.itkDataObjectDecoratorTF32_Get(self)


    def GetModifiable(self) -> "itkTransformF32 *":
        """GetModifiable(itkDataObjectDecoratorTF32 self) -> itkTransformF32"""
        return _itkTransformBasePython.itkDataObjectDecoratorTF32_GetModifiable(self)


    def Graft(self, *args) -> "void":
        """
        Graft(itkDataObjectDecoratorTF32 self, itkDataObject arg0)
        Graft(itkDataObjectDecoratorTF32 self, itkDataObjectDecoratorTF32 decorator)

        Method to aid in dynamic
        Graft of polymorphic types.

        To this method by default a raw pointer must be used or explicit
        template parameter must be provided. 
        """
        return _itkTransformBasePython.itkDataObjectDecoratorTF32_Graft(self, *args)

    __swig_destroy__ = _itkTransformBasePython.delete_itkDataObjectDecoratorTF32

    def cast(obj: 'itkLightObject') -> "itkDataObjectDecoratorTF32 *":
        """cast(itkLightObject obj) -> itkDataObjectDecoratorTF32"""
        return _itkTransformBasePython.itkDataObjectDecoratorTF32_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkDataObjectDecoratorTF32

        Create a new object of the class itkDataObjectDecoratorTF32 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkDataObjectDecoratorTF32.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkDataObjectDecoratorTF32.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkDataObjectDecoratorTF32.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkDataObjectDecoratorTF32.Clone = new_instancemethod(_itkTransformBasePython.itkDataObjectDecoratorTF32_Clone, None, itkDataObjectDecoratorTF32)
itkDataObjectDecoratorTF32.Set = new_instancemethod(_itkTransformBasePython.itkDataObjectDecoratorTF32_Set, None, itkDataObjectDecoratorTF32)
itkDataObjectDecoratorTF32.Get = new_instancemethod(_itkTransformBasePython.itkDataObjectDecoratorTF32_Get, None, itkDataObjectDecoratorTF32)
itkDataObjectDecoratorTF32.GetModifiable = new_instancemethod(_itkTransformBasePython.itkDataObjectDecoratorTF32_GetModifiable, None, itkDataObjectDecoratorTF32)
itkDataObjectDecoratorTF32.Graft = new_instancemethod(_itkTransformBasePython.itkDataObjectDecoratorTF32_Graft, None, itkDataObjectDecoratorTF32)
itkDataObjectDecoratorTF32_swigregister = _itkTransformBasePython.itkDataObjectDecoratorTF32_swigregister
itkDataObjectDecoratorTF32_swigregister(itkDataObjectDecoratorTF32)

def itkDataObjectDecoratorTF32___New_orig__() -> "itkDataObjectDecoratorTF32_Pointer":
    """itkDataObjectDecoratorTF32___New_orig__() -> itkDataObjectDecoratorTF32_Pointer"""
    return _itkTransformBasePython.itkDataObjectDecoratorTF32___New_orig__()

def itkDataObjectDecoratorTF32_cast(obj: 'itkLightObject') -> "itkDataObjectDecoratorTF32 *":
    """itkDataObjectDecoratorTF32_cast(itkLightObject obj) -> itkDataObjectDecoratorTF32"""
    return _itkTransformBasePython.itkDataObjectDecoratorTF32_cast(obj)

class itkDataObjectDecoratorTF33(ITKCommonBasePython.itkDataObject):
    """


    Decorates any subclass of itkObject with a DataObject API.

    DataObjectDecorator decorates an instance of a subclass of itkObject
    with a DataObject API. This allows any itkObject to be encapsulated
    into a DataObject that can be passed down the pipeline. To decorate
    simple types (float, int, std::vector) see SimpleDataObjectDecorator.

    The decorator provides two methods Set() and Get() to access the
    decorated object (referred internally as the component).

    Note that when an instance of DataObjectDecorator is created, the
    component is initialized with its default constructor (in this case a
    null pointer).

    DataObjectDecorator can decorate any subclass of itkObject. Two other
    decorators are provided. SimpleDataObjectDecorator can encapsulate
    simple types (float, int, std::vector). AutoPointerDataObjectDecorator
    will decorate any pointer type (for objects other than subclasses of
    itkObject) and manage the memory deallocating of the component.

    See:  SimpleDataObjectDecorator

    See:  AutoPointerDataObjectDecorator

    C++ includes: itkDataObjectDecorator.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkDataObjectDecoratorTF33_Pointer":
        """__New_orig__() -> itkDataObjectDecoratorTF33_Pointer"""
        return _itkTransformBasePython.itkDataObjectDecoratorTF33___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkDataObjectDecoratorTF33_Pointer":
        """Clone(itkDataObjectDecoratorTF33 self) -> itkDataObjectDecoratorTF33_Pointer"""
        return _itkTransformBasePython.itkDataObjectDecoratorTF33_Clone(self)


    def Set(self, val: 'itkTransformF33') -> "void":
        """
        Set(itkDataObjectDecoratorTF33 self, itkTransformF33 val)

        Set the contained object 
        """
        return _itkTransformBasePython.itkDataObjectDecoratorTF33_Set(self, val)


    def Get(self) -> "itkTransformF33 const *":
        """Get(itkDataObjectDecoratorTF33 self) -> itkTransformF33"""
        return _itkTransformBasePython.itkDataObjectDecoratorTF33_Get(self)


    def GetModifiable(self) -> "itkTransformF33 *":
        """GetModifiable(itkDataObjectDecoratorTF33 self) -> itkTransformF33"""
        return _itkTransformBasePython.itkDataObjectDecoratorTF33_GetModifiable(self)


    def Graft(self, *args) -> "void":
        """
        Graft(itkDataObjectDecoratorTF33 self, itkDataObject arg0)
        Graft(itkDataObjectDecoratorTF33 self, itkDataObjectDecoratorTF33 decorator)

        Method to aid in dynamic
        Graft of polymorphic types.

        To this method by default a raw pointer must be used or explicit
        template parameter must be provided. 
        """
        return _itkTransformBasePython.itkDataObjectDecoratorTF33_Graft(self, *args)

    __swig_destroy__ = _itkTransformBasePython.delete_itkDataObjectDecoratorTF33

    def cast(obj: 'itkLightObject') -> "itkDataObjectDecoratorTF33 *":
        """cast(itkLightObject obj) -> itkDataObjectDecoratorTF33"""
        return _itkTransformBasePython.itkDataObjectDecoratorTF33_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkDataObjectDecoratorTF33

        Create a new object of the class itkDataObjectDecoratorTF33 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkDataObjectDecoratorTF33.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkDataObjectDecoratorTF33.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkDataObjectDecoratorTF33.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkDataObjectDecoratorTF33.Clone = new_instancemethod(_itkTransformBasePython.itkDataObjectDecoratorTF33_Clone, None, itkDataObjectDecoratorTF33)
itkDataObjectDecoratorTF33.Set = new_instancemethod(_itkTransformBasePython.itkDataObjectDecoratorTF33_Set, None, itkDataObjectDecoratorTF33)
itkDataObjectDecoratorTF33.Get = new_instancemethod(_itkTransformBasePython.itkDataObjectDecoratorTF33_Get, None, itkDataObjectDecoratorTF33)
itkDataObjectDecoratorTF33.GetModifiable = new_instancemethod(_itkTransformBasePython.itkDataObjectDecoratorTF33_GetModifiable, None, itkDataObjectDecoratorTF33)
itkDataObjectDecoratorTF33.Graft = new_instancemethod(_itkTransformBasePython.itkDataObjectDecoratorTF33_Graft, None, itkDataObjectDecoratorTF33)
itkDataObjectDecoratorTF33_swigregister = _itkTransformBasePython.itkDataObjectDecoratorTF33_swigregister
itkDataObjectDecoratorTF33_swigregister(itkDataObjectDecoratorTF33)

def itkDataObjectDecoratorTF33___New_orig__() -> "itkDataObjectDecoratorTF33_Pointer":
    """itkDataObjectDecoratorTF33___New_orig__() -> itkDataObjectDecoratorTF33_Pointer"""
    return _itkTransformBasePython.itkDataObjectDecoratorTF33___New_orig__()

def itkDataObjectDecoratorTF33_cast(obj: 'itkLightObject') -> "itkDataObjectDecoratorTF33 *":
    """itkDataObjectDecoratorTF33_cast(itkLightObject obj) -> itkDataObjectDecoratorTF33"""
    return _itkTransformBasePython.itkDataObjectDecoratorTF33_cast(obj)

class itkTransformBaseTemplateD(ITKCommonBasePython.itkObject):
    """Proxy of C++ itkTransformBaseTemplateD class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def GetNumberOfParameters(self) -> "unsigned long":
        """GetNumberOfParameters(itkTransformBaseTemplateD self) -> unsigned long"""
        return _itkTransformBasePython.itkTransformBaseTemplateD_GetNumberOfParameters(self)


    def GetParameters(self) -> "itkOptimizerParametersD const &":
        """GetParameters(itkTransformBaseTemplateD self) -> itkOptimizerParametersD"""
        return _itkTransformBasePython.itkTransformBaseTemplateD_GetParameters(self)


    def GetInputSpaceDimension(self) -> "unsigned int":
        """GetInputSpaceDimension(itkTransformBaseTemplateD self) -> unsigned int"""
        return _itkTransformBasePython.itkTransformBaseTemplateD_GetInputSpaceDimension(self)


    def GetOutputSpaceDimension(self) -> "unsigned int":
        """GetOutputSpaceDimension(itkTransformBaseTemplateD self) -> unsigned int"""
        return _itkTransformBasePython.itkTransformBaseTemplateD_GetOutputSpaceDimension(self)


    def SetParameters(self, arg0: 'itkOptimizerParametersD') -> "void":
        """SetParameters(itkTransformBaseTemplateD self, itkOptimizerParametersD arg0)"""
        return _itkTransformBasePython.itkTransformBaseTemplateD_SetParameters(self, arg0)


    def SetParametersByValue(self, p: 'itkOptimizerParametersD') -> "void":
        """SetParametersByValue(itkTransformBaseTemplateD self, itkOptimizerParametersD p)"""
        return _itkTransformBasePython.itkTransformBaseTemplateD_SetParametersByValue(self, p)


    def SetFixedParameters(self, arg0: 'itkOptimizerParametersD') -> "void":
        """SetFixedParameters(itkTransformBaseTemplateD self, itkOptimizerParametersD arg0)"""
        return _itkTransformBasePython.itkTransformBaseTemplateD_SetFixedParameters(self, arg0)


    def CopyInParameters(self, begin: 'double const *const', end: 'double const *const') -> "void":
        """CopyInParameters(itkTransformBaseTemplateD self, double const *const begin, double const *const end)"""
        return _itkTransformBasePython.itkTransformBaseTemplateD_CopyInParameters(self, begin, end)


    def CopyInFixedParameters(self, begin: 'double const *const', end: 'double const *const') -> "void":
        """CopyInFixedParameters(itkTransformBaseTemplateD self, double const *const begin, double const *const end)"""
        return _itkTransformBasePython.itkTransformBaseTemplateD_CopyInFixedParameters(self, begin, end)


    def GetFixedParameters(self) -> "itkOptimizerParametersD const &":
        """GetFixedParameters(itkTransformBaseTemplateD self) -> itkOptimizerParametersD"""
        return _itkTransformBasePython.itkTransformBaseTemplateD_GetFixedParameters(self)


    def GetTransformTypeAsString(self) -> "std::string":
        """GetTransformTypeAsString(itkTransformBaseTemplateD self) -> std::string"""
        return _itkTransformBasePython.itkTransformBaseTemplateD_GetTransformTypeAsString(self)


    def GetTransformCategory(self) -> "itkTransformBaseTemplateEnums::TransformCategory":
        """GetTransformCategory(itkTransformBaseTemplateD self) -> itkTransformBaseTemplateEnums::TransformCategory"""
        return _itkTransformBasePython.itkTransformBaseTemplateD_GetTransformCategory(self)

    __swig_destroy__ = _itkTransformBasePython.delete_itkTransformBaseTemplateD

    def cast(obj: 'itkLightObject') -> "itkTransformBaseTemplateD *":
        """cast(itkLightObject obj) -> itkTransformBaseTemplateD"""
        return _itkTransformBasePython.itkTransformBaseTemplateD_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkTransformBaseTemplateD

        Create a new object of the class itkTransformBaseTemplateD and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkTransformBaseTemplateD.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkTransformBaseTemplateD.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkTransformBaseTemplateD.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkTransformBaseTemplateD.GetNumberOfParameters = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateD_GetNumberOfParameters, None, itkTransformBaseTemplateD)
itkTransformBaseTemplateD.GetParameters = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateD_GetParameters, None, itkTransformBaseTemplateD)
itkTransformBaseTemplateD.GetInputSpaceDimension = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateD_GetInputSpaceDimension, None, itkTransformBaseTemplateD)
itkTransformBaseTemplateD.GetOutputSpaceDimension = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateD_GetOutputSpaceDimension, None, itkTransformBaseTemplateD)
itkTransformBaseTemplateD.SetParameters = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateD_SetParameters, None, itkTransformBaseTemplateD)
itkTransformBaseTemplateD.SetParametersByValue = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateD_SetParametersByValue, None, itkTransformBaseTemplateD)
itkTransformBaseTemplateD.SetFixedParameters = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateD_SetFixedParameters, None, itkTransformBaseTemplateD)
itkTransformBaseTemplateD.CopyInParameters = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateD_CopyInParameters, None, itkTransformBaseTemplateD)
itkTransformBaseTemplateD.CopyInFixedParameters = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateD_CopyInFixedParameters, None, itkTransformBaseTemplateD)
itkTransformBaseTemplateD.GetFixedParameters = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateD_GetFixedParameters, None, itkTransformBaseTemplateD)
itkTransformBaseTemplateD.GetTransformTypeAsString = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateD_GetTransformTypeAsString, None, itkTransformBaseTemplateD)
itkTransformBaseTemplateD.GetTransformCategory = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateD_GetTransformCategory, None, itkTransformBaseTemplateD)
itkTransformBaseTemplateD_swigregister = _itkTransformBasePython.itkTransformBaseTemplateD_swigregister
itkTransformBaseTemplateD_swigregister(itkTransformBaseTemplateD)

def itkTransformBaseTemplateD_cast(obj: 'itkLightObject') -> "itkTransformBaseTemplateD *":
    """itkTransformBaseTemplateD_cast(itkLightObject obj) -> itkTransformBaseTemplateD"""
    return _itkTransformBasePython.itkTransformBaseTemplateD_cast(obj)

class itkTransformBaseTemplateD_ConstPointer(object):
    """Proxy of C++ itkTransformBaseTemplateD_ConstPointer class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkTransformBaseTemplateD_ConstPointer self) -> itkTransformBaseTemplateD_ConstPointer
        __init__(itkTransformBaseTemplateD_ConstPointer self, itkTransformBaseTemplateD_ConstPointer p) -> itkTransformBaseTemplateD_ConstPointer
        __init__(itkTransformBaseTemplateD_ConstPointer self, itkTransformBaseTemplateD p) -> itkTransformBaseTemplateD_ConstPointer
        """
        _itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_swiginit(self, _itkTransformBasePython.new_itkTransformBaseTemplateD_ConstPointer(*args))
    __swig_destroy__ = _itkTransformBasePython.delete_itkTransformBaseTemplateD_ConstPointer

    def __deref__(self) -> "itkTransformBaseTemplateD const *":
        """__deref__(itkTransformBaseTemplateD_ConstPointer self) -> itkTransformBaseTemplateD"""
        return _itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer___deref__(self)


    def __ref__(self) -> "itkTransformBaseTemplateD const &":
        """__ref__(itkTransformBaseTemplateD_ConstPointer self) -> itkTransformBaseTemplateD"""
        return _itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer___ref__(self)


    def IsNotNull(self) -> "bool":
        """IsNotNull(itkTransformBaseTemplateD_ConstPointer self) -> bool"""
        return _itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_IsNotNull(self)


    def IsNull(self) -> "bool":
        """IsNull(itkTransformBaseTemplateD_ConstPointer self) -> bool"""
        return _itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_IsNull(self)


    def GetPointer(self) -> "itkTransformBaseTemplateD const *":
        """GetPointer(itkTransformBaseTemplateD_ConstPointer self) -> itkTransformBaseTemplateD"""
        return _itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_GetPointer(self)


    def Print(self, os: 'ostream') -> "itkTransformBaseTemplateD const *":
        """Print(itkTransformBaseTemplateD_ConstPointer self, ostream os) -> itkTransformBaseTemplateD"""
        return _itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_Print(self, os)


    def Swap(self, other: 'itkTransformBaseTemplateD_ConstPointer') -> "void":
        """Swap(itkTransformBaseTemplateD_ConstPointer self, itkTransformBaseTemplateD_ConstPointer other)"""
        return _itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_Swap(self, other)


    def GetNumberOfParameters(self) -> "unsigned long":
        """GetNumberOfParameters(itkTransformBaseTemplateD_ConstPointer self) -> unsigned long"""
        return _itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_GetNumberOfParameters(self)


    def GetParameters(self) -> "itkOptimizerParametersD const &":
        """GetParameters(itkTransformBaseTemplateD_ConstPointer self) -> itkOptimizerParametersD"""
        return _itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_GetParameters(self)


    def GetInputSpaceDimension(self) -> "unsigned int":
        """GetInputSpaceDimension(itkTransformBaseTemplateD_ConstPointer self) -> unsigned int"""
        return _itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_GetInputSpaceDimension(self)


    def GetOutputSpaceDimension(self) -> "unsigned int":
        """GetOutputSpaceDimension(itkTransformBaseTemplateD_ConstPointer self) -> unsigned int"""
        return _itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_GetOutputSpaceDimension(self)


    def GetFixedParameters(self) -> "itkOptimizerParametersD const &":
        """GetFixedParameters(itkTransformBaseTemplateD_ConstPointer self) -> itkOptimizerParametersD"""
        return _itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_GetFixedParameters(self)


    def GetTransformTypeAsString(self) -> "std::string":
        """GetTransformTypeAsString(itkTransformBaseTemplateD_ConstPointer self) -> std::string"""
        return _itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_GetTransformTypeAsString(self)


    def GetTransformCategory(self) -> "itkTransformBaseTemplateEnums::TransformCategory":
        """GetTransformCategory(itkTransformBaseTemplateD_ConstPointer self) -> itkTransformBaseTemplateEnums::TransformCategory"""
        return _itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_GetTransformCategory(self)


    def DebugOn(self) -> "void":
        """
        DebugOn(itkTransformBaseTemplateD_ConstPointer self)

        Turn debugging output on.

        """
        return _itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_DebugOn(self)


    def DebugOff(self) -> "void":
        """
        DebugOff(itkTransformBaseTemplateD_ConstPointer self)

        Turn debugging output off.

        """
        return _itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_DebugOff(self)


    def GetDebug(self) -> "bool":
        """
        GetDebug(itkTransformBaseTemplateD_ConstPointer self) -> bool

        Get the value of the debug
        flag. 
        """
        return _itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_GetDebug(self)


    def SetDebug(self, debugFlag: 'bool') -> "void":
        """
        SetDebug(itkTransformBaseTemplateD_ConstPointer self, bool debugFlag)

        Set the value of the debug
        flag. A non-zero value turns debugging on. 
        """
        return _itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_SetDebug(self, debugFlag)


    def GetMTime(self) -> "unsigned long":
        """
        GetMTime(itkTransformBaseTemplateD_ConstPointer self) -> unsigned long

        Return this object's
        modified time. 
        """
        return _itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_GetMTime(self)


    def GetTimeStamp(self) -> "itkTimeStamp const &":
        """
        GetTimeStamp(itkTransformBaseTemplateD_ConstPointer self) -> itkTimeStamp

        Return this object's
        time stamp. 
        """
        return _itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_GetTimeStamp(self)


    def Modified(self) -> "void":
        """
        Modified(itkTransformBaseTemplateD_ConstPointer self)

        Update the modification
        time for this object. Many filters rely on the modification time to
        determine if they need to recompute their data. 
        """
        return _itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_Modified(self)


    def AddObserver(self, *args) -> "unsigned long":
        """
        AddObserver(itkTransformBaseTemplateD_ConstPointer self, itkEventObject event, itkCommand arg1) -> unsigned long
        AddObserver(itkTransformBaseTemplateD_ConstPointer self, itkEventObject event, itkCommand arg1) -> unsigned long

        Allow people to
        add/remove/invoke observers (callbacks) to any ITK object. This is an
        implementation of the subject/observer design pattern. An observer is
        added by specifying an event to respond to and an itk::Command to
        execute. It returns an unsigned long tag which can be used later to
        remove the event or retrieve the command. The memory for the Command
        becomes the responsibility of this object, so don't pass the same
        instance of a command to two different objects 
        """

        import itk
        if len(args) == 3 and not issubclass(args[2].__class__, itk.Command) and callable(args[2]):
            args = list(args)
            pycommand = itk.PyCommand.New()
            pycommand.SetCommandCallable( args[2] )
            args[2] = pycommand
            args = tuple(args)
        elif len(args) == 2 and not issubclass(args[1].__class__, itk.Command) and callable(args[1]):
            args = list(args)
            pycommand = itk.PyCommand.New()
            pycommand.SetCommandCallable( args[1] )
            args[1] = pycommand
            args = tuple(args)


        return _itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_AddObserver(self, *args)


    def InvokeEvent(self, *args) -> "void":
        """
        InvokeEvent(itkTransformBaseTemplateD_ConstPointer self, itkEventObject arg0)
        InvokeEvent(itkTransformBaseTemplateD_ConstPointer self, itkEventObject arg0)

        Call Execute on all the
        Commands observing this event id. The actions triggered by this call
        doesn't modify this object. 
        """
        return _itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_InvokeEvent(self, *args)


    def HasObserver(self, event: 'itkEventObject') -> "bool":
        """
        HasObserver(itkTransformBaseTemplateD_ConstPointer self, itkEventObject event) -> bool

        Return true if an
        observer is registered for this event. 
        """
        return _itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_HasObserver(self, event)


    def GetMetaDataDictionary(self, *args) -> "itkMetaDataDictionary const &":
        """
        GetMetaDataDictionary(itkTransformBaseTemplateD_ConstPointer self) -> itkMetaDataDictionary
        GetMetaDataDictionary(itkTransformBaseTemplateD_ConstPointer self) -> itkMetaDataDictionary



        A constant reference to this objects MetaDataDictionary. 
        """
        return _itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_GetMetaDataDictionary(self, *args)


    def GetObjectName(self) -> "std::string const &":
        """GetObjectName(itkTransformBaseTemplateD_ConstPointer self) -> std::string const &"""
        return _itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_GetObjectName(self)


    def CreateAnother(self) -> "itkLightObject_Pointer":
        """
        CreateAnother(itkTransformBaseTemplateD_ConstPointer self) -> itkLightObject_Pointer

        Create an object from
        an instance, potentially deferring to a factory. This method allows
        you to create an instance of an object that is exactly the same type
        as the referring object. This is useful in cases where an object has
        been cast back to a base class. 
        """
        return _itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_CreateAnother(self)


    def Clone(self) -> "itkLightObject_Pointer":
        """Clone(itkTransformBaseTemplateD_ConstPointer self) -> itkLightObject_Pointer"""
        return _itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_Clone(self)


    def GetNameOfClass(self) -> "char const *":
        """
        GetNameOfClass(itkTransformBaseTemplateD_ConstPointer self) -> char const *

        Return the name of
        this class as a string. Used by the object factory (implemented in
        New()) to instantiate objects of a named type. Also used for debugging
        and other output information. 
        """
        return _itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_GetNameOfClass(self)


    def GetReferenceCount(self) -> "int":
        """
        GetReferenceCount(itkTransformBaseTemplateD_ConstPointer self) -> int

        Gets the
        reference count on this object. 
        """
        return _itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_GetReferenceCount(self)

itkTransformBaseTemplateD_ConstPointer.__deref__ = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer___deref__, None, itkTransformBaseTemplateD_ConstPointer)
itkTransformBaseTemplateD_ConstPointer.__ref__ = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer___ref__, None, itkTransformBaseTemplateD_ConstPointer)
itkTransformBaseTemplateD_ConstPointer.IsNotNull = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_IsNotNull, None, itkTransformBaseTemplateD_ConstPointer)
itkTransformBaseTemplateD_ConstPointer.IsNull = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_IsNull, None, itkTransformBaseTemplateD_ConstPointer)
itkTransformBaseTemplateD_ConstPointer.GetPointer = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_GetPointer, None, itkTransformBaseTemplateD_ConstPointer)
itkTransformBaseTemplateD_ConstPointer.Print = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_Print, None, itkTransformBaseTemplateD_ConstPointer)
itkTransformBaseTemplateD_ConstPointer.Swap = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_Swap, None, itkTransformBaseTemplateD_ConstPointer)
itkTransformBaseTemplateD_ConstPointer.GetNumberOfParameters = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_GetNumberOfParameters, None, itkTransformBaseTemplateD_ConstPointer)
itkTransformBaseTemplateD_ConstPointer.GetParameters = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_GetParameters, None, itkTransformBaseTemplateD_ConstPointer)
itkTransformBaseTemplateD_ConstPointer.GetInputSpaceDimension = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_GetInputSpaceDimension, None, itkTransformBaseTemplateD_ConstPointer)
itkTransformBaseTemplateD_ConstPointer.GetOutputSpaceDimension = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_GetOutputSpaceDimension, None, itkTransformBaseTemplateD_ConstPointer)
itkTransformBaseTemplateD_ConstPointer.GetFixedParameters = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_GetFixedParameters, None, itkTransformBaseTemplateD_ConstPointer)
itkTransformBaseTemplateD_ConstPointer.GetTransformTypeAsString = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_GetTransformTypeAsString, None, itkTransformBaseTemplateD_ConstPointer)
itkTransformBaseTemplateD_ConstPointer.GetTransformCategory = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_GetTransformCategory, None, itkTransformBaseTemplateD_ConstPointer)
itkTransformBaseTemplateD_ConstPointer.DebugOn = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_DebugOn, None, itkTransformBaseTemplateD_ConstPointer)
itkTransformBaseTemplateD_ConstPointer.DebugOff = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_DebugOff, None, itkTransformBaseTemplateD_ConstPointer)
itkTransformBaseTemplateD_ConstPointer.GetDebug = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_GetDebug, None, itkTransformBaseTemplateD_ConstPointer)
itkTransformBaseTemplateD_ConstPointer.SetDebug = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_SetDebug, None, itkTransformBaseTemplateD_ConstPointer)
itkTransformBaseTemplateD_ConstPointer.GetMTime = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_GetMTime, None, itkTransformBaseTemplateD_ConstPointer)
itkTransformBaseTemplateD_ConstPointer.GetTimeStamp = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_GetTimeStamp, None, itkTransformBaseTemplateD_ConstPointer)
itkTransformBaseTemplateD_ConstPointer.Modified = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_Modified, None, itkTransformBaseTemplateD_ConstPointer)
itkTransformBaseTemplateD_ConstPointer.InvokeEvent = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_InvokeEvent, None, itkTransformBaseTemplateD_ConstPointer)
itkTransformBaseTemplateD_ConstPointer.HasObserver = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_HasObserver, None, itkTransformBaseTemplateD_ConstPointer)
itkTransformBaseTemplateD_ConstPointer.GetMetaDataDictionary = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_GetMetaDataDictionary, None, itkTransformBaseTemplateD_ConstPointer)
itkTransformBaseTemplateD_ConstPointer.GetObjectName = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_GetObjectName, None, itkTransformBaseTemplateD_ConstPointer)
itkTransformBaseTemplateD_ConstPointer.CreateAnother = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_CreateAnother, None, itkTransformBaseTemplateD_ConstPointer)
itkTransformBaseTemplateD_ConstPointer.Clone = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_Clone, None, itkTransformBaseTemplateD_ConstPointer)
itkTransformBaseTemplateD_ConstPointer.GetNameOfClass = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_GetNameOfClass, None, itkTransformBaseTemplateD_ConstPointer)
itkTransformBaseTemplateD_ConstPointer.GetReferenceCount = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_GetReferenceCount, None, itkTransformBaseTemplateD_ConstPointer)
itkTransformBaseTemplateD_ConstPointer_swigregister = _itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_swigregister
itkTransformBaseTemplateD_ConstPointer_swigregister(itkTransformBaseTemplateD_ConstPointer)

class itkTransformBaseTemplateEnums(object):
    """Proxy of C++ itkTransformBaseTemplateEnums class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    TransformCategory_UnknownTransformCategory = _itkTransformBasePython.itkTransformBaseTemplateEnums_TransformCategory_UnknownTransformCategory
    TransformCategory_Linear = _itkTransformBasePython.itkTransformBaseTemplateEnums_TransformCategory_Linear
    TransformCategory_BSpline = _itkTransformBasePython.itkTransformBaseTemplateEnums_TransformCategory_BSpline
    TransformCategory_Spline = _itkTransformBasePython.itkTransformBaseTemplateEnums_TransformCategory_Spline
    TransformCategory_DisplacementField = _itkTransformBasePython.itkTransformBaseTemplateEnums_TransformCategory_DisplacementField
    TransformCategory_VelocityField = _itkTransformBasePython.itkTransformBaseTemplateEnums_TransformCategory_VelocityField

    def __init__(self, *args):
        """
        __init__(itkTransformBaseTemplateEnums self) -> itkTransformBaseTemplateEnums
        __init__(itkTransformBaseTemplateEnums self, itkTransformBaseTemplateEnums arg0) -> itkTransformBaseTemplateEnums
        """
        _itkTransformBasePython.itkTransformBaseTemplateEnums_swiginit(self, _itkTransformBasePython.new_itkTransformBaseTemplateEnums(*args))
    __swig_destroy__ = _itkTransformBasePython.delete_itkTransformBaseTemplateEnums
itkTransformBaseTemplateEnums_swigregister = _itkTransformBasePython.itkTransformBaseTemplateEnums_swigregister
itkTransformBaseTemplateEnums_swigregister(itkTransformBaseTemplateEnums)

class itkTransformBaseTemplateF(ITKCommonBasePython.itkObject):
    """Proxy of C++ itkTransformBaseTemplateF class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def GetNumberOfParameters(self) -> "unsigned long":
        """GetNumberOfParameters(itkTransformBaseTemplateF self) -> unsigned long"""
        return _itkTransformBasePython.itkTransformBaseTemplateF_GetNumberOfParameters(self)


    def GetParameters(self) -> "itkOptimizerParametersF const &":
        """GetParameters(itkTransformBaseTemplateF self) -> itkOptimizerParametersF"""
        return _itkTransformBasePython.itkTransformBaseTemplateF_GetParameters(self)


    def GetInputSpaceDimension(self) -> "unsigned int":
        """GetInputSpaceDimension(itkTransformBaseTemplateF self) -> unsigned int"""
        return _itkTransformBasePython.itkTransformBaseTemplateF_GetInputSpaceDimension(self)


    def GetOutputSpaceDimension(self) -> "unsigned int":
        """GetOutputSpaceDimension(itkTransformBaseTemplateF self) -> unsigned int"""
        return _itkTransformBasePython.itkTransformBaseTemplateF_GetOutputSpaceDimension(self)


    def SetParameters(self, arg0: 'itkOptimizerParametersF') -> "void":
        """SetParameters(itkTransformBaseTemplateF self, itkOptimizerParametersF arg0)"""
        return _itkTransformBasePython.itkTransformBaseTemplateF_SetParameters(self, arg0)


    def SetParametersByValue(self, p: 'itkOptimizerParametersF') -> "void":
        """SetParametersByValue(itkTransformBaseTemplateF self, itkOptimizerParametersF p)"""
        return _itkTransformBasePython.itkTransformBaseTemplateF_SetParametersByValue(self, p)


    def SetFixedParameters(self, arg0: 'itkOptimizerParametersD') -> "void":
        """SetFixedParameters(itkTransformBaseTemplateF self, itkOptimizerParametersD arg0)"""
        return _itkTransformBasePython.itkTransformBaseTemplateF_SetFixedParameters(self, arg0)


    def CopyInParameters(self, begin: 'float const *const', end: 'float const *const') -> "void":
        """CopyInParameters(itkTransformBaseTemplateF self, float const *const begin, float const *const end)"""
        return _itkTransformBasePython.itkTransformBaseTemplateF_CopyInParameters(self, begin, end)


    def CopyInFixedParameters(self, begin: 'double const *const', end: 'double const *const') -> "void":
        """CopyInFixedParameters(itkTransformBaseTemplateF self, double const *const begin, double const *const end)"""
        return _itkTransformBasePython.itkTransformBaseTemplateF_CopyInFixedParameters(self, begin, end)


    def GetFixedParameters(self) -> "itkOptimizerParametersD const &":
        """GetFixedParameters(itkTransformBaseTemplateF self) -> itkOptimizerParametersD"""
        return _itkTransformBasePython.itkTransformBaseTemplateF_GetFixedParameters(self)


    def GetTransformTypeAsString(self) -> "std::string":
        """GetTransformTypeAsString(itkTransformBaseTemplateF self) -> std::string"""
        return _itkTransformBasePython.itkTransformBaseTemplateF_GetTransformTypeAsString(self)


    def GetTransformCategory(self) -> "itkTransformBaseTemplateEnums::TransformCategory":
        """GetTransformCategory(itkTransformBaseTemplateF self) -> itkTransformBaseTemplateEnums::TransformCategory"""
        return _itkTransformBasePython.itkTransformBaseTemplateF_GetTransformCategory(self)

    __swig_destroy__ = _itkTransformBasePython.delete_itkTransformBaseTemplateF

    def cast(obj: 'itkLightObject') -> "itkTransformBaseTemplateF *":
        """cast(itkLightObject obj) -> itkTransformBaseTemplateF"""
        return _itkTransformBasePython.itkTransformBaseTemplateF_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkTransformBaseTemplateF

        Create a new object of the class itkTransformBaseTemplateF and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkTransformBaseTemplateF.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkTransformBaseTemplateF.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkTransformBaseTemplateF.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkTransformBaseTemplateF.GetNumberOfParameters = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateF_GetNumberOfParameters, None, itkTransformBaseTemplateF)
itkTransformBaseTemplateF.GetParameters = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateF_GetParameters, None, itkTransformBaseTemplateF)
itkTransformBaseTemplateF.GetInputSpaceDimension = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateF_GetInputSpaceDimension, None, itkTransformBaseTemplateF)
itkTransformBaseTemplateF.GetOutputSpaceDimension = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateF_GetOutputSpaceDimension, None, itkTransformBaseTemplateF)
itkTransformBaseTemplateF.SetParameters = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateF_SetParameters, None, itkTransformBaseTemplateF)
itkTransformBaseTemplateF.SetParametersByValue = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateF_SetParametersByValue, None, itkTransformBaseTemplateF)
itkTransformBaseTemplateF.SetFixedParameters = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateF_SetFixedParameters, None, itkTransformBaseTemplateF)
itkTransformBaseTemplateF.CopyInParameters = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateF_CopyInParameters, None, itkTransformBaseTemplateF)
itkTransformBaseTemplateF.CopyInFixedParameters = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateF_CopyInFixedParameters, None, itkTransformBaseTemplateF)
itkTransformBaseTemplateF.GetFixedParameters = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateF_GetFixedParameters, None, itkTransformBaseTemplateF)
itkTransformBaseTemplateF.GetTransformTypeAsString = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateF_GetTransformTypeAsString, None, itkTransformBaseTemplateF)
itkTransformBaseTemplateF.GetTransformCategory = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateF_GetTransformCategory, None, itkTransformBaseTemplateF)
itkTransformBaseTemplateF_swigregister = _itkTransformBasePython.itkTransformBaseTemplateF_swigregister
itkTransformBaseTemplateF_swigregister(itkTransformBaseTemplateF)

def itkTransformBaseTemplateF_cast(obj: 'itkLightObject') -> "itkTransformBaseTemplateF *":
    """itkTransformBaseTemplateF_cast(itkLightObject obj) -> itkTransformBaseTemplateF"""
    return _itkTransformBasePython.itkTransformBaseTemplateF_cast(obj)

class itkTransformBaseTemplateF_ConstPointer(object):
    """Proxy of C++ itkTransformBaseTemplateF_ConstPointer class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkTransformBaseTemplateF_ConstPointer self) -> itkTransformBaseTemplateF_ConstPointer
        __init__(itkTransformBaseTemplateF_ConstPointer self, itkTransformBaseTemplateF_ConstPointer p) -> itkTransformBaseTemplateF_ConstPointer
        __init__(itkTransformBaseTemplateF_ConstPointer self, itkTransformBaseTemplateF p) -> itkTransformBaseTemplateF_ConstPointer
        """
        _itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_swiginit(self, _itkTransformBasePython.new_itkTransformBaseTemplateF_ConstPointer(*args))
    __swig_destroy__ = _itkTransformBasePython.delete_itkTransformBaseTemplateF_ConstPointer

    def __deref__(self) -> "itkTransformBaseTemplateF const *":
        """__deref__(itkTransformBaseTemplateF_ConstPointer self) -> itkTransformBaseTemplateF"""
        return _itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer___deref__(self)


    def __ref__(self) -> "itkTransformBaseTemplateF const &":
        """__ref__(itkTransformBaseTemplateF_ConstPointer self) -> itkTransformBaseTemplateF"""
        return _itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer___ref__(self)


    def IsNotNull(self) -> "bool":
        """IsNotNull(itkTransformBaseTemplateF_ConstPointer self) -> bool"""
        return _itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_IsNotNull(self)


    def IsNull(self) -> "bool":
        """IsNull(itkTransformBaseTemplateF_ConstPointer self) -> bool"""
        return _itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_IsNull(self)


    def GetPointer(self) -> "itkTransformBaseTemplateF const *":
        """GetPointer(itkTransformBaseTemplateF_ConstPointer self) -> itkTransformBaseTemplateF"""
        return _itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_GetPointer(self)


    def Print(self, os: 'ostream') -> "itkTransformBaseTemplateF const *":
        """Print(itkTransformBaseTemplateF_ConstPointer self, ostream os) -> itkTransformBaseTemplateF"""
        return _itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_Print(self, os)


    def Swap(self, other: 'itkTransformBaseTemplateF_ConstPointer') -> "void":
        """Swap(itkTransformBaseTemplateF_ConstPointer self, itkTransformBaseTemplateF_ConstPointer other)"""
        return _itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_Swap(self, other)


    def GetNumberOfParameters(self) -> "unsigned long":
        """GetNumberOfParameters(itkTransformBaseTemplateF_ConstPointer self) -> unsigned long"""
        return _itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_GetNumberOfParameters(self)


    def GetParameters(self) -> "itkOptimizerParametersF const &":
        """GetParameters(itkTransformBaseTemplateF_ConstPointer self) -> itkOptimizerParametersF"""
        return _itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_GetParameters(self)


    def GetInputSpaceDimension(self) -> "unsigned int":
        """GetInputSpaceDimension(itkTransformBaseTemplateF_ConstPointer self) -> unsigned int"""
        return _itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_GetInputSpaceDimension(self)


    def GetOutputSpaceDimension(self) -> "unsigned int":
        """GetOutputSpaceDimension(itkTransformBaseTemplateF_ConstPointer self) -> unsigned int"""
        return _itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_GetOutputSpaceDimension(self)


    def GetFixedParameters(self) -> "itkOptimizerParametersD const &":
        """GetFixedParameters(itkTransformBaseTemplateF_ConstPointer self) -> itkOptimizerParametersD"""
        return _itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_GetFixedParameters(self)


    def GetTransformTypeAsString(self) -> "std::string":
        """GetTransformTypeAsString(itkTransformBaseTemplateF_ConstPointer self) -> std::string"""
        return _itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_GetTransformTypeAsString(self)


    def GetTransformCategory(self) -> "itkTransformBaseTemplateEnums::TransformCategory":
        """GetTransformCategory(itkTransformBaseTemplateF_ConstPointer self) -> itkTransformBaseTemplateEnums::TransformCategory"""
        return _itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_GetTransformCategory(self)


    def DebugOn(self) -> "void":
        """
        DebugOn(itkTransformBaseTemplateF_ConstPointer self)

        Turn debugging output on.

        """
        return _itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_DebugOn(self)


    def DebugOff(self) -> "void":
        """
        DebugOff(itkTransformBaseTemplateF_ConstPointer self)

        Turn debugging output off.

        """
        return _itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_DebugOff(self)


    def GetDebug(self) -> "bool":
        """
        GetDebug(itkTransformBaseTemplateF_ConstPointer self) -> bool

        Get the value of the debug
        flag. 
        """
        return _itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_GetDebug(self)


    def SetDebug(self, debugFlag: 'bool') -> "void":
        """
        SetDebug(itkTransformBaseTemplateF_ConstPointer self, bool debugFlag)

        Set the value of the debug
        flag. A non-zero value turns debugging on. 
        """
        return _itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_SetDebug(self, debugFlag)


    def GetMTime(self) -> "unsigned long":
        """
        GetMTime(itkTransformBaseTemplateF_ConstPointer self) -> unsigned long

        Return this object's
        modified time. 
        """
        return _itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_GetMTime(self)


    def GetTimeStamp(self) -> "itkTimeStamp const &":
        """
        GetTimeStamp(itkTransformBaseTemplateF_ConstPointer self) -> itkTimeStamp

        Return this object's
        time stamp. 
        """
        return _itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_GetTimeStamp(self)


    def Modified(self) -> "void":
        """
        Modified(itkTransformBaseTemplateF_ConstPointer self)

        Update the modification
        time for this object. Many filters rely on the modification time to
        determine if they need to recompute their data. 
        """
        return _itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_Modified(self)


    def AddObserver(self, *args) -> "unsigned long":
        """
        AddObserver(itkTransformBaseTemplateF_ConstPointer self, itkEventObject event, itkCommand arg1) -> unsigned long
        AddObserver(itkTransformBaseTemplateF_ConstPointer self, itkEventObject event, itkCommand arg1) -> unsigned long

        Allow people to
        add/remove/invoke observers (callbacks) to any ITK object. This is an
        implementation of the subject/observer design pattern. An observer is
        added by specifying an event to respond to and an itk::Command to
        execute. It returns an unsigned long tag which can be used later to
        remove the event or retrieve the command. The memory for the Command
        becomes the responsibility of this object, so don't pass the same
        instance of a command to two different objects 
        """

        import itk
        if len(args) == 3 and not issubclass(args[2].__class__, itk.Command) and callable(args[2]):
            args = list(args)
            pycommand = itk.PyCommand.New()
            pycommand.SetCommandCallable( args[2] )
            args[2] = pycommand
            args = tuple(args)
        elif len(args) == 2 and not issubclass(args[1].__class__, itk.Command) and callable(args[1]):
            args = list(args)
            pycommand = itk.PyCommand.New()
            pycommand.SetCommandCallable( args[1] )
            args[1] = pycommand
            args = tuple(args)


        return _itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_AddObserver(self, *args)


    def InvokeEvent(self, *args) -> "void":
        """
        InvokeEvent(itkTransformBaseTemplateF_ConstPointer self, itkEventObject arg0)
        InvokeEvent(itkTransformBaseTemplateF_ConstPointer self, itkEventObject arg0)

        Call Execute on all the
        Commands observing this event id. The actions triggered by this call
        doesn't modify this object. 
        """
        return _itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_InvokeEvent(self, *args)


    def HasObserver(self, event: 'itkEventObject') -> "bool":
        """
        HasObserver(itkTransformBaseTemplateF_ConstPointer self, itkEventObject event) -> bool

        Return true if an
        observer is registered for this event. 
        """
        return _itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_HasObserver(self, event)


    def GetMetaDataDictionary(self, *args) -> "itkMetaDataDictionary const &":
        """
        GetMetaDataDictionary(itkTransformBaseTemplateF_ConstPointer self) -> itkMetaDataDictionary
        GetMetaDataDictionary(itkTransformBaseTemplateF_ConstPointer self) -> itkMetaDataDictionary



        A constant reference to this objects MetaDataDictionary. 
        """
        return _itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_GetMetaDataDictionary(self, *args)


    def GetObjectName(self) -> "std::string const &":
        """GetObjectName(itkTransformBaseTemplateF_ConstPointer self) -> std::string const &"""
        return _itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_GetObjectName(self)


    def CreateAnother(self) -> "itkLightObject_Pointer":
        """
        CreateAnother(itkTransformBaseTemplateF_ConstPointer self) -> itkLightObject_Pointer

        Create an object from
        an instance, potentially deferring to a factory. This method allows
        you to create an instance of an object that is exactly the same type
        as the referring object. This is useful in cases where an object has
        been cast back to a base class. 
        """
        return _itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_CreateAnother(self)


    def Clone(self) -> "itkLightObject_Pointer":
        """Clone(itkTransformBaseTemplateF_ConstPointer self) -> itkLightObject_Pointer"""
        return _itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_Clone(self)


    def GetNameOfClass(self) -> "char const *":
        """
        GetNameOfClass(itkTransformBaseTemplateF_ConstPointer self) -> char const *

        Return the name of
        this class as a string. Used by the object factory (implemented in
        New()) to instantiate objects of a named type. Also used for debugging
        and other output information. 
        """
        return _itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_GetNameOfClass(self)


    def GetReferenceCount(self) -> "int":
        """
        GetReferenceCount(itkTransformBaseTemplateF_ConstPointer self) -> int

        Gets the
        reference count on this object. 
        """
        return _itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_GetReferenceCount(self)

itkTransformBaseTemplateF_ConstPointer.__deref__ = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer___deref__, None, itkTransformBaseTemplateF_ConstPointer)
itkTransformBaseTemplateF_ConstPointer.__ref__ = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer___ref__, None, itkTransformBaseTemplateF_ConstPointer)
itkTransformBaseTemplateF_ConstPointer.IsNotNull = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_IsNotNull, None, itkTransformBaseTemplateF_ConstPointer)
itkTransformBaseTemplateF_ConstPointer.IsNull = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_IsNull, None, itkTransformBaseTemplateF_ConstPointer)
itkTransformBaseTemplateF_ConstPointer.GetPointer = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_GetPointer, None, itkTransformBaseTemplateF_ConstPointer)
itkTransformBaseTemplateF_ConstPointer.Print = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_Print, None, itkTransformBaseTemplateF_ConstPointer)
itkTransformBaseTemplateF_ConstPointer.Swap = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_Swap, None, itkTransformBaseTemplateF_ConstPointer)
itkTransformBaseTemplateF_ConstPointer.GetNumberOfParameters = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_GetNumberOfParameters, None, itkTransformBaseTemplateF_ConstPointer)
itkTransformBaseTemplateF_ConstPointer.GetParameters = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_GetParameters, None, itkTransformBaseTemplateF_ConstPointer)
itkTransformBaseTemplateF_ConstPointer.GetInputSpaceDimension = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_GetInputSpaceDimension, None, itkTransformBaseTemplateF_ConstPointer)
itkTransformBaseTemplateF_ConstPointer.GetOutputSpaceDimension = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_GetOutputSpaceDimension, None, itkTransformBaseTemplateF_ConstPointer)
itkTransformBaseTemplateF_ConstPointer.GetFixedParameters = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_GetFixedParameters, None, itkTransformBaseTemplateF_ConstPointer)
itkTransformBaseTemplateF_ConstPointer.GetTransformTypeAsString = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_GetTransformTypeAsString, None, itkTransformBaseTemplateF_ConstPointer)
itkTransformBaseTemplateF_ConstPointer.GetTransformCategory = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_GetTransformCategory, None, itkTransformBaseTemplateF_ConstPointer)
itkTransformBaseTemplateF_ConstPointer.DebugOn = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_DebugOn, None, itkTransformBaseTemplateF_ConstPointer)
itkTransformBaseTemplateF_ConstPointer.DebugOff = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_DebugOff, None, itkTransformBaseTemplateF_ConstPointer)
itkTransformBaseTemplateF_ConstPointer.GetDebug = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_GetDebug, None, itkTransformBaseTemplateF_ConstPointer)
itkTransformBaseTemplateF_ConstPointer.SetDebug = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_SetDebug, None, itkTransformBaseTemplateF_ConstPointer)
itkTransformBaseTemplateF_ConstPointer.GetMTime = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_GetMTime, None, itkTransformBaseTemplateF_ConstPointer)
itkTransformBaseTemplateF_ConstPointer.GetTimeStamp = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_GetTimeStamp, None, itkTransformBaseTemplateF_ConstPointer)
itkTransformBaseTemplateF_ConstPointer.Modified = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_Modified, None, itkTransformBaseTemplateF_ConstPointer)
itkTransformBaseTemplateF_ConstPointer.InvokeEvent = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_InvokeEvent, None, itkTransformBaseTemplateF_ConstPointer)
itkTransformBaseTemplateF_ConstPointer.HasObserver = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_HasObserver, None, itkTransformBaseTemplateF_ConstPointer)
itkTransformBaseTemplateF_ConstPointer.GetMetaDataDictionary = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_GetMetaDataDictionary, None, itkTransformBaseTemplateF_ConstPointer)
itkTransformBaseTemplateF_ConstPointer.GetObjectName = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_GetObjectName, None, itkTransformBaseTemplateF_ConstPointer)
itkTransformBaseTemplateF_ConstPointer.CreateAnother = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_CreateAnother, None, itkTransformBaseTemplateF_ConstPointer)
itkTransformBaseTemplateF_ConstPointer.Clone = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_Clone, None, itkTransformBaseTemplateF_ConstPointer)
itkTransformBaseTemplateF_ConstPointer.GetNameOfClass = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_GetNameOfClass, None, itkTransformBaseTemplateF_ConstPointer)
itkTransformBaseTemplateF_ConstPointer.GetReferenceCount = new_instancemethod(_itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_GetReferenceCount, None, itkTransformBaseTemplateF_ConstPointer)
itkTransformBaseTemplateF_ConstPointer_swigregister = _itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_swigregister
itkTransformBaseTemplateF_ConstPointer_swigregister(itkTransformBaseTemplateF_ConstPointer)

class itkTransformD2(itkTransformBaseTemplateD):
    """


    Transform points and vectors from an input space to an output space.

    This abstract class defines the generic interface for a geometric
    transformation from one space to another. The class provides methods
    for mapping points, vectors and covariant vectors from the input space
    to the output space.

    Given that transformations are not necessarily invertible, this basic
    class does not provide the methods for back transformation. Back
    transform methods are implemented in derived classes where
    appropriate.

    Registration Framework Support Typically a Transform class has several
    methods for setting its parameters. For use in the registration
    framework, the parameters must also be represented by an array of
    doubles to allow communication with generic optimizers. The Array of
    transformation parameters is set using the SetParameters() method.
    Another requirement of the registration framework is the computation
    of the transform Jacobian. In general, an ImageToImageMetric requires
    the knowledge of the Jacobian in order to compute the metric
    derivatives. The Jacobian is a matrix whose element are the partial
    derivatives of the output point with respect to the array of
    parameters that defines the transform.

    Subclasses must provide implementations for:  virtual OutputPointType
    TransformPoint(const InputPointType  &) const  virtual
    OutputVectorType TransformVector(const InputVectorType &) const
    virtual OutputVnlVectorType TransformVector(const InputVnlVectorType
    &) const  virtual OutputCovariantVectorType
    TransformCovariantVector(const InputCovariantVectorType &) const
    virtual void SetParameters(const ParametersType &)  virtual void
    SetFixedParameters(const FixedParametersType &)  virtual void
    ComputeJacobianWithRespectToParameters( const InputPointType &,
    JacobianType &) const  virtual void
    ComputeJacobianWithRespectToPosition( const InputPointType & x,
    JacobianPositionType &jacobian ) const;

    Since TranformVector and TransformCovariantVector have multiple
    overloaded methods from the base class, subclasses must specify:
    using Superclass::TransformVector;  using
    Superclass::TransformCovariantVector;

    C++ includes: itkTransform.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Clone(self) -> "itkTransformD23_Pointer":
        """Clone(itkTransformD2 self) -> itkTransformD23_Pointer"""
        return _itkTransformBasePython.itkTransformD2_Clone(self)


    def TransformPoint(self, arg0: 'itkPointD2') -> "itkPointD3":
        """
        TransformPoint(itkTransformD2 self, itkPointD2 arg0) -> itkPointD3

        Method to transform
        a point. WARNING:  This method must be thread-safe. See, e.g., its use
        in ResampleImageFilter. 
        """
        return _itkTransformBasePython.itkTransformD2_TransformPoint(self, arg0)


    def TransformVector(self, *args) -> "itkVariableLengthVectorD":
        """
        TransformVector(itkTransformD2 self, itkVectorD2 arg0) -> itkVectorD3
        TransformVector(itkTransformD2 self, itkVectorD2 vector, itkPointD2 point) -> itkVectorD3
        TransformVector(itkTransformD2 self, vnl_vector_fixed< double,2 > const & arg0) -> vnl_vector_fixed< double,3 >
        TransformVector(itkTransformD2 self, vnl_vector_fixed< double,2 > const & vector, itkPointD2 point) -> vnl_vector_fixed< double,3 >
        TransformVector(itkTransformD2 self, itkVariableLengthVectorD arg0) -> itkVariableLengthVectorD
        TransformVector(itkTransformD2 self, itkVariableLengthVectorD vector, itkPointD2 point) -> itkVariableLengthVectorD

        Method to transform
        a vector stored in a VectorImage, at a point. For global transforms,
        point is ignored and TransformVector( vector ) is called. Local
        transforms (e.g. deformation field transform) must override and
        provide required behavior. 
        """
        return _itkTransformBasePython.itkTransformD2_TransformVector(self, *args)


    def TransformCovariantVector(self, *args) -> "itkVariableLengthVectorD":
        """
        TransformCovariantVector(itkTransformD2 self, itkCovariantVectorD2 arg0) -> itkCovariantVectorD3
        TransformCovariantVector(itkTransformD2 self, itkCovariantVectorD2 vector, itkPointD2 point) -> itkCovariantVectorD3
        TransformCovariantVector(itkTransformD2 self, itkVariableLengthVectorD arg0) -> itkVariableLengthVectorD
        TransformCovariantVector(itkTransformD2 self, itkVariableLengthVectorD vector, itkPointD2 point) -> itkVariableLengthVectorD

        Method to
        transform a CovariantVector, using a point. Global transforms can
        ignore the point parameter. Local transforms (e.g. deformation field
        transform) must override and provide required behavior. By default,
        point is ignored and TransformCovariantVector(vector) is called 
        """
        return _itkTransformBasePython.itkTransformD2_TransformCovariantVector(self, *args)


    def TransformDiffusionTensor3D(self, *args) -> "itkVariableLengthVectorD":
        """
        TransformDiffusionTensor3D(itkTransformD2 self, itkDiffusionTensor3DD arg0) -> itkDiffusionTensor3DD
        TransformDiffusionTensor3D(itkTransformD2 self, itkDiffusionTensor3DD tensor, itkPointD2 point) -> itkDiffusionTensor3DD
        TransformDiffusionTensor3D(itkTransformD2 self, itkVariableLengthVectorD arg0) -> itkVariableLengthVectorD
        TransformDiffusionTensor3D(itkTransformD2 self, itkVariableLengthVectorD tensor, itkPointD2 point) -> itkVariableLengthVectorD

        Method
        to transform a diffusion tensor stored in a VectorImage 
        """
        return _itkTransformBasePython.itkTransformD2_TransformDiffusionTensor3D(self, *args)


    def TransformSymmetricSecondRankTensor(self, *args) -> "itkVariableLengthVectorD":
        """
        TransformSymmetricSecondRankTensor(itkTransformD2 self, itkSymmetricSecondRankTensorD2 tensor, itkPointD2 point) -> itkSymmetricSecondRankTensorD3
        TransformSymmetricSecondRankTensor(itkTransformD2 self, itkSymmetricSecondRankTensorD2 arg0) -> itkSymmetricSecondRankTensorD3
        TransformSymmetricSecondRankTensor(itkTransformD2 self, itkVariableLengthVectorD arg0) -> itkVariableLengthVectorD
        TransformSymmetricSecondRankTensor(itkTransformD2 self, itkVariableLengthVectorD tensor, itkPointD2 point) -> itkVariableLengthVectorD

        Method to transform a diffusion tensor stored in a VectorImage, at a
        point. Global transforms can ignore the point parameter. Local
        transforms (e.g. deformation field transform) must override and
        provide required behavior. By default, point is ignored and
        TransformDiffusionTensor(tensor) is called 
        """
        return _itkTransformBasePython.itkTransformD2_TransformSymmetricSecondRankTensor(self, *args)


    def UpdateTransformParameters(self, update: 'itkArrayD', factor: 'double'=1.) -> "void":
        """
        UpdateTransformParameters(itkTransformD2 self, itkArrayD update, double factor=1.)
        UpdateTransformParameters(itkTransformD2 self, itkArrayD update)

        Update
        the transform's parameters by the values in update.

        Parameters:
        -----------

        update:  must be of the same length as returned by
        GetNumberOfParameters(). Throw an exception otherwise.

        factor:  is a scalar multiplier for each value in update.
        SetParameters is called at the end of this method, to allow the
        transform to perform any required operations on the updated parameters
        - typically a conversion to member variables for use in
        TransformPoint. 
        """
        return _itkTransformBasePython.itkTransformD2_UpdateTransformParameters(self, update, factor)


    def GetNumberOfLocalParameters(self) -> "unsigned long":
        """
        GetNumberOfLocalParameters(itkTransformD2 self) -> unsigned long

        Return
        the number of local parameters that completely defines the Transform
        at an individual voxel. For transforms with local support, this will
        enable downstream computation of the jacobian wrt only the local
        support region. For instance, in the case of a deformation field, this
        will be equal to the number of image dimensions. If it is an affine
        transform, this will be the same as the GetNumberOfParameters(). 
        """
        return _itkTransformBasePython.itkTransformD2_GetNumberOfLocalParameters(self)


    def GetNumberOfFixedParameters(self) -> "unsigned long":
        """
        GetNumberOfFixedParameters(itkTransformD2 self) -> unsigned long

        Return
        the number of parameters that define the constant elements of a
        Transfom 
        """
        return _itkTransformBasePython.itkTransformD2_GetNumberOfFixedParameters(self)


    def GetInverse(self, arg0: 'itkTransformD23') -> "bool":
        """
        GetInverse(itkTransformD2 self, itkTransformD23 arg0) -> bool

        Returns a boolean
        indicating whether it is possible or not to compute the inverse of
        this current Transform. If it is possible, then the inverse of the
        transform is returned in the inverseTransform variable passed by the
        user. The inverse is recomputed if this current transform has been
        modified. This method is intended to be overriden as needed by derived
        classes. 
        """
        return _itkTransformBasePython.itkTransformD2_GetInverse(self, arg0)


    def GetInverseTransform(self) -> "itkTransformD32_Pointer":
        """
        GetInverseTransform(itkTransformD2 self) -> itkTransformD32_Pointer

        Return an
        inverse of this transform. If the inverse has not been implemented,
        return nullptr. The type of the inverse transform does not necessarily
        need to match the type of the forward transform. This allows one to
        return a numeric inverse transform instead. 
        """
        return _itkTransformBasePython.itkTransformD2_GetInverseTransform(self)


    def IsLinear(self) -> "bool":
        """IsLinear(itkTransformD2 self) -> bool"""
        return _itkTransformBasePython.itkTransformD2_IsLinear(self)


    def ComputeJacobianWithRespectToParameters(self, arg0: 'itkPointD2', arg1: 'itkArray2DD') -> "void":
        """
        ComputeJacobianWithRespectToParameters(itkTransformD2 self, itkPointD2 arg0, itkArray2DD arg1)

        Compute the
        Jacobian of the transformation

        This method computes the Jacobian matrix of the transformation at a
        given input point. The rank of the Jacobian will also indicate if the
        transform is invertible at this point.

        The Jacobian is be expressed as a matrix of partial derivatives of the
        output point components with respect to the parameters that defined
        the transform:

        \\[ J=\\left[ \\begin{array}{cccc} \\frac{\\partial
        x_{1}}{\\partial p_{1}} & \\frac{\\partial x_{1}}{\\partial
        p_{2}} & \\cdots & \\frac{\\partial x_{1}}{\\partial
        p_{m}}\\\\ \\frac{\\partial x_{2}}{\\partial p_{1}} &
        \\frac{\\partial x_{2}}{\\partial p_{2}} & \\cdots &
        \\frac{\\partial x_{2}}{\\partial p_{m}}\\\\ \\vdots &
        \\vdots & \\ddots & \\vdots \\\\ \\frac{\\partial
        x_{n}}{\\partial p_{1}} & \\frac{\\partial x_{n}}{\\partial
        p_{2}} & \\cdots & \\frac{\\partial x_{n}}{\\partial p_{m}}
        \\end{array}\\right] \\]

        This is also used for efficient computation of a point-local jacobian
        for dense transforms. jacobian is assumed to be thread-local variable,
        otherwise memory corruption will most likely occur during multi-
        threading. To avoid repetitive memory allocation, pass in 'jacobian'
        with its size already set. 
        """
        return _itkTransformBasePython.itkTransformD2_ComputeJacobianWithRespectToParameters(self, arg0, arg1)


    def ComputeJacobianWithRespectToParametersCachedTemporaries(self, p: 'itkPointD2', jacobian: 'itkArray2DD', arg2: 'itkArray2DD') -> "void":
        """ComputeJacobianWithRespectToParametersCachedTemporaries(itkTransformD2 self, itkPointD2 p, itkArray2DD jacobian, itkArray2DD arg2)"""
        return _itkTransformBasePython.itkTransformD2_ComputeJacobianWithRespectToParametersCachedTemporaries(self, p, jacobian, arg2)


    def ComputeJacobianWithRespectToPosition(self, arg0: 'itkPointD2', arg1: 'vnl_matrix_fixed< double,3,2 > &') -> "void":
        """
        ComputeJacobianWithRespectToPosition(itkTransformD2 self, itkPointD2 arg0, vnl_matrix_fixed< double,3,2 > & arg1)

        This provides the ability to get a local jacobian value in a
        dense/local transform, e.g. DisplacementFieldTransform. For such
        transforms it would be unclear what parameters would refer to.
        Generally, global transforms should return an identity jacobian since
        there is no change with respect to position. 
        """
        return _itkTransformBasePython.itkTransformD2_ComputeJacobianWithRespectToPosition(self, arg0, arg1)


    def ComputeInverseJacobianWithRespectToPosition(self, x: 'itkPointD2', jacobian: 'vnl_matrix_fixedD_2_3') -> "void":
        """
        ComputeInverseJacobianWithRespectToPosition(itkTransformD2 self, itkPointD2 x, vnl_matrix_fixedD_2_3 jacobian)

        This provides
        the ability to get a local jacobian value in a dense/local transform,
        e.g. DisplacementFieldTransform. For such transforms it would be
        unclear what parameters would refer to. Generally, global transforms
        should return an identity jacobian since there is no change with
        respect to position. 
        """
        return _itkTransformBasePython.itkTransformD2_ComputeInverseJacobianWithRespectToPosition(self, x, jacobian)

    __swig_destroy__ = _itkTransformBasePython.delete_itkTransformD2

    def cast(obj: 'itkLightObject') -> "itkTransformD2 *":
        """cast(itkLightObject obj) -> itkTransformD2"""
        return _itkTransformBasePython.itkTransformD2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkTransformD2

        Create a new object of the class itkTransformD2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkTransformD2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkTransformD2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkTransformD2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkTransformD2.Clone = new_instancemethod(_itkTransformBasePython.itkTransformD2_Clone, None, itkTransformD2)
itkTransformD2.TransformPoint = new_instancemethod(_itkTransformBasePython.itkTransformD2_TransformPoint, None, itkTransformD2)
itkTransformD2.TransformVector = new_instancemethod(_itkTransformBasePython.itkTransformD2_TransformVector, None, itkTransformD2)
itkTransformD2.TransformCovariantVector = new_instancemethod(_itkTransformBasePython.itkTransformD2_TransformCovariantVector, None, itkTransformD2)
itkTransformD2.TransformDiffusionTensor3D = new_instancemethod(_itkTransformBasePython.itkTransformD2_TransformDiffusionTensor3D, None, itkTransformD2)
itkTransformD2.TransformSymmetricSecondRankTensor = new_instancemethod(_itkTransformBasePython.itkTransformD2_TransformSymmetricSecondRankTensor, None, itkTransformD2)
itkTransformD2.UpdateTransformParameters = new_instancemethod(_itkTransformBasePython.itkTransformD2_UpdateTransformParameters, None, itkTransformD2)
itkTransformD2.GetNumberOfLocalParameters = new_instancemethod(_itkTransformBasePython.itkTransformD2_GetNumberOfLocalParameters, None, itkTransformD2)
itkTransformD2.GetNumberOfFixedParameters = new_instancemethod(_itkTransformBasePython.itkTransformD2_GetNumberOfFixedParameters, None, itkTransformD2)
itkTransformD2.GetInverse = new_instancemethod(_itkTransformBasePython.itkTransformD2_GetInverse, None, itkTransformD2)
itkTransformD2.GetInverseTransform = new_instancemethod(_itkTransformBasePython.itkTransformD2_GetInverseTransform, None, itkTransformD2)
itkTransformD2.IsLinear = new_instancemethod(_itkTransformBasePython.itkTransformD2_IsLinear, None, itkTransformD2)
itkTransformD2.ComputeJacobianWithRespectToParameters = new_instancemethod(_itkTransformBasePython.itkTransformD2_ComputeJacobianWithRespectToParameters, None, itkTransformD2)
itkTransformD2.ComputeJacobianWithRespectToParametersCachedTemporaries = new_instancemethod(_itkTransformBasePython.itkTransformD2_ComputeJacobianWithRespectToParametersCachedTemporaries, None, itkTransformD2)
itkTransformD2.ComputeJacobianWithRespectToPosition = new_instancemethod(_itkTransformBasePython.itkTransformD2_ComputeJacobianWithRespectToPosition, None, itkTransformD2)
itkTransformD2.ComputeInverseJacobianWithRespectToPosition = new_instancemethod(_itkTransformBasePython.itkTransformD2_ComputeInverseJacobianWithRespectToPosition, None, itkTransformD2)
itkTransformD2_swigregister = _itkTransformBasePython.itkTransformD2_swigregister
itkTransformD2_swigregister(itkTransformD2)

def itkTransformD2_cast(obj: 'itkLightObject') -> "itkTransformD2 *":
    """itkTransformD2_cast(itkLightObject obj) -> itkTransformD2"""
    return _itkTransformBasePython.itkTransformD2_cast(obj)

class itkTransformD22(itkTransformBaseTemplateD):
    """


    Transform points and vectors from an input space to an output space.

    This abstract class defines the generic interface for a geometric
    transformation from one space to another. The class provides methods
    for mapping points, vectors and covariant vectors from the input space
    to the output space.

    Given that transformations are not necessarily invertible, this basic
    class does not provide the methods for back transformation. Back
    transform methods are implemented in derived classes where
    appropriate.

    Registration Framework Support Typically a Transform class has several
    methods for setting its parameters. For use in the registration
    framework, the parameters must also be represented by an array of
    doubles to allow communication with generic optimizers. The Array of
    transformation parameters is set using the SetParameters() method.
    Another requirement of the registration framework is the computation
    of the transform Jacobian. In general, an ImageToImageMetric requires
    the knowledge of the Jacobian in order to compute the metric
    derivatives. The Jacobian is a matrix whose element are the partial
    derivatives of the output point with respect to the array of
    parameters that defines the transform.

    Subclasses must provide implementations for:  virtual OutputPointType
    TransformPoint(const InputPointType  &) const  virtual
    OutputVectorType TransformVector(const InputVectorType &) const
    virtual OutputVnlVectorType TransformVector(const InputVnlVectorType
    &) const  virtual OutputCovariantVectorType
    TransformCovariantVector(const InputCovariantVectorType &) const
    virtual void SetParameters(const ParametersType &)  virtual void
    SetFixedParameters(const FixedParametersType &)  virtual void
    ComputeJacobianWithRespectToParameters( const InputPointType &,
    JacobianType &) const  virtual void
    ComputeJacobianWithRespectToPosition( const InputPointType & x,
    JacobianPositionType &jacobian ) const;

    Since TranformVector and TransformCovariantVector have multiple
    overloaded methods from the base class, subclasses must specify:
    using Superclass::TransformVector;  using
    Superclass::TransformCovariantVector;

    C++ includes: itkTransform.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Clone(self) -> "itkTransformD22_Pointer":
        """Clone(itkTransformD22 self) -> itkTransformD22_Pointer"""
        return _itkTransformBasePython.itkTransformD22_Clone(self)


    def TransformPoint(self, arg0: 'itkPointD2') -> "itkPointD2":
        """
        TransformPoint(itkTransformD22 self, itkPointD2 arg0) -> itkPointD2

        Method to transform
        a point. WARNING:  This method must be thread-safe. See, e.g., its use
        in ResampleImageFilter. 
        """
        return _itkTransformBasePython.itkTransformD22_TransformPoint(self, arg0)


    def TransformVector(self, *args) -> "itkVariableLengthVectorD":
        """
        TransformVector(itkTransformD22 self, itkVectorD2 arg0) -> itkVectorD2
        TransformVector(itkTransformD22 self, itkVectorD2 vector, itkPointD2 point) -> itkVectorD2
        TransformVector(itkTransformD22 self, vnl_vector_fixed< double,2 > const & arg0) -> vnl_vector_fixed< double,2 >
        TransformVector(itkTransformD22 self, vnl_vector_fixed< double,2 > const & vector, itkPointD2 point) -> vnl_vector_fixed< double,2 >
        TransformVector(itkTransformD22 self, itkVariableLengthVectorD arg0) -> itkVariableLengthVectorD
        TransformVector(itkTransformD22 self, itkVariableLengthVectorD vector, itkPointD2 point) -> itkVariableLengthVectorD

        Method to transform
        a vector stored in a VectorImage, at a point. For global transforms,
        point is ignored and TransformVector( vector ) is called. Local
        transforms (e.g. deformation field transform) must override and
        provide required behavior. 
        """
        return _itkTransformBasePython.itkTransformD22_TransformVector(self, *args)


    def TransformCovariantVector(self, *args) -> "itkVariableLengthVectorD":
        """
        TransformCovariantVector(itkTransformD22 self, itkCovariantVectorD2 arg0) -> itkCovariantVectorD2
        TransformCovariantVector(itkTransformD22 self, itkCovariantVectorD2 vector, itkPointD2 point) -> itkCovariantVectorD2
        TransformCovariantVector(itkTransformD22 self, itkVariableLengthVectorD arg0) -> itkVariableLengthVectorD
        TransformCovariantVector(itkTransformD22 self, itkVariableLengthVectorD vector, itkPointD2 point) -> itkVariableLengthVectorD

        Method to
        transform a CovariantVector, using a point. Global transforms can
        ignore the point parameter. Local transforms (e.g. deformation field
        transform) must override and provide required behavior. By default,
        point is ignored and TransformCovariantVector(vector) is called 
        """
        return _itkTransformBasePython.itkTransformD22_TransformCovariantVector(self, *args)


    def TransformDiffusionTensor3D(self, *args) -> "itkVariableLengthVectorD":
        """
        TransformDiffusionTensor3D(itkTransformD22 self, itkDiffusionTensor3DD arg0) -> itkDiffusionTensor3DD
        TransformDiffusionTensor3D(itkTransformD22 self, itkDiffusionTensor3DD tensor, itkPointD2 point) -> itkDiffusionTensor3DD
        TransformDiffusionTensor3D(itkTransformD22 self, itkVariableLengthVectorD arg0) -> itkVariableLengthVectorD
        TransformDiffusionTensor3D(itkTransformD22 self, itkVariableLengthVectorD tensor, itkPointD2 point) -> itkVariableLengthVectorD

        Method
        to transform a diffusion tensor stored in a VectorImage 
        """
        return _itkTransformBasePython.itkTransformD22_TransformDiffusionTensor3D(self, *args)


    def TransformSymmetricSecondRankTensor(self, *args) -> "itkVariableLengthVectorD":
        """
        TransformSymmetricSecondRankTensor(itkTransformD22 self, itkSymmetricSecondRankTensorD2 tensor, itkPointD2 point) -> itkSymmetricSecondRankTensorD2
        TransformSymmetricSecondRankTensor(itkTransformD22 self, itkSymmetricSecondRankTensorD2 arg0) -> itkSymmetricSecondRankTensorD2
        TransformSymmetricSecondRankTensor(itkTransformD22 self, itkVariableLengthVectorD arg0) -> itkVariableLengthVectorD
        TransformSymmetricSecondRankTensor(itkTransformD22 self, itkVariableLengthVectorD tensor, itkPointD2 point) -> itkVariableLengthVectorD

        Method to transform a diffusion tensor stored in a VectorImage, at a
        point. Global transforms can ignore the point parameter. Local
        transforms (e.g. deformation field transform) must override and
        provide required behavior. By default, point is ignored and
        TransformDiffusionTensor(tensor) is called 
        """
        return _itkTransformBasePython.itkTransformD22_TransformSymmetricSecondRankTensor(self, *args)


    def UpdateTransformParameters(self, update: 'itkArrayD', factor: 'double'=1.) -> "void":
        """
        UpdateTransformParameters(itkTransformD22 self, itkArrayD update, double factor=1.)
        UpdateTransformParameters(itkTransformD22 self, itkArrayD update)

        Update
        the transform's parameters by the values in update.

        Parameters:
        -----------

        update:  must be of the same length as returned by
        GetNumberOfParameters(). Throw an exception otherwise.

        factor:  is a scalar multiplier for each value in update.
        SetParameters is called at the end of this method, to allow the
        transform to perform any required operations on the updated parameters
        - typically a conversion to member variables for use in
        TransformPoint. 
        """
        return _itkTransformBasePython.itkTransformD22_UpdateTransformParameters(self, update, factor)


    def GetNumberOfLocalParameters(self) -> "unsigned long":
        """
        GetNumberOfLocalParameters(itkTransformD22 self) -> unsigned long

        Return
        the number of local parameters that completely defines the Transform
        at an individual voxel. For transforms with local support, this will
        enable downstream computation of the jacobian wrt only the local
        support region. For instance, in the case of a deformation field, this
        will be equal to the number of image dimensions. If it is an affine
        transform, this will be the same as the GetNumberOfParameters(). 
        """
        return _itkTransformBasePython.itkTransformD22_GetNumberOfLocalParameters(self)


    def GetNumberOfFixedParameters(self) -> "unsigned long":
        """
        GetNumberOfFixedParameters(itkTransformD22 self) -> unsigned long

        Return
        the number of parameters that define the constant elements of a
        Transfom 
        """
        return _itkTransformBasePython.itkTransformD22_GetNumberOfFixedParameters(self)


    def GetInverse(self, arg0: 'itkTransformD22') -> "bool":
        """
        GetInverse(itkTransformD22 self, itkTransformD22 arg0) -> bool

        Returns a boolean
        indicating whether it is possible or not to compute the inverse of
        this current Transform. If it is possible, then the inverse of the
        transform is returned in the inverseTransform variable passed by the
        user. The inverse is recomputed if this current transform has been
        modified. This method is intended to be overriden as needed by derived
        classes. 
        """
        return _itkTransformBasePython.itkTransformD22_GetInverse(self, arg0)


    def GetInverseTransform(self) -> "itkTransformD22_Pointer":
        """
        GetInverseTransform(itkTransformD22 self) -> itkTransformD22_Pointer

        Return an
        inverse of this transform. If the inverse has not been implemented,
        return nullptr. The type of the inverse transform does not necessarily
        need to match the type of the forward transform. This allows one to
        return a numeric inverse transform instead. 
        """
        return _itkTransformBasePython.itkTransformD22_GetInverseTransform(self)


    def IsLinear(self) -> "bool":
        """IsLinear(itkTransformD22 self) -> bool"""
        return _itkTransformBasePython.itkTransformD22_IsLinear(self)


    def ComputeJacobianWithRespectToParameters(self, arg0: 'itkPointD2', arg1: 'itkArray2DD') -> "void":
        """
        ComputeJacobianWithRespectToParameters(itkTransformD22 self, itkPointD2 arg0, itkArray2DD arg1)

        Compute the
        Jacobian of the transformation

        This method computes the Jacobian matrix of the transformation at a
        given input point. The rank of the Jacobian will also indicate if the
        transform is invertible at this point.

        The Jacobian is be expressed as a matrix of partial derivatives of the
        output point components with respect to the parameters that defined
        the transform:

        \\[ J=\\left[ \\begin{array}{cccc} \\frac{\\partial
        x_{1}}{\\partial p_{1}} & \\frac{\\partial x_{1}}{\\partial
        p_{2}} & \\cdots & \\frac{\\partial x_{1}}{\\partial
        p_{m}}\\\\ \\frac{\\partial x_{2}}{\\partial p_{1}} &
        \\frac{\\partial x_{2}}{\\partial p_{2}} & \\cdots &
        \\frac{\\partial x_{2}}{\\partial p_{m}}\\\\ \\vdots &
        \\vdots & \\ddots & \\vdots \\\\ \\frac{\\partial
        x_{n}}{\\partial p_{1}} & \\frac{\\partial x_{n}}{\\partial
        p_{2}} & \\cdots & \\frac{\\partial x_{n}}{\\partial p_{m}}
        \\end{array}\\right] \\]

        This is also used for efficient computation of a point-local jacobian
        for dense transforms. jacobian is assumed to be thread-local variable,
        otherwise memory corruption will most likely occur during multi-
        threading. To avoid repetitive memory allocation, pass in 'jacobian'
        with its size already set. 
        """
        return _itkTransformBasePython.itkTransformD22_ComputeJacobianWithRespectToParameters(self, arg0, arg1)


    def ComputeJacobianWithRespectToParametersCachedTemporaries(self, p: 'itkPointD2', jacobian: 'itkArray2DD', arg2: 'itkArray2DD') -> "void":
        """ComputeJacobianWithRespectToParametersCachedTemporaries(itkTransformD22 self, itkPointD2 p, itkArray2DD jacobian, itkArray2DD arg2)"""
        return _itkTransformBasePython.itkTransformD22_ComputeJacobianWithRespectToParametersCachedTemporaries(self, p, jacobian, arg2)


    def ComputeJacobianWithRespectToPosition(self, arg0: 'itkPointD2', arg1: 'vnl_matrix_fixedD_2_2') -> "void":
        """
        ComputeJacobianWithRespectToPosition(itkTransformD22 self, itkPointD2 arg0, vnl_matrix_fixedD_2_2 arg1)

        This provides the ability to get a local jacobian value in a
        dense/local transform, e.g. DisplacementFieldTransform. For such
        transforms it would be unclear what parameters would refer to.
        Generally, global transforms should return an identity jacobian since
        there is no change with respect to position. 
        """
        return _itkTransformBasePython.itkTransformD22_ComputeJacobianWithRespectToPosition(self, arg0, arg1)


    def ComputeInverseJacobianWithRespectToPosition(self, x: 'itkPointD2', jacobian: 'vnl_matrix_fixedD_2_2') -> "void":
        """
        ComputeInverseJacobianWithRespectToPosition(itkTransformD22 self, itkPointD2 x, vnl_matrix_fixedD_2_2 jacobian)

        This provides
        the ability to get a local jacobian value in a dense/local transform,
        e.g. DisplacementFieldTransform. For such transforms it would be
        unclear what parameters would refer to. Generally, global transforms
        should return an identity jacobian since there is no change with
        respect to position. 
        """
        return _itkTransformBasePython.itkTransformD22_ComputeInverseJacobianWithRespectToPosition(self, x, jacobian)

    __swig_destroy__ = _itkTransformBasePython.delete_itkTransformD22

    def cast(obj: 'itkLightObject') -> "itkTransformD22 *":
        """cast(itkLightObject obj) -> itkTransformD22"""
        return _itkTransformBasePython.itkTransformD22_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkTransformD22

        Create a new object of the class itkTransformD22 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkTransformD22.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkTransformD22.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkTransformD22.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkTransformD22.Clone = new_instancemethod(_itkTransformBasePython.itkTransformD22_Clone, None, itkTransformD22)
itkTransformD22.TransformPoint = new_instancemethod(_itkTransformBasePython.itkTransformD22_TransformPoint, None, itkTransformD22)
itkTransformD22.TransformVector = new_instancemethod(_itkTransformBasePython.itkTransformD22_TransformVector, None, itkTransformD22)
itkTransformD22.TransformCovariantVector = new_instancemethod(_itkTransformBasePython.itkTransformD22_TransformCovariantVector, None, itkTransformD22)
itkTransformD22.TransformDiffusionTensor3D = new_instancemethod(_itkTransformBasePython.itkTransformD22_TransformDiffusionTensor3D, None, itkTransformD22)
itkTransformD22.TransformSymmetricSecondRankTensor = new_instancemethod(_itkTransformBasePython.itkTransformD22_TransformSymmetricSecondRankTensor, None, itkTransformD22)
itkTransformD22.UpdateTransformParameters = new_instancemethod(_itkTransformBasePython.itkTransformD22_UpdateTransformParameters, None, itkTransformD22)
itkTransformD22.GetNumberOfLocalParameters = new_instancemethod(_itkTransformBasePython.itkTransformD22_GetNumberOfLocalParameters, None, itkTransformD22)
itkTransformD22.GetNumberOfFixedParameters = new_instancemethod(_itkTransformBasePython.itkTransformD22_GetNumberOfFixedParameters, None, itkTransformD22)
itkTransformD22.GetInverse = new_instancemethod(_itkTransformBasePython.itkTransformD22_GetInverse, None, itkTransformD22)
itkTransformD22.GetInverseTransform = new_instancemethod(_itkTransformBasePython.itkTransformD22_GetInverseTransform, None, itkTransformD22)
itkTransformD22.IsLinear = new_instancemethod(_itkTransformBasePython.itkTransformD22_IsLinear, None, itkTransformD22)
itkTransformD22.ComputeJacobianWithRespectToParameters = new_instancemethod(_itkTransformBasePython.itkTransformD22_ComputeJacobianWithRespectToParameters, None, itkTransformD22)
itkTransformD22.ComputeJacobianWithRespectToParametersCachedTemporaries = new_instancemethod(_itkTransformBasePython.itkTransformD22_ComputeJacobianWithRespectToParametersCachedTemporaries, None, itkTransformD22)
itkTransformD22.ComputeJacobianWithRespectToPosition = new_instancemethod(_itkTransformBasePython.itkTransformD22_ComputeJacobianWithRespectToPosition, None, itkTransformD22)
itkTransformD22.ComputeInverseJacobianWithRespectToPosition = new_instancemethod(_itkTransformBasePython.itkTransformD22_ComputeInverseJacobianWithRespectToPosition, None, itkTransformD22)
itkTransformD22_swigregister = _itkTransformBasePython.itkTransformD22_swigregister
itkTransformD22_swigregister(itkTransformD22)

def itkTransformD22_cast(obj: 'itkLightObject') -> "itkTransformD22 *":
    """itkTransformD22_cast(itkLightObject obj) -> itkTransformD22"""
    return _itkTransformBasePython.itkTransformD22_cast(obj)

class itkTransformD23(itkTransformBaseTemplateD):
    """


    Transform points and vectors from an input space to an output space.

    This abstract class defines the generic interface for a geometric
    transformation from one space to another. The class provides methods
    for mapping points, vectors and covariant vectors from the input space
    to the output space.

    Given that transformations are not necessarily invertible, this basic
    class does not provide the methods for back transformation. Back
    transform methods are implemented in derived classes where
    appropriate.

    Registration Framework Support Typically a Transform class has several
    methods for setting its parameters. For use in the registration
    framework, the parameters must also be represented by an array of
    doubles to allow communication with generic optimizers. The Array of
    transformation parameters is set using the SetParameters() method.
    Another requirement of the registration framework is the computation
    of the transform Jacobian. In general, an ImageToImageMetric requires
    the knowledge of the Jacobian in order to compute the metric
    derivatives. The Jacobian is a matrix whose element are the partial
    derivatives of the output point with respect to the array of
    parameters that defines the transform.

    Subclasses must provide implementations for:  virtual OutputPointType
    TransformPoint(const InputPointType  &) const  virtual
    OutputVectorType TransformVector(const InputVectorType &) const
    virtual OutputVnlVectorType TransformVector(const InputVnlVectorType
    &) const  virtual OutputCovariantVectorType
    TransformCovariantVector(const InputCovariantVectorType &) const
    virtual void SetParameters(const ParametersType &)  virtual void
    SetFixedParameters(const FixedParametersType &)  virtual void
    ComputeJacobianWithRespectToParameters( const InputPointType &,
    JacobianType &) const  virtual void
    ComputeJacobianWithRespectToPosition( const InputPointType & x,
    JacobianPositionType &jacobian ) const;

    Since TranformVector and TransformCovariantVector have multiple
    overloaded methods from the base class, subclasses must specify:
    using Superclass::TransformVector;  using
    Superclass::TransformCovariantVector;

    C++ includes: itkTransform.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Clone(self) -> "itkTransformD23_Pointer":
        """Clone(itkTransformD23 self) -> itkTransformD23_Pointer"""
        return _itkTransformBasePython.itkTransformD23_Clone(self)


    def TransformPoint(self, arg0: 'itkPointD2') -> "itkPointD3":
        """
        TransformPoint(itkTransformD23 self, itkPointD2 arg0) -> itkPointD3

        Method to transform
        a point. WARNING:  This method must be thread-safe. See, e.g., its use
        in ResampleImageFilter. 
        """
        return _itkTransformBasePython.itkTransformD23_TransformPoint(self, arg0)


    def TransformVector(self, *args) -> "itkVariableLengthVectorD":
        """
        TransformVector(itkTransformD23 self, itkVectorD2 arg0) -> itkVectorD3
        TransformVector(itkTransformD23 self, itkVectorD2 vector, itkPointD2 point) -> itkVectorD3
        TransformVector(itkTransformD23 self, vnl_vector_fixed< double,2 > const & arg0) -> vnl_vector_fixed< double,3 >
        TransformVector(itkTransformD23 self, vnl_vector_fixed< double,2 > const & vector, itkPointD2 point) -> vnl_vector_fixed< double,3 >
        TransformVector(itkTransformD23 self, itkVariableLengthVectorD arg0) -> itkVariableLengthVectorD
        TransformVector(itkTransformD23 self, itkVariableLengthVectorD vector, itkPointD2 point) -> itkVariableLengthVectorD

        Method to transform
        a vector stored in a VectorImage, at a point. For global transforms,
        point is ignored and TransformVector( vector ) is called. Local
        transforms (e.g. deformation field transform) must override and
        provide required behavior. 
        """
        return _itkTransformBasePython.itkTransformD23_TransformVector(self, *args)


    def TransformCovariantVector(self, *args) -> "itkVariableLengthVectorD":
        """
        TransformCovariantVector(itkTransformD23 self, itkCovariantVectorD2 arg0) -> itkCovariantVectorD3
        TransformCovariantVector(itkTransformD23 self, itkCovariantVectorD2 vector, itkPointD2 point) -> itkCovariantVectorD3
        TransformCovariantVector(itkTransformD23 self, itkVariableLengthVectorD arg0) -> itkVariableLengthVectorD
        TransformCovariantVector(itkTransformD23 self, itkVariableLengthVectorD vector, itkPointD2 point) -> itkVariableLengthVectorD

        Method to
        transform a CovariantVector, using a point. Global transforms can
        ignore the point parameter. Local transforms (e.g. deformation field
        transform) must override and provide required behavior. By default,
        point is ignored and TransformCovariantVector(vector) is called 
        """
        return _itkTransformBasePython.itkTransformD23_TransformCovariantVector(self, *args)


    def TransformDiffusionTensor3D(self, *args) -> "itkVariableLengthVectorD":
        """
        TransformDiffusionTensor3D(itkTransformD23 self, itkDiffusionTensor3DD arg0) -> itkDiffusionTensor3DD
        TransformDiffusionTensor3D(itkTransformD23 self, itkDiffusionTensor3DD tensor, itkPointD2 point) -> itkDiffusionTensor3DD
        TransformDiffusionTensor3D(itkTransformD23 self, itkVariableLengthVectorD arg0) -> itkVariableLengthVectorD
        TransformDiffusionTensor3D(itkTransformD23 self, itkVariableLengthVectorD tensor, itkPointD2 point) -> itkVariableLengthVectorD

        Method
        to transform a diffusion tensor stored in a VectorImage 
        """
        return _itkTransformBasePython.itkTransformD23_TransformDiffusionTensor3D(self, *args)


    def TransformSymmetricSecondRankTensor(self, *args) -> "itkVariableLengthVectorD":
        """
        TransformSymmetricSecondRankTensor(itkTransformD23 self, itkSymmetricSecondRankTensorD2 tensor, itkPointD2 point) -> itkSymmetricSecondRankTensorD3
        TransformSymmetricSecondRankTensor(itkTransformD23 self, itkSymmetricSecondRankTensorD2 arg0) -> itkSymmetricSecondRankTensorD3
        TransformSymmetricSecondRankTensor(itkTransformD23 self, itkVariableLengthVectorD arg0) -> itkVariableLengthVectorD
        TransformSymmetricSecondRankTensor(itkTransformD23 self, itkVariableLengthVectorD tensor, itkPointD2 point) -> itkVariableLengthVectorD

        Method to transform a diffusion tensor stored in a VectorImage, at a
        point. Global transforms can ignore the point parameter. Local
        transforms (e.g. deformation field transform) must override and
        provide required behavior. By default, point is ignored and
        TransformDiffusionTensor(tensor) is called 
        """
        return _itkTransformBasePython.itkTransformD23_TransformSymmetricSecondRankTensor(self, *args)


    def UpdateTransformParameters(self, update: 'itkArrayD', factor: 'double'=1.) -> "void":
        """
        UpdateTransformParameters(itkTransformD23 self, itkArrayD update, double factor=1.)
        UpdateTransformParameters(itkTransformD23 self, itkArrayD update)

        Update
        the transform's parameters by the values in update.

        Parameters:
        -----------

        update:  must be of the same length as returned by
        GetNumberOfParameters(). Throw an exception otherwise.

        factor:  is a scalar multiplier for each value in update.
        SetParameters is called at the end of this method, to allow the
        transform to perform any required operations on the updated parameters
        - typically a conversion to member variables for use in
        TransformPoint. 
        """
        return _itkTransformBasePython.itkTransformD23_UpdateTransformParameters(self, update, factor)


    def GetNumberOfLocalParameters(self) -> "unsigned long":
        """
        GetNumberOfLocalParameters(itkTransformD23 self) -> unsigned long

        Return
        the number of local parameters that completely defines the Transform
        at an individual voxel. For transforms with local support, this will
        enable downstream computation of the jacobian wrt only the local
        support region. For instance, in the case of a deformation field, this
        will be equal to the number of image dimensions. If it is an affine
        transform, this will be the same as the GetNumberOfParameters(). 
        """
        return _itkTransformBasePython.itkTransformD23_GetNumberOfLocalParameters(self)


    def GetNumberOfFixedParameters(self) -> "unsigned long":
        """
        GetNumberOfFixedParameters(itkTransformD23 self) -> unsigned long

        Return
        the number of parameters that define the constant elements of a
        Transfom 
        """
        return _itkTransformBasePython.itkTransformD23_GetNumberOfFixedParameters(self)


    def GetInverse(self, arg0: 'itkTransformD23') -> "bool":
        """
        GetInverse(itkTransformD23 self, itkTransformD23 arg0) -> bool

        Returns a boolean
        indicating whether it is possible or not to compute the inverse of
        this current Transform. If it is possible, then the inverse of the
        transform is returned in the inverseTransform variable passed by the
        user. The inverse is recomputed if this current transform has been
        modified. This method is intended to be overriden as needed by derived
        classes. 
        """
        return _itkTransformBasePython.itkTransformD23_GetInverse(self, arg0)


    def GetInverseTransform(self) -> "itkTransformD32_Pointer":
        """
        GetInverseTransform(itkTransformD23 self) -> itkTransformD32_Pointer

        Return an
        inverse of this transform. If the inverse has not been implemented,
        return nullptr. The type of the inverse transform does not necessarily
        need to match the type of the forward transform. This allows one to
        return a numeric inverse transform instead. 
        """
        return _itkTransformBasePython.itkTransformD23_GetInverseTransform(self)


    def IsLinear(self) -> "bool":
        """IsLinear(itkTransformD23 self) -> bool"""
        return _itkTransformBasePython.itkTransformD23_IsLinear(self)


    def ComputeJacobianWithRespectToParameters(self, arg0: 'itkPointD2', arg1: 'itkArray2DD') -> "void":
        """
        ComputeJacobianWithRespectToParameters(itkTransformD23 self, itkPointD2 arg0, itkArray2DD arg1)

        Compute the
        Jacobian of the transformation

        This method computes the Jacobian matrix of the transformation at a
        given input point. The rank of the Jacobian will also indicate if the
        transform is invertible at this point.

        The Jacobian is be expressed as a matrix of partial derivatives of the
        output point components with respect to the parameters that defined
        the transform:

        \\[ J=\\left[ \\begin{array}{cccc} \\frac{\\partial
        x_{1}}{\\partial p_{1}} & \\frac{\\partial x_{1}}{\\partial
        p_{2}} & \\cdots & \\frac{\\partial x_{1}}{\\partial
        p_{m}}\\\\ \\frac{\\partial x_{2}}{\\partial p_{1}} &
        \\frac{\\partial x_{2}}{\\partial p_{2}} & \\cdots &
        \\frac{\\partial x_{2}}{\\partial p_{m}}\\\\ \\vdots &
        \\vdots & \\ddots & \\vdots \\\\ \\frac{\\partial
        x_{n}}{\\partial p_{1}} & \\frac{\\partial x_{n}}{\\partial
        p_{2}} & \\cdots & \\frac{\\partial x_{n}}{\\partial p_{m}}
        \\end{array}\\right] \\]

        This is also used for efficient computation of a point-local jacobian
        for dense transforms. jacobian is assumed to be thread-local variable,
        otherwise memory corruption will most likely occur during multi-
        threading. To avoid repetitive memory allocation, pass in 'jacobian'
        with its size already set. 
        """
        return _itkTransformBasePython.itkTransformD23_ComputeJacobianWithRespectToParameters(self, arg0, arg1)


    def ComputeJacobianWithRespectToParametersCachedTemporaries(self, p: 'itkPointD2', jacobian: 'itkArray2DD', arg2: 'itkArray2DD') -> "void":
        """ComputeJacobianWithRespectToParametersCachedTemporaries(itkTransformD23 self, itkPointD2 p, itkArray2DD jacobian, itkArray2DD arg2)"""
        return _itkTransformBasePython.itkTransformD23_ComputeJacobianWithRespectToParametersCachedTemporaries(self, p, jacobian, arg2)


    def ComputeJacobianWithRespectToPosition(self, arg0: 'itkPointD2', arg1: 'vnl_matrix_fixed< double,3,2 > &') -> "void":
        """
        ComputeJacobianWithRespectToPosition(itkTransformD23 self, itkPointD2 arg0, vnl_matrix_fixed< double,3,2 > & arg1)

        This provides the ability to get a local jacobian value in a
        dense/local transform, e.g. DisplacementFieldTransform. For such
        transforms it would be unclear what parameters would refer to.
        Generally, global transforms should return an identity jacobian since
        there is no change with respect to position. 
        """
        return _itkTransformBasePython.itkTransformD23_ComputeJacobianWithRespectToPosition(self, arg0, arg1)


    def ComputeInverseJacobianWithRespectToPosition(self, x: 'itkPointD2', jacobian: 'vnl_matrix_fixedD_2_3') -> "void":
        """
        ComputeInverseJacobianWithRespectToPosition(itkTransformD23 self, itkPointD2 x, vnl_matrix_fixedD_2_3 jacobian)

        This provides
        the ability to get a local jacobian value in a dense/local transform,
        e.g. DisplacementFieldTransform. For such transforms it would be
        unclear what parameters would refer to. Generally, global transforms
        should return an identity jacobian since there is no change with
        respect to position. 
        """
        return _itkTransformBasePython.itkTransformD23_ComputeInverseJacobianWithRespectToPosition(self, x, jacobian)

    __swig_destroy__ = _itkTransformBasePython.delete_itkTransformD23

    def cast(obj: 'itkLightObject') -> "itkTransformD23 *":
        """cast(itkLightObject obj) -> itkTransformD23"""
        return _itkTransformBasePython.itkTransformD23_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkTransformD23

        Create a new object of the class itkTransformD23 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkTransformD23.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkTransformD23.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkTransformD23.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkTransformD23.Clone = new_instancemethod(_itkTransformBasePython.itkTransformD23_Clone, None, itkTransformD23)
itkTransformD23.TransformPoint = new_instancemethod(_itkTransformBasePython.itkTransformD23_TransformPoint, None, itkTransformD23)
itkTransformD23.TransformVector = new_instancemethod(_itkTransformBasePython.itkTransformD23_TransformVector, None, itkTransformD23)
itkTransformD23.TransformCovariantVector = new_instancemethod(_itkTransformBasePython.itkTransformD23_TransformCovariantVector, None, itkTransformD23)
itkTransformD23.TransformDiffusionTensor3D = new_instancemethod(_itkTransformBasePython.itkTransformD23_TransformDiffusionTensor3D, None, itkTransformD23)
itkTransformD23.TransformSymmetricSecondRankTensor = new_instancemethod(_itkTransformBasePython.itkTransformD23_TransformSymmetricSecondRankTensor, None, itkTransformD23)
itkTransformD23.UpdateTransformParameters = new_instancemethod(_itkTransformBasePython.itkTransformD23_UpdateTransformParameters, None, itkTransformD23)
itkTransformD23.GetNumberOfLocalParameters = new_instancemethod(_itkTransformBasePython.itkTransformD23_GetNumberOfLocalParameters, None, itkTransformD23)
itkTransformD23.GetNumberOfFixedParameters = new_instancemethod(_itkTransformBasePython.itkTransformD23_GetNumberOfFixedParameters, None, itkTransformD23)
itkTransformD23.GetInverse = new_instancemethod(_itkTransformBasePython.itkTransformD23_GetInverse, None, itkTransformD23)
itkTransformD23.GetInverseTransform = new_instancemethod(_itkTransformBasePython.itkTransformD23_GetInverseTransform, None, itkTransformD23)
itkTransformD23.IsLinear = new_instancemethod(_itkTransformBasePython.itkTransformD23_IsLinear, None, itkTransformD23)
itkTransformD23.ComputeJacobianWithRespectToParameters = new_instancemethod(_itkTransformBasePython.itkTransformD23_ComputeJacobianWithRespectToParameters, None, itkTransformD23)
itkTransformD23.ComputeJacobianWithRespectToParametersCachedTemporaries = new_instancemethod(_itkTransformBasePython.itkTransformD23_ComputeJacobianWithRespectToParametersCachedTemporaries, None, itkTransformD23)
itkTransformD23.ComputeJacobianWithRespectToPosition = new_instancemethod(_itkTransformBasePython.itkTransformD23_ComputeJacobianWithRespectToPosition, None, itkTransformD23)
itkTransformD23.ComputeInverseJacobianWithRespectToPosition = new_instancemethod(_itkTransformBasePython.itkTransformD23_ComputeInverseJacobianWithRespectToPosition, None, itkTransformD23)
itkTransformD23_swigregister = _itkTransformBasePython.itkTransformD23_swigregister
itkTransformD23_swigregister(itkTransformD23)

def itkTransformD23_cast(obj: 'itkLightObject') -> "itkTransformD23 *":
    """itkTransformD23_cast(itkLightObject obj) -> itkTransformD23"""
    return _itkTransformBasePython.itkTransformD23_cast(obj)

class itkTransformD3(itkTransformBaseTemplateD):
    """


    Transform points and vectors from an input space to an output space.

    This abstract class defines the generic interface for a geometric
    transformation from one space to another. The class provides methods
    for mapping points, vectors and covariant vectors from the input space
    to the output space.

    Given that transformations are not necessarily invertible, this basic
    class does not provide the methods for back transformation. Back
    transform methods are implemented in derived classes where
    appropriate.

    Registration Framework Support Typically a Transform class has several
    methods for setting its parameters. For use in the registration
    framework, the parameters must also be represented by an array of
    doubles to allow communication with generic optimizers. The Array of
    transformation parameters is set using the SetParameters() method.
    Another requirement of the registration framework is the computation
    of the transform Jacobian. In general, an ImageToImageMetric requires
    the knowledge of the Jacobian in order to compute the metric
    derivatives. The Jacobian is a matrix whose element are the partial
    derivatives of the output point with respect to the array of
    parameters that defines the transform.

    Subclasses must provide implementations for:  virtual OutputPointType
    TransformPoint(const InputPointType  &) const  virtual
    OutputVectorType TransformVector(const InputVectorType &) const
    virtual OutputVnlVectorType TransformVector(const InputVnlVectorType
    &) const  virtual OutputCovariantVectorType
    TransformCovariantVector(const InputCovariantVectorType &) const
    virtual void SetParameters(const ParametersType &)  virtual void
    SetFixedParameters(const FixedParametersType &)  virtual void
    ComputeJacobianWithRespectToParameters( const InputPointType &,
    JacobianType &) const  virtual void
    ComputeJacobianWithRespectToPosition( const InputPointType & x,
    JacobianPositionType &jacobian ) const;

    Since TranformVector and TransformCovariantVector have multiple
    overloaded methods from the base class, subclasses must specify:
    using Superclass::TransformVector;  using
    Superclass::TransformCovariantVector;

    C++ includes: itkTransform.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Clone(self) -> "itkTransformD33_Pointer":
        """Clone(itkTransformD3 self) -> itkTransformD33_Pointer"""
        return _itkTransformBasePython.itkTransformD3_Clone(self)


    def TransformPoint(self, arg0: 'itkPointD3') -> "itkPointD3":
        """
        TransformPoint(itkTransformD3 self, itkPointD3 arg0) -> itkPointD3

        Method to transform
        a point. WARNING:  This method must be thread-safe. See, e.g., its use
        in ResampleImageFilter. 
        """
        return _itkTransformBasePython.itkTransformD3_TransformPoint(self, arg0)


    def TransformVector(self, *args) -> "itkVariableLengthVectorD":
        """
        TransformVector(itkTransformD3 self, itkVectorD3 arg0) -> itkVectorD3
        TransformVector(itkTransformD3 self, itkVectorD3 vector, itkPointD3 point) -> itkVectorD3
        TransformVector(itkTransformD3 self, vnl_vector_fixed< double,3 > const & arg0) -> vnl_vector_fixed< double,3 >
        TransformVector(itkTransformD3 self, vnl_vector_fixed< double,3 > const & vector, itkPointD3 point) -> vnl_vector_fixed< double,3 >
        TransformVector(itkTransformD3 self, itkVariableLengthVectorD arg0) -> itkVariableLengthVectorD
        TransformVector(itkTransformD3 self, itkVariableLengthVectorD vector, itkPointD3 point) -> itkVariableLengthVectorD

        Method to transform
        a vector stored in a VectorImage, at a point. For global transforms,
        point is ignored and TransformVector( vector ) is called. Local
        transforms (e.g. deformation field transform) must override and
        provide required behavior. 
        """
        return _itkTransformBasePython.itkTransformD3_TransformVector(self, *args)


    def TransformCovariantVector(self, *args) -> "itkVariableLengthVectorD":
        """
        TransformCovariantVector(itkTransformD3 self, itkCovariantVectorD3 arg0) -> itkCovariantVectorD3
        TransformCovariantVector(itkTransformD3 self, itkCovariantVectorD3 vector, itkPointD3 point) -> itkCovariantVectorD3
        TransformCovariantVector(itkTransformD3 self, itkVariableLengthVectorD arg0) -> itkVariableLengthVectorD
        TransformCovariantVector(itkTransformD3 self, itkVariableLengthVectorD vector, itkPointD3 point) -> itkVariableLengthVectorD

        Method to
        transform a CovariantVector, using a point. Global transforms can
        ignore the point parameter. Local transforms (e.g. deformation field
        transform) must override and provide required behavior. By default,
        point is ignored and TransformCovariantVector(vector) is called 
        """
        return _itkTransformBasePython.itkTransformD3_TransformCovariantVector(self, *args)


    def TransformDiffusionTensor3D(self, *args) -> "itkVariableLengthVectorD":
        """
        TransformDiffusionTensor3D(itkTransformD3 self, itkDiffusionTensor3DD arg0) -> itkDiffusionTensor3DD
        TransformDiffusionTensor3D(itkTransformD3 self, itkDiffusionTensor3DD tensor, itkPointD3 point) -> itkDiffusionTensor3DD
        TransformDiffusionTensor3D(itkTransformD3 self, itkVariableLengthVectorD arg0) -> itkVariableLengthVectorD
        TransformDiffusionTensor3D(itkTransformD3 self, itkVariableLengthVectorD tensor, itkPointD3 point) -> itkVariableLengthVectorD

        Method
        to transform a diffusion tensor stored in a VectorImage 
        """
        return _itkTransformBasePython.itkTransformD3_TransformDiffusionTensor3D(self, *args)


    def TransformSymmetricSecondRankTensor(self, *args) -> "itkVariableLengthVectorD":
        """
        TransformSymmetricSecondRankTensor(itkTransformD3 self, itkSymmetricSecondRankTensorD3 tensor, itkPointD3 point) -> itkSymmetricSecondRankTensorD3
        TransformSymmetricSecondRankTensor(itkTransformD3 self, itkSymmetricSecondRankTensorD3 arg0) -> itkSymmetricSecondRankTensorD3
        TransformSymmetricSecondRankTensor(itkTransformD3 self, itkVariableLengthVectorD arg0) -> itkVariableLengthVectorD
        TransformSymmetricSecondRankTensor(itkTransformD3 self, itkVariableLengthVectorD tensor, itkPointD3 point) -> itkVariableLengthVectorD

        Method to transform a diffusion tensor stored in a VectorImage, at a
        point. Global transforms can ignore the point parameter. Local
        transforms (e.g. deformation field transform) must override and
        provide required behavior. By default, point is ignored and
        TransformDiffusionTensor(tensor) is called 
        """
        return _itkTransformBasePython.itkTransformD3_TransformSymmetricSecondRankTensor(self, *args)


    def UpdateTransformParameters(self, update: 'itkArrayD', factor: 'double'=1.) -> "void":
        """
        UpdateTransformParameters(itkTransformD3 self, itkArrayD update, double factor=1.)
        UpdateTransformParameters(itkTransformD3 self, itkArrayD update)

        Update
        the transform's parameters by the values in update.

        Parameters:
        -----------

        update:  must be of the same length as returned by
        GetNumberOfParameters(). Throw an exception otherwise.

        factor:  is a scalar multiplier for each value in update.
        SetParameters is called at the end of this method, to allow the
        transform to perform any required operations on the updated parameters
        - typically a conversion to member variables for use in
        TransformPoint. 
        """
        return _itkTransformBasePython.itkTransformD3_UpdateTransformParameters(self, update, factor)


    def GetNumberOfLocalParameters(self) -> "unsigned long":
        """
        GetNumberOfLocalParameters(itkTransformD3 self) -> unsigned long

        Return
        the number of local parameters that completely defines the Transform
        at an individual voxel. For transforms with local support, this will
        enable downstream computation of the jacobian wrt only the local
        support region. For instance, in the case of a deformation field, this
        will be equal to the number of image dimensions. If it is an affine
        transform, this will be the same as the GetNumberOfParameters(). 
        """
        return _itkTransformBasePython.itkTransformD3_GetNumberOfLocalParameters(self)


    def GetNumberOfFixedParameters(self) -> "unsigned long":
        """
        GetNumberOfFixedParameters(itkTransformD3 self) -> unsigned long

        Return
        the number of parameters that define the constant elements of a
        Transfom 
        """
        return _itkTransformBasePython.itkTransformD3_GetNumberOfFixedParameters(self)


    def GetInverse(self, arg0: 'itkTransformD33') -> "bool":
        """
        GetInverse(itkTransformD3 self, itkTransformD33 arg0) -> bool

        Returns a boolean
        indicating whether it is possible or not to compute the inverse of
        this current Transform. If it is possible, then the inverse of the
        transform is returned in the inverseTransform variable passed by the
        user. The inverse is recomputed if this current transform has been
        modified. This method is intended to be overriden as needed by derived
        classes. 
        """
        return _itkTransformBasePython.itkTransformD3_GetInverse(self, arg0)


    def GetInverseTransform(self) -> "itkTransformD33_Pointer":
        """
        GetInverseTransform(itkTransformD3 self) -> itkTransformD33_Pointer

        Return an
        inverse of this transform. If the inverse has not been implemented,
        return nullptr. The type of the inverse transform does not necessarily
        need to match the type of the forward transform. This allows one to
        return a numeric inverse transform instead. 
        """
        return _itkTransformBasePython.itkTransformD3_GetInverseTransform(self)


    def IsLinear(self) -> "bool":
        """IsLinear(itkTransformD3 self) -> bool"""
        return _itkTransformBasePython.itkTransformD3_IsLinear(self)


    def ComputeJacobianWithRespectToParameters(self, arg0: 'itkPointD3', arg1: 'itkArray2DD') -> "void":
        """
        ComputeJacobianWithRespectToParameters(itkTransformD3 self, itkPointD3 arg0, itkArray2DD arg1)

        Compute the
        Jacobian of the transformation

        This method computes the Jacobian matrix of the transformation at a
        given input point. The rank of the Jacobian will also indicate if the
        transform is invertible at this point.

        The Jacobian is be expressed as a matrix of partial derivatives of the
        output point components with respect to the parameters that defined
        the transform:

        \\[ J=\\left[ \\begin{array}{cccc} \\frac{\\partial
        x_{1}}{\\partial p_{1}} & \\frac{\\partial x_{1}}{\\partial
        p_{2}} & \\cdots & \\frac{\\partial x_{1}}{\\partial
        p_{m}}\\\\ \\frac{\\partial x_{2}}{\\partial p_{1}} &
        \\frac{\\partial x_{2}}{\\partial p_{2}} & \\cdots &
        \\frac{\\partial x_{2}}{\\partial p_{m}}\\\\ \\vdots &
        \\vdots & \\ddots & \\vdots \\\\ \\frac{\\partial
        x_{n}}{\\partial p_{1}} & \\frac{\\partial x_{n}}{\\partial
        p_{2}} & \\cdots & \\frac{\\partial x_{n}}{\\partial p_{m}}
        \\end{array}\\right] \\]

        This is also used for efficient computation of a point-local jacobian
        for dense transforms. jacobian is assumed to be thread-local variable,
        otherwise memory corruption will most likely occur during multi-
        threading. To avoid repetitive memory allocation, pass in 'jacobian'
        with its size already set. 
        """
        return _itkTransformBasePython.itkTransformD3_ComputeJacobianWithRespectToParameters(self, arg0, arg1)


    def ComputeJacobianWithRespectToParametersCachedTemporaries(self, p: 'itkPointD3', jacobian: 'itkArray2DD', arg2: 'itkArray2DD') -> "void":
        """ComputeJacobianWithRespectToParametersCachedTemporaries(itkTransformD3 self, itkPointD3 p, itkArray2DD jacobian, itkArray2DD arg2)"""
        return _itkTransformBasePython.itkTransformD3_ComputeJacobianWithRespectToParametersCachedTemporaries(self, p, jacobian, arg2)


    def ComputeJacobianWithRespectToPosition(self, arg0: 'itkPointD3', arg1: 'vnl_matrix_fixedD_3_3') -> "void":
        """
        ComputeJacobianWithRespectToPosition(itkTransformD3 self, itkPointD3 arg0, vnl_matrix_fixedD_3_3 arg1)

        This provides the ability to get a local jacobian value in a
        dense/local transform, e.g. DisplacementFieldTransform. For such
        transforms it would be unclear what parameters would refer to.
        Generally, global transforms should return an identity jacobian since
        there is no change with respect to position. 
        """
        return _itkTransformBasePython.itkTransformD3_ComputeJacobianWithRespectToPosition(self, arg0, arg1)


    def ComputeInverseJacobianWithRespectToPosition(self, x: 'itkPointD3', jacobian: 'vnl_matrix_fixedD_3_3') -> "void":
        """
        ComputeInverseJacobianWithRespectToPosition(itkTransformD3 self, itkPointD3 x, vnl_matrix_fixedD_3_3 jacobian)

        This provides
        the ability to get a local jacobian value in a dense/local transform,
        e.g. DisplacementFieldTransform. For such transforms it would be
        unclear what parameters would refer to. Generally, global transforms
        should return an identity jacobian since there is no change with
        respect to position. 
        """
        return _itkTransformBasePython.itkTransformD3_ComputeInverseJacobianWithRespectToPosition(self, x, jacobian)

    __swig_destroy__ = _itkTransformBasePython.delete_itkTransformD3

    def cast(obj: 'itkLightObject') -> "itkTransformD3 *":
        """cast(itkLightObject obj) -> itkTransformD3"""
        return _itkTransformBasePython.itkTransformD3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkTransformD3

        Create a new object of the class itkTransformD3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkTransformD3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkTransformD3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkTransformD3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkTransformD3.Clone = new_instancemethod(_itkTransformBasePython.itkTransformD3_Clone, None, itkTransformD3)
itkTransformD3.TransformPoint = new_instancemethod(_itkTransformBasePython.itkTransformD3_TransformPoint, None, itkTransformD3)
itkTransformD3.TransformVector = new_instancemethod(_itkTransformBasePython.itkTransformD3_TransformVector, None, itkTransformD3)
itkTransformD3.TransformCovariantVector = new_instancemethod(_itkTransformBasePython.itkTransformD3_TransformCovariantVector, None, itkTransformD3)
itkTransformD3.TransformDiffusionTensor3D = new_instancemethod(_itkTransformBasePython.itkTransformD3_TransformDiffusionTensor3D, None, itkTransformD3)
itkTransformD3.TransformSymmetricSecondRankTensor = new_instancemethod(_itkTransformBasePython.itkTransformD3_TransformSymmetricSecondRankTensor, None, itkTransformD3)
itkTransformD3.UpdateTransformParameters = new_instancemethod(_itkTransformBasePython.itkTransformD3_UpdateTransformParameters, None, itkTransformD3)
itkTransformD3.GetNumberOfLocalParameters = new_instancemethod(_itkTransformBasePython.itkTransformD3_GetNumberOfLocalParameters, None, itkTransformD3)
itkTransformD3.GetNumberOfFixedParameters = new_instancemethod(_itkTransformBasePython.itkTransformD3_GetNumberOfFixedParameters, None, itkTransformD3)
itkTransformD3.GetInverse = new_instancemethod(_itkTransformBasePython.itkTransformD3_GetInverse, None, itkTransformD3)
itkTransformD3.GetInverseTransform = new_instancemethod(_itkTransformBasePython.itkTransformD3_GetInverseTransform, None, itkTransformD3)
itkTransformD3.IsLinear = new_instancemethod(_itkTransformBasePython.itkTransformD3_IsLinear, None, itkTransformD3)
itkTransformD3.ComputeJacobianWithRespectToParameters = new_instancemethod(_itkTransformBasePython.itkTransformD3_ComputeJacobianWithRespectToParameters, None, itkTransformD3)
itkTransformD3.ComputeJacobianWithRespectToParametersCachedTemporaries = new_instancemethod(_itkTransformBasePython.itkTransformD3_ComputeJacobianWithRespectToParametersCachedTemporaries, None, itkTransformD3)
itkTransformD3.ComputeJacobianWithRespectToPosition = new_instancemethod(_itkTransformBasePython.itkTransformD3_ComputeJacobianWithRespectToPosition, None, itkTransformD3)
itkTransformD3.ComputeInverseJacobianWithRespectToPosition = new_instancemethod(_itkTransformBasePython.itkTransformD3_ComputeInverseJacobianWithRespectToPosition, None, itkTransformD3)
itkTransformD3_swigregister = _itkTransformBasePython.itkTransformD3_swigregister
itkTransformD3_swigregister(itkTransformD3)

def itkTransformD3_cast(obj: 'itkLightObject') -> "itkTransformD3 *":
    """itkTransformD3_cast(itkLightObject obj) -> itkTransformD3"""
    return _itkTransformBasePython.itkTransformD3_cast(obj)

class itkTransformD32(itkTransformBaseTemplateD):
    """


    Transform points and vectors from an input space to an output space.

    This abstract class defines the generic interface for a geometric
    transformation from one space to another. The class provides methods
    for mapping points, vectors and covariant vectors from the input space
    to the output space.

    Given that transformations are not necessarily invertible, this basic
    class does not provide the methods for back transformation. Back
    transform methods are implemented in derived classes where
    appropriate.

    Registration Framework Support Typically a Transform class has several
    methods for setting its parameters. For use in the registration
    framework, the parameters must also be represented by an array of
    doubles to allow communication with generic optimizers. The Array of
    transformation parameters is set using the SetParameters() method.
    Another requirement of the registration framework is the computation
    of the transform Jacobian. In general, an ImageToImageMetric requires
    the knowledge of the Jacobian in order to compute the metric
    derivatives. The Jacobian is a matrix whose element are the partial
    derivatives of the output point with respect to the array of
    parameters that defines the transform.

    Subclasses must provide implementations for:  virtual OutputPointType
    TransformPoint(const InputPointType  &) const  virtual
    OutputVectorType TransformVector(const InputVectorType &) const
    virtual OutputVnlVectorType TransformVector(const InputVnlVectorType
    &) const  virtual OutputCovariantVectorType
    TransformCovariantVector(const InputCovariantVectorType &) const
    virtual void SetParameters(const ParametersType &)  virtual void
    SetFixedParameters(const FixedParametersType &)  virtual void
    ComputeJacobianWithRespectToParameters( const InputPointType &,
    JacobianType &) const  virtual void
    ComputeJacobianWithRespectToPosition( const InputPointType & x,
    JacobianPositionType &jacobian ) const;

    Since TranformVector and TransformCovariantVector have multiple
    overloaded methods from the base class, subclasses must specify:
    using Superclass::TransformVector;  using
    Superclass::TransformCovariantVector;

    C++ includes: itkTransform.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Clone(self) -> "itkTransformD32_Pointer":
        """Clone(itkTransformD32 self) -> itkTransformD32_Pointer"""
        return _itkTransformBasePython.itkTransformD32_Clone(self)


    def TransformPoint(self, arg0: 'itkPointD3') -> "itkPointD2":
        """
        TransformPoint(itkTransformD32 self, itkPointD3 arg0) -> itkPointD2

        Method to transform
        a point. WARNING:  This method must be thread-safe. See, e.g., its use
        in ResampleImageFilter. 
        """
        return _itkTransformBasePython.itkTransformD32_TransformPoint(self, arg0)


    def TransformVector(self, *args) -> "itkVariableLengthVectorD":
        """
        TransformVector(itkTransformD32 self, itkVectorD3 arg0) -> itkVectorD2
        TransformVector(itkTransformD32 self, itkVectorD3 vector, itkPointD3 point) -> itkVectorD2
        TransformVector(itkTransformD32 self, vnl_vector_fixed< double,3 > const & arg0) -> vnl_vector_fixed< double,2 >
        TransformVector(itkTransformD32 self, vnl_vector_fixed< double,3 > const & vector, itkPointD3 point) -> vnl_vector_fixed< double,2 >
        TransformVector(itkTransformD32 self, itkVariableLengthVectorD arg0) -> itkVariableLengthVectorD
        TransformVector(itkTransformD32 self, itkVariableLengthVectorD vector, itkPointD3 point) -> itkVariableLengthVectorD

        Method to transform
        a vector stored in a VectorImage, at a point. For global transforms,
        point is ignored and TransformVector( vector ) is called. Local
        transforms (e.g. deformation field transform) must override and
        provide required behavior. 
        """
        return _itkTransformBasePython.itkTransformD32_TransformVector(self, *args)


    def TransformCovariantVector(self, *args) -> "itkVariableLengthVectorD":
        """
        TransformCovariantVector(itkTransformD32 self, itkCovariantVectorD3 arg0) -> itkCovariantVectorD2
        TransformCovariantVector(itkTransformD32 self, itkCovariantVectorD3 vector, itkPointD3 point) -> itkCovariantVectorD2
        TransformCovariantVector(itkTransformD32 self, itkVariableLengthVectorD arg0) -> itkVariableLengthVectorD
        TransformCovariantVector(itkTransformD32 self, itkVariableLengthVectorD vector, itkPointD3 point) -> itkVariableLengthVectorD

        Method to
        transform a CovariantVector, using a point. Global transforms can
        ignore the point parameter. Local transforms (e.g. deformation field
        transform) must override and provide required behavior. By default,
        point is ignored and TransformCovariantVector(vector) is called 
        """
        return _itkTransformBasePython.itkTransformD32_TransformCovariantVector(self, *args)


    def TransformDiffusionTensor3D(self, *args) -> "itkVariableLengthVectorD":
        """
        TransformDiffusionTensor3D(itkTransformD32 self, itkDiffusionTensor3DD arg0) -> itkDiffusionTensor3DD
        TransformDiffusionTensor3D(itkTransformD32 self, itkDiffusionTensor3DD tensor, itkPointD3 point) -> itkDiffusionTensor3DD
        TransformDiffusionTensor3D(itkTransformD32 self, itkVariableLengthVectorD arg0) -> itkVariableLengthVectorD
        TransformDiffusionTensor3D(itkTransformD32 self, itkVariableLengthVectorD tensor, itkPointD3 point) -> itkVariableLengthVectorD

        Method
        to transform a diffusion tensor stored in a VectorImage 
        """
        return _itkTransformBasePython.itkTransformD32_TransformDiffusionTensor3D(self, *args)


    def TransformSymmetricSecondRankTensor(self, *args) -> "itkVariableLengthVectorD":
        """
        TransformSymmetricSecondRankTensor(itkTransformD32 self, itkSymmetricSecondRankTensorD3 tensor, itkPointD3 point) -> itkSymmetricSecondRankTensorD2
        TransformSymmetricSecondRankTensor(itkTransformD32 self, itkSymmetricSecondRankTensorD3 arg0) -> itkSymmetricSecondRankTensorD2
        TransformSymmetricSecondRankTensor(itkTransformD32 self, itkVariableLengthVectorD arg0) -> itkVariableLengthVectorD
        TransformSymmetricSecondRankTensor(itkTransformD32 self, itkVariableLengthVectorD tensor, itkPointD3 point) -> itkVariableLengthVectorD

        Method to transform a diffusion tensor stored in a VectorImage, at a
        point. Global transforms can ignore the point parameter. Local
        transforms (e.g. deformation field transform) must override and
        provide required behavior. By default, point is ignored and
        TransformDiffusionTensor(tensor) is called 
        """
        return _itkTransformBasePython.itkTransformD32_TransformSymmetricSecondRankTensor(self, *args)


    def UpdateTransformParameters(self, update: 'itkArrayD', factor: 'double'=1.) -> "void":
        """
        UpdateTransformParameters(itkTransformD32 self, itkArrayD update, double factor=1.)
        UpdateTransformParameters(itkTransformD32 self, itkArrayD update)

        Update
        the transform's parameters by the values in update.

        Parameters:
        -----------

        update:  must be of the same length as returned by
        GetNumberOfParameters(). Throw an exception otherwise.

        factor:  is a scalar multiplier for each value in update.
        SetParameters is called at the end of this method, to allow the
        transform to perform any required operations on the updated parameters
        - typically a conversion to member variables for use in
        TransformPoint. 
        """
        return _itkTransformBasePython.itkTransformD32_UpdateTransformParameters(self, update, factor)


    def GetNumberOfLocalParameters(self) -> "unsigned long":
        """
        GetNumberOfLocalParameters(itkTransformD32 self) -> unsigned long

        Return
        the number of local parameters that completely defines the Transform
        at an individual voxel. For transforms with local support, this will
        enable downstream computation of the jacobian wrt only the local
        support region. For instance, in the case of a deformation field, this
        will be equal to the number of image dimensions. If it is an affine
        transform, this will be the same as the GetNumberOfParameters(). 
        """
        return _itkTransformBasePython.itkTransformD32_GetNumberOfLocalParameters(self)


    def GetNumberOfFixedParameters(self) -> "unsigned long":
        """
        GetNumberOfFixedParameters(itkTransformD32 self) -> unsigned long

        Return
        the number of parameters that define the constant elements of a
        Transfom 
        """
        return _itkTransformBasePython.itkTransformD32_GetNumberOfFixedParameters(self)


    def GetInverse(self, arg0: 'itkTransformD32') -> "bool":
        """
        GetInverse(itkTransformD32 self, itkTransformD32 arg0) -> bool

        Returns a boolean
        indicating whether it is possible or not to compute the inverse of
        this current Transform. If it is possible, then the inverse of the
        transform is returned in the inverseTransform variable passed by the
        user. The inverse is recomputed if this current transform has been
        modified. This method is intended to be overriden as needed by derived
        classes. 
        """
        return _itkTransformBasePython.itkTransformD32_GetInverse(self, arg0)


    def GetInverseTransform(self) -> "itkTransformD23_Pointer":
        """
        GetInverseTransform(itkTransformD32 self) -> itkTransformD23_Pointer

        Return an
        inverse of this transform. If the inverse has not been implemented,
        return nullptr. The type of the inverse transform does not necessarily
        need to match the type of the forward transform. This allows one to
        return a numeric inverse transform instead. 
        """
        return _itkTransformBasePython.itkTransformD32_GetInverseTransform(self)


    def IsLinear(self) -> "bool":
        """IsLinear(itkTransformD32 self) -> bool"""
        return _itkTransformBasePython.itkTransformD32_IsLinear(self)


    def ComputeJacobianWithRespectToParameters(self, arg0: 'itkPointD3', arg1: 'itkArray2DD') -> "void":
        """
        ComputeJacobianWithRespectToParameters(itkTransformD32 self, itkPointD3 arg0, itkArray2DD arg1)

        Compute the
        Jacobian of the transformation

        This method computes the Jacobian matrix of the transformation at a
        given input point. The rank of the Jacobian will also indicate if the
        transform is invertible at this point.

        The Jacobian is be expressed as a matrix of partial derivatives of the
        output point components with respect to the parameters that defined
        the transform:

        \\[ J=\\left[ \\begin{array}{cccc} \\frac{\\partial
        x_{1}}{\\partial p_{1}} & \\frac{\\partial x_{1}}{\\partial
        p_{2}} & \\cdots & \\frac{\\partial x_{1}}{\\partial
        p_{m}}\\\\ \\frac{\\partial x_{2}}{\\partial p_{1}} &
        \\frac{\\partial x_{2}}{\\partial p_{2}} & \\cdots &
        \\frac{\\partial x_{2}}{\\partial p_{m}}\\\\ \\vdots &
        \\vdots & \\ddots & \\vdots \\\\ \\frac{\\partial
        x_{n}}{\\partial p_{1}} & \\frac{\\partial x_{n}}{\\partial
        p_{2}} & \\cdots & \\frac{\\partial x_{n}}{\\partial p_{m}}
        \\end{array}\\right] \\]

        This is also used for efficient computation of a point-local jacobian
        for dense transforms. jacobian is assumed to be thread-local variable,
        otherwise memory corruption will most likely occur during multi-
        threading. To avoid repetitive memory allocation, pass in 'jacobian'
        with its size already set. 
        """
        return _itkTransformBasePython.itkTransformD32_ComputeJacobianWithRespectToParameters(self, arg0, arg1)


    def ComputeJacobianWithRespectToParametersCachedTemporaries(self, p: 'itkPointD3', jacobian: 'itkArray2DD', arg2: 'itkArray2DD') -> "void":
        """ComputeJacobianWithRespectToParametersCachedTemporaries(itkTransformD32 self, itkPointD3 p, itkArray2DD jacobian, itkArray2DD arg2)"""
        return _itkTransformBasePython.itkTransformD32_ComputeJacobianWithRespectToParametersCachedTemporaries(self, p, jacobian, arg2)


    def ComputeJacobianWithRespectToPosition(self, arg0: 'itkPointD3', arg1: 'vnl_matrix_fixedD_2_3') -> "void":
        """
        ComputeJacobianWithRespectToPosition(itkTransformD32 self, itkPointD3 arg0, vnl_matrix_fixedD_2_3 arg1)

        This provides the ability to get a local jacobian value in a
        dense/local transform, e.g. DisplacementFieldTransform. For such
        transforms it would be unclear what parameters would refer to.
        Generally, global transforms should return an identity jacobian since
        there is no change with respect to position. 
        """
        return _itkTransformBasePython.itkTransformD32_ComputeJacobianWithRespectToPosition(self, arg0, arg1)


    def ComputeInverseJacobianWithRespectToPosition(self, x: 'itkPointD3', jacobian: 'vnl_matrix_fixed< double,3,2 > &') -> "void":
        """
        ComputeInverseJacobianWithRespectToPosition(itkTransformD32 self, itkPointD3 x, vnl_matrix_fixed< double,3,2 > & jacobian)

        This provides
        the ability to get a local jacobian value in a dense/local transform,
        e.g. DisplacementFieldTransform. For such transforms it would be
        unclear what parameters would refer to. Generally, global transforms
        should return an identity jacobian since there is no change with
        respect to position. 
        """
        return _itkTransformBasePython.itkTransformD32_ComputeInverseJacobianWithRespectToPosition(self, x, jacobian)

    __swig_destroy__ = _itkTransformBasePython.delete_itkTransformD32

    def cast(obj: 'itkLightObject') -> "itkTransformD32 *":
        """cast(itkLightObject obj) -> itkTransformD32"""
        return _itkTransformBasePython.itkTransformD32_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkTransformD32

        Create a new object of the class itkTransformD32 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkTransformD32.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkTransformD32.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkTransformD32.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkTransformD32.Clone = new_instancemethod(_itkTransformBasePython.itkTransformD32_Clone, None, itkTransformD32)
itkTransformD32.TransformPoint = new_instancemethod(_itkTransformBasePython.itkTransformD32_TransformPoint, None, itkTransformD32)
itkTransformD32.TransformVector = new_instancemethod(_itkTransformBasePython.itkTransformD32_TransformVector, None, itkTransformD32)
itkTransformD32.TransformCovariantVector = new_instancemethod(_itkTransformBasePython.itkTransformD32_TransformCovariantVector, None, itkTransformD32)
itkTransformD32.TransformDiffusionTensor3D = new_instancemethod(_itkTransformBasePython.itkTransformD32_TransformDiffusionTensor3D, None, itkTransformD32)
itkTransformD32.TransformSymmetricSecondRankTensor = new_instancemethod(_itkTransformBasePython.itkTransformD32_TransformSymmetricSecondRankTensor, None, itkTransformD32)
itkTransformD32.UpdateTransformParameters = new_instancemethod(_itkTransformBasePython.itkTransformD32_UpdateTransformParameters, None, itkTransformD32)
itkTransformD32.GetNumberOfLocalParameters = new_instancemethod(_itkTransformBasePython.itkTransformD32_GetNumberOfLocalParameters, None, itkTransformD32)
itkTransformD32.GetNumberOfFixedParameters = new_instancemethod(_itkTransformBasePython.itkTransformD32_GetNumberOfFixedParameters, None, itkTransformD32)
itkTransformD32.GetInverse = new_instancemethod(_itkTransformBasePython.itkTransformD32_GetInverse, None, itkTransformD32)
itkTransformD32.GetInverseTransform = new_instancemethod(_itkTransformBasePython.itkTransformD32_GetInverseTransform, None, itkTransformD32)
itkTransformD32.IsLinear = new_instancemethod(_itkTransformBasePython.itkTransformD32_IsLinear, None, itkTransformD32)
itkTransformD32.ComputeJacobianWithRespectToParameters = new_instancemethod(_itkTransformBasePython.itkTransformD32_ComputeJacobianWithRespectToParameters, None, itkTransformD32)
itkTransformD32.ComputeJacobianWithRespectToParametersCachedTemporaries = new_instancemethod(_itkTransformBasePython.itkTransformD32_ComputeJacobianWithRespectToParametersCachedTemporaries, None, itkTransformD32)
itkTransformD32.ComputeJacobianWithRespectToPosition = new_instancemethod(_itkTransformBasePython.itkTransformD32_ComputeJacobianWithRespectToPosition, None, itkTransformD32)
itkTransformD32.ComputeInverseJacobianWithRespectToPosition = new_instancemethod(_itkTransformBasePython.itkTransformD32_ComputeInverseJacobianWithRespectToPosition, None, itkTransformD32)
itkTransformD32_swigregister = _itkTransformBasePython.itkTransformD32_swigregister
itkTransformD32_swigregister(itkTransformD32)

def itkTransformD32_cast(obj: 'itkLightObject') -> "itkTransformD32 *":
    """itkTransformD32_cast(itkLightObject obj) -> itkTransformD32"""
    return _itkTransformBasePython.itkTransformD32_cast(obj)

class itkTransformD33(itkTransformBaseTemplateD):
    """


    Transform points and vectors from an input space to an output space.

    This abstract class defines the generic interface for a geometric
    transformation from one space to another. The class provides methods
    for mapping points, vectors and covariant vectors from the input space
    to the output space.

    Given that transformations are not necessarily invertible, this basic
    class does not provide the methods for back transformation. Back
    transform methods are implemented in derived classes where
    appropriate.

    Registration Framework Support Typically a Transform class has several
    methods for setting its parameters. For use in the registration
    framework, the parameters must also be represented by an array of
    doubles to allow communication with generic optimizers. The Array of
    transformation parameters is set using the SetParameters() method.
    Another requirement of the registration framework is the computation
    of the transform Jacobian. In general, an ImageToImageMetric requires
    the knowledge of the Jacobian in order to compute the metric
    derivatives. The Jacobian is a matrix whose element are the partial
    derivatives of the output point with respect to the array of
    parameters that defines the transform.

    Subclasses must provide implementations for:  virtual OutputPointType
    TransformPoint(const InputPointType  &) const  virtual
    OutputVectorType TransformVector(const InputVectorType &) const
    virtual OutputVnlVectorType TransformVector(const InputVnlVectorType
    &) const  virtual OutputCovariantVectorType
    TransformCovariantVector(const InputCovariantVectorType &) const
    virtual void SetParameters(const ParametersType &)  virtual void
    SetFixedParameters(const FixedParametersType &)  virtual void
    ComputeJacobianWithRespectToParameters( const InputPointType &,
    JacobianType &) const  virtual void
    ComputeJacobianWithRespectToPosition( const InputPointType & x,
    JacobianPositionType &jacobian ) const;

    Since TranformVector and TransformCovariantVector have multiple
    overloaded methods from the base class, subclasses must specify:
    using Superclass::TransformVector;  using
    Superclass::TransformCovariantVector;

    C++ includes: itkTransform.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Clone(self) -> "itkTransformD33_Pointer":
        """Clone(itkTransformD33 self) -> itkTransformD33_Pointer"""
        return _itkTransformBasePython.itkTransformD33_Clone(self)


    def TransformPoint(self, arg0: 'itkPointD3') -> "itkPointD3":
        """
        TransformPoint(itkTransformD33 self, itkPointD3 arg0) -> itkPointD3

        Method to transform
        a point. WARNING:  This method must be thread-safe. See, e.g., its use
        in ResampleImageFilter. 
        """
        return _itkTransformBasePython.itkTransformD33_TransformPoint(self, arg0)


    def TransformVector(self, *args) -> "itkVariableLengthVectorD":
        """
        TransformVector(itkTransformD33 self, itkVectorD3 arg0) -> itkVectorD3
        TransformVector(itkTransformD33 self, itkVectorD3 vector, itkPointD3 point) -> itkVectorD3
        TransformVector(itkTransformD33 self, vnl_vector_fixed< double,3 > const & arg0) -> vnl_vector_fixed< double,3 >
        TransformVector(itkTransformD33 self, vnl_vector_fixed< double,3 > const & vector, itkPointD3 point) -> vnl_vector_fixed< double,3 >
        TransformVector(itkTransformD33 self, itkVariableLengthVectorD arg0) -> itkVariableLengthVectorD
        TransformVector(itkTransformD33 self, itkVariableLengthVectorD vector, itkPointD3 point) -> itkVariableLengthVectorD

        Method to transform
        a vector stored in a VectorImage, at a point. For global transforms,
        point is ignored and TransformVector( vector ) is called. Local
        transforms (e.g. deformation field transform) must override and
        provide required behavior. 
        """
        return _itkTransformBasePython.itkTransformD33_TransformVector(self, *args)


    def TransformCovariantVector(self, *args) -> "itkVariableLengthVectorD":
        """
        TransformCovariantVector(itkTransformD33 self, itkCovariantVectorD3 arg0) -> itkCovariantVectorD3
        TransformCovariantVector(itkTransformD33 self, itkCovariantVectorD3 vector, itkPointD3 point) -> itkCovariantVectorD3
        TransformCovariantVector(itkTransformD33 self, itkVariableLengthVectorD arg0) -> itkVariableLengthVectorD
        TransformCovariantVector(itkTransformD33 self, itkVariableLengthVectorD vector, itkPointD3 point) -> itkVariableLengthVectorD

        Method to
        transform a CovariantVector, using a point. Global transforms can
        ignore the point parameter. Local transforms (e.g. deformation field
        transform) must override and provide required behavior. By default,
        point is ignored and TransformCovariantVector(vector) is called 
        """
        return _itkTransformBasePython.itkTransformD33_TransformCovariantVector(self, *args)


    def TransformDiffusionTensor3D(self, *args) -> "itkVariableLengthVectorD":
        """
        TransformDiffusionTensor3D(itkTransformD33 self, itkDiffusionTensor3DD arg0) -> itkDiffusionTensor3DD
        TransformDiffusionTensor3D(itkTransformD33 self, itkDiffusionTensor3DD tensor, itkPointD3 point) -> itkDiffusionTensor3DD
        TransformDiffusionTensor3D(itkTransformD33 self, itkVariableLengthVectorD arg0) -> itkVariableLengthVectorD
        TransformDiffusionTensor3D(itkTransformD33 self, itkVariableLengthVectorD tensor, itkPointD3 point) -> itkVariableLengthVectorD

        Method
        to transform a diffusion tensor stored in a VectorImage 
        """
        return _itkTransformBasePython.itkTransformD33_TransformDiffusionTensor3D(self, *args)


    def TransformSymmetricSecondRankTensor(self, *args) -> "itkVariableLengthVectorD":
        """
        TransformSymmetricSecondRankTensor(itkTransformD33 self, itkSymmetricSecondRankTensorD3 tensor, itkPointD3 point) -> itkSymmetricSecondRankTensorD3
        TransformSymmetricSecondRankTensor(itkTransformD33 self, itkSymmetricSecondRankTensorD3 arg0) -> itkSymmetricSecondRankTensorD3
        TransformSymmetricSecondRankTensor(itkTransformD33 self, itkVariableLengthVectorD arg0) -> itkVariableLengthVectorD
        TransformSymmetricSecondRankTensor(itkTransformD33 self, itkVariableLengthVectorD tensor, itkPointD3 point) -> itkVariableLengthVectorD

        Method to transform a diffusion tensor stored in a VectorImage, at a
        point. Global transforms can ignore the point parameter. Local
        transforms (e.g. deformation field transform) must override and
        provide required behavior. By default, point is ignored and
        TransformDiffusionTensor(tensor) is called 
        """
        return _itkTransformBasePython.itkTransformD33_TransformSymmetricSecondRankTensor(self, *args)


    def UpdateTransformParameters(self, update: 'itkArrayD', factor: 'double'=1.) -> "void":
        """
        UpdateTransformParameters(itkTransformD33 self, itkArrayD update, double factor=1.)
        UpdateTransformParameters(itkTransformD33 self, itkArrayD update)

        Update
        the transform's parameters by the values in update.

        Parameters:
        -----------

        update:  must be of the same length as returned by
        GetNumberOfParameters(). Throw an exception otherwise.

        factor:  is a scalar multiplier for each value in update.
        SetParameters is called at the end of this method, to allow the
        transform to perform any required operations on the updated parameters
        - typically a conversion to member variables for use in
        TransformPoint. 
        """
        return _itkTransformBasePython.itkTransformD33_UpdateTransformParameters(self, update, factor)


    def GetNumberOfLocalParameters(self) -> "unsigned long":
        """
        GetNumberOfLocalParameters(itkTransformD33 self) -> unsigned long

        Return
        the number of local parameters that completely defines the Transform
        at an individual voxel. For transforms with local support, this will
        enable downstream computation of the jacobian wrt only the local
        support region. For instance, in the case of a deformation field, this
        will be equal to the number of image dimensions. If it is an affine
        transform, this will be the same as the GetNumberOfParameters(). 
        """
        return _itkTransformBasePython.itkTransformD33_GetNumberOfLocalParameters(self)


    def GetNumberOfFixedParameters(self) -> "unsigned long":
        """
        GetNumberOfFixedParameters(itkTransformD33 self) -> unsigned long

        Return
        the number of parameters that define the constant elements of a
        Transfom 
        """
        return _itkTransformBasePython.itkTransformD33_GetNumberOfFixedParameters(self)


    def GetInverse(self, arg0: 'itkTransformD33') -> "bool":
        """
        GetInverse(itkTransformD33 self, itkTransformD33 arg0) -> bool

        Returns a boolean
        indicating whether it is possible or not to compute the inverse of
        this current Transform. If it is possible, then the inverse of the
        transform is returned in the inverseTransform variable passed by the
        user. The inverse is recomputed if this current transform has been
        modified. This method is intended to be overriden as needed by derived
        classes. 
        """
        return _itkTransformBasePython.itkTransformD33_GetInverse(self, arg0)


    def GetInverseTransform(self) -> "itkTransformD33_Pointer":
        """
        GetInverseTransform(itkTransformD33 self) -> itkTransformD33_Pointer

        Return an
        inverse of this transform. If the inverse has not been implemented,
        return nullptr. The type of the inverse transform does not necessarily
        need to match the type of the forward transform. This allows one to
        return a numeric inverse transform instead. 
        """
        return _itkTransformBasePython.itkTransformD33_GetInverseTransform(self)


    def IsLinear(self) -> "bool":
        """IsLinear(itkTransformD33 self) -> bool"""
        return _itkTransformBasePython.itkTransformD33_IsLinear(self)


    def ComputeJacobianWithRespectToParameters(self, arg0: 'itkPointD3', arg1: 'itkArray2DD') -> "void":
        """
        ComputeJacobianWithRespectToParameters(itkTransformD33 self, itkPointD3 arg0, itkArray2DD arg1)

        Compute the
        Jacobian of the transformation

        This method computes the Jacobian matrix of the transformation at a
        given input point. The rank of the Jacobian will also indicate if the
        transform is invertible at this point.

        The Jacobian is be expressed as a matrix of partial derivatives of the
        output point components with respect to the parameters that defined
        the transform:

        \\[ J=\\left[ \\begin{array}{cccc} \\frac{\\partial
        x_{1}}{\\partial p_{1}} & \\frac{\\partial x_{1}}{\\partial
        p_{2}} & \\cdots & \\frac{\\partial x_{1}}{\\partial
        p_{m}}\\\\ \\frac{\\partial x_{2}}{\\partial p_{1}} &
        \\frac{\\partial x_{2}}{\\partial p_{2}} & \\cdots &
        \\frac{\\partial x_{2}}{\\partial p_{m}}\\\\ \\vdots &
        \\vdots & \\ddots & \\vdots \\\\ \\frac{\\partial
        x_{n}}{\\partial p_{1}} & \\frac{\\partial x_{n}}{\\partial
        p_{2}} & \\cdots & \\frac{\\partial x_{n}}{\\partial p_{m}}
        \\end{array}\\right] \\]

        This is also used for efficient computation of a point-local jacobian
        for dense transforms. jacobian is assumed to be thread-local variable,
        otherwise memory corruption will most likely occur during multi-
        threading. To avoid repetitive memory allocation, pass in 'jacobian'
        with its size already set. 
        """
        return _itkTransformBasePython.itkTransformD33_ComputeJacobianWithRespectToParameters(self, arg0, arg1)


    def ComputeJacobianWithRespectToParametersCachedTemporaries(self, p: 'itkPointD3', jacobian: 'itkArray2DD', arg2: 'itkArray2DD') -> "void":
        """ComputeJacobianWithRespectToParametersCachedTemporaries(itkTransformD33 self, itkPointD3 p, itkArray2DD jacobian, itkArray2DD arg2)"""
        return _itkTransformBasePython.itkTransformD33_ComputeJacobianWithRespectToParametersCachedTemporaries(self, p, jacobian, arg2)


    def ComputeJacobianWithRespectToPosition(self, arg0: 'itkPointD3', arg1: 'vnl_matrix_fixedD_3_3') -> "void":
        """
        ComputeJacobianWithRespectToPosition(itkTransformD33 self, itkPointD3 arg0, vnl_matrix_fixedD_3_3 arg1)

        This provides the ability to get a local jacobian value in a
        dense/local transform, e.g. DisplacementFieldTransform. For such
        transforms it would be unclear what parameters would refer to.
        Generally, global transforms should return an identity jacobian since
        there is no change with respect to position. 
        """
        return _itkTransformBasePython.itkTransformD33_ComputeJacobianWithRespectToPosition(self, arg0, arg1)


    def ComputeInverseJacobianWithRespectToPosition(self, x: 'itkPointD3', jacobian: 'vnl_matrix_fixedD_3_3') -> "void":
        """
        ComputeInverseJacobianWithRespectToPosition(itkTransformD33 self, itkPointD3 x, vnl_matrix_fixedD_3_3 jacobian)

        This provides
        the ability to get a local jacobian value in a dense/local transform,
        e.g. DisplacementFieldTransform. For such transforms it would be
        unclear what parameters would refer to. Generally, global transforms
        should return an identity jacobian since there is no change with
        respect to position. 
        """
        return _itkTransformBasePython.itkTransformD33_ComputeInverseJacobianWithRespectToPosition(self, x, jacobian)

    __swig_destroy__ = _itkTransformBasePython.delete_itkTransformD33

    def cast(obj: 'itkLightObject') -> "itkTransformD33 *":
        """cast(itkLightObject obj) -> itkTransformD33"""
        return _itkTransformBasePython.itkTransformD33_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkTransformD33

        Create a new object of the class itkTransformD33 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkTransformD33.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkTransformD33.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkTransformD33.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkTransformD33.Clone = new_instancemethod(_itkTransformBasePython.itkTransformD33_Clone, None, itkTransformD33)
itkTransformD33.TransformPoint = new_instancemethod(_itkTransformBasePython.itkTransformD33_TransformPoint, None, itkTransformD33)
itkTransformD33.TransformVector = new_instancemethod(_itkTransformBasePython.itkTransformD33_TransformVector, None, itkTransformD33)
itkTransformD33.TransformCovariantVector = new_instancemethod(_itkTransformBasePython.itkTransformD33_TransformCovariantVector, None, itkTransformD33)
itkTransformD33.TransformDiffusionTensor3D = new_instancemethod(_itkTransformBasePython.itkTransformD33_TransformDiffusionTensor3D, None, itkTransformD33)
itkTransformD33.TransformSymmetricSecondRankTensor = new_instancemethod(_itkTransformBasePython.itkTransformD33_TransformSymmetricSecondRankTensor, None, itkTransformD33)
itkTransformD33.UpdateTransformParameters = new_instancemethod(_itkTransformBasePython.itkTransformD33_UpdateTransformParameters, None, itkTransformD33)
itkTransformD33.GetNumberOfLocalParameters = new_instancemethod(_itkTransformBasePython.itkTransformD33_GetNumberOfLocalParameters, None, itkTransformD33)
itkTransformD33.GetNumberOfFixedParameters = new_instancemethod(_itkTransformBasePython.itkTransformD33_GetNumberOfFixedParameters, None, itkTransformD33)
itkTransformD33.GetInverse = new_instancemethod(_itkTransformBasePython.itkTransformD33_GetInverse, None, itkTransformD33)
itkTransformD33.GetInverseTransform = new_instancemethod(_itkTransformBasePython.itkTransformD33_GetInverseTransform, None, itkTransformD33)
itkTransformD33.IsLinear = new_instancemethod(_itkTransformBasePython.itkTransformD33_IsLinear, None, itkTransformD33)
itkTransformD33.ComputeJacobianWithRespectToParameters = new_instancemethod(_itkTransformBasePython.itkTransformD33_ComputeJacobianWithRespectToParameters, None, itkTransformD33)
itkTransformD33.ComputeJacobianWithRespectToParametersCachedTemporaries = new_instancemethod(_itkTransformBasePython.itkTransformD33_ComputeJacobianWithRespectToParametersCachedTemporaries, None, itkTransformD33)
itkTransformD33.ComputeJacobianWithRespectToPosition = new_instancemethod(_itkTransformBasePython.itkTransformD33_ComputeJacobianWithRespectToPosition, None, itkTransformD33)
itkTransformD33.ComputeInverseJacobianWithRespectToPosition = new_instancemethod(_itkTransformBasePython.itkTransformD33_ComputeInverseJacobianWithRespectToPosition, None, itkTransformD33)
itkTransformD33_swigregister = _itkTransformBasePython.itkTransformD33_swigregister
itkTransformD33_swigregister(itkTransformD33)

def itkTransformD33_cast(obj: 'itkLightObject') -> "itkTransformD33 *":
    """itkTransformD33_cast(itkLightObject obj) -> itkTransformD33"""
    return _itkTransformBasePython.itkTransformD33_cast(obj)

class itkTransformF2(itkTransformBaseTemplateF):
    """


    Transform points and vectors from an input space to an output space.

    This abstract class defines the generic interface for a geometric
    transformation from one space to another. The class provides methods
    for mapping points, vectors and covariant vectors from the input space
    to the output space.

    Given that transformations are not necessarily invertible, this basic
    class does not provide the methods for back transformation. Back
    transform methods are implemented in derived classes where
    appropriate.

    Registration Framework Support Typically a Transform class has several
    methods for setting its parameters. For use in the registration
    framework, the parameters must also be represented by an array of
    doubles to allow communication with generic optimizers. The Array of
    transformation parameters is set using the SetParameters() method.
    Another requirement of the registration framework is the computation
    of the transform Jacobian. In general, an ImageToImageMetric requires
    the knowledge of the Jacobian in order to compute the metric
    derivatives. The Jacobian is a matrix whose element are the partial
    derivatives of the output point with respect to the array of
    parameters that defines the transform.

    Subclasses must provide implementations for:  virtual OutputPointType
    TransformPoint(const InputPointType  &) const  virtual
    OutputVectorType TransformVector(const InputVectorType &) const
    virtual OutputVnlVectorType TransformVector(const InputVnlVectorType
    &) const  virtual OutputCovariantVectorType
    TransformCovariantVector(const InputCovariantVectorType &) const
    virtual void SetParameters(const ParametersType &)  virtual void
    SetFixedParameters(const FixedParametersType &)  virtual void
    ComputeJacobianWithRespectToParameters( const InputPointType &,
    JacobianType &) const  virtual void
    ComputeJacobianWithRespectToPosition( const InputPointType & x,
    JacobianPositionType &jacobian ) const;

    Since TranformVector and TransformCovariantVector have multiple
    overloaded methods from the base class, subclasses must specify:
    using Superclass::TransformVector;  using
    Superclass::TransformCovariantVector;

    C++ includes: itkTransform.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Clone(self) -> "itkTransformF23_Pointer":
        """Clone(itkTransformF2 self) -> itkTransformF23_Pointer"""
        return _itkTransformBasePython.itkTransformF2_Clone(self)


    def TransformPoint(self, arg0: 'itkPointF2') -> "itkPointF3":
        """
        TransformPoint(itkTransformF2 self, itkPointF2 arg0) -> itkPointF3

        Method to transform
        a point. WARNING:  This method must be thread-safe. See, e.g., its use
        in ResampleImageFilter. 
        """
        return _itkTransformBasePython.itkTransformF2_TransformPoint(self, arg0)


    def TransformVector(self, *args) -> "itkVariableLengthVectorF":
        """
        TransformVector(itkTransformF2 self, itkVectorF2 arg0) -> itkVectorF3
        TransformVector(itkTransformF2 self, itkVectorF2 vector, itkPointF2 point) -> itkVectorF3
        TransformVector(itkTransformF2 self, vnl_vector_fixed< float,2 > const & arg0) -> vnl_vector_fixed< float,3 >
        TransformVector(itkTransformF2 self, vnl_vector_fixed< float,2 > const & vector, itkPointF2 point) -> vnl_vector_fixed< float,3 >
        TransformVector(itkTransformF2 self, itkVariableLengthVectorF arg0) -> itkVariableLengthVectorF
        TransformVector(itkTransformF2 self, itkVariableLengthVectorF vector, itkPointF2 point) -> itkVariableLengthVectorF

        Method to transform
        a vector stored in a VectorImage, at a point. For global transforms,
        point is ignored and TransformVector( vector ) is called. Local
        transforms (e.g. deformation field transform) must override and
        provide required behavior. 
        """
        return _itkTransformBasePython.itkTransformF2_TransformVector(self, *args)


    def TransformCovariantVector(self, *args) -> "itkVariableLengthVectorF":
        """
        TransformCovariantVector(itkTransformF2 self, itkCovariantVectorF2 arg0) -> itkCovariantVectorF3
        TransformCovariantVector(itkTransformF2 self, itkCovariantVectorF2 vector, itkPointF2 point) -> itkCovariantVectorF3
        TransformCovariantVector(itkTransformF2 self, itkVariableLengthVectorF arg0) -> itkVariableLengthVectorF
        TransformCovariantVector(itkTransformF2 self, itkVariableLengthVectorF vector, itkPointF2 point) -> itkVariableLengthVectorF

        Method to
        transform a CovariantVector, using a point. Global transforms can
        ignore the point parameter. Local transforms (e.g. deformation field
        transform) must override and provide required behavior. By default,
        point is ignored and TransformCovariantVector(vector) is called 
        """
        return _itkTransformBasePython.itkTransformF2_TransformCovariantVector(self, *args)


    def TransformDiffusionTensor3D(self, *args) -> "itkVariableLengthVectorF":
        """
        TransformDiffusionTensor3D(itkTransformF2 self, itkDiffusionTensor3DF arg0) -> itkDiffusionTensor3DF
        TransformDiffusionTensor3D(itkTransformF2 self, itkDiffusionTensor3DF tensor, itkPointF2 point) -> itkDiffusionTensor3DF
        TransformDiffusionTensor3D(itkTransformF2 self, itkVariableLengthVectorF arg0) -> itkVariableLengthVectorF
        TransformDiffusionTensor3D(itkTransformF2 self, itkVariableLengthVectorF tensor, itkPointF2 point) -> itkVariableLengthVectorF

        Method
        to transform a diffusion tensor stored in a VectorImage 
        """
        return _itkTransformBasePython.itkTransformF2_TransformDiffusionTensor3D(self, *args)


    def TransformSymmetricSecondRankTensor(self, *args) -> "itkVariableLengthVectorF":
        """
        TransformSymmetricSecondRankTensor(itkTransformF2 self, itkSymmetricSecondRankTensorF2 tensor, itkPointF2 point) -> itkSymmetricSecondRankTensorF3
        TransformSymmetricSecondRankTensor(itkTransformF2 self, itkSymmetricSecondRankTensorF2 arg0) -> itkSymmetricSecondRankTensorF3
        TransformSymmetricSecondRankTensor(itkTransformF2 self, itkVariableLengthVectorF arg0) -> itkVariableLengthVectorF
        TransformSymmetricSecondRankTensor(itkTransformF2 self, itkVariableLengthVectorF tensor, itkPointF2 point) -> itkVariableLengthVectorF

        Method to transform a diffusion tensor stored in a VectorImage, at a
        point. Global transforms can ignore the point parameter. Local
        transforms (e.g. deformation field transform) must override and
        provide required behavior. By default, point is ignored and
        TransformDiffusionTensor(tensor) is called 
        """
        return _itkTransformBasePython.itkTransformF2_TransformSymmetricSecondRankTensor(self, *args)


    def UpdateTransformParameters(self, update: 'itkArrayF', factor: 'float'=1.) -> "void":
        """
        UpdateTransformParameters(itkTransformF2 self, itkArrayF update, float factor=1.)
        UpdateTransformParameters(itkTransformF2 self, itkArrayF update)

        Update
        the transform's parameters by the values in update.

        Parameters:
        -----------

        update:  must be of the same length as returned by
        GetNumberOfParameters(). Throw an exception otherwise.

        factor:  is a scalar multiplier for each value in update.
        SetParameters is called at the end of this method, to allow the
        transform to perform any required operations on the updated parameters
        - typically a conversion to member variables for use in
        TransformPoint. 
        """
        return _itkTransformBasePython.itkTransformF2_UpdateTransformParameters(self, update, factor)


    def GetNumberOfLocalParameters(self) -> "unsigned long":
        """
        GetNumberOfLocalParameters(itkTransformF2 self) -> unsigned long

        Return
        the number of local parameters that completely defines the Transform
        at an individual voxel. For transforms with local support, this will
        enable downstream computation of the jacobian wrt only the local
        support region. For instance, in the case of a deformation field, this
        will be equal to the number of image dimensions. If it is an affine
        transform, this will be the same as the GetNumberOfParameters(). 
        """
        return _itkTransformBasePython.itkTransformF2_GetNumberOfLocalParameters(self)


    def GetNumberOfFixedParameters(self) -> "unsigned long":
        """
        GetNumberOfFixedParameters(itkTransformF2 self) -> unsigned long

        Return
        the number of parameters that define the constant elements of a
        Transfom 
        """
        return _itkTransformBasePython.itkTransformF2_GetNumberOfFixedParameters(self)


    def GetInverse(self, arg0: 'itkTransformF23') -> "bool":
        """
        GetInverse(itkTransformF2 self, itkTransformF23 arg0) -> bool

        Returns a boolean
        indicating whether it is possible or not to compute the inverse of
        this current Transform. If it is possible, then the inverse of the
        transform is returned in the inverseTransform variable passed by the
        user. The inverse is recomputed if this current transform has been
        modified. This method is intended to be overriden as needed by derived
        classes. 
        """
        return _itkTransformBasePython.itkTransformF2_GetInverse(self, arg0)


    def GetInverseTransform(self) -> "itkTransformF32_Pointer":
        """
        GetInverseTransform(itkTransformF2 self) -> itkTransformF32_Pointer

        Return an
        inverse of this transform. If the inverse has not been implemented,
        return nullptr. The type of the inverse transform does not necessarily
        need to match the type of the forward transform. This allows one to
        return a numeric inverse transform instead. 
        """
        return _itkTransformBasePython.itkTransformF2_GetInverseTransform(self)


    def IsLinear(self) -> "bool":
        """IsLinear(itkTransformF2 self) -> bool"""
        return _itkTransformBasePython.itkTransformF2_IsLinear(self)


    def ComputeJacobianWithRespectToParameters(self, arg0: 'itkPointF2', arg1: 'itkArray2DF') -> "void":
        """
        ComputeJacobianWithRespectToParameters(itkTransformF2 self, itkPointF2 arg0, itkArray2DF arg1)

        Compute the
        Jacobian of the transformation

        This method computes the Jacobian matrix of the transformation at a
        given input point. The rank of the Jacobian will also indicate if the
        transform is invertible at this point.

        The Jacobian is be expressed as a matrix of partial derivatives of the
        output point components with respect to the parameters that defined
        the transform:

        \\[ J=\\left[ \\begin{array}{cccc} \\frac{\\partial
        x_{1}}{\\partial p_{1}} & \\frac{\\partial x_{1}}{\\partial
        p_{2}} & \\cdots & \\frac{\\partial x_{1}}{\\partial
        p_{m}}\\\\ \\frac{\\partial x_{2}}{\\partial p_{1}} &
        \\frac{\\partial x_{2}}{\\partial p_{2}} & \\cdots &
        \\frac{\\partial x_{2}}{\\partial p_{m}}\\\\ \\vdots &
        \\vdots & \\ddots & \\vdots \\\\ \\frac{\\partial
        x_{n}}{\\partial p_{1}} & \\frac{\\partial x_{n}}{\\partial
        p_{2}} & \\cdots & \\frac{\\partial x_{n}}{\\partial p_{m}}
        \\end{array}\\right] \\]

        This is also used for efficient computation of a point-local jacobian
        for dense transforms. jacobian is assumed to be thread-local variable,
        otherwise memory corruption will most likely occur during multi-
        threading. To avoid repetitive memory allocation, pass in 'jacobian'
        with its size already set. 
        """
        return _itkTransformBasePython.itkTransformF2_ComputeJacobianWithRespectToParameters(self, arg0, arg1)


    def ComputeJacobianWithRespectToParametersCachedTemporaries(self, p: 'itkPointF2', jacobian: 'itkArray2DF', arg2: 'itkArray2DF') -> "void":
        """ComputeJacobianWithRespectToParametersCachedTemporaries(itkTransformF2 self, itkPointF2 p, itkArray2DF jacobian, itkArray2DF arg2)"""
        return _itkTransformBasePython.itkTransformF2_ComputeJacobianWithRespectToParametersCachedTemporaries(self, p, jacobian, arg2)


    def ComputeJacobianWithRespectToPosition(self, arg0: 'itkPointF2', arg1: 'vnl_matrix_fixed< float,3,2 > &') -> "void":
        """
        ComputeJacobianWithRespectToPosition(itkTransformF2 self, itkPointF2 arg0, vnl_matrix_fixed< float,3,2 > & arg1)

        This provides the ability to get a local jacobian value in a
        dense/local transform, e.g. DisplacementFieldTransform. For such
        transforms it would be unclear what parameters would refer to.
        Generally, global transforms should return an identity jacobian since
        there is no change with respect to position. 
        """
        return _itkTransformBasePython.itkTransformF2_ComputeJacobianWithRespectToPosition(self, arg0, arg1)


    def ComputeInverseJacobianWithRespectToPosition(self, x: 'itkPointF2', jacobian: 'vnl_matrix_fixed< float,2,3 > &') -> "void":
        """
        ComputeInverseJacobianWithRespectToPosition(itkTransformF2 self, itkPointF2 x, vnl_matrix_fixed< float,2,3 > & jacobian)

        This provides
        the ability to get a local jacobian value in a dense/local transform,
        e.g. DisplacementFieldTransform. For such transforms it would be
        unclear what parameters would refer to. Generally, global transforms
        should return an identity jacobian since there is no change with
        respect to position. 
        """
        return _itkTransformBasePython.itkTransformF2_ComputeInverseJacobianWithRespectToPosition(self, x, jacobian)

    __swig_destroy__ = _itkTransformBasePython.delete_itkTransformF2

    def cast(obj: 'itkLightObject') -> "itkTransformF2 *":
        """cast(itkLightObject obj) -> itkTransformF2"""
        return _itkTransformBasePython.itkTransformF2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkTransformF2

        Create a new object of the class itkTransformF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkTransformF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkTransformF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkTransformF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkTransformF2.Clone = new_instancemethod(_itkTransformBasePython.itkTransformF2_Clone, None, itkTransformF2)
itkTransformF2.TransformPoint = new_instancemethod(_itkTransformBasePython.itkTransformF2_TransformPoint, None, itkTransformF2)
itkTransformF2.TransformVector = new_instancemethod(_itkTransformBasePython.itkTransformF2_TransformVector, None, itkTransformF2)
itkTransformF2.TransformCovariantVector = new_instancemethod(_itkTransformBasePython.itkTransformF2_TransformCovariantVector, None, itkTransformF2)
itkTransformF2.TransformDiffusionTensor3D = new_instancemethod(_itkTransformBasePython.itkTransformF2_TransformDiffusionTensor3D, None, itkTransformF2)
itkTransformF2.TransformSymmetricSecondRankTensor = new_instancemethod(_itkTransformBasePython.itkTransformF2_TransformSymmetricSecondRankTensor, None, itkTransformF2)
itkTransformF2.UpdateTransformParameters = new_instancemethod(_itkTransformBasePython.itkTransformF2_UpdateTransformParameters, None, itkTransformF2)
itkTransformF2.GetNumberOfLocalParameters = new_instancemethod(_itkTransformBasePython.itkTransformF2_GetNumberOfLocalParameters, None, itkTransformF2)
itkTransformF2.GetNumberOfFixedParameters = new_instancemethod(_itkTransformBasePython.itkTransformF2_GetNumberOfFixedParameters, None, itkTransformF2)
itkTransformF2.GetInverse = new_instancemethod(_itkTransformBasePython.itkTransformF2_GetInverse, None, itkTransformF2)
itkTransformF2.GetInverseTransform = new_instancemethod(_itkTransformBasePython.itkTransformF2_GetInverseTransform, None, itkTransformF2)
itkTransformF2.IsLinear = new_instancemethod(_itkTransformBasePython.itkTransformF2_IsLinear, None, itkTransformF2)
itkTransformF2.ComputeJacobianWithRespectToParameters = new_instancemethod(_itkTransformBasePython.itkTransformF2_ComputeJacobianWithRespectToParameters, None, itkTransformF2)
itkTransformF2.ComputeJacobianWithRespectToParametersCachedTemporaries = new_instancemethod(_itkTransformBasePython.itkTransformF2_ComputeJacobianWithRespectToParametersCachedTemporaries, None, itkTransformF2)
itkTransformF2.ComputeJacobianWithRespectToPosition = new_instancemethod(_itkTransformBasePython.itkTransformF2_ComputeJacobianWithRespectToPosition, None, itkTransformF2)
itkTransformF2.ComputeInverseJacobianWithRespectToPosition = new_instancemethod(_itkTransformBasePython.itkTransformF2_ComputeInverseJacobianWithRespectToPosition, None, itkTransformF2)
itkTransformF2_swigregister = _itkTransformBasePython.itkTransformF2_swigregister
itkTransformF2_swigregister(itkTransformF2)

def itkTransformF2_cast(obj: 'itkLightObject') -> "itkTransformF2 *":
    """itkTransformF2_cast(itkLightObject obj) -> itkTransformF2"""
    return _itkTransformBasePython.itkTransformF2_cast(obj)

class itkTransformF22(itkTransformBaseTemplateF):
    """


    Transform points and vectors from an input space to an output space.

    This abstract class defines the generic interface for a geometric
    transformation from one space to another. The class provides methods
    for mapping points, vectors and covariant vectors from the input space
    to the output space.

    Given that transformations are not necessarily invertible, this basic
    class does not provide the methods for back transformation. Back
    transform methods are implemented in derived classes where
    appropriate.

    Registration Framework Support Typically a Transform class has several
    methods for setting its parameters. For use in the registration
    framework, the parameters must also be represented by an array of
    doubles to allow communication with generic optimizers. The Array of
    transformation parameters is set using the SetParameters() method.
    Another requirement of the registration framework is the computation
    of the transform Jacobian. In general, an ImageToImageMetric requires
    the knowledge of the Jacobian in order to compute the metric
    derivatives. The Jacobian is a matrix whose element are the partial
    derivatives of the output point with respect to the array of
    parameters that defines the transform.

    Subclasses must provide implementations for:  virtual OutputPointType
    TransformPoint(const InputPointType  &) const  virtual
    OutputVectorType TransformVector(const InputVectorType &) const
    virtual OutputVnlVectorType TransformVector(const InputVnlVectorType
    &) const  virtual OutputCovariantVectorType
    TransformCovariantVector(const InputCovariantVectorType &) const
    virtual void SetParameters(const ParametersType &)  virtual void
    SetFixedParameters(const FixedParametersType &)  virtual void
    ComputeJacobianWithRespectToParameters( const InputPointType &,
    JacobianType &) const  virtual void
    ComputeJacobianWithRespectToPosition( const InputPointType & x,
    JacobianPositionType &jacobian ) const;

    Since TranformVector and TransformCovariantVector have multiple
    overloaded methods from the base class, subclasses must specify:
    using Superclass::TransformVector;  using
    Superclass::TransformCovariantVector;

    C++ includes: itkTransform.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Clone(self) -> "itkTransformF22_Pointer":
        """Clone(itkTransformF22 self) -> itkTransformF22_Pointer"""
        return _itkTransformBasePython.itkTransformF22_Clone(self)


    def TransformPoint(self, arg0: 'itkPointF2') -> "itkPointF2":
        """
        TransformPoint(itkTransformF22 self, itkPointF2 arg0) -> itkPointF2

        Method to transform
        a point. WARNING:  This method must be thread-safe. See, e.g., its use
        in ResampleImageFilter. 
        """
        return _itkTransformBasePython.itkTransformF22_TransformPoint(self, arg0)


    def TransformVector(self, *args) -> "itkVariableLengthVectorF":
        """
        TransformVector(itkTransformF22 self, itkVectorF2 arg0) -> itkVectorF2
        TransformVector(itkTransformF22 self, itkVectorF2 vector, itkPointF2 point) -> itkVectorF2
        TransformVector(itkTransformF22 self, vnl_vector_fixed< float,2 > const & arg0) -> vnl_vector_fixed< float,2 >
        TransformVector(itkTransformF22 self, vnl_vector_fixed< float,2 > const & vector, itkPointF2 point) -> vnl_vector_fixed< float,2 >
        TransformVector(itkTransformF22 self, itkVariableLengthVectorF arg0) -> itkVariableLengthVectorF
        TransformVector(itkTransformF22 self, itkVariableLengthVectorF vector, itkPointF2 point) -> itkVariableLengthVectorF

        Method to transform
        a vector stored in a VectorImage, at a point. For global transforms,
        point is ignored and TransformVector( vector ) is called. Local
        transforms (e.g. deformation field transform) must override and
        provide required behavior. 
        """
        return _itkTransformBasePython.itkTransformF22_TransformVector(self, *args)


    def TransformCovariantVector(self, *args) -> "itkVariableLengthVectorF":
        """
        TransformCovariantVector(itkTransformF22 self, itkCovariantVectorF2 arg0) -> itkCovariantVectorF2
        TransformCovariantVector(itkTransformF22 self, itkCovariantVectorF2 vector, itkPointF2 point) -> itkCovariantVectorF2
        TransformCovariantVector(itkTransformF22 self, itkVariableLengthVectorF arg0) -> itkVariableLengthVectorF
        TransformCovariantVector(itkTransformF22 self, itkVariableLengthVectorF vector, itkPointF2 point) -> itkVariableLengthVectorF

        Method to
        transform a CovariantVector, using a point. Global transforms can
        ignore the point parameter. Local transforms (e.g. deformation field
        transform) must override and provide required behavior. By default,
        point is ignored and TransformCovariantVector(vector) is called 
        """
        return _itkTransformBasePython.itkTransformF22_TransformCovariantVector(self, *args)


    def TransformDiffusionTensor3D(self, *args) -> "itkVariableLengthVectorF":
        """
        TransformDiffusionTensor3D(itkTransformF22 self, itkDiffusionTensor3DF arg0) -> itkDiffusionTensor3DF
        TransformDiffusionTensor3D(itkTransformF22 self, itkDiffusionTensor3DF tensor, itkPointF2 point) -> itkDiffusionTensor3DF
        TransformDiffusionTensor3D(itkTransformF22 self, itkVariableLengthVectorF arg0) -> itkVariableLengthVectorF
        TransformDiffusionTensor3D(itkTransformF22 self, itkVariableLengthVectorF tensor, itkPointF2 point) -> itkVariableLengthVectorF

        Method
        to transform a diffusion tensor stored in a VectorImage 
        """
        return _itkTransformBasePython.itkTransformF22_TransformDiffusionTensor3D(self, *args)


    def TransformSymmetricSecondRankTensor(self, *args) -> "itkVariableLengthVectorF":
        """
        TransformSymmetricSecondRankTensor(itkTransformF22 self, itkSymmetricSecondRankTensorF2 tensor, itkPointF2 point) -> itkSymmetricSecondRankTensorF2
        TransformSymmetricSecondRankTensor(itkTransformF22 self, itkSymmetricSecondRankTensorF2 arg0) -> itkSymmetricSecondRankTensorF2
        TransformSymmetricSecondRankTensor(itkTransformF22 self, itkVariableLengthVectorF arg0) -> itkVariableLengthVectorF
        TransformSymmetricSecondRankTensor(itkTransformF22 self, itkVariableLengthVectorF tensor, itkPointF2 point) -> itkVariableLengthVectorF

        Method to transform a diffusion tensor stored in a VectorImage, at a
        point. Global transforms can ignore the point parameter. Local
        transforms (e.g. deformation field transform) must override and
        provide required behavior. By default, point is ignored and
        TransformDiffusionTensor(tensor) is called 
        """
        return _itkTransformBasePython.itkTransformF22_TransformSymmetricSecondRankTensor(self, *args)


    def UpdateTransformParameters(self, update: 'itkArrayF', factor: 'float'=1.) -> "void":
        """
        UpdateTransformParameters(itkTransformF22 self, itkArrayF update, float factor=1.)
        UpdateTransformParameters(itkTransformF22 self, itkArrayF update)

        Update
        the transform's parameters by the values in update.

        Parameters:
        -----------

        update:  must be of the same length as returned by
        GetNumberOfParameters(). Throw an exception otherwise.

        factor:  is a scalar multiplier for each value in update.
        SetParameters is called at the end of this method, to allow the
        transform to perform any required operations on the updated parameters
        - typically a conversion to member variables for use in
        TransformPoint. 
        """
        return _itkTransformBasePython.itkTransformF22_UpdateTransformParameters(self, update, factor)


    def GetNumberOfLocalParameters(self) -> "unsigned long":
        """
        GetNumberOfLocalParameters(itkTransformF22 self) -> unsigned long

        Return
        the number of local parameters that completely defines the Transform
        at an individual voxel. For transforms with local support, this will
        enable downstream computation of the jacobian wrt only the local
        support region. For instance, in the case of a deformation field, this
        will be equal to the number of image dimensions. If it is an affine
        transform, this will be the same as the GetNumberOfParameters(). 
        """
        return _itkTransformBasePython.itkTransformF22_GetNumberOfLocalParameters(self)


    def GetNumberOfFixedParameters(self) -> "unsigned long":
        """
        GetNumberOfFixedParameters(itkTransformF22 self) -> unsigned long

        Return
        the number of parameters that define the constant elements of a
        Transfom 
        """
        return _itkTransformBasePython.itkTransformF22_GetNumberOfFixedParameters(self)


    def GetInverse(self, arg0: 'itkTransformF22') -> "bool":
        """
        GetInverse(itkTransformF22 self, itkTransformF22 arg0) -> bool

        Returns a boolean
        indicating whether it is possible or not to compute the inverse of
        this current Transform. If it is possible, then the inverse of the
        transform is returned in the inverseTransform variable passed by the
        user. The inverse is recomputed if this current transform has been
        modified. This method is intended to be overriden as needed by derived
        classes. 
        """
        return _itkTransformBasePython.itkTransformF22_GetInverse(self, arg0)


    def GetInverseTransform(self) -> "itkTransformF22_Pointer":
        """
        GetInverseTransform(itkTransformF22 self) -> itkTransformF22_Pointer

        Return an
        inverse of this transform. If the inverse has not been implemented,
        return nullptr. The type of the inverse transform does not necessarily
        need to match the type of the forward transform. This allows one to
        return a numeric inverse transform instead. 
        """
        return _itkTransformBasePython.itkTransformF22_GetInverseTransform(self)


    def IsLinear(self) -> "bool":
        """IsLinear(itkTransformF22 self) -> bool"""
        return _itkTransformBasePython.itkTransformF22_IsLinear(self)


    def ComputeJacobianWithRespectToParameters(self, arg0: 'itkPointF2', arg1: 'itkArray2DF') -> "void":
        """
        ComputeJacobianWithRespectToParameters(itkTransformF22 self, itkPointF2 arg0, itkArray2DF arg1)

        Compute the
        Jacobian of the transformation

        This method computes the Jacobian matrix of the transformation at a
        given input point. The rank of the Jacobian will also indicate if the
        transform is invertible at this point.

        The Jacobian is be expressed as a matrix of partial derivatives of the
        output point components with respect to the parameters that defined
        the transform:

        \\[ J=\\left[ \\begin{array}{cccc} \\frac{\\partial
        x_{1}}{\\partial p_{1}} & \\frac{\\partial x_{1}}{\\partial
        p_{2}} & \\cdots & \\frac{\\partial x_{1}}{\\partial
        p_{m}}\\\\ \\frac{\\partial x_{2}}{\\partial p_{1}} &
        \\frac{\\partial x_{2}}{\\partial p_{2}} & \\cdots &
        \\frac{\\partial x_{2}}{\\partial p_{m}}\\\\ \\vdots &
        \\vdots & \\ddots & \\vdots \\\\ \\frac{\\partial
        x_{n}}{\\partial p_{1}} & \\frac{\\partial x_{n}}{\\partial
        p_{2}} & \\cdots & \\frac{\\partial x_{n}}{\\partial p_{m}}
        \\end{array}\\right] \\]

        This is also used for efficient computation of a point-local jacobian
        for dense transforms. jacobian is assumed to be thread-local variable,
        otherwise memory corruption will most likely occur during multi-
        threading. To avoid repetitive memory allocation, pass in 'jacobian'
        with its size already set. 
        """
        return _itkTransformBasePython.itkTransformF22_ComputeJacobianWithRespectToParameters(self, arg0, arg1)


    def ComputeJacobianWithRespectToParametersCachedTemporaries(self, p: 'itkPointF2', jacobian: 'itkArray2DF', arg2: 'itkArray2DF') -> "void":
        """ComputeJacobianWithRespectToParametersCachedTemporaries(itkTransformF22 self, itkPointF2 p, itkArray2DF jacobian, itkArray2DF arg2)"""
        return _itkTransformBasePython.itkTransformF22_ComputeJacobianWithRespectToParametersCachedTemporaries(self, p, jacobian, arg2)


    def ComputeJacobianWithRespectToPosition(self, arg0: 'itkPointF2', arg1: 'vnl_matrix_fixed< float,2,2 > &') -> "void":
        """
        ComputeJacobianWithRespectToPosition(itkTransformF22 self, itkPointF2 arg0, vnl_matrix_fixed< float,2,2 > & arg1)

        This provides the ability to get a local jacobian value in a
        dense/local transform, e.g. DisplacementFieldTransform. For such
        transforms it would be unclear what parameters would refer to.
        Generally, global transforms should return an identity jacobian since
        there is no change with respect to position. 
        """
        return _itkTransformBasePython.itkTransformF22_ComputeJacobianWithRespectToPosition(self, arg0, arg1)


    def ComputeInverseJacobianWithRespectToPosition(self, x: 'itkPointF2', jacobian: 'vnl_matrix_fixed< float,2,2 > &') -> "void":
        """
        ComputeInverseJacobianWithRespectToPosition(itkTransformF22 self, itkPointF2 x, vnl_matrix_fixed< float,2,2 > & jacobian)

        This provides
        the ability to get a local jacobian value in a dense/local transform,
        e.g. DisplacementFieldTransform. For such transforms it would be
        unclear what parameters would refer to. Generally, global transforms
        should return an identity jacobian since there is no change with
        respect to position. 
        """
        return _itkTransformBasePython.itkTransformF22_ComputeInverseJacobianWithRespectToPosition(self, x, jacobian)

    __swig_destroy__ = _itkTransformBasePython.delete_itkTransformF22

    def cast(obj: 'itkLightObject') -> "itkTransformF22 *":
        """cast(itkLightObject obj) -> itkTransformF22"""
        return _itkTransformBasePython.itkTransformF22_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkTransformF22

        Create a new object of the class itkTransformF22 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkTransformF22.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkTransformF22.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkTransformF22.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkTransformF22.Clone = new_instancemethod(_itkTransformBasePython.itkTransformF22_Clone, None, itkTransformF22)
itkTransformF22.TransformPoint = new_instancemethod(_itkTransformBasePython.itkTransformF22_TransformPoint, None, itkTransformF22)
itkTransformF22.TransformVector = new_instancemethod(_itkTransformBasePython.itkTransformF22_TransformVector, None, itkTransformF22)
itkTransformF22.TransformCovariantVector = new_instancemethod(_itkTransformBasePython.itkTransformF22_TransformCovariantVector, None, itkTransformF22)
itkTransformF22.TransformDiffusionTensor3D = new_instancemethod(_itkTransformBasePython.itkTransformF22_TransformDiffusionTensor3D, None, itkTransformF22)
itkTransformF22.TransformSymmetricSecondRankTensor = new_instancemethod(_itkTransformBasePython.itkTransformF22_TransformSymmetricSecondRankTensor, None, itkTransformF22)
itkTransformF22.UpdateTransformParameters = new_instancemethod(_itkTransformBasePython.itkTransformF22_UpdateTransformParameters, None, itkTransformF22)
itkTransformF22.GetNumberOfLocalParameters = new_instancemethod(_itkTransformBasePython.itkTransformF22_GetNumberOfLocalParameters, None, itkTransformF22)
itkTransformF22.GetNumberOfFixedParameters = new_instancemethod(_itkTransformBasePython.itkTransformF22_GetNumberOfFixedParameters, None, itkTransformF22)
itkTransformF22.GetInverse = new_instancemethod(_itkTransformBasePython.itkTransformF22_GetInverse, None, itkTransformF22)
itkTransformF22.GetInverseTransform = new_instancemethod(_itkTransformBasePython.itkTransformF22_GetInverseTransform, None, itkTransformF22)
itkTransformF22.IsLinear = new_instancemethod(_itkTransformBasePython.itkTransformF22_IsLinear, None, itkTransformF22)
itkTransformF22.ComputeJacobianWithRespectToParameters = new_instancemethod(_itkTransformBasePython.itkTransformF22_ComputeJacobianWithRespectToParameters, None, itkTransformF22)
itkTransformF22.ComputeJacobianWithRespectToParametersCachedTemporaries = new_instancemethod(_itkTransformBasePython.itkTransformF22_ComputeJacobianWithRespectToParametersCachedTemporaries, None, itkTransformF22)
itkTransformF22.ComputeJacobianWithRespectToPosition = new_instancemethod(_itkTransformBasePython.itkTransformF22_ComputeJacobianWithRespectToPosition, None, itkTransformF22)
itkTransformF22.ComputeInverseJacobianWithRespectToPosition = new_instancemethod(_itkTransformBasePython.itkTransformF22_ComputeInverseJacobianWithRespectToPosition, None, itkTransformF22)
itkTransformF22_swigregister = _itkTransformBasePython.itkTransformF22_swigregister
itkTransformF22_swigregister(itkTransformF22)

def itkTransformF22_cast(obj: 'itkLightObject') -> "itkTransformF22 *":
    """itkTransformF22_cast(itkLightObject obj) -> itkTransformF22"""
    return _itkTransformBasePython.itkTransformF22_cast(obj)

class itkTransformF23(itkTransformBaseTemplateF):
    """


    Transform points and vectors from an input space to an output space.

    This abstract class defines the generic interface for a geometric
    transformation from one space to another. The class provides methods
    for mapping points, vectors and covariant vectors from the input space
    to the output space.

    Given that transformations are not necessarily invertible, this basic
    class does not provide the methods for back transformation. Back
    transform methods are implemented in derived classes where
    appropriate.

    Registration Framework Support Typically a Transform class has several
    methods for setting its parameters. For use in the registration
    framework, the parameters must also be represented by an array of
    doubles to allow communication with generic optimizers. The Array of
    transformation parameters is set using the SetParameters() method.
    Another requirement of the registration framework is the computation
    of the transform Jacobian. In general, an ImageToImageMetric requires
    the knowledge of the Jacobian in order to compute the metric
    derivatives. The Jacobian is a matrix whose element are the partial
    derivatives of the output point with respect to the array of
    parameters that defines the transform.

    Subclasses must provide implementations for:  virtual OutputPointType
    TransformPoint(const InputPointType  &) const  virtual
    OutputVectorType TransformVector(const InputVectorType &) const
    virtual OutputVnlVectorType TransformVector(const InputVnlVectorType
    &) const  virtual OutputCovariantVectorType
    TransformCovariantVector(const InputCovariantVectorType &) const
    virtual void SetParameters(const ParametersType &)  virtual void
    SetFixedParameters(const FixedParametersType &)  virtual void
    ComputeJacobianWithRespectToParameters( const InputPointType &,
    JacobianType &) const  virtual void
    ComputeJacobianWithRespectToPosition( const InputPointType & x,
    JacobianPositionType &jacobian ) const;

    Since TranformVector and TransformCovariantVector have multiple
    overloaded methods from the base class, subclasses must specify:
    using Superclass::TransformVector;  using
    Superclass::TransformCovariantVector;

    C++ includes: itkTransform.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Clone(self) -> "itkTransformF23_Pointer":
        """Clone(itkTransformF23 self) -> itkTransformF23_Pointer"""
        return _itkTransformBasePython.itkTransformF23_Clone(self)


    def TransformPoint(self, arg0: 'itkPointF2') -> "itkPointF3":
        """
        TransformPoint(itkTransformF23 self, itkPointF2 arg0) -> itkPointF3

        Method to transform
        a point. WARNING:  This method must be thread-safe. See, e.g., its use
        in ResampleImageFilter. 
        """
        return _itkTransformBasePython.itkTransformF23_TransformPoint(self, arg0)


    def TransformVector(self, *args) -> "itkVariableLengthVectorF":
        """
        TransformVector(itkTransformF23 self, itkVectorF2 arg0) -> itkVectorF3
        TransformVector(itkTransformF23 self, itkVectorF2 vector, itkPointF2 point) -> itkVectorF3
        TransformVector(itkTransformF23 self, vnl_vector_fixed< float,2 > const & arg0) -> vnl_vector_fixed< float,3 >
        TransformVector(itkTransformF23 self, vnl_vector_fixed< float,2 > const & vector, itkPointF2 point) -> vnl_vector_fixed< float,3 >
        TransformVector(itkTransformF23 self, itkVariableLengthVectorF arg0) -> itkVariableLengthVectorF
        TransformVector(itkTransformF23 self, itkVariableLengthVectorF vector, itkPointF2 point) -> itkVariableLengthVectorF

        Method to transform
        a vector stored in a VectorImage, at a point. For global transforms,
        point is ignored and TransformVector( vector ) is called. Local
        transforms (e.g. deformation field transform) must override and
        provide required behavior. 
        """
        return _itkTransformBasePython.itkTransformF23_TransformVector(self, *args)


    def TransformCovariantVector(self, *args) -> "itkVariableLengthVectorF":
        """
        TransformCovariantVector(itkTransformF23 self, itkCovariantVectorF2 arg0) -> itkCovariantVectorF3
        TransformCovariantVector(itkTransformF23 self, itkCovariantVectorF2 vector, itkPointF2 point) -> itkCovariantVectorF3
        TransformCovariantVector(itkTransformF23 self, itkVariableLengthVectorF arg0) -> itkVariableLengthVectorF
        TransformCovariantVector(itkTransformF23 self, itkVariableLengthVectorF vector, itkPointF2 point) -> itkVariableLengthVectorF

        Method to
        transform a CovariantVector, using a point. Global transforms can
        ignore the point parameter. Local transforms (e.g. deformation field
        transform) must override and provide required behavior. By default,
        point is ignored and TransformCovariantVector(vector) is called 
        """
        return _itkTransformBasePython.itkTransformF23_TransformCovariantVector(self, *args)


    def TransformDiffusionTensor3D(self, *args) -> "itkVariableLengthVectorF":
        """
        TransformDiffusionTensor3D(itkTransformF23 self, itkDiffusionTensor3DF arg0) -> itkDiffusionTensor3DF
        TransformDiffusionTensor3D(itkTransformF23 self, itkDiffusionTensor3DF tensor, itkPointF2 point) -> itkDiffusionTensor3DF
        TransformDiffusionTensor3D(itkTransformF23 self, itkVariableLengthVectorF arg0) -> itkVariableLengthVectorF
        TransformDiffusionTensor3D(itkTransformF23 self, itkVariableLengthVectorF tensor, itkPointF2 point) -> itkVariableLengthVectorF

        Method
        to transform a diffusion tensor stored in a VectorImage 
        """
        return _itkTransformBasePython.itkTransformF23_TransformDiffusionTensor3D(self, *args)


    def TransformSymmetricSecondRankTensor(self, *args) -> "itkVariableLengthVectorF":
        """
        TransformSymmetricSecondRankTensor(itkTransformF23 self, itkSymmetricSecondRankTensorF2 tensor, itkPointF2 point) -> itkSymmetricSecondRankTensorF3
        TransformSymmetricSecondRankTensor(itkTransformF23 self, itkSymmetricSecondRankTensorF2 arg0) -> itkSymmetricSecondRankTensorF3
        TransformSymmetricSecondRankTensor(itkTransformF23 self, itkVariableLengthVectorF arg0) -> itkVariableLengthVectorF
        TransformSymmetricSecondRankTensor(itkTransformF23 self, itkVariableLengthVectorF tensor, itkPointF2 point) -> itkVariableLengthVectorF

        Method to transform a diffusion tensor stored in a VectorImage, at a
        point. Global transforms can ignore the point parameter. Local
        transforms (e.g. deformation field transform) must override and
        provide required behavior. By default, point is ignored and
        TransformDiffusionTensor(tensor) is called 
        """
        return _itkTransformBasePython.itkTransformF23_TransformSymmetricSecondRankTensor(self, *args)


    def UpdateTransformParameters(self, update: 'itkArrayF', factor: 'float'=1.) -> "void":
        """
        UpdateTransformParameters(itkTransformF23 self, itkArrayF update, float factor=1.)
        UpdateTransformParameters(itkTransformF23 self, itkArrayF update)

        Update
        the transform's parameters by the values in update.

        Parameters:
        -----------

        update:  must be of the same length as returned by
        GetNumberOfParameters(). Throw an exception otherwise.

        factor:  is a scalar multiplier for each value in update.
        SetParameters is called at the end of this method, to allow the
        transform to perform any required operations on the updated parameters
        - typically a conversion to member variables for use in
        TransformPoint. 
        """
        return _itkTransformBasePython.itkTransformF23_UpdateTransformParameters(self, update, factor)


    def GetNumberOfLocalParameters(self) -> "unsigned long":
        """
        GetNumberOfLocalParameters(itkTransformF23 self) -> unsigned long

        Return
        the number of local parameters that completely defines the Transform
        at an individual voxel. For transforms with local support, this will
        enable downstream computation of the jacobian wrt only the local
        support region. For instance, in the case of a deformation field, this
        will be equal to the number of image dimensions. If it is an affine
        transform, this will be the same as the GetNumberOfParameters(). 
        """
        return _itkTransformBasePython.itkTransformF23_GetNumberOfLocalParameters(self)


    def GetNumberOfFixedParameters(self) -> "unsigned long":
        """
        GetNumberOfFixedParameters(itkTransformF23 self) -> unsigned long

        Return
        the number of parameters that define the constant elements of a
        Transfom 
        """
        return _itkTransformBasePython.itkTransformF23_GetNumberOfFixedParameters(self)


    def GetInverse(self, arg0: 'itkTransformF23') -> "bool":
        """
        GetInverse(itkTransformF23 self, itkTransformF23 arg0) -> bool

        Returns a boolean
        indicating whether it is possible or not to compute the inverse of
        this current Transform. If it is possible, then the inverse of the
        transform is returned in the inverseTransform variable passed by the
        user. The inverse is recomputed if this current transform has been
        modified. This method is intended to be overriden as needed by derived
        classes. 
        """
        return _itkTransformBasePython.itkTransformF23_GetInverse(self, arg0)


    def GetInverseTransform(self) -> "itkTransformF32_Pointer":
        """
        GetInverseTransform(itkTransformF23 self) -> itkTransformF32_Pointer

        Return an
        inverse of this transform. If the inverse has not been implemented,
        return nullptr. The type of the inverse transform does not necessarily
        need to match the type of the forward transform. This allows one to
        return a numeric inverse transform instead. 
        """
        return _itkTransformBasePython.itkTransformF23_GetInverseTransform(self)


    def IsLinear(self) -> "bool":
        """IsLinear(itkTransformF23 self) -> bool"""
        return _itkTransformBasePython.itkTransformF23_IsLinear(self)


    def ComputeJacobianWithRespectToParameters(self, arg0: 'itkPointF2', arg1: 'itkArray2DF') -> "void":
        """
        ComputeJacobianWithRespectToParameters(itkTransformF23 self, itkPointF2 arg0, itkArray2DF arg1)

        Compute the
        Jacobian of the transformation

        This method computes the Jacobian matrix of the transformation at a
        given input point. The rank of the Jacobian will also indicate if the
        transform is invertible at this point.

        The Jacobian is be expressed as a matrix of partial derivatives of the
        output point components with respect to the parameters that defined
        the transform:

        \\[ J=\\left[ \\begin{array}{cccc} \\frac{\\partial
        x_{1}}{\\partial p_{1}} & \\frac{\\partial x_{1}}{\\partial
        p_{2}} & \\cdots & \\frac{\\partial x_{1}}{\\partial
        p_{m}}\\\\ \\frac{\\partial x_{2}}{\\partial p_{1}} &
        \\frac{\\partial x_{2}}{\\partial p_{2}} & \\cdots &
        \\frac{\\partial x_{2}}{\\partial p_{m}}\\\\ \\vdots &
        \\vdots & \\ddots & \\vdots \\\\ \\frac{\\partial
        x_{n}}{\\partial p_{1}} & \\frac{\\partial x_{n}}{\\partial
        p_{2}} & \\cdots & \\frac{\\partial x_{n}}{\\partial p_{m}}
        \\end{array}\\right] \\]

        This is also used for efficient computation of a point-local jacobian
        for dense transforms. jacobian is assumed to be thread-local variable,
        otherwise memory corruption will most likely occur during multi-
        threading. To avoid repetitive memory allocation, pass in 'jacobian'
        with its size already set. 
        """
        return _itkTransformBasePython.itkTransformF23_ComputeJacobianWithRespectToParameters(self, arg0, arg1)


    def ComputeJacobianWithRespectToParametersCachedTemporaries(self, p: 'itkPointF2', jacobian: 'itkArray2DF', arg2: 'itkArray2DF') -> "void":
        """ComputeJacobianWithRespectToParametersCachedTemporaries(itkTransformF23 self, itkPointF2 p, itkArray2DF jacobian, itkArray2DF arg2)"""
        return _itkTransformBasePython.itkTransformF23_ComputeJacobianWithRespectToParametersCachedTemporaries(self, p, jacobian, arg2)


    def ComputeJacobianWithRespectToPosition(self, arg0: 'itkPointF2', arg1: 'vnl_matrix_fixed< float,3,2 > &') -> "void":
        """
        ComputeJacobianWithRespectToPosition(itkTransformF23 self, itkPointF2 arg0, vnl_matrix_fixed< float,3,2 > & arg1)

        This provides the ability to get a local jacobian value in a
        dense/local transform, e.g. DisplacementFieldTransform. For such
        transforms it would be unclear what parameters would refer to.
        Generally, global transforms should return an identity jacobian since
        there is no change with respect to position. 
        """
        return _itkTransformBasePython.itkTransformF23_ComputeJacobianWithRespectToPosition(self, arg0, arg1)


    def ComputeInverseJacobianWithRespectToPosition(self, x: 'itkPointF2', jacobian: 'vnl_matrix_fixed< float,2,3 > &') -> "void":
        """
        ComputeInverseJacobianWithRespectToPosition(itkTransformF23 self, itkPointF2 x, vnl_matrix_fixed< float,2,3 > & jacobian)

        This provides
        the ability to get a local jacobian value in a dense/local transform,
        e.g. DisplacementFieldTransform. For such transforms it would be
        unclear what parameters would refer to. Generally, global transforms
        should return an identity jacobian since there is no change with
        respect to position. 
        """
        return _itkTransformBasePython.itkTransformF23_ComputeInverseJacobianWithRespectToPosition(self, x, jacobian)

    __swig_destroy__ = _itkTransformBasePython.delete_itkTransformF23

    def cast(obj: 'itkLightObject') -> "itkTransformF23 *":
        """cast(itkLightObject obj) -> itkTransformF23"""
        return _itkTransformBasePython.itkTransformF23_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkTransformF23

        Create a new object of the class itkTransformF23 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkTransformF23.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkTransformF23.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkTransformF23.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkTransformF23.Clone = new_instancemethod(_itkTransformBasePython.itkTransformF23_Clone, None, itkTransformF23)
itkTransformF23.TransformPoint = new_instancemethod(_itkTransformBasePython.itkTransformF23_TransformPoint, None, itkTransformF23)
itkTransformF23.TransformVector = new_instancemethod(_itkTransformBasePython.itkTransformF23_TransformVector, None, itkTransformF23)
itkTransformF23.TransformCovariantVector = new_instancemethod(_itkTransformBasePython.itkTransformF23_TransformCovariantVector, None, itkTransformF23)
itkTransformF23.TransformDiffusionTensor3D = new_instancemethod(_itkTransformBasePython.itkTransformF23_TransformDiffusionTensor3D, None, itkTransformF23)
itkTransformF23.TransformSymmetricSecondRankTensor = new_instancemethod(_itkTransformBasePython.itkTransformF23_TransformSymmetricSecondRankTensor, None, itkTransformF23)
itkTransformF23.UpdateTransformParameters = new_instancemethod(_itkTransformBasePython.itkTransformF23_UpdateTransformParameters, None, itkTransformF23)
itkTransformF23.GetNumberOfLocalParameters = new_instancemethod(_itkTransformBasePython.itkTransformF23_GetNumberOfLocalParameters, None, itkTransformF23)
itkTransformF23.GetNumberOfFixedParameters = new_instancemethod(_itkTransformBasePython.itkTransformF23_GetNumberOfFixedParameters, None, itkTransformF23)
itkTransformF23.GetInverse = new_instancemethod(_itkTransformBasePython.itkTransformF23_GetInverse, None, itkTransformF23)
itkTransformF23.GetInverseTransform = new_instancemethod(_itkTransformBasePython.itkTransformF23_GetInverseTransform, None, itkTransformF23)
itkTransformF23.IsLinear = new_instancemethod(_itkTransformBasePython.itkTransformF23_IsLinear, None, itkTransformF23)
itkTransformF23.ComputeJacobianWithRespectToParameters = new_instancemethod(_itkTransformBasePython.itkTransformF23_ComputeJacobianWithRespectToParameters, None, itkTransformF23)
itkTransformF23.ComputeJacobianWithRespectToParametersCachedTemporaries = new_instancemethod(_itkTransformBasePython.itkTransformF23_ComputeJacobianWithRespectToParametersCachedTemporaries, None, itkTransformF23)
itkTransformF23.ComputeJacobianWithRespectToPosition = new_instancemethod(_itkTransformBasePython.itkTransformF23_ComputeJacobianWithRespectToPosition, None, itkTransformF23)
itkTransformF23.ComputeInverseJacobianWithRespectToPosition = new_instancemethod(_itkTransformBasePython.itkTransformF23_ComputeInverseJacobianWithRespectToPosition, None, itkTransformF23)
itkTransformF23_swigregister = _itkTransformBasePython.itkTransformF23_swigregister
itkTransformF23_swigregister(itkTransformF23)

def itkTransformF23_cast(obj: 'itkLightObject') -> "itkTransformF23 *":
    """itkTransformF23_cast(itkLightObject obj) -> itkTransformF23"""
    return _itkTransformBasePython.itkTransformF23_cast(obj)

class itkTransformF3(itkTransformBaseTemplateF):
    """


    Transform points and vectors from an input space to an output space.

    This abstract class defines the generic interface for a geometric
    transformation from one space to another. The class provides methods
    for mapping points, vectors and covariant vectors from the input space
    to the output space.

    Given that transformations are not necessarily invertible, this basic
    class does not provide the methods for back transformation. Back
    transform methods are implemented in derived classes where
    appropriate.

    Registration Framework Support Typically a Transform class has several
    methods for setting its parameters. For use in the registration
    framework, the parameters must also be represented by an array of
    doubles to allow communication with generic optimizers. The Array of
    transformation parameters is set using the SetParameters() method.
    Another requirement of the registration framework is the computation
    of the transform Jacobian. In general, an ImageToImageMetric requires
    the knowledge of the Jacobian in order to compute the metric
    derivatives. The Jacobian is a matrix whose element are the partial
    derivatives of the output point with respect to the array of
    parameters that defines the transform.

    Subclasses must provide implementations for:  virtual OutputPointType
    TransformPoint(const InputPointType  &) const  virtual
    OutputVectorType TransformVector(const InputVectorType &) const
    virtual OutputVnlVectorType TransformVector(const InputVnlVectorType
    &) const  virtual OutputCovariantVectorType
    TransformCovariantVector(const InputCovariantVectorType &) const
    virtual void SetParameters(const ParametersType &)  virtual void
    SetFixedParameters(const FixedParametersType &)  virtual void
    ComputeJacobianWithRespectToParameters( const InputPointType &,
    JacobianType &) const  virtual void
    ComputeJacobianWithRespectToPosition( const InputPointType & x,
    JacobianPositionType &jacobian ) const;

    Since TranformVector and TransformCovariantVector have multiple
    overloaded methods from the base class, subclasses must specify:
    using Superclass::TransformVector;  using
    Superclass::TransformCovariantVector;

    C++ includes: itkTransform.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Clone(self) -> "itkTransformF33_Pointer":
        """Clone(itkTransformF3 self) -> itkTransformF33_Pointer"""
        return _itkTransformBasePython.itkTransformF3_Clone(self)


    def TransformPoint(self, arg0: 'itkPointF3') -> "itkPointF3":
        """
        TransformPoint(itkTransformF3 self, itkPointF3 arg0) -> itkPointF3

        Method to transform
        a point. WARNING:  This method must be thread-safe. See, e.g., its use
        in ResampleImageFilter. 
        """
        return _itkTransformBasePython.itkTransformF3_TransformPoint(self, arg0)


    def TransformVector(self, *args) -> "itkVariableLengthVectorF":
        """
        TransformVector(itkTransformF3 self, itkVectorF3 arg0) -> itkVectorF3
        TransformVector(itkTransformF3 self, itkVectorF3 vector, itkPointF3 point) -> itkVectorF3
        TransformVector(itkTransformF3 self, vnl_vector_fixed< float,3 > const & arg0) -> vnl_vector_fixed< float,3 >
        TransformVector(itkTransformF3 self, vnl_vector_fixed< float,3 > const & vector, itkPointF3 point) -> vnl_vector_fixed< float,3 >
        TransformVector(itkTransformF3 self, itkVariableLengthVectorF arg0) -> itkVariableLengthVectorF
        TransformVector(itkTransformF3 self, itkVariableLengthVectorF vector, itkPointF3 point) -> itkVariableLengthVectorF

        Method to transform
        a vector stored in a VectorImage, at a point. For global transforms,
        point is ignored and TransformVector( vector ) is called. Local
        transforms (e.g. deformation field transform) must override and
        provide required behavior. 
        """
        return _itkTransformBasePython.itkTransformF3_TransformVector(self, *args)


    def TransformCovariantVector(self, *args) -> "itkVariableLengthVectorF":
        """
        TransformCovariantVector(itkTransformF3 self, itkCovariantVectorF3 arg0) -> itkCovariantVectorF3
        TransformCovariantVector(itkTransformF3 self, itkCovariantVectorF3 vector, itkPointF3 point) -> itkCovariantVectorF3
        TransformCovariantVector(itkTransformF3 self, itkVariableLengthVectorF arg0) -> itkVariableLengthVectorF
        TransformCovariantVector(itkTransformF3 self, itkVariableLengthVectorF vector, itkPointF3 point) -> itkVariableLengthVectorF

        Method to
        transform a CovariantVector, using a point. Global transforms can
        ignore the point parameter. Local transforms (e.g. deformation field
        transform) must override and provide required behavior. By default,
        point is ignored and TransformCovariantVector(vector) is called 
        """
        return _itkTransformBasePython.itkTransformF3_TransformCovariantVector(self, *args)


    def TransformDiffusionTensor3D(self, *args) -> "itkVariableLengthVectorF":
        """
        TransformDiffusionTensor3D(itkTransformF3 self, itkDiffusionTensor3DF arg0) -> itkDiffusionTensor3DF
        TransformDiffusionTensor3D(itkTransformF3 self, itkDiffusionTensor3DF tensor, itkPointF3 point) -> itkDiffusionTensor3DF
        TransformDiffusionTensor3D(itkTransformF3 self, itkVariableLengthVectorF arg0) -> itkVariableLengthVectorF
        TransformDiffusionTensor3D(itkTransformF3 self, itkVariableLengthVectorF tensor, itkPointF3 point) -> itkVariableLengthVectorF

        Method
        to transform a diffusion tensor stored in a VectorImage 
        """
        return _itkTransformBasePython.itkTransformF3_TransformDiffusionTensor3D(self, *args)


    def TransformSymmetricSecondRankTensor(self, *args) -> "itkVariableLengthVectorF":
        """
        TransformSymmetricSecondRankTensor(itkTransformF3 self, itkSymmetricSecondRankTensorF3 tensor, itkPointF3 point) -> itkSymmetricSecondRankTensorF3
        TransformSymmetricSecondRankTensor(itkTransformF3 self, itkSymmetricSecondRankTensorF3 arg0) -> itkSymmetricSecondRankTensorF3
        TransformSymmetricSecondRankTensor(itkTransformF3 self, itkVariableLengthVectorF arg0) -> itkVariableLengthVectorF
        TransformSymmetricSecondRankTensor(itkTransformF3 self, itkVariableLengthVectorF tensor, itkPointF3 point) -> itkVariableLengthVectorF

        Method to transform a diffusion tensor stored in a VectorImage, at a
        point. Global transforms can ignore the point parameter. Local
        transforms (e.g. deformation field transform) must override and
        provide required behavior. By default, point is ignored and
        TransformDiffusionTensor(tensor) is called 
        """
        return _itkTransformBasePython.itkTransformF3_TransformSymmetricSecondRankTensor(self, *args)


    def UpdateTransformParameters(self, update: 'itkArrayF', factor: 'float'=1.) -> "void":
        """
        UpdateTransformParameters(itkTransformF3 self, itkArrayF update, float factor=1.)
        UpdateTransformParameters(itkTransformF3 self, itkArrayF update)

        Update
        the transform's parameters by the values in update.

        Parameters:
        -----------

        update:  must be of the same length as returned by
        GetNumberOfParameters(). Throw an exception otherwise.

        factor:  is a scalar multiplier for each value in update.
        SetParameters is called at the end of this method, to allow the
        transform to perform any required operations on the updated parameters
        - typically a conversion to member variables for use in
        TransformPoint. 
        """
        return _itkTransformBasePython.itkTransformF3_UpdateTransformParameters(self, update, factor)


    def GetNumberOfLocalParameters(self) -> "unsigned long":
        """
        GetNumberOfLocalParameters(itkTransformF3 self) -> unsigned long

        Return
        the number of local parameters that completely defines the Transform
        at an individual voxel. For transforms with local support, this will
        enable downstream computation of the jacobian wrt only the local
        support region. For instance, in the case of a deformation field, this
        will be equal to the number of image dimensions. If it is an affine
        transform, this will be the same as the GetNumberOfParameters(). 
        """
        return _itkTransformBasePython.itkTransformF3_GetNumberOfLocalParameters(self)


    def GetNumberOfFixedParameters(self) -> "unsigned long":
        """
        GetNumberOfFixedParameters(itkTransformF3 self) -> unsigned long

        Return
        the number of parameters that define the constant elements of a
        Transfom 
        """
        return _itkTransformBasePython.itkTransformF3_GetNumberOfFixedParameters(self)


    def GetInverse(self, arg0: 'itkTransformF33') -> "bool":
        """
        GetInverse(itkTransformF3 self, itkTransformF33 arg0) -> bool

        Returns a boolean
        indicating whether it is possible or not to compute the inverse of
        this current Transform. If it is possible, then the inverse of the
        transform is returned in the inverseTransform variable passed by the
        user. The inverse is recomputed if this current transform has been
        modified. This method is intended to be overriden as needed by derived
        classes. 
        """
        return _itkTransformBasePython.itkTransformF3_GetInverse(self, arg0)


    def GetInverseTransform(self) -> "itkTransformF33_Pointer":
        """
        GetInverseTransform(itkTransformF3 self) -> itkTransformF33_Pointer

        Return an
        inverse of this transform. If the inverse has not been implemented,
        return nullptr. The type of the inverse transform does not necessarily
        need to match the type of the forward transform. This allows one to
        return a numeric inverse transform instead. 
        """
        return _itkTransformBasePython.itkTransformF3_GetInverseTransform(self)


    def IsLinear(self) -> "bool":
        """IsLinear(itkTransformF3 self) -> bool"""
        return _itkTransformBasePython.itkTransformF3_IsLinear(self)


    def ComputeJacobianWithRespectToParameters(self, arg0: 'itkPointF3', arg1: 'itkArray2DF') -> "void":
        """
        ComputeJacobianWithRespectToParameters(itkTransformF3 self, itkPointF3 arg0, itkArray2DF arg1)

        Compute the
        Jacobian of the transformation

        This method computes the Jacobian matrix of the transformation at a
        given input point. The rank of the Jacobian will also indicate if the
        transform is invertible at this point.

        The Jacobian is be expressed as a matrix of partial derivatives of the
        output point components with respect to the parameters that defined
        the transform:

        \\[ J=\\left[ \\begin{array}{cccc} \\frac{\\partial
        x_{1}}{\\partial p_{1}} & \\frac{\\partial x_{1}}{\\partial
        p_{2}} & \\cdots & \\frac{\\partial x_{1}}{\\partial
        p_{m}}\\\\ \\frac{\\partial x_{2}}{\\partial p_{1}} &
        \\frac{\\partial x_{2}}{\\partial p_{2}} & \\cdots &
        \\frac{\\partial x_{2}}{\\partial p_{m}}\\\\ \\vdots &
        \\vdots & \\ddots & \\vdots \\\\ \\frac{\\partial
        x_{n}}{\\partial p_{1}} & \\frac{\\partial x_{n}}{\\partial
        p_{2}} & \\cdots & \\frac{\\partial x_{n}}{\\partial p_{m}}
        \\end{array}\\right] \\]

        This is also used for efficient computation of a point-local jacobian
        for dense transforms. jacobian is assumed to be thread-local variable,
        otherwise memory corruption will most likely occur during multi-
        threading. To avoid repetitive memory allocation, pass in 'jacobian'
        with its size already set. 
        """
        return _itkTransformBasePython.itkTransformF3_ComputeJacobianWithRespectToParameters(self, arg0, arg1)


    def ComputeJacobianWithRespectToParametersCachedTemporaries(self, p: 'itkPointF3', jacobian: 'itkArray2DF', arg2: 'itkArray2DF') -> "void":
        """ComputeJacobianWithRespectToParametersCachedTemporaries(itkTransformF3 self, itkPointF3 p, itkArray2DF jacobian, itkArray2DF arg2)"""
        return _itkTransformBasePython.itkTransformF3_ComputeJacobianWithRespectToParametersCachedTemporaries(self, p, jacobian, arg2)


    def ComputeJacobianWithRespectToPosition(self, arg0: 'itkPointF3', arg1: 'vnl_matrix_fixedF_3_3') -> "void":
        """
        ComputeJacobianWithRespectToPosition(itkTransformF3 self, itkPointF3 arg0, vnl_matrix_fixedF_3_3 arg1)

        This provides the ability to get a local jacobian value in a
        dense/local transform, e.g. DisplacementFieldTransform. For such
        transforms it would be unclear what parameters would refer to.
        Generally, global transforms should return an identity jacobian since
        there is no change with respect to position. 
        """
        return _itkTransformBasePython.itkTransformF3_ComputeJacobianWithRespectToPosition(self, arg0, arg1)


    def ComputeInverseJacobianWithRespectToPosition(self, x: 'itkPointF3', jacobian: 'vnl_matrix_fixedF_3_3') -> "void":
        """
        ComputeInverseJacobianWithRespectToPosition(itkTransformF3 self, itkPointF3 x, vnl_matrix_fixedF_3_3 jacobian)

        This provides
        the ability to get a local jacobian value in a dense/local transform,
        e.g. DisplacementFieldTransform. For such transforms it would be
        unclear what parameters would refer to. Generally, global transforms
        should return an identity jacobian since there is no change with
        respect to position. 
        """
        return _itkTransformBasePython.itkTransformF3_ComputeInverseJacobianWithRespectToPosition(self, x, jacobian)

    __swig_destroy__ = _itkTransformBasePython.delete_itkTransformF3

    def cast(obj: 'itkLightObject') -> "itkTransformF3 *":
        """cast(itkLightObject obj) -> itkTransformF3"""
        return _itkTransformBasePython.itkTransformF3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkTransformF3

        Create a new object of the class itkTransformF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkTransformF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkTransformF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkTransformF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkTransformF3.Clone = new_instancemethod(_itkTransformBasePython.itkTransformF3_Clone, None, itkTransformF3)
itkTransformF3.TransformPoint = new_instancemethod(_itkTransformBasePython.itkTransformF3_TransformPoint, None, itkTransformF3)
itkTransformF3.TransformVector = new_instancemethod(_itkTransformBasePython.itkTransformF3_TransformVector, None, itkTransformF3)
itkTransformF3.TransformCovariantVector = new_instancemethod(_itkTransformBasePython.itkTransformF3_TransformCovariantVector, None, itkTransformF3)
itkTransformF3.TransformDiffusionTensor3D = new_instancemethod(_itkTransformBasePython.itkTransformF3_TransformDiffusionTensor3D, None, itkTransformF3)
itkTransformF3.TransformSymmetricSecondRankTensor = new_instancemethod(_itkTransformBasePython.itkTransformF3_TransformSymmetricSecondRankTensor, None, itkTransformF3)
itkTransformF3.UpdateTransformParameters = new_instancemethod(_itkTransformBasePython.itkTransformF3_UpdateTransformParameters, None, itkTransformF3)
itkTransformF3.GetNumberOfLocalParameters = new_instancemethod(_itkTransformBasePython.itkTransformF3_GetNumberOfLocalParameters, None, itkTransformF3)
itkTransformF3.GetNumberOfFixedParameters = new_instancemethod(_itkTransformBasePython.itkTransformF3_GetNumberOfFixedParameters, None, itkTransformF3)
itkTransformF3.GetInverse = new_instancemethod(_itkTransformBasePython.itkTransformF3_GetInverse, None, itkTransformF3)
itkTransformF3.GetInverseTransform = new_instancemethod(_itkTransformBasePython.itkTransformF3_GetInverseTransform, None, itkTransformF3)
itkTransformF3.IsLinear = new_instancemethod(_itkTransformBasePython.itkTransformF3_IsLinear, None, itkTransformF3)
itkTransformF3.ComputeJacobianWithRespectToParameters = new_instancemethod(_itkTransformBasePython.itkTransformF3_ComputeJacobianWithRespectToParameters, None, itkTransformF3)
itkTransformF3.ComputeJacobianWithRespectToParametersCachedTemporaries = new_instancemethod(_itkTransformBasePython.itkTransformF3_ComputeJacobianWithRespectToParametersCachedTemporaries, None, itkTransformF3)
itkTransformF3.ComputeJacobianWithRespectToPosition = new_instancemethod(_itkTransformBasePython.itkTransformF3_ComputeJacobianWithRespectToPosition, None, itkTransformF3)
itkTransformF3.ComputeInverseJacobianWithRespectToPosition = new_instancemethod(_itkTransformBasePython.itkTransformF3_ComputeInverseJacobianWithRespectToPosition, None, itkTransformF3)
itkTransformF3_swigregister = _itkTransformBasePython.itkTransformF3_swigregister
itkTransformF3_swigregister(itkTransformF3)

def itkTransformF3_cast(obj: 'itkLightObject') -> "itkTransformF3 *":
    """itkTransformF3_cast(itkLightObject obj) -> itkTransformF3"""
    return _itkTransformBasePython.itkTransformF3_cast(obj)

class itkTransformF32(itkTransformBaseTemplateF):
    """


    Transform points and vectors from an input space to an output space.

    This abstract class defines the generic interface for a geometric
    transformation from one space to another. The class provides methods
    for mapping points, vectors and covariant vectors from the input space
    to the output space.

    Given that transformations are not necessarily invertible, this basic
    class does not provide the methods for back transformation. Back
    transform methods are implemented in derived classes where
    appropriate.

    Registration Framework Support Typically a Transform class has several
    methods for setting its parameters. For use in the registration
    framework, the parameters must also be represented by an array of
    doubles to allow communication with generic optimizers. The Array of
    transformation parameters is set using the SetParameters() method.
    Another requirement of the registration framework is the computation
    of the transform Jacobian. In general, an ImageToImageMetric requires
    the knowledge of the Jacobian in order to compute the metric
    derivatives. The Jacobian is a matrix whose element are the partial
    derivatives of the output point with respect to the array of
    parameters that defines the transform.

    Subclasses must provide implementations for:  virtual OutputPointType
    TransformPoint(const InputPointType  &) const  virtual
    OutputVectorType TransformVector(const InputVectorType &) const
    virtual OutputVnlVectorType TransformVector(const InputVnlVectorType
    &) const  virtual OutputCovariantVectorType
    TransformCovariantVector(const InputCovariantVectorType &) const
    virtual void SetParameters(const ParametersType &)  virtual void
    SetFixedParameters(const FixedParametersType &)  virtual void
    ComputeJacobianWithRespectToParameters( const InputPointType &,
    JacobianType &) const  virtual void
    ComputeJacobianWithRespectToPosition( const InputPointType & x,
    JacobianPositionType &jacobian ) const;

    Since TranformVector and TransformCovariantVector have multiple
    overloaded methods from the base class, subclasses must specify:
    using Superclass::TransformVector;  using
    Superclass::TransformCovariantVector;

    C++ includes: itkTransform.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Clone(self) -> "itkTransformF32_Pointer":
        """Clone(itkTransformF32 self) -> itkTransformF32_Pointer"""
        return _itkTransformBasePython.itkTransformF32_Clone(self)


    def TransformPoint(self, arg0: 'itkPointF3') -> "itkPointF2":
        """
        TransformPoint(itkTransformF32 self, itkPointF3 arg0) -> itkPointF2

        Method to transform
        a point. WARNING:  This method must be thread-safe. See, e.g., its use
        in ResampleImageFilter. 
        """
        return _itkTransformBasePython.itkTransformF32_TransformPoint(self, arg0)


    def TransformVector(self, *args) -> "itkVariableLengthVectorF":
        """
        TransformVector(itkTransformF32 self, itkVectorF3 arg0) -> itkVectorF2
        TransformVector(itkTransformF32 self, itkVectorF3 vector, itkPointF3 point) -> itkVectorF2
        TransformVector(itkTransformF32 self, vnl_vector_fixed< float,3 > const & arg0) -> vnl_vector_fixed< float,2 >
        TransformVector(itkTransformF32 self, vnl_vector_fixed< float,3 > const & vector, itkPointF3 point) -> vnl_vector_fixed< float,2 >
        TransformVector(itkTransformF32 self, itkVariableLengthVectorF arg0) -> itkVariableLengthVectorF
        TransformVector(itkTransformF32 self, itkVariableLengthVectorF vector, itkPointF3 point) -> itkVariableLengthVectorF

        Method to transform
        a vector stored in a VectorImage, at a point. For global transforms,
        point is ignored and TransformVector( vector ) is called. Local
        transforms (e.g. deformation field transform) must override and
        provide required behavior. 
        """
        return _itkTransformBasePython.itkTransformF32_TransformVector(self, *args)


    def TransformCovariantVector(self, *args) -> "itkVariableLengthVectorF":
        """
        TransformCovariantVector(itkTransformF32 self, itkCovariantVectorF3 arg0) -> itkCovariantVectorF2
        TransformCovariantVector(itkTransformF32 self, itkCovariantVectorF3 vector, itkPointF3 point) -> itkCovariantVectorF2
        TransformCovariantVector(itkTransformF32 self, itkVariableLengthVectorF arg0) -> itkVariableLengthVectorF
        TransformCovariantVector(itkTransformF32 self, itkVariableLengthVectorF vector, itkPointF3 point) -> itkVariableLengthVectorF

        Method to
        transform a CovariantVector, using a point. Global transforms can
        ignore the point parameter. Local transforms (e.g. deformation field
        transform) must override and provide required behavior. By default,
        point is ignored and TransformCovariantVector(vector) is called 
        """
        return _itkTransformBasePython.itkTransformF32_TransformCovariantVector(self, *args)


    def TransformDiffusionTensor3D(self, *args) -> "itkVariableLengthVectorF":
        """
        TransformDiffusionTensor3D(itkTransformF32 self, itkDiffusionTensor3DF arg0) -> itkDiffusionTensor3DF
        TransformDiffusionTensor3D(itkTransformF32 self, itkDiffusionTensor3DF tensor, itkPointF3 point) -> itkDiffusionTensor3DF
        TransformDiffusionTensor3D(itkTransformF32 self, itkVariableLengthVectorF arg0) -> itkVariableLengthVectorF
        TransformDiffusionTensor3D(itkTransformF32 self, itkVariableLengthVectorF tensor, itkPointF3 point) -> itkVariableLengthVectorF

        Method
        to transform a diffusion tensor stored in a VectorImage 
        """
        return _itkTransformBasePython.itkTransformF32_TransformDiffusionTensor3D(self, *args)


    def TransformSymmetricSecondRankTensor(self, *args) -> "itkVariableLengthVectorF":
        """
        TransformSymmetricSecondRankTensor(itkTransformF32 self, itkSymmetricSecondRankTensorF3 tensor, itkPointF3 point) -> itkSymmetricSecondRankTensorF2
        TransformSymmetricSecondRankTensor(itkTransformF32 self, itkSymmetricSecondRankTensorF3 arg0) -> itkSymmetricSecondRankTensorF2
        TransformSymmetricSecondRankTensor(itkTransformF32 self, itkVariableLengthVectorF arg0) -> itkVariableLengthVectorF
        TransformSymmetricSecondRankTensor(itkTransformF32 self, itkVariableLengthVectorF tensor, itkPointF3 point) -> itkVariableLengthVectorF

        Method to transform a diffusion tensor stored in a VectorImage, at a
        point. Global transforms can ignore the point parameter. Local
        transforms (e.g. deformation field transform) must override and
        provide required behavior. By default, point is ignored and
        TransformDiffusionTensor(tensor) is called 
        """
        return _itkTransformBasePython.itkTransformF32_TransformSymmetricSecondRankTensor(self, *args)


    def UpdateTransformParameters(self, update: 'itkArrayF', factor: 'float'=1.) -> "void":
        """
        UpdateTransformParameters(itkTransformF32 self, itkArrayF update, float factor=1.)
        UpdateTransformParameters(itkTransformF32 self, itkArrayF update)

        Update
        the transform's parameters by the values in update.

        Parameters:
        -----------

        update:  must be of the same length as returned by
        GetNumberOfParameters(). Throw an exception otherwise.

        factor:  is a scalar multiplier for each value in update.
        SetParameters is called at the end of this method, to allow the
        transform to perform any required operations on the updated parameters
        - typically a conversion to member variables for use in
        TransformPoint. 
        """
        return _itkTransformBasePython.itkTransformF32_UpdateTransformParameters(self, update, factor)


    def GetNumberOfLocalParameters(self) -> "unsigned long":
        """
        GetNumberOfLocalParameters(itkTransformF32 self) -> unsigned long

        Return
        the number of local parameters that completely defines the Transform
        at an individual voxel. For transforms with local support, this will
        enable downstream computation of the jacobian wrt only the local
        support region. For instance, in the case of a deformation field, this
        will be equal to the number of image dimensions. If it is an affine
        transform, this will be the same as the GetNumberOfParameters(). 
        """
        return _itkTransformBasePython.itkTransformF32_GetNumberOfLocalParameters(self)


    def GetNumberOfFixedParameters(self) -> "unsigned long":
        """
        GetNumberOfFixedParameters(itkTransformF32 self) -> unsigned long

        Return
        the number of parameters that define the constant elements of a
        Transfom 
        """
        return _itkTransformBasePython.itkTransformF32_GetNumberOfFixedParameters(self)


    def GetInverse(self, arg0: 'itkTransformF32') -> "bool":
        """
        GetInverse(itkTransformF32 self, itkTransformF32 arg0) -> bool

        Returns a boolean
        indicating whether it is possible or not to compute the inverse of
        this current Transform. If it is possible, then the inverse of the
        transform is returned in the inverseTransform variable passed by the
        user. The inverse is recomputed if this current transform has been
        modified. This method is intended to be overriden as needed by derived
        classes. 
        """
        return _itkTransformBasePython.itkTransformF32_GetInverse(self, arg0)


    def GetInverseTransform(self) -> "itkTransformF23_Pointer":
        """
        GetInverseTransform(itkTransformF32 self) -> itkTransformF23_Pointer

        Return an
        inverse of this transform. If the inverse has not been implemented,
        return nullptr. The type of the inverse transform does not necessarily
        need to match the type of the forward transform. This allows one to
        return a numeric inverse transform instead. 
        """
        return _itkTransformBasePython.itkTransformF32_GetInverseTransform(self)


    def IsLinear(self) -> "bool":
        """IsLinear(itkTransformF32 self) -> bool"""
        return _itkTransformBasePython.itkTransformF32_IsLinear(self)


    def ComputeJacobianWithRespectToParameters(self, arg0: 'itkPointF3', arg1: 'itkArray2DF') -> "void":
        """
        ComputeJacobianWithRespectToParameters(itkTransformF32 self, itkPointF3 arg0, itkArray2DF arg1)

        Compute the
        Jacobian of the transformation

        This method computes the Jacobian matrix of the transformation at a
        given input point. The rank of the Jacobian will also indicate if the
        transform is invertible at this point.

        The Jacobian is be expressed as a matrix of partial derivatives of the
        output point components with respect to the parameters that defined
        the transform:

        \\[ J=\\left[ \\begin{array}{cccc} \\frac{\\partial
        x_{1}}{\\partial p_{1}} & \\frac{\\partial x_{1}}{\\partial
        p_{2}} & \\cdots & \\frac{\\partial x_{1}}{\\partial
        p_{m}}\\\\ \\frac{\\partial x_{2}}{\\partial p_{1}} &
        \\frac{\\partial x_{2}}{\\partial p_{2}} & \\cdots &
        \\frac{\\partial x_{2}}{\\partial p_{m}}\\\\ \\vdots &
        \\vdots & \\ddots & \\vdots \\\\ \\frac{\\partial
        x_{n}}{\\partial p_{1}} & \\frac{\\partial x_{n}}{\\partial
        p_{2}} & \\cdots & \\frac{\\partial x_{n}}{\\partial p_{m}}
        \\end{array}\\right] \\]

        This is also used for efficient computation of a point-local jacobian
        for dense transforms. jacobian is assumed to be thread-local variable,
        otherwise memory corruption will most likely occur during multi-
        threading. To avoid repetitive memory allocation, pass in 'jacobian'
        with its size already set. 
        """
        return _itkTransformBasePython.itkTransformF32_ComputeJacobianWithRespectToParameters(self, arg0, arg1)


    def ComputeJacobianWithRespectToParametersCachedTemporaries(self, p: 'itkPointF3', jacobian: 'itkArray2DF', arg2: 'itkArray2DF') -> "void":
        """ComputeJacobianWithRespectToParametersCachedTemporaries(itkTransformF32 self, itkPointF3 p, itkArray2DF jacobian, itkArray2DF arg2)"""
        return _itkTransformBasePython.itkTransformF32_ComputeJacobianWithRespectToParametersCachedTemporaries(self, p, jacobian, arg2)


    def ComputeJacobianWithRespectToPosition(self, arg0: 'itkPointF3', arg1: 'vnl_matrix_fixed< float,2,3 > &') -> "void":
        """
        ComputeJacobianWithRespectToPosition(itkTransformF32 self, itkPointF3 arg0, vnl_matrix_fixed< float,2,3 > & arg1)

        This provides the ability to get a local jacobian value in a
        dense/local transform, e.g. DisplacementFieldTransform. For such
        transforms it would be unclear what parameters would refer to.
        Generally, global transforms should return an identity jacobian since
        there is no change with respect to position. 
        """
        return _itkTransformBasePython.itkTransformF32_ComputeJacobianWithRespectToPosition(self, arg0, arg1)


    def ComputeInverseJacobianWithRespectToPosition(self, x: 'itkPointF3', jacobian: 'vnl_matrix_fixed< float,3,2 > &') -> "void":
        """
        ComputeInverseJacobianWithRespectToPosition(itkTransformF32 self, itkPointF3 x, vnl_matrix_fixed< float,3,2 > & jacobian)

        This provides
        the ability to get a local jacobian value in a dense/local transform,
        e.g. DisplacementFieldTransform. For such transforms it would be
        unclear what parameters would refer to. Generally, global transforms
        should return an identity jacobian since there is no change with
        respect to position. 
        """
        return _itkTransformBasePython.itkTransformF32_ComputeInverseJacobianWithRespectToPosition(self, x, jacobian)

    __swig_destroy__ = _itkTransformBasePython.delete_itkTransformF32

    def cast(obj: 'itkLightObject') -> "itkTransformF32 *":
        """cast(itkLightObject obj) -> itkTransformF32"""
        return _itkTransformBasePython.itkTransformF32_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkTransformF32

        Create a new object of the class itkTransformF32 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkTransformF32.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkTransformF32.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkTransformF32.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkTransformF32.Clone = new_instancemethod(_itkTransformBasePython.itkTransformF32_Clone, None, itkTransformF32)
itkTransformF32.TransformPoint = new_instancemethod(_itkTransformBasePython.itkTransformF32_TransformPoint, None, itkTransformF32)
itkTransformF32.TransformVector = new_instancemethod(_itkTransformBasePython.itkTransformF32_TransformVector, None, itkTransformF32)
itkTransformF32.TransformCovariantVector = new_instancemethod(_itkTransformBasePython.itkTransformF32_TransformCovariantVector, None, itkTransformF32)
itkTransformF32.TransformDiffusionTensor3D = new_instancemethod(_itkTransformBasePython.itkTransformF32_TransformDiffusionTensor3D, None, itkTransformF32)
itkTransformF32.TransformSymmetricSecondRankTensor = new_instancemethod(_itkTransformBasePython.itkTransformF32_TransformSymmetricSecondRankTensor, None, itkTransformF32)
itkTransformF32.UpdateTransformParameters = new_instancemethod(_itkTransformBasePython.itkTransformF32_UpdateTransformParameters, None, itkTransformF32)
itkTransformF32.GetNumberOfLocalParameters = new_instancemethod(_itkTransformBasePython.itkTransformF32_GetNumberOfLocalParameters, None, itkTransformF32)
itkTransformF32.GetNumberOfFixedParameters = new_instancemethod(_itkTransformBasePython.itkTransformF32_GetNumberOfFixedParameters, None, itkTransformF32)
itkTransformF32.GetInverse = new_instancemethod(_itkTransformBasePython.itkTransformF32_GetInverse, None, itkTransformF32)
itkTransformF32.GetInverseTransform = new_instancemethod(_itkTransformBasePython.itkTransformF32_GetInverseTransform, None, itkTransformF32)
itkTransformF32.IsLinear = new_instancemethod(_itkTransformBasePython.itkTransformF32_IsLinear, None, itkTransformF32)
itkTransformF32.ComputeJacobianWithRespectToParameters = new_instancemethod(_itkTransformBasePython.itkTransformF32_ComputeJacobianWithRespectToParameters, None, itkTransformF32)
itkTransformF32.ComputeJacobianWithRespectToParametersCachedTemporaries = new_instancemethod(_itkTransformBasePython.itkTransformF32_ComputeJacobianWithRespectToParametersCachedTemporaries, None, itkTransformF32)
itkTransformF32.ComputeJacobianWithRespectToPosition = new_instancemethod(_itkTransformBasePython.itkTransformF32_ComputeJacobianWithRespectToPosition, None, itkTransformF32)
itkTransformF32.ComputeInverseJacobianWithRespectToPosition = new_instancemethod(_itkTransformBasePython.itkTransformF32_ComputeInverseJacobianWithRespectToPosition, None, itkTransformF32)
itkTransformF32_swigregister = _itkTransformBasePython.itkTransformF32_swigregister
itkTransformF32_swigregister(itkTransformF32)

def itkTransformF32_cast(obj: 'itkLightObject') -> "itkTransformF32 *":
    """itkTransformF32_cast(itkLightObject obj) -> itkTransformF32"""
    return _itkTransformBasePython.itkTransformF32_cast(obj)

class itkTransformF33(itkTransformBaseTemplateF):
    """


    Transform points and vectors from an input space to an output space.

    This abstract class defines the generic interface for a geometric
    transformation from one space to another. The class provides methods
    for mapping points, vectors and covariant vectors from the input space
    to the output space.

    Given that transformations are not necessarily invertible, this basic
    class does not provide the methods for back transformation. Back
    transform methods are implemented in derived classes where
    appropriate.

    Registration Framework Support Typically a Transform class has several
    methods for setting its parameters. For use in the registration
    framework, the parameters must also be represented by an array of
    doubles to allow communication with generic optimizers. The Array of
    transformation parameters is set using the SetParameters() method.
    Another requirement of the registration framework is the computation
    of the transform Jacobian. In general, an ImageToImageMetric requires
    the knowledge of the Jacobian in order to compute the metric
    derivatives. The Jacobian is a matrix whose element are the partial
    derivatives of the output point with respect to the array of
    parameters that defines the transform.

    Subclasses must provide implementations for:  virtual OutputPointType
    TransformPoint(const InputPointType  &) const  virtual
    OutputVectorType TransformVector(const InputVectorType &) const
    virtual OutputVnlVectorType TransformVector(const InputVnlVectorType
    &) const  virtual OutputCovariantVectorType
    TransformCovariantVector(const InputCovariantVectorType &) const
    virtual void SetParameters(const ParametersType &)  virtual void
    SetFixedParameters(const FixedParametersType &)  virtual void
    ComputeJacobianWithRespectToParameters( const InputPointType &,
    JacobianType &) const  virtual void
    ComputeJacobianWithRespectToPosition( const InputPointType & x,
    JacobianPositionType &jacobian ) const;

    Since TranformVector and TransformCovariantVector have multiple
    overloaded methods from the base class, subclasses must specify:
    using Superclass::TransformVector;  using
    Superclass::TransformCovariantVector;

    C++ includes: itkTransform.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Clone(self) -> "itkTransformF33_Pointer":
        """Clone(itkTransformF33 self) -> itkTransformF33_Pointer"""
        return _itkTransformBasePython.itkTransformF33_Clone(self)


    def TransformPoint(self, arg0: 'itkPointF3') -> "itkPointF3":
        """
        TransformPoint(itkTransformF33 self, itkPointF3 arg0) -> itkPointF3

        Method to transform
        a point. WARNING:  This method must be thread-safe. See, e.g., its use
        in ResampleImageFilter. 
        """
        return _itkTransformBasePython.itkTransformF33_TransformPoint(self, arg0)


    def TransformVector(self, *args) -> "itkVariableLengthVectorF":
        """
        TransformVector(itkTransformF33 self, itkVectorF3 arg0) -> itkVectorF3
        TransformVector(itkTransformF33 self, itkVectorF3 vector, itkPointF3 point) -> itkVectorF3
        TransformVector(itkTransformF33 self, vnl_vector_fixed< float,3 > const & arg0) -> vnl_vector_fixed< float,3 >
        TransformVector(itkTransformF33 self, vnl_vector_fixed< float,3 > const & vector, itkPointF3 point) -> vnl_vector_fixed< float,3 >
        TransformVector(itkTransformF33 self, itkVariableLengthVectorF arg0) -> itkVariableLengthVectorF
        TransformVector(itkTransformF33 self, itkVariableLengthVectorF vector, itkPointF3 point) -> itkVariableLengthVectorF

        Method to transform
        a vector stored in a VectorImage, at a point. For global transforms,
        point is ignored and TransformVector( vector ) is called. Local
        transforms (e.g. deformation field transform) must override and
        provide required behavior. 
        """
        return _itkTransformBasePython.itkTransformF33_TransformVector(self, *args)


    def TransformCovariantVector(self, *args) -> "itkVariableLengthVectorF":
        """
        TransformCovariantVector(itkTransformF33 self, itkCovariantVectorF3 arg0) -> itkCovariantVectorF3
        TransformCovariantVector(itkTransformF33 self, itkCovariantVectorF3 vector, itkPointF3 point) -> itkCovariantVectorF3
        TransformCovariantVector(itkTransformF33 self, itkVariableLengthVectorF arg0) -> itkVariableLengthVectorF
        TransformCovariantVector(itkTransformF33 self, itkVariableLengthVectorF vector, itkPointF3 point) -> itkVariableLengthVectorF

        Method to
        transform a CovariantVector, using a point. Global transforms can
        ignore the point parameter. Local transforms (e.g. deformation field
        transform) must override and provide required behavior. By default,
        point is ignored and TransformCovariantVector(vector) is called 
        """
        return _itkTransformBasePython.itkTransformF33_TransformCovariantVector(self, *args)


    def TransformDiffusionTensor3D(self, *args) -> "itkVariableLengthVectorF":
        """
        TransformDiffusionTensor3D(itkTransformF33 self, itkDiffusionTensor3DF arg0) -> itkDiffusionTensor3DF
        TransformDiffusionTensor3D(itkTransformF33 self, itkDiffusionTensor3DF tensor, itkPointF3 point) -> itkDiffusionTensor3DF
        TransformDiffusionTensor3D(itkTransformF33 self, itkVariableLengthVectorF arg0) -> itkVariableLengthVectorF
        TransformDiffusionTensor3D(itkTransformF33 self, itkVariableLengthVectorF tensor, itkPointF3 point) -> itkVariableLengthVectorF

        Method
        to transform a diffusion tensor stored in a VectorImage 
        """
        return _itkTransformBasePython.itkTransformF33_TransformDiffusionTensor3D(self, *args)


    def TransformSymmetricSecondRankTensor(self, *args) -> "itkVariableLengthVectorF":
        """
        TransformSymmetricSecondRankTensor(itkTransformF33 self, itkSymmetricSecondRankTensorF3 tensor, itkPointF3 point) -> itkSymmetricSecondRankTensorF3
        TransformSymmetricSecondRankTensor(itkTransformF33 self, itkSymmetricSecondRankTensorF3 arg0) -> itkSymmetricSecondRankTensorF3
        TransformSymmetricSecondRankTensor(itkTransformF33 self, itkVariableLengthVectorF arg0) -> itkVariableLengthVectorF
        TransformSymmetricSecondRankTensor(itkTransformF33 self, itkVariableLengthVectorF tensor, itkPointF3 point) -> itkVariableLengthVectorF

        Method to transform a diffusion tensor stored in a VectorImage, at a
        point. Global transforms can ignore the point parameter. Local
        transforms (e.g. deformation field transform) must override and
        provide required behavior. By default, point is ignored and
        TransformDiffusionTensor(tensor) is called 
        """
        return _itkTransformBasePython.itkTransformF33_TransformSymmetricSecondRankTensor(self, *args)


    def UpdateTransformParameters(self, update: 'itkArrayF', factor: 'float'=1.) -> "void":
        """
        UpdateTransformParameters(itkTransformF33 self, itkArrayF update, float factor=1.)
        UpdateTransformParameters(itkTransformF33 self, itkArrayF update)

        Update
        the transform's parameters by the values in update.

        Parameters:
        -----------

        update:  must be of the same length as returned by
        GetNumberOfParameters(). Throw an exception otherwise.

        factor:  is a scalar multiplier for each value in update.
        SetParameters is called at the end of this method, to allow the
        transform to perform any required operations on the updated parameters
        - typically a conversion to member variables for use in
        TransformPoint. 
        """
        return _itkTransformBasePython.itkTransformF33_UpdateTransformParameters(self, update, factor)


    def GetNumberOfLocalParameters(self) -> "unsigned long":
        """
        GetNumberOfLocalParameters(itkTransformF33 self) -> unsigned long

        Return
        the number of local parameters that completely defines the Transform
        at an individual voxel. For transforms with local support, this will
        enable downstream computation of the jacobian wrt only the local
        support region. For instance, in the case of a deformation field, this
        will be equal to the number of image dimensions. If it is an affine
        transform, this will be the same as the GetNumberOfParameters(). 
        """
        return _itkTransformBasePython.itkTransformF33_GetNumberOfLocalParameters(self)


    def GetNumberOfFixedParameters(self) -> "unsigned long":
        """
        GetNumberOfFixedParameters(itkTransformF33 self) -> unsigned long

        Return
        the number of parameters that define the constant elements of a
        Transfom 
        """
        return _itkTransformBasePython.itkTransformF33_GetNumberOfFixedParameters(self)


    def GetInverse(self, arg0: 'itkTransformF33') -> "bool":
        """
        GetInverse(itkTransformF33 self, itkTransformF33 arg0) -> bool

        Returns a boolean
        indicating whether it is possible or not to compute the inverse of
        this current Transform. If it is possible, then the inverse of the
        transform is returned in the inverseTransform variable passed by the
        user. The inverse is recomputed if this current transform has been
        modified. This method is intended to be overriden as needed by derived
        classes. 
        """
        return _itkTransformBasePython.itkTransformF33_GetInverse(self, arg0)


    def GetInverseTransform(self) -> "itkTransformF33_Pointer":
        """
        GetInverseTransform(itkTransformF33 self) -> itkTransformF33_Pointer

        Return an
        inverse of this transform. If the inverse has not been implemented,
        return nullptr. The type of the inverse transform does not necessarily
        need to match the type of the forward transform. This allows one to
        return a numeric inverse transform instead. 
        """
        return _itkTransformBasePython.itkTransformF33_GetInverseTransform(self)


    def IsLinear(self) -> "bool":
        """IsLinear(itkTransformF33 self) -> bool"""
        return _itkTransformBasePython.itkTransformF33_IsLinear(self)


    def ComputeJacobianWithRespectToParameters(self, arg0: 'itkPointF3', arg1: 'itkArray2DF') -> "void":
        """
        ComputeJacobianWithRespectToParameters(itkTransformF33 self, itkPointF3 arg0, itkArray2DF arg1)

        Compute the
        Jacobian of the transformation

        This method computes the Jacobian matrix of the transformation at a
        given input point. The rank of the Jacobian will also indicate if the
        transform is invertible at this point.

        The Jacobian is be expressed as a matrix of partial derivatives of the
        output point components with respect to the parameters that defined
        the transform:

        \\[ J=\\left[ \\begin{array}{cccc} \\frac{\\partial
        x_{1}}{\\partial p_{1}} & \\frac{\\partial x_{1}}{\\partial
        p_{2}} & \\cdots & \\frac{\\partial x_{1}}{\\partial
        p_{m}}\\\\ \\frac{\\partial x_{2}}{\\partial p_{1}} &
        \\frac{\\partial x_{2}}{\\partial p_{2}} & \\cdots &
        \\frac{\\partial x_{2}}{\\partial p_{m}}\\\\ \\vdots &
        \\vdots & \\ddots & \\vdots \\\\ \\frac{\\partial
        x_{n}}{\\partial p_{1}} & \\frac{\\partial x_{n}}{\\partial
        p_{2}} & \\cdots & \\frac{\\partial x_{n}}{\\partial p_{m}}
        \\end{array}\\right] \\]

        This is also used for efficient computation of a point-local jacobian
        for dense transforms. jacobian is assumed to be thread-local variable,
        otherwise memory corruption will most likely occur during multi-
        threading. To avoid repetitive memory allocation, pass in 'jacobian'
        with its size already set. 
        """
        return _itkTransformBasePython.itkTransformF33_ComputeJacobianWithRespectToParameters(self, arg0, arg1)


    def ComputeJacobianWithRespectToParametersCachedTemporaries(self, p: 'itkPointF3', jacobian: 'itkArray2DF', arg2: 'itkArray2DF') -> "void":
        """ComputeJacobianWithRespectToParametersCachedTemporaries(itkTransformF33 self, itkPointF3 p, itkArray2DF jacobian, itkArray2DF arg2)"""
        return _itkTransformBasePython.itkTransformF33_ComputeJacobianWithRespectToParametersCachedTemporaries(self, p, jacobian, arg2)


    def ComputeJacobianWithRespectToPosition(self, arg0: 'itkPointF3', arg1: 'vnl_matrix_fixedF_3_3') -> "void":
        """
        ComputeJacobianWithRespectToPosition(itkTransformF33 self, itkPointF3 arg0, vnl_matrix_fixedF_3_3 arg1)

        This provides the ability to get a local jacobian value in a
        dense/local transform, e.g. DisplacementFieldTransform. For such
        transforms it would be unclear what parameters would refer to.
        Generally, global transforms should return an identity jacobian since
        there is no change with respect to position. 
        """
        return _itkTransformBasePython.itkTransformF33_ComputeJacobianWithRespectToPosition(self, arg0, arg1)


    def ComputeInverseJacobianWithRespectToPosition(self, x: 'itkPointF3', jacobian: 'vnl_matrix_fixedF_3_3') -> "void":
        """
        ComputeInverseJacobianWithRespectToPosition(itkTransformF33 self, itkPointF3 x, vnl_matrix_fixedF_3_3 jacobian)

        This provides
        the ability to get a local jacobian value in a dense/local transform,
        e.g. DisplacementFieldTransform. For such transforms it would be
        unclear what parameters would refer to. Generally, global transforms
        should return an identity jacobian since there is no change with
        respect to position. 
        """
        return _itkTransformBasePython.itkTransformF33_ComputeInverseJacobianWithRespectToPosition(self, x, jacobian)

    __swig_destroy__ = _itkTransformBasePython.delete_itkTransformF33

    def cast(obj: 'itkLightObject') -> "itkTransformF33 *":
        """cast(itkLightObject obj) -> itkTransformF33"""
        return _itkTransformBasePython.itkTransformF33_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkTransformF33

        Create a new object of the class itkTransformF33 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkTransformF33.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkTransformF33.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkTransformF33.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkTransformF33.Clone = new_instancemethod(_itkTransformBasePython.itkTransformF33_Clone, None, itkTransformF33)
itkTransformF33.TransformPoint = new_instancemethod(_itkTransformBasePython.itkTransformF33_TransformPoint, None, itkTransformF33)
itkTransformF33.TransformVector = new_instancemethod(_itkTransformBasePython.itkTransformF33_TransformVector, None, itkTransformF33)
itkTransformF33.TransformCovariantVector = new_instancemethod(_itkTransformBasePython.itkTransformF33_TransformCovariantVector, None, itkTransformF33)
itkTransformF33.TransformDiffusionTensor3D = new_instancemethod(_itkTransformBasePython.itkTransformF33_TransformDiffusionTensor3D, None, itkTransformF33)
itkTransformF33.TransformSymmetricSecondRankTensor = new_instancemethod(_itkTransformBasePython.itkTransformF33_TransformSymmetricSecondRankTensor, None, itkTransformF33)
itkTransformF33.UpdateTransformParameters = new_instancemethod(_itkTransformBasePython.itkTransformF33_UpdateTransformParameters, None, itkTransformF33)
itkTransformF33.GetNumberOfLocalParameters = new_instancemethod(_itkTransformBasePython.itkTransformF33_GetNumberOfLocalParameters, None, itkTransformF33)
itkTransformF33.GetNumberOfFixedParameters = new_instancemethod(_itkTransformBasePython.itkTransformF33_GetNumberOfFixedParameters, None, itkTransformF33)
itkTransformF33.GetInverse = new_instancemethod(_itkTransformBasePython.itkTransformF33_GetInverse, None, itkTransformF33)
itkTransformF33.GetInverseTransform = new_instancemethod(_itkTransformBasePython.itkTransformF33_GetInverseTransform, None, itkTransformF33)
itkTransformF33.IsLinear = new_instancemethod(_itkTransformBasePython.itkTransformF33_IsLinear, None, itkTransformF33)
itkTransformF33.ComputeJacobianWithRespectToParameters = new_instancemethod(_itkTransformBasePython.itkTransformF33_ComputeJacobianWithRespectToParameters, None, itkTransformF33)
itkTransformF33.ComputeJacobianWithRespectToParametersCachedTemporaries = new_instancemethod(_itkTransformBasePython.itkTransformF33_ComputeJacobianWithRespectToParametersCachedTemporaries, None, itkTransformF33)
itkTransformF33.ComputeJacobianWithRespectToPosition = new_instancemethod(_itkTransformBasePython.itkTransformF33_ComputeJacobianWithRespectToPosition, None, itkTransformF33)
itkTransformF33.ComputeInverseJacobianWithRespectToPosition = new_instancemethod(_itkTransformBasePython.itkTransformF33_ComputeInverseJacobianWithRespectToPosition, None, itkTransformF33)
itkTransformF33_swigregister = _itkTransformBasePython.itkTransformF33_swigregister
itkTransformF33_swigregister(itkTransformF33)

def itkTransformF33_cast(obj: 'itkLightObject') -> "itkTransformF33 *":
    """itkTransformF33_cast(itkLightObject obj) -> itkTransformF33"""
    return _itkTransformBasePython.itkTransformF33_cast(obj)



