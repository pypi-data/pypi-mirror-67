# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.8
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _itkMeshBasePython.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_itkMeshBasePython', [dirname(__file__)])
        except ImportError:
            import _itkMeshBasePython
            return _itkMeshBasePython
        if fp is not None:
            try:
                _mod = imp.load_module('_itkMeshBasePython', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _itkMeshBasePython = swig_import_helper()
    del swig_import_helper
else:
    import _itkMeshBasePython
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0



def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


import itkVectorContainerPython
import itkPointPython
import vnl_vector_refPython
import stdcomplexPython
import pyBasePython
import vnl_vectorPython
import vnl_matrixPython
import itkFixedArrayPython
import itkVectorPython
import itkMatrixPython
import itkCovariantVectorPython
import vnl_matrix_fixedPython
import ITKCommonBasePython
import itkOffsetPython
import itkSizePython
import itkContinuousIndexPython
import itkIndexPython
import itkBoundingBoxPython
import itkMapContainerPython
import itkPointSetPython
import itkArrayPython

def itkCellInterfaceVisitorDCTI3FFULULULPF3MCULPF3_New():
  return itkCellInterfaceVisitorDCTI3FFULULULPF3MCULPF3.New()


def itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3_New():
  return itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3.New()


def itkCellInterfaceVisitorUSCTI3FFULULULPF3MCULPF3_New():
  return itkCellInterfaceVisitorUSCTI3FFULULULPF3MCULPF3.New()


def itkCellInterfaceVisitorUCCTI3FFULULULPF3MCULPF3_New():
  return itkCellInterfaceVisitorUCCTI3FFULULULPF3MCULPF3.New()


def itkCellInterfaceVisitorSSCTI3FFULULULPF3MCULPF3_New():
  return itkCellInterfaceVisitorSSCTI3FFULULULPF3MCULPF3.New()


def itkCellInterfaceVisitorDCTI2FFULULULPF2MCULPF2_New():
  return itkCellInterfaceVisitorDCTI2FFULULULPF2MCULPF2.New()


def itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2_New():
  return itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2.New()


def itkCellInterfaceVisitorUSCTI2FFULULULPF2MCULPF2_New():
  return itkCellInterfaceVisitorUSCTI2FFULULULPF2MCULPF2.New()


def itkCellInterfaceVisitorUCCTI2FFULULULPF2MCULPF2_New():
  return itkCellInterfaceVisitorUCCTI2FFULULULPF2MCULPF2.New()


def itkCellInterfaceVisitorSSCTI2FFULULULPF2MCULPF2_New():
  return itkCellInterfaceVisitorSSCTI2FFULULULPF2MCULPF2.New()


def itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3_New():
  return itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3.New()


def itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_New():
  return itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3.New()


def itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3_New():
  return itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3.New()


def itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3_New():
  return itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3.New()


def itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3_New():
  return itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3.New()


def itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2_New():
  return itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2.New()


def itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_New():
  return itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2.New()


def itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2_New():
  return itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2.New()


def itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2_New():
  return itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2.New()


def itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2_New():
  return itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2.New()


def itkMapContainerULCIDCTI3FFULULULPF3MCULPF3_New():
  return itkMapContainerULCIDCTI3FFULULULPF3MCULPF3.New()


def itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_New():
  return itkMapContainerULCIFCTI3FFULULULPF3MCULPF3.New()


def itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3_New():
  return itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3.New()


def itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3_New():
  return itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3.New()


def itkMapContainerULCISSCTI3FFULULULPF3MCULPF3_New():
  return itkMapContainerULCISSCTI3FFULULULPF3MCULPF3.New()


def itkMapContainerULCIDCTI2FFULULULPF2MCULPF2_New():
  return itkMapContainerULCIDCTI2FFULULULPF2MCULPF2.New()


def itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_New():
  return itkMapContainerULCIFCTI2FFULULULPF2MCULPF2.New()


def itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2_New():
  return itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2.New()


def itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2_New():
  return itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2.New()


def itkMapContainerULCISSCTI2FFULULULPF2MCULPF2_New():
  return itkMapContainerULCISSCTI2FFULULULPF2MCULPF2.New()


def itkMeshD3_New():
  return itkMeshD3.New()


def itkMeshF3_New():
  return itkMeshF3.New()


def itkMeshUS3_New():
  return itkMeshUS3.New()


def itkMeshUC3_New():
  return itkMeshUC3.New()


def itkMeshSS3_New():
  return itkMeshSS3.New()


def itkMeshD2_New():
  return itkMeshD2.New()


def itkMeshF2_New():
  return itkMeshF2.New()


def itkMeshUS2_New():
  return itkMeshUS2.New()


def itkMeshUC2_New():
  return itkMeshUC2.New()


def itkMeshSS2_New():
  return itkMeshSS2.New()

class itkCellInterfaceDCTI2FFULULULPF2MCULPF2(object):
    """


    An abstract interface for cells.

    Define an abstract interface for cells. Actual cell types derive from
    this class.

    Parameters:
    -----------

    TPixelType:  The type stored with an entity (cell, point, or
    boundary).

    TCellTraits:  Type information for cell.

    C++ includes: itkCellInterface.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceDCTI2FFULULULPF2MCULPF2::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceDCTI2FFULULULPF2MCULPF2 self, unsigned long cellId, itkCellInterfaceDCTI2FFULULULPF2MCULPF2::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCommonEnums::CellGeometry":
        """
        GetType(itkCellInterfaceDCTI2FFULULULPF2MCULPF2 self) -> itkCommonEnums::CellGeometry

        Return the type of the cell
        (one of the CellGeometryEnum enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceDCTI2FFULULULPF2MCULPF2 self, itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceDCTI2FFULULULPF2MCULPF2 self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceDCTI2FFULULULPF2MCULPF2 self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceDCTI2FFULULULPF2MCULPF2 self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceDCTI2FFULULULPF2MCULPF2 self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceDCTI2FFULULULPF2MCULPF2 self, int dimension, unsigned long arg1, itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceDCTI2FFULULULPF2MCULPF2 self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceDCTI2FFULULULPF2MCULPF2 self, unsigned long const * first)
        SetPointIds(itkCellInterfaceDCTI2FFULULULPF2MCULPF2 self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceDCTI2FFULULULPF2MCULPF2 self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceDCTI2FFULULULPF2MCULPF2 self) -> unsigned long
        PointIdsBegin(itkCellInterfaceDCTI2FFULULULPF2MCULPF2 self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceDCTI2FFULULULPF2MCULPF2 self) -> unsigned long
        PointIdsEnd(itkCellInterfaceDCTI2FFULULULPF2MCULPF2 self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceDCTI2FFULULULPF2MCULPF2 self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceDCTI2FFULULULPF2MCULPF2 self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'float *', arg1: 'bool *', arg2: 'itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceDCTI2FFULULULPF2MCULPF2 self, float * arg0, bool * arg1, itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not nullptr, the flag is set to indicate whether the point is inside
        the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'float *', arg1: 'itkMapContainerULPF2', arg2: 'float *', arg3: 'float *', arg4: 'double *', arg5: 'float *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceDCTI2FFULULULPF2MCULPF2 self, float * arg0, itkMapContainerULPF2 arg1, float * arg2, float * arg3, double * arg4, float * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not nullptr:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayF', arg1: 'itkArrayF') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceDCTI2FFULULULPF2MCULPF2 self, itkArrayF arg0, itkArrayF arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float', arg3: 'float *', arg4: 'float *', arg5: 'float *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceDCTI2FFULULULPF2MCULPF2 self, float * arg0, float * arg1, float arg2, float * arg3, float * arg4, float * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'float *') -> "float *":
        """
        GetBoundingBox(itkCellInterfaceDCTI2FFULULULPF2MCULPF2 self, float * arg0) -> float *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "float":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceDCTI2FFULULULPF2MCULPF2 self) -> float

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float *', arg3: 'float *', arg4: 'float *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceDCTI2FFULULULPF2MCULPF2 self, float * arg0, float * arg1, float * arg2, float * arg3, float * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceDCTI2FFULULULPF2MCULPF2 self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceDCTI2FFULULULPF2MCULPF2 self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceDCTI2FFULULULPF2MCULPF2 self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceDCTI2FFULULULPF2MCULPF2 self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceDCTI2FFULULULPF2MCULPF2 self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceDCTI2FFULULULPF2MCULPF2 self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_GetNameOfClass(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceDCTI2FFULULULPF2MCULPF2
itkCellInterfaceDCTI2FFULULULPF2MCULPF2.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_Accept, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_GetType, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_MakeCopy, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_GetDimension, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_GetInterpolationOrder, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_GetNumberOfPoints, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_GetNumberOfBoundaryFeatures, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_GetBoundaryFeature, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_GetPointIds, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_SetPointIds, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_SetPointId, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_PointIdsBegin, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_PointIdsEnd, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_GetPointIdsContainer, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_SetPointIdsContainer, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_GetClosestBoundary, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_EvaluatePosition, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_EvaluateShapeFunctions, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_IntersectWithLine, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_GetBoundingBox, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_IntersectBoundingBoxWithLine, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_IsExplicitBoundary, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AddUsingCell, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_RemoveUsingCell, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_IsUsingCell, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_GetNumberOfUsingCells, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_GetNameOfClass, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2_swigregister = _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_swigregister
itkCellInterfaceDCTI2FFULULULPF2MCULPF2_swigregister(itkCellInterfaceDCTI2FFULULULPF2MCULPF2)

class itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer(object):
    """Proxy of C++ itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer self) -> itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer
        __init__(itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer p) -> itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer
        __init__(itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceDCTI2FFULULULPF2MCULPF2 p, bool takeOwnership) -> itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer
        """
        _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_swiginit(self, _itkMeshBasePython.new_itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer(*args))
    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer

    def __deref__(self) -> "itkCellInterfaceDCTI2FFULULULPF2MCULPF2 *":
        """__deref__(itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer self) -> itkCellInterfaceDCTI2FFULULULPF2MCULPF2"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer___deref__(self)


    def Reset(self) -> "void":
        """Reset(itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer self)"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_Reset(self)


    def TakeOwnership(self, *args) -> "void":
        """
        TakeOwnership(itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer self)
        TakeOwnership(itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceDCTI2FFULULULPF2MCULPF2 objectptr)
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_TakeOwnership(self, *args)


    def TakeNoOwnership(self, objectptr: 'itkCellInterfaceDCTI2FFULULULPF2MCULPF2') -> "void":
        """TakeNoOwnership(itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceDCTI2FFULULULPF2MCULPF2 objectptr)"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_TakeNoOwnership(self, objectptr)


    def IsOwner(self) -> "bool":
        """IsOwner(itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer self) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_IsOwner(self)


    def ReleaseOwnership(self) -> "itkCellInterfaceDCTI2FFULULULPF2MCULPF2 *":
        """ReleaseOwnership(itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer self) -> itkCellInterfaceDCTI2FFULULULPF2MCULPF2"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_ReleaseOwnership(self)


    def GetPointer(self) -> "itkCellInterfaceDCTI2FFULULULPF2MCULPF2 *":
        """GetPointer(itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer self) -> itkCellInterfaceDCTI2FFULULULPF2MCULPF2"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_GetPointer(self)


    def __eq__(self, r: 'itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """__eq__(itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer___eq__(self, r)


    def __ne__(self, r: 'itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """__ne__(itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer___ne__(self, r)


    def __lt__(self, r: 'itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """__lt__(itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer___lt__(self, r)


    def __gt__(self, r: 'itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """__gt__(itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer___gt__(self, r)


    def __le__(self, r: 'itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """__le__(itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer___le__(self, r)


    def __ge__(self, r: 'itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """__ge__(itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer___ge__(self, r)


    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceDCTI2FFULULULPF2MCULPF2::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer self, unsigned long cellId, itkCellInterfaceDCTI2FFULULULPF2MCULPF2::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCommonEnums::CellGeometry":
        """
        GetType(itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer self) -> itkCommonEnums::CellGeometry

        Return the type of the cell
        (one of the CellGeometryEnum enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer self, int dimension, unsigned long arg1, itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer self, unsigned long const * first)
        SetPointIds(itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer self) -> unsigned long
        PointIdsBegin(itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer self) -> unsigned long
        PointIdsEnd(itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'float *', arg1: 'bool *', arg2: 'itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer self, float * arg0, bool * arg1, itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not nullptr, the flag is set to indicate whether the point is inside
        the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'float *', arg1: 'itkMapContainerULPF2', arg2: 'float *', arg3: 'float *', arg4: 'double *', arg5: 'float *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer self, float * arg0, itkMapContainerULPF2 arg1, float * arg2, float * arg3, double * arg4, float * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not nullptr:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayF', arg1: 'itkArrayF') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer self, itkArrayF arg0, itkArrayF arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float', arg3: 'float *', arg4: 'float *', arg5: 'float *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer self, float * arg0, float * arg1, float arg2, float * arg3, float * arg4, float * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'float *') -> "float *":
        """
        GetBoundingBox(itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer self, float * arg0) -> float *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "float":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer self) -> float

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float *', arg3: 'float *', arg4: 'float *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer self, float * arg0, float * arg1, float * arg2, float * arg3, float * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_GetNameOfClass(self)

itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer.__deref__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer___deref__, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer.Reset = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_Reset, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer.TakeOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_TakeOwnership, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer.TakeNoOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_TakeNoOwnership, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer.IsOwner = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_IsOwner, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer.ReleaseOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_ReleaseOwnership, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer.GetPointer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_GetPointer, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer.__eq__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer___eq__, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer.__ne__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer___ne__, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer.__lt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer___lt__, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer.__gt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer___gt__, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer.__le__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer___le__, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer.__ge__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer___ge__, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_Accept, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_GetType, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_MakeCopy, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_GetDimension, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_GetInterpolationOrder, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_GetNumberOfPoints, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_GetNumberOfBoundaryFeatures, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_GetBoundaryFeature, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_GetPointIds, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_SetPointIds, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_SetPointId, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_PointIdsBegin, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_PointIdsEnd, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_GetPointIdsContainer, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_SetPointIdsContainer, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_GetClosestBoundary, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_EvaluatePosition, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_EvaluateShapeFunctions, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_IntersectWithLine, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_GetBoundingBox, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_IntersectBoundingBoxWithLine, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_IsExplicitBoundary, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_AddUsingCell, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_RemoveUsingCell, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_IsUsingCell, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_GetNumberOfUsingCells, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_GetNameOfClass, None, itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_swigregister = _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_swigregister
itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer_swigregister(itkCellInterfaceDCTI2FFULULULPF2MCULPF2_AutoPointer)

class itkCellInterfaceDCTI2FFULULULPF2VCULPF2(object):
    """


    An abstract interface for cells.

    Define an abstract interface for cells. Actual cell types derive from
    this class.

    Parameters:
    -----------

    TPixelType:  The type stored with an entity (cell, point, or
    boundary).

    TCellTraits:  Type information for cell.

    C++ includes: itkCellInterface.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceDCTI2FFULULULPF2VCULPF2::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceDCTI2FFULULULPF2VCULPF2 self, unsigned long cellId, itkCellInterfaceDCTI2FFULULULPF2VCULPF2::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCommonEnums::CellGeometry":
        """
        GetType(itkCellInterfaceDCTI2FFULULULPF2VCULPF2 self) -> itkCommonEnums::CellGeometry

        Return the type of the cell
        (one of the CellGeometryEnum enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceDCTI2FFULULULPF2VCULPF2 self, itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceDCTI2FFULULULPF2VCULPF2 self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceDCTI2FFULULULPF2VCULPF2 self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceDCTI2FFULULULPF2VCULPF2 self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceDCTI2FFULULULPF2VCULPF2 self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceDCTI2FFULULULPF2VCULPF2 self, int dimension, unsigned long arg1, itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceDCTI2FFULULULPF2VCULPF2 self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceDCTI2FFULULULPF2VCULPF2 self, unsigned long const * first)
        SetPointIds(itkCellInterfaceDCTI2FFULULULPF2VCULPF2 self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceDCTI2FFULULULPF2VCULPF2 self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceDCTI2FFULULULPF2VCULPF2 self) -> unsigned long
        PointIdsBegin(itkCellInterfaceDCTI2FFULULULPF2VCULPF2 self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceDCTI2FFULULULPF2VCULPF2 self) -> unsigned long
        PointIdsEnd(itkCellInterfaceDCTI2FFULULULPF2VCULPF2 self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceDCTI2FFULULULPF2VCULPF2 self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceDCTI2FFULULULPF2VCULPF2 self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'float *', arg1: 'bool *', arg2: 'itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceDCTI2FFULULULPF2VCULPF2 self, float * arg0, bool * arg1, itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not nullptr, the flag is set to indicate whether the point is inside
        the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'float *', arg1: 'itkVectorContainerULPF2', arg2: 'float *', arg3: 'float *', arg4: 'double *', arg5: 'float *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceDCTI2FFULULULPF2VCULPF2 self, float * arg0, itkVectorContainerULPF2 arg1, float * arg2, float * arg3, double * arg4, float * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not nullptr:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayF', arg1: 'itkArrayF') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceDCTI2FFULULULPF2VCULPF2 self, itkArrayF arg0, itkArrayF arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float', arg3: 'float *', arg4: 'float *', arg5: 'float *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceDCTI2FFULULULPF2VCULPF2 self, float * arg0, float * arg1, float arg2, float * arg3, float * arg4, float * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'float *') -> "float *":
        """
        GetBoundingBox(itkCellInterfaceDCTI2FFULULULPF2VCULPF2 self, float * arg0) -> float *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "float":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceDCTI2FFULULULPF2VCULPF2 self) -> float

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float *', arg3: 'float *', arg4: 'float *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceDCTI2FFULULULPF2VCULPF2 self, float * arg0, float * arg1, float * arg2, float * arg3, float * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceDCTI2FFULULULPF2VCULPF2 self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceDCTI2FFULULULPF2VCULPF2 self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceDCTI2FFULULULPF2VCULPF2 self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceDCTI2FFULULULPF2VCULPF2 self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceDCTI2FFULULULPF2VCULPF2 self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceDCTI2FFULULULPF2VCULPF2 self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_GetNameOfClass(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceDCTI2FFULULULPF2VCULPF2
itkCellInterfaceDCTI2FFULULULPF2VCULPF2.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_Accept, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_GetType, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_MakeCopy, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_GetDimension, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_GetInterpolationOrder, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_GetNumberOfPoints, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_GetNumberOfBoundaryFeatures, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_GetBoundaryFeature, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_GetPointIds, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_SetPointIds, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_SetPointId, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_PointIdsBegin, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_PointIdsEnd, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_GetPointIdsContainer, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_SetPointIdsContainer, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_GetClosestBoundary, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_EvaluatePosition, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_EvaluateShapeFunctions, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_IntersectWithLine, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_GetBoundingBox, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_IntersectBoundingBoxWithLine, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_IsExplicitBoundary, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AddUsingCell, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_RemoveUsingCell, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_IsUsingCell, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_GetNumberOfUsingCells, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_GetNameOfClass, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2_swigregister = _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_swigregister
itkCellInterfaceDCTI2FFULULULPF2VCULPF2_swigregister(itkCellInterfaceDCTI2FFULULULPF2VCULPF2)

class itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer(object):
    """Proxy of C++ itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer self) -> itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer
        __init__(itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer p) -> itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer
        __init__(itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceDCTI2FFULULULPF2VCULPF2 p, bool takeOwnership) -> itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer
        """
        _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_swiginit(self, _itkMeshBasePython.new_itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer(*args))
    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer

    def __deref__(self) -> "itkCellInterfaceDCTI2FFULULULPF2VCULPF2 *":
        """__deref__(itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer self) -> itkCellInterfaceDCTI2FFULULULPF2VCULPF2"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer___deref__(self)


    def Reset(self) -> "void":
        """Reset(itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer self)"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_Reset(self)


    def TakeOwnership(self, *args) -> "void":
        """
        TakeOwnership(itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer self)
        TakeOwnership(itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceDCTI2FFULULULPF2VCULPF2 objectptr)
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_TakeOwnership(self, *args)


    def TakeNoOwnership(self, objectptr: 'itkCellInterfaceDCTI2FFULULULPF2VCULPF2') -> "void":
        """TakeNoOwnership(itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceDCTI2FFULULULPF2VCULPF2 objectptr)"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_TakeNoOwnership(self, objectptr)


    def IsOwner(self) -> "bool":
        """IsOwner(itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer self) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_IsOwner(self)


    def ReleaseOwnership(self) -> "itkCellInterfaceDCTI2FFULULULPF2VCULPF2 *":
        """ReleaseOwnership(itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer self) -> itkCellInterfaceDCTI2FFULULULPF2VCULPF2"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_ReleaseOwnership(self)


    def GetPointer(self) -> "itkCellInterfaceDCTI2FFULULULPF2VCULPF2 *":
        """GetPointer(itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer self) -> itkCellInterfaceDCTI2FFULULULPF2VCULPF2"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_GetPointer(self)


    def __eq__(self, r: 'itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """__eq__(itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer___eq__(self, r)


    def __ne__(self, r: 'itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """__ne__(itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer___ne__(self, r)


    def __lt__(self, r: 'itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """__lt__(itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer___lt__(self, r)


    def __gt__(self, r: 'itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """__gt__(itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer___gt__(self, r)


    def __le__(self, r: 'itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """__le__(itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer___le__(self, r)


    def __ge__(self, r: 'itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """__ge__(itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer___ge__(self, r)


    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceDCTI2FFULULULPF2VCULPF2::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer self, unsigned long cellId, itkCellInterfaceDCTI2FFULULULPF2VCULPF2::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCommonEnums::CellGeometry":
        """
        GetType(itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer self) -> itkCommonEnums::CellGeometry

        Return the type of the cell
        (one of the CellGeometryEnum enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer self, int dimension, unsigned long arg1, itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer self, unsigned long const * first)
        SetPointIds(itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer self) -> unsigned long
        PointIdsBegin(itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer self) -> unsigned long
        PointIdsEnd(itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'float *', arg1: 'bool *', arg2: 'itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer self, float * arg0, bool * arg1, itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not nullptr, the flag is set to indicate whether the point is inside
        the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'float *', arg1: 'itkVectorContainerULPF2', arg2: 'float *', arg3: 'float *', arg4: 'double *', arg5: 'float *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer self, float * arg0, itkVectorContainerULPF2 arg1, float * arg2, float * arg3, double * arg4, float * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not nullptr:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayF', arg1: 'itkArrayF') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer self, itkArrayF arg0, itkArrayF arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float', arg3: 'float *', arg4: 'float *', arg5: 'float *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer self, float * arg0, float * arg1, float arg2, float * arg3, float * arg4, float * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'float *') -> "float *":
        """
        GetBoundingBox(itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer self, float * arg0) -> float *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "float":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer self) -> float

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float *', arg3: 'float *', arg4: 'float *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer self, float * arg0, float * arg1, float * arg2, float * arg3, float * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_GetNameOfClass(self)

itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer.__deref__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer___deref__, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer.Reset = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_Reset, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer.TakeOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_TakeOwnership, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer.TakeNoOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_TakeNoOwnership, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer.IsOwner = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_IsOwner, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer.ReleaseOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_ReleaseOwnership, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer.GetPointer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_GetPointer, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer.__eq__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer___eq__, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer.__ne__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer___ne__, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer.__lt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer___lt__, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer.__gt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer___gt__, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer.__le__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer___le__, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer.__ge__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer___ge__, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_Accept, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_GetType, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_MakeCopy, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_GetDimension, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_GetInterpolationOrder, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_GetNumberOfPoints, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_GetNumberOfBoundaryFeatures, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_GetBoundaryFeature, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_GetPointIds, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_SetPointIds, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_SetPointId, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_PointIdsBegin, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_PointIdsEnd, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_GetPointIdsContainer, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_SetPointIdsContainer, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_GetClosestBoundary, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_EvaluatePosition, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_EvaluateShapeFunctions, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_IntersectWithLine, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_GetBoundingBox, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_IntersectBoundingBoxWithLine, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_IsExplicitBoundary, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_AddUsingCell, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_RemoveUsingCell, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_IsUsingCell, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_GetNumberOfUsingCells, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_GetNameOfClass, None, itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_swigregister = _itkMeshBasePython.itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_swigregister
itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer_swigregister(itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer)

class itkCellInterfaceDCTI3FFULULULPF3MCULPF3(object):
    """


    An abstract interface for cells.

    Define an abstract interface for cells. Actual cell types derive from
    this class.

    Parameters:
    -----------

    TPixelType:  The type stored with an entity (cell, point, or
    boundary).

    TCellTraits:  Type information for cell.

    C++ includes: itkCellInterface.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceDCTI3FFULULULPF3MCULPF3::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceDCTI3FFULULULPF3MCULPF3 self, unsigned long cellId, itkCellInterfaceDCTI3FFULULULPF3MCULPF3::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCommonEnums::CellGeometry":
        """
        GetType(itkCellInterfaceDCTI3FFULULULPF3MCULPF3 self) -> itkCommonEnums::CellGeometry

        Return the type of the cell
        (one of the CellGeometryEnum enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceDCTI3FFULULULPF3MCULPF3 self, itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceDCTI3FFULULULPF3MCULPF3 self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceDCTI3FFULULULPF3MCULPF3 self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceDCTI3FFULULULPF3MCULPF3 self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceDCTI3FFULULULPF3MCULPF3 self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceDCTI3FFULULULPF3MCULPF3 self, int dimension, unsigned long arg1, itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceDCTI3FFULULULPF3MCULPF3 self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceDCTI3FFULULULPF3MCULPF3 self, unsigned long const * first)
        SetPointIds(itkCellInterfaceDCTI3FFULULULPF3MCULPF3 self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceDCTI3FFULULULPF3MCULPF3 self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceDCTI3FFULULULPF3MCULPF3 self) -> unsigned long
        PointIdsBegin(itkCellInterfaceDCTI3FFULULULPF3MCULPF3 self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceDCTI3FFULULULPF3MCULPF3 self) -> unsigned long
        PointIdsEnd(itkCellInterfaceDCTI3FFULULULPF3MCULPF3 self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceDCTI3FFULULULPF3MCULPF3 self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceDCTI3FFULULULPF3MCULPF3 self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'float *', arg1: 'bool *', arg2: 'itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceDCTI3FFULULULPF3MCULPF3 self, float * arg0, bool * arg1, itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not nullptr, the flag is set to indicate whether the point is inside
        the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'float *', arg1: 'itkMapContainerULPF3', arg2: 'float *', arg3: 'float *', arg4: 'double *', arg5: 'float *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceDCTI3FFULULULPF3MCULPF3 self, float * arg0, itkMapContainerULPF3 arg1, float * arg2, float * arg3, double * arg4, float * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not nullptr:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayF', arg1: 'itkArrayF') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceDCTI3FFULULULPF3MCULPF3 self, itkArrayF arg0, itkArrayF arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float', arg3: 'float *', arg4: 'float *', arg5: 'float *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceDCTI3FFULULULPF3MCULPF3 self, float * arg0, float * arg1, float arg2, float * arg3, float * arg4, float * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'float *') -> "float *":
        """
        GetBoundingBox(itkCellInterfaceDCTI3FFULULULPF3MCULPF3 self, float * arg0) -> float *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "float":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceDCTI3FFULULULPF3MCULPF3 self) -> float

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float *', arg3: 'float *', arg4: 'float *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceDCTI3FFULULULPF3MCULPF3 self, float * arg0, float * arg1, float * arg2, float * arg3, float * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceDCTI3FFULULULPF3MCULPF3 self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceDCTI3FFULULULPF3MCULPF3 self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceDCTI3FFULULULPF3MCULPF3 self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceDCTI3FFULULULPF3MCULPF3 self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceDCTI3FFULULULPF3MCULPF3 self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceDCTI3FFULULULPF3MCULPF3 self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_GetNameOfClass(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceDCTI3FFULULULPF3MCULPF3
itkCellInterfaceDCTI3FFULULULPF3MCULPF3.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_Accept, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_GetType, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_MakeCopy, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_GetDimension, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_GetInterpolationOrder, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_GetNumberOfPoints, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_GetNumberOfBoundaryFeatures, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_GetBoundaryFeature, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_GetPointIds, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_SetPointIds, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_SetPointId, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_PointIdsBegin, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_PointIdsEnd, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_GetPointIdsContainer, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_SetPointIdsContainer, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_GetClosestBoundary, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_EvaluatePosition, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_EvaluateShapeFunctions, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_IntersectWithLine, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_GetBoundingBox, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_IntersectBoundingBoxWithLine, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_IsExplicitBoundary, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AddUsingCell, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_RemoveUsingCell, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_IsUsingCell, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_GetNumberOfUsingCells, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_GetNameOfClass, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3_swigregister = _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_swigregister
itkCellInterfaceDCTI3FFULULULPF3MCULPF3_swigregister(itkCellInterfaceDCTI3FFULULULPF3MCULPF3)

class itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer(object):
    """Proxy of C++ itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer self) -> itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer
        __init__(itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer p) -> itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer
        __init__(itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceDCTI3FFULULULPF3MCULPF3 p, bool takeOwnership) -> itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer
        """
        _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_swiginit(self, _itkMeshBasePython.new_itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer(*args))
    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer

    def __deref__(self) -> "itkCellInterfaceDCTI3FFULULULPF3MCULPF3 *":
        """__deref__(itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer self) -> itkCellInterfaceDCTI3FFULULULPF3MCULPF3"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer___deref__(self)


    def Reset(self) -> "void":
        """Reset(itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer self)"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_Reset(self)


    def TakeOwnership(self, *args) -> "void":
        """
        TakeOwnership(itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer self)
        TakeOwnership(itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceDCTI3FFULULULPF3MCULPF3 objectptr)
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_TakeOwnership(self, *args)


    def TakeNoOwnership(self, objectptr: 'itkCellInterfaceDCTI3FFULULULPF3MCULPF3') -> "void":
        """TakeNoOwnership(itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceDCTI3FFULULULPF3MCULPF3 objectptr)"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_TakeNoOwnership(self, objectptr)


    def IsOwner(self) -> "bool":
        """IsOwner(itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer self) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_IsOwner(self)


    def ReleaseOwnership(self) -> "itkCellInterfaceDCTI3FFULULULPF3MCULPF3 *":
        """ReleaseOwnership(itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer self) -> itkCellInterfaceDCTI3FFULULULPF3MCULPF3"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_ReleaseOwnership(self)


    def GetPointer(self) -> "itkCellInterfaceDCTI3FFULULULPF3MCULPF3 *":
        """GetPointer(itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer self) -> itkCellInterfaceDCTI3FFULULULPF3MCULPF3"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_GetPointer(self)


    def __eq__(self, r: 'itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """__eq__(itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer___eq__(self, r)


    def __ne__(self, r: 'itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """__ne__(itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer___ne__(self, r)


    def __lt__(self, r: 'itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """__lt__(itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer___lt__(self, r)


    def __gt__(self, r: 'itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """__gt__(itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer___gt__(self, r)


    def __le__(self, r: 'itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """__le__(itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer___le__(self, r)


    def __ge__(self, r: 'itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """__ge__(itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer___ge__(self, r)


    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceDCTI3FFULULULPF3MCULPF3::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer self, unsigned long cellId, itkCellInterfaceDCTI3FFULULULPF3MCULPF3::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCommonEnums::CellGeometry":
        """
        GetType(itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer self) -> itkCommonEnums::CellGeometry

        Return the type of the cell
        (one of the CellGeometryEnum enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer self, int dimension, unsigned long arg1, itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer self, unsigned long const * first)
        SetPointIds(itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer self) -> unsigned long
        PointIdsBegin(itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer self) -> unsigned long
        PointIdsEnd(itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'float *', arg1: 'bool *', arg2: 'itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer self, float * arg0, bool * arg1, itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not nullptr, the flag is set to indicate whether the point is inside
        the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'float *', arg1: 'itkMapContainerULPF3', arg2: 'float *', arg3: 'float *', arg4: 'double *', arg5: 'float *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer self, float * arg0, itkMapContainerULPF3 arg1, float * arg2, float * arg3, double * arg4, float * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not nullptr:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayF', arg1: 'itkArrayF') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer self, itkArrayF arg0, itkArrayF arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float', arg3: 'float *', arg4: 'float *', arg5: 'float *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer self, float * arg0, float * arg1, float arg2, float * arg3, float * arg4, float * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'float *') -> "float *":
        """
        GetBoundingBox(itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer self, float * arg0) -> float *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "float":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer self) -> float

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float *', arg3: 'float *', arg4: 'float *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer self, float * arg0, float * arg1, float * arg2, float * arg3, float * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_GetNameOfClass(self)

itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer.__deref__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer___deref__, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer.Reset = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_Reset, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer.TakeOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_TakeOwnership, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer.TakeNoOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_TakeNoOwnership, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer.IsOwner = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_IsOwner, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer.ReleaseOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_ReleaseOwnership, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer.GetPointer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_GetPointer, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer.__eq__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer___eq__, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer.__ne__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer___ne__, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer.__lt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer___lt__, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer.__gt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer___gt__, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer.__le__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer___le__, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer.__ge__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer___ge__, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_Accept, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_GetType, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_MakeCopy, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_GetDimension, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_GetInterpolationOrder, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_GetNumberOfPoints, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_GetNumberOfBoundaryFeatures, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_GetBoundaryFeature, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_GetPointIds, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_SetPointIds, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_SetPointId, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_PointIdsBegin, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_PointIdsEnd, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_GetPointIdsContainer, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_SetPointIdsContainer, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_GetClosestBoundary, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_EvaluatePosition, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_EvaluateShapeFunctions, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_IntersectWithLine, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_GetBoundingBox, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_IntersectBoundingBoxWithLine, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_IsExplicitBoundary, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_AddUsingCell, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_RemoveUsingCell, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_IsUsingCell, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_GetNumberOfUsingCells, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_GetNameOfClass, None, itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_swigregister = _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_swigregister
itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer_swigregister(itkCellInterfaceDCTI3FFULULULPF3MCULPF3_AutoPointer)

class itkCellInterfaceDCTI3FFULULULPF3VCULPF3(object):
    """


    An abstract interface for cells.

    Define an abstract interface for cells. Actual cell types derive from
    this class.

    Parameters:
    -----------

    TPixelType:  The type stored with an entity (cell, point, or
    boundary).

    TCellTraits:  Type information for cell.

    C++ includes: itkCellInterface.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceDCTI3FFULULULPF3VCULPF3::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceDCTI3FFULULULPF3VCULPF3 self, unsigned long cellId, itkCellInterfaceDCTI3FFULULULPF3VCULPF3::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCommonEnums::CellGeometry":
        """
        GetType(itkCellInterfaceDCTI3FFULULULPF3VCULPF3 self) -> itkCommonEnums::CellGeometry

        Return the type of the cell
        (one of the CellGeometryEnum enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceDCTI3FFULULULPF3VCULPF3 self, itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceDCTI3FFULULULPF3VCULPF3 self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceDCTI3FFULULULPF3VCULPF3 self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceDCTI3FFULULULPF3VCULPF3 self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceDCTI3FFULULULPF3VCULPF3 self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceDCTI3FFULULULPF3VCULPF3 self, int dimension, unsigned long arg1, itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceDCTI3FFULULULPF3VCULPF3 self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceDCTI3FFULULULPF3VCULPF3 self, unsigned long const * first)
        SetPointIds(itkCellInterfaceDCTI3FFULULULPF3VCULPF3 self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceDCTI3FFULULULPF3VCULPF3 self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceDCTI3FFULULULPF3VCULPF3 self) -> unsigned long
        PointIdsBegin(itkCellInterfaceDCTI3FFULULULPF3VCULPF3 self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceDCTI3FFULULULPF3VCULPF3 self) -> unsigned long
        PointIdsEnd(itkCellInterfaceDCTI3FFULULULPF3VCULPF3 self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceDCTI3FFULULULPF3VCULPF3 self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceDCTI3FFULULULPF3VCULPF3 self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'float *', arg1: 'bool *', arg2: 'itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceDCTI3FFULULULPF3VCULPF3 self, float * arg0, bool * arg1, itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not nullptr, the flag is set to indicate whether the point is inside
        the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'float *', arg1: 'itkVectorContainerULPF3', arg2: 'float *', arg3: 'float *', arg4: 'double *', arg5: 'float *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceDCTI3FFULULULPF3VCULPF3 self, float * arg0, itkVectorContainerULPF3 arg1, float * arg2, float * arg3, double * arg4, float * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not nullptr:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayF', arg1: 'itkArrayF') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceDCTI3FFULULULPF3VCULPF3 self, itkArrayF arg0, itkArrayF arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float', arg3: 'float *', arg4: 'float *', arg5: 'float *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceDCTI3FFULULULPF3VCULPF3 self, float * arg0, float * arg1, float arg2, float * arg3, float * arg4, float * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'float *') -> "float *":
        """
        GetBoundingBox(itkCellInterfaceDCTI3FFULULULPF3VCULPF3 self, float * arg0) -> float *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "float":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceDCTI3FFULULULPF3VCULPF3 self) -> float

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float *', arg3: 'float *', arg4: 'float *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceDCTI3FFULULULPF3VCULPF3 self, float * arg0, float * arg1, float * arg2, float * arg3, float * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceDCTI3FFULULULPF3VCULPF3 self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceDCTI3FFULULULPF3VCULPF3 self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceDCTI3FFULULULPF3VCULPF3 self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceDCTI3FFULULULPF3VCULPF3 self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceDCTI3FFULULULPF3VCULPF3 self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceDCTI3FFULULULPF3VCULPF3 self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_GetNameOfClass(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceDCTI3FFULULULPF3VCULPF3
itkCellInterfaceDCTI3FFULULULPF3VCULPF3.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_Accept, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_GetType, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_MakeCopy, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_GetDimension, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_GetInterpolationOrder, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_GetNumberOfPoints, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_GetNumberOfBoundaryFeatures, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_GetBoundaryFeature, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_GetPointIds, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_SetPointIds, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_SetPointId, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_PointIdsBegin, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_PointIdsEnd, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_GetPointIdsContainer, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_SetPointIdsContainer, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_GetClosestBoundary, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_EvaluatePosition, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_EvaluateShapeFunctions, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_IntersectWithLine, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_GetBoundingBox, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_IntersectBoundingBoxWithLine, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_IsExplicitBoundary, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AddUsingCell, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_RemoveUsingCell, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_IsUsingCell, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_GetNumberOfUsingCells, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_GetNameOfClass, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3_swigregister = _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_swigregister
itkCellInterfaceDCTI3FFULULULPF3VCULPF3_swigregister(itkCellInterfaceDCTI3FFULULULPF3VCULPF3)

class itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer(object):
    """Proxy of C++ itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer self) -> itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer
        __init__(itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer p) -> itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer
        __init__(itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceDCTI3FFULULULPF3VCULPF3 p, bool takeOwnership) -> itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer
        """
        _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_swiginit(self, _itkMeshBasePython.new_itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer(*args))
    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer

    def __deref__(self) -> "itkCellInterfaceDCTI3FFULULULPF3VCULPF3 *":
        """__deref__(itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer self) -> itkCellInterfaceDCTI3FFULULULPF3VCULPF3"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer___deref__(self)


    def Reset(self) -> "void":
        """Reset(itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer self)"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_Reset(self)


    def TakeOwnership(self, *args) -> "void":
        """
        TakeOwnership(itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer self)
        TakeOwnership(itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceDCTI3FFULULULPF3VCULPF3 objectptr)
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_TakeOwnership(self, *args)


    def TakeNoOwnership(self, objectptr: 'itkCellInterfaceDCTI3FFULULULPF3VCULPF3') -> "void":
        """TakeNoOwnership(itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceDCTI3FFULULULPF3VCULPF3 objectptr)"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_TakeNoOwnership(self, objectptr)


    def IsOwner(self) -> "bool":
        """IsOwner(itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer self) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_IsOwner(self)


    def ReleaseOwnership(self) -> "itkCellInterfaceDCTI3FFULULULPF3VCULPF3 *":
        """ReleaseOwnership(itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer self) -> itkCellInterfaceDCTI3FFULULULPF3VCULPF3"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_ReleaseOwnership(self)


    def GetPointer(self) -> "itkCellInterfaceDCTI3FFULULULPF3VCULPF3 *":
        """GetPointer(itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer self) -> itkCellInterfaceDCTI3FFULULULPF3VCULPF3"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_GetPointer(self)


    def __eq__(self, r: 'itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """__eq__(itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer___eq__(self, r)


    def __ne__(self, r: 'itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """__ne__(itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer___ne__(self, r)


    def __lt__(self, r: 'itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """__lt__(itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer___lt__(self, r)


    def __gt__(self, r: 'itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """__gt__(itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer___gt__(self, r)


    def __le__(self, r: 'itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """__le__(itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer___le__(self, r)


    def __ge__(self, r: 'itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """__ge__(itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer___ge__(self, r)


    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceDCTI3FFULULULPF3VCULPF3::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer self, unsigned long cellId, itkCellInterfaceDCTI3FFULULULPF3VCULPF3::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCommonEnums::CellGeometry":
        """
        GetType(itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer self) -> itkCommonEnums::CellGeometry

        Return the type of the cell
        (one of the CellGeometryEnum enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer self, int dimension, unsigned long arg1, itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer self, unsigned long const * first)
        SetPointIds(itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer self) -> unsigned long
        PointIdsBegin(itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer self) -> unsigned long
        PointIdsEnd(itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'float *', arg1: 'bool *', arg2: 'itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer self, float * arg0, bool * arg1, itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not nullptr, the flag is set to indicate whether the point is inside
        the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'float *', arg1: 'itkVectorContainerULPF3', arg2: 'float *', arg3: 'float *', arg4: 'double *', arg5: 'float *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer self, float * arg0, itkVectorContainerULPF3 arg1, float * arg2, float * arg3, double * arg4, float * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not nullptr:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayF', arg1: 'itkArrayF') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer self, itkArrayF arg0, itkArrayF arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float', arg3: 'float *', arg4: 'float *', arg5: 'float *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer self, float * arg0, float * arg1, float arg2, float * arg3, float * arg4, float * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'float *') -> "float *":
        """
        GetBoundingBox(itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer self, float * arg0) -> float *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "float":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer self) -> float

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float *', arg3: 'float *', arg4: 'float *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer self, float * arg0, float * arg1, float * arg2, float * arg3, float * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_GetNameOfClass(self)

itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer.__deref__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer___deref__, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer.Reset = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_Reset, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer.TakeOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_TakeOwnership, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer.TakeNoOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_TakeNoOwnership, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer.IsOwner = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_IsOwner, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer.ReleaseOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_ReleaseOwnership, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer.GetPointer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_GetPointer, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer.__eq__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer___eq__, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer.__ne__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer___ne__, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer.__lt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer___lt__, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer.__gt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer___gt__, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer.__le__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer___le__, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer.__ge__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer___ge__, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_Accept, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_GetType, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_MakeCopy, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_GetDimension, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_GetInterpolationOrder, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_GetNumberOfPoints, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_GetNumberOfBoundaryFeatures, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_GetBoundaryFeature, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_GetPointIds, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_SetPointIds, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_SetPointId, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_PointIdsBegin, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_PointIdsEnd, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_GetPointIdsContainer, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_SetPointIdsContainer, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_GetClosestBoundary, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_EvaluatePosition, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_EvaluateShapeFunctions, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_IntersectWithLine, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_GetBoundingBox, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_IntersectBoundingBoxWithLine, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_IsExplicitBoundary, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_AddUsingCell, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_RemoveUsingCell, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_IsUsingCell, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_GetNumberOfUsingCells, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_GetNameOfClass, None, itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_swigregister = _itkMeshBasePython.itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_swigregister
itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer_swigregister(itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer)

class itkCellInterfaceFCTI2FFULULULPF2MCULPF2(object):
    """


    An abstract interface for cells.

    Define an abstract interface for cells. Actual cell types derive from
    this class.

    Parameters:
    -----------

    TPixelType:  The type stored with an entity (cell, point, or
    boundary).

    TCellTraits:  Type information for cell.

    C++ includes: itkCellInterface.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceFCTI2FFULULULPF2MCULPF2::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceFCTI2FFULULULPF2MCULPF2 self, unsigned long cellId, itkCellInterfaceFCTI2FFULULULPF2MCULPF2::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCommonEnums::CellGeometry":
        """
        GetType(itkCellInterfaceFCTI2FFULULULPF2MCULPF2 self) -> itkCommonEnums::CellGeometry

        Return the type of the cell
        (one of the CellGeometryEnum enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceFCTI2FFULULULPF2MCULPF2 self, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceFCTI2FFULULULPF2MCULPF2 self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceFCTI2FFULULULPF2MCULPF2 self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceFCTI2FFULULULPF2MCULPF2 self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceFCTI2FFULULULPF2MCULPF2 self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceFCTI2FFULULULPF2MCULPF2 self, int dimension, unsigned long arg1, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceFCTI2FFULULULPF2MCULPF2 self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceFCTI2FFULULULPF2MCULPF2 self, unsigned long const * first)
        SetPointIds(itkCellInterfaceFCTI2FFULULULPF2MCULPF2 self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceFCTI2FFULULULPF2MCULPF2 self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceFCTI2FFULULULPF2MCULPF2 self) -> unsigned long
        PointIdsBegin(itkCellInterfaceFCTI2FFULULULPF2MCULPF2 self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceFCTI2FFULULULPF2MCULPF2 self) -> unsigned long
        PointIdsEnd(itkCellInterfaceFCTI2FFULULULPF2MCULPF2 self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceFCTI2FFULULULPF2MCULPF2 self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceFCTI2FFULULULPF2MCULPF2 self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'float *', arg1: 'bool *', arg2: 'itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceFCTI2FFULULULPF2MCULPF2 self, float * arg0, bool * arg1, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not nullptr, the flag is set to indicate whether the point is inside
        the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'float *', arg1: 'itkMapContainerULPF2', arg2: 'float *', arg3: 'float *', arg4: 'double *', arg5: 'float *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceFCTI2FFULULULPF2MCULPF2 self, float * arg0, itkMapContainerULPF2 arg1, float * arg2, float * arg3, double * arg4, float * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not nullptr:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayF', arg1: 'itkArrayF') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceFCTI2FFULULULPF2MCULPF2 self, itkArrayF arg0, itkArrayF arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float', arg3: 'float *', arg4: 'float *', arg5: 'float *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceFCTI2FFULULULPF2MCULPF2 self, float * arg0, float * arg1, float arg2, float * arg3, float * arg4, float * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'float *') -> "float *":
        """
        GetBoundingBox(itkCellInterfaceFCTI2FFULULULPF2MCULPF2 self, float * arg0) -> float *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "float":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceFCTI2FFULULULPF2MCULPF2 self) -> float

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float *', arg3: 'float *', arg4: 'float *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceFCTI2FFULULULPF2MCULPF2 self, float * arg0, float * arg1, float * arg2, float * arg3, float * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceFCTI2FFULULULPF2MCULPF2 self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceFCTI2FFULULULPF2MCULPF2 self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceFCTI2FFULULULPF2MCULPF2 self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceFCTI2FFULULULPF2MCULPF2 self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceFCTI2FFULULULPF2MCULPF2 self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceFCTI2FFULULULPF2MCULPF2 self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_GetNameOfClass(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceFCTI2FFULULULPF2MCULPF2
itkCellInterfaceFCTI2FFULULULPF2MCULPF2.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_Accept, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_GetType, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_MakeCopy, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_GetDimension, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_GetInterpolationOrder, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_GetNumberOfPoints, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_GetNumberOfBoundaryFeatures, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_GetBoundaryFeature, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_GetPointIds, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_SetPointIds, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_SetPointId, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_PointIdsBegin, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_PointIdsEnd, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_GetPointIdsContainer, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_SetPointIdsContainer, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_GetClosestBoundary, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_EvaluatePosition, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_EvaluateShapeFunctions, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_IntersectWithLine, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_GetBoundingBox, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_IntersectBoundingBoxWithLine, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_IsExplicitBoundary, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AddUsingCell, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_RemoveUsingCell, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_IsUsingCell, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_GetNumberOfUsingCells, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_GetNameOfClass, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_swigregister = _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_swigregister
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_swigregister(itkCellInterfaceFCTI2FFULULULPF2MCULPF2)

class itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer(object):
    """Proxy of C++ itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self) -> itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer
        __init__(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer p) -> itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer
        __init__(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceFCTI2FFULULULPF2MCULPF2 p, bool takeOwnership) -> itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer
        """
        _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_swiginit(self, _itkMeshBasePython.new_itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer(*args))
    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer

    def __deref__(self) -> "itkCellInterfaceFCTI2FFULULULPF2MCULPF2 *":
        """__deref__(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self) -> itkCellInterfaceFCTI2FFULULULPF2MCULPF2"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer___deref__(self)


    def Reset(self) -> "void":
        """Reset(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self)"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_Reset(self)


    def TakeOwnership(self, *args) -> "void":
        """
        TakeOwnership(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self)
        TakeOwnership(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceFCTI2FFULULULPF2MCULPF2 objectptr)
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_TakeOwnership(self, *args)


    def TakeNoOwnership(self, objectptr: 'itkCellInterfaceFCTI2FFULULULPF2MCULPF2') -> "void":
        """TakeNoOwnership(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceFCTI2FFULULULPF2MCULPF2 objectptr)"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_TakeNoOwnership(self, objectptr)


    def IsOwner(self) -> "bool":
        """IsOwner(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_IsOwner(self)


    def ReleaseOwnership(self) -> "itkCellInterfaceFCTI2FFULULULPF2MCULPF2 *":
        """ReleaseOwnership(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self) -> itkCellInterfaceFCTI2FFULULULPF2MCULPF2"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_ReleaseOwnership(self)


    def GetPointer(self) -> "itkCellInterfaceFCTI2FFULULULPF2MCULPF2 *":
        """GetPointer(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self) -> itkCellInterfaceFCTI2FFULULULPF2MCULPF2"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_GetPointer(self)


    def __eq__(self, r: 'itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """__eq__(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer___eq__(self, r)


    def __ne__(self, r: 'itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """__ne__(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer___ne__(self, r)


    def __lt__(self, r: 'itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """__lt__(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer___lt__(self, r)


    def __gt__(self, r: 'itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """__gt__(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer___gt__(self, r)


    def __le__(self, r: 'itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """__le__(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer___le__(self, r)


    def __ge__(self, r: 'itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """__ge__(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer___ge__(self, r)


    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceFCTI2FFULULULPF2MCULPF2::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self, unsigned long cellId, itkCellInterfaceFCTI2FFULULULPF2MCULPF2::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCommonEnums::CellGeometry":
        """
        GetType(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self) -> itkCommonEnums::CellGeometry

        Return the type of the cell
        (one of the CellGeometryEnum enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self, int dimension, unsigned long arg1, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self, unsigned long const * first)
        SetPointIds(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self) -> unsigned long
        PointIdsBegin(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self) -> unsigned long
        PointIdsEnd(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'float *', arg1: 'bool *', arg2: 'itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self, float * arg0, bool * arg1, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not nullptr, the flag is set to indicate whether the point is inside
        the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'float *', arg1: 'itkMapContainerULPF2', arg2: 'float *', arg3: 'float *', arg4: 'double *', arg5: 'float *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self, float * arg0, itkMapContainerULPF2 arg1, float * arg2, float * arg3, double * arg4, float * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not nullptr:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayF', arg1: 'itkArrayF') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self, itkArrayF arg0, itkArrayF arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float', arg3: 'float *', arg4: 'float *', arg5: 'float *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self, float * arg0, float * arg1, float arg2, float * arg3, float * arg4, float * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'float *') -> "float *":
        """
        GetBoundingBox(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self, float * arg0) -> float *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "float":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self) -> float

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float *', arg3: 'float *', arg4: 'float *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self, float * arg0, float * arg1, float * arg2, float * arg3, float * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_GetNameOfClass(self)

itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.__deref__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer___deref__, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.Reset = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_Reset, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.TakeOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_TakeOwnership, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.TakeNoOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_TakeNoOwnership, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.IsOwner = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_IsOwner, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.ReleaseOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_ReleaseOwnership, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.GetPointer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_GetPointer, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.__eq__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer___eq__, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.__ne__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer___ne__, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.__lt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer___lt__, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.__gt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer___gt__, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.__le__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer___le__, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.__ge__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer___ge__, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_Accept, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_GetType, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_MakeCopy, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_GetDimension, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_GetInterpolationOrder, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_GetNumberOfPoints, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_GetNumberOfBoundaryFeatures, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_GetBoundaryFeature, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_GetPointIds, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_SetPointIds, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_SetPointId, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_PointIdsBegin, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_PointIdsEnd, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_GetPointIdsContainer, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_SetPointIdsContainer, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_GetClosestBoundary, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_EvaluatePosition, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_EvaluateShapeFunctions, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_IntersectWithLine, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_GetBoundingBox, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_IntersectBoundingBoxWithLine, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_IsExplicitBoundary, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_AddUsingCell, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_RemoveUsingCell, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_IsUsingCell, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_GetNumberOfUsingCells, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_GetNameOfClass, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_swigregister = _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_swigregister
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_swigregister(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)

class itkCellInterfaceFCTI2FFULULULPF2VCULPF2(object):
    """


    An abstract interface for cells.

    Define an abstract interface for cells. Actual cell types derive from
    this class.

    Parameters:
    -----------

    TPixelType:  The type stored with an entity (cell, point, or
    boundary).

    TCellTraits:  Type information for cell.

    C++ includes: itkCellInterface.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceFCTI2FFULULULPF2VCULPF2::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceFCTI2FFULULULPF2VCULPF2 self, unsigned long cellId, itkCellInterfaceFCTI2FFULULULPF2VCULPF2::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCommonEnums::CellGeometry":
        """
        GetType(itkCellInterfaceFCTI2FFULULULPF2VCULPF2 self) -> itkCommonEnums::CellGeometry

        Return the type of the cell
        (one of the CellGeometryEnum enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceFCTI2FFULULULPF2VCULPF2 self, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceFCTI2FFULULULPF2VCULPF2 self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceFCTI2FFULULULPF2VCULPF2 self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceFCTI2FFULULULPF2VCULPF2 self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceFCTI2FFULULULPF2VCULPF2 self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceFCTI2FFULULULPF2VCULPF2 self, int dimension, unsigned long arg1, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceFCTI2FFULULULPF2VCULPF2 self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceFCTI2FFULULULPF2VCULPF2 self, unsigned long const * first)
        SetPointIds(itkCellInterfaceFCTI2FFULULULPF2VCULPF2 self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceFCTI2FFULULULPF2VCULPF2 self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceFCTI2FFULULULPF2VCULPF2 self) -> unsigned long
        PointIdsBegin(itkCellInterfaceFCTI2FFULULULPF2VCULPF2 self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceFCTI2FFULULULPF2VCULPF2 self) -> unsigned long
        PointIdsEnd(itkCellInterfaceFCTI2FFULULULPF2VCULPF2 self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceFCTI2FFULULULPF2VCULPF2 self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceFCTI2FFULULULPF2VCULPF2 self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'float *', arg1: 'bool *', arg2: 'itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceFCTI2FFULULULPF2VCULPF2 self, float * arg0, bool * arg1, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not nullptr, the flag is set to indicate whether the point is inside
        the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'float *', arg1: 'itkVectorContainerULPF2', arg2: 'float *', arg3: 'float *', arg4: 'double *', arg5: 'float *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceFCTI2FFULULULPF2VCULPF2 self, float * arg0, itkVectorContainerULPF2 arg1, float * arg2, float * arg3, double * arg4, float * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not nullptr:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayF', arg1: 'itkArrayF') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceFCTI2FFULULULPF2VCULPF2 self, itkArrayF arg0, itkArrayF arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float', arg3: 'float *', arg4: 'float *', arg5: 'float *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceFCTI2FFULULULPF2VCULPF2 self, float * arg0, float * arg1, float arg2, float * arg3, float * arg4, float * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'float *') -> "float *":
        """
        GetBoundingBox(itkCellInterfaceFCTI2FFULULULPF2VCULPF2 self, float * arg0) -> float *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "float":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceFCTI2FFULULULPF2VCULPF2 self) -> float

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float *', arg3: 'float *', arg4: 'float *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceFCTI2FFULULULPF2VCULPF2 self, float * arg0, float * arg1, float * arg2, float * arg3, float * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceFCTI2FFULULULPF2VCULPF2 self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceFCTI2FFULULULPF2VCULPF2 self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceFCTI2FFULULULPF2VCULPF2 self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceFCTI2FFULULULPF2VCULPF2 self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceFCTI2FFULULULPF2VCULPF2 self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceFCTI2FFULULULPF2VCULPF2 self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_GetNameOfClass(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceFCTI2FFULULULPF2VCULPF2
itkCellInterfaceFCTI2FFULULULPF2VCULPF2.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_Accept, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_GetType, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_MakeCopy, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_GetDimension, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_GetInterpolationOrder, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_GetNumberOfPoints, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_GetNumberOfBoundaryFeatures, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_GetBoundaryFeature, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_GetPointIds, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_SetPointIds, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_SetPointId, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_PointIdsBegin, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_PointIdsEnd, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_GetPointIdsContainer, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_SetPointIdsContainer, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_GetClosestBoundary, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_EvaluatePosition, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_EvaluateShapeFunctions, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_IntersectWithLine, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_GetBoundingBox, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_IntersectBoundingBoxWithLine, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_IsExplicitBoundary, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AddUsingCell, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_RemoveUsingCell, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_IsUsingCell, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_GetNumberOfUsingCells, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_GetNameOfClass, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_swigregister = _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_swigregister
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_swigregister(itkCellInterfaceFCTI2FFULULULPF2VCULPF2)

class itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer(object):
    """Proxy of C++ itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self) -> itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer
        __init__(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer p) -> itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer
        __init__(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceFCTI2FFULULULPF2VCULPF2 p, bool takeOwnership) -> itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer
        """
        _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_swiginit(self, _itkMeshBasePython.new_itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer(*args))
    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer

    def __deref__(self) -> "itkCellInterfaceFCTI2FFULULULPF2VCULPF2 *":
        """__deref__(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self) -> itkCellInterfaceFCTI2FFULULULPF2VCULPF2"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer___deref__(self)


    def Reset(self) -> "void":
        """Reset(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self)"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_Reset(self)


    def TakeOwnership(self, *args) -> "void":
        """
        TakeOwnership(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self)
        TakeOwnership(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceFCTI2FFULULULPF2VCULPF2 objectptr)
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_TakeOwnership(self, *args)


    def TakeNoOwnership(self, objectptr: 'itkCellInterfaceFCTI2FFULULULPF2VCULPF2') -> "void":
        """TakeNoOwnership(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceFCTI2FFULULULPF2VCULPF2 objectptr)"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_TakeNoOwnership(self, objectptr)


    def IsOwner(self) -> "bool":
        """IsOwner(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_IsOwner(self)


    def ReleaseOwnership(self) -> "itkCellInterfaceFCTI2FFULULULPF2VCULPF2 *":
        """ReleaseOwnership(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self) -> itkCellInterfaceFCTI2FFULULULPF2VCULPF2"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_ReleaseOwnership(self)


    def GetPointer(self) -> "itkCellInterfaceFCTI2FFULULULPF2VCULPF2 *":
        """GetPointer(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self) -> itkCellInterfaceFCTI2FFULULULPF2VCULPF2"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_GetPointer(self)


    def __eq__(self, r: 'itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """__eq__(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer___eq__(self, r)


    def __ne__(self, r: 'itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """__ne__(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer___ne__(self, r)


    def __lt__(self, r: 'itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """__lt__(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer___lt__(self, r)


    def __gt__(self, r: 'itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """__gt__(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer___gt__(self, r)


    def __le__(self, r: 'itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """__le__(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer___le__(self, r)


    def __ge__(self, r: 'itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """__ge__(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer___ge__(self, r)


    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceFCTI2FFULULULPF2VCULPF2::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self, unsigned long cellId, itkCellInterfaceFCTI2FFULULULPF2VCULPF2::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCommonEnums::CellGeometry":
        """
        GetType(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self) -> itkCommonEnums::CellGeometry

        Return the type of the cell
        (one of the CellGeometryEnum enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self, int dimension, unsigned long arg1, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self, unsigned long const * first)
        SetPointIds(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self) -> unsigned long
        PointIdsBegin(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self) -> unsigned long
        PointIdsEnd(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'float *', arg1: 'bool *', arg2: 'itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self, float * arg0, bool * arg1, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not nullptr, the flag is set to indicate whether the point is inside
        the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'float *', arg1: 'itkVectorContainerULPF2', arg2: 'float *', arg3: 'float *', arg4: 'double *', arg5: 'float *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self, float * arg0, itkVectorContainerULPF2 arg1, float * arg2, float * arg3, double * arg4, float * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not nullptr:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayF', arg1: 'itkArrayF') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self, itkArrayF arg0, itkArrayF arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float', arg3: 'float *', arg4: 'float *', arg5: 'float *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self, float * arg0, float * arg1, float arg2, float * arg3, float * arg4, float * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'float *') -> "float *":
        """
        GetBoundingBox(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self, float * arg0) -> float *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "float":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self) -> float

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float *', arg3: 'float *', arg4: 'float *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self, float * arg0, float * arg1, float * arg2, float * arg3, float * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_GetNameOfClass(self)

itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.__deref__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer___deref__, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.Reset = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_Reset, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.TakeOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_TakeOwnership, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.TakeNoOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_TakeNoOwnership, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.IsOwner = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_IsOwner, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.ReleaseOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_ReleaseOwnership, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.GetPointer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_GetPointer, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.__eq__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer___eq__, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.__ne__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer___ne__, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.__lt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer___lt__, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.__gt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer___gt__, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.__le__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer___le__, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.__ge__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer___ge__, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_Accept, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_GetType, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_MakeCopy, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_GetDimension, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_GetInterpolationOrder, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_GetNumberOfPoints, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_GetNumberOfBoundaryFeatures, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_GetBoundaryFeature, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_GetPointIds, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_SetPointIds, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_SetPointId, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_PointIdsBegin, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_PointIdsEnd, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_GetPointIdsContainer, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_SetPointIdsContainer, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_GetClosestBoundary, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_EvaluatePosition, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_EvaluateShapeFunctions, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_IntersectWithLine, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_GetBoundingBox, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_IntersectBoundingBoxWithLine, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_IsExplicitBoundary, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_AddUsingCell, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_RemoveUsingCell, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_IsUsingCell, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_GetNumberOfUsingCells, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_GetNameOfClass, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_swigregister = _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_swigregister
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_swigregister(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)

class itkCellInterfaceFCTI3FFULULULPF3MCULPF3(object):
    """


    An abstract interface for cells.

    Define an abstract interface for cells. Actual cell types derive from
    this class.

    Parameters:
    -----------

    TPixelType:  The type stored with an entity (cell, point, or
    boundary).

    TCellTraits:  Type information for cell.

    C++ includes: itkCellInterface.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceFCTI3FFULULULPF3MCULPF3::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceFCTI3FFULULULPF3MCULPF3 self, unsigned long cellId, itkCellInterfaceFCTI3FFULULULPF3MCULPF3::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCommonEnums::CellGeometry":
        """
        GetType(itkCellInterfaceFCTI3FFULULULPF3MCULPF3 self) -> itkCommonEnums::CellGeometry

        Return the type of the cell
        (one of the CellGeometryEnum enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceFCTI3FFULULULPF3MCULPF3 self, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceFCTI3FFULULULPF3MCULPF3 self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceFCTI3FFULULULPF3MCULPF3 self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceFCTI3FFULULULPF3MCULPF3 self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceFCTI3FFULULULPF3MCULPF3 self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceFCTI3FFULULULPF3MCULPF3 self, int dimension, unsigned long arg1, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceFCTI3FFULULULPF3MCULPF3 self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceFCTI3FFULULULPF3MCULPF3 self, unsigned long const * first)
        SetPointIds(itkCellInterfaceFCTI3FFULULULPF3MCULPF3 self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceFCTI3FFULULULPF3MCULPF3 self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceFCTI3FFULULULPF3MCULPF3 self) -> unsigned long
        PointIdsBegin(itkCellInterfaceFCTI3FFULULULPF3MCULPF3 self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceFCTI3FFULULULPF3MCULPF3 self) -> unsigned long
        PointIdsEnd(itkCellInterfaceFCTI3FFULULULPF3MCULPF3 self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceFCTI3FFULULULPF3MCULPF3 self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceFCTI3FFULULULPF3MCULPF3 self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'float *', arg1: 'bool *', arg2: 'itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceFCTI3FFULULULPF3MCULPF3 self, float * arg0, bool * arg1, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not nullptr, the flag is set to indicate whether the point is inside
        the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'float *', arg1: 'itkMapContainerULPF3', arg2: 'float *', arg3: 'float *', arg4: 'double *', arg5: 'float *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceFCTI3FFULULULPF3MCULPF3 self, float * arg0, itkMapContainerULPF3 arg1, float * arg2, float * arg3, double * arg4, float * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not nullptr:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayF', arg1: 'itkArrayF') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceFCTI3FFULULULPF3MCULPF3 self, itkArrayF arg0, itkArrayF arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float', arg3: 'float *', arg4: 'float *', arg5: 'float *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceFCTI3FFULULULPF3MCULPF3 self, float * arg0, float * arg1, float arg2, float * arg3, float * arg4, float * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'float *') -> "float *":
        """
        GetBoundingBox(itkCellInterfaceFCTI3FFULULULPF3MCULPF3 self, float * arg0) -> float *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "float":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceFCTI3FFULULULPF3MCULPF3 self) -> float

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float *', arg3: 'float *', arg4: 'float *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceFCTI3FFULULULPF3MCULPF3 self, float * arg0, float * arg1, float * arg2, float * arg3, float * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceFCTI3FFULULULPF3MCULPF3 self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceFCTI3FFULULULPF3MCULPF3 self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceFCTI3FFULULULPF3MCULPF3 self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceFCTI3FFULULULPF3MCULPF3 self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceFCTI3FFULULULPF3MCULPF3 self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceFCTI3FFULULULPF3MCULPF3 self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_GetNameOfClass(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceFCTI3FFULULULPF3MCULPF3
itkCellInterfaceFCTI3FFULULULPF3MCULPF3.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_Accept, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_GetType, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_MakeCopy, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_GetDimension, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_GetInterpolationOrder, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_GetNumberOfPoints, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_GetNumberOfBoundaryFeatures, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_GetBoundaryFeature, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_GetPointIds, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_SetPointIds, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_SetPointId, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_PointIdsBegin, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_PointIdsEnd, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_GetPointIdsContainer, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_SetPointIdsContainer, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_GetClosestBoundary, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_EvaluatePosition, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_EvaluateShapeFunctions, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_IntersectWithLine, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_GetBoundingBox, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_IntersectBoundingBoxWithLine, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_IsExplicitBoundary, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AddUsingCell, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_RemoveUsingCell, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_IsUsingCell, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_GetNumberOfUsingCells, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_GetNameOfClass, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_swigregister = _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_swigregister
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_swigregister(itkCellInterfaceFCTI3FFULULULPF3MCULPF3)

class itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer(object):
    """Proxy of C++ itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self) -> itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer
        __init__(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer p) -> itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer
        __init__(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceFCTI3FFULULULPF3MCULPF3 p, bool takeOwnership) -> itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer
        """
        _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_swiginit(self, _itkMeshBasePython.new_itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer(*args))
    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer

    def __deref__(self) -> "itkCellInterfaceFCTI3FFULULULPF3MCULPF3 *":
        """__deref__(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self) -> itkCellInterfaceFCTI3FFULULULPF3MCULPF3"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer___deref__(self)


    def Reset(self) -> "void":
        """Reset(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self)"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_Reset(self)


    def TakeOwnership(self, *args) -> "void":
        """
        TakeOwnership(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self)
        TakeOwnership(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceFCTI3FFULULULPF3MCULPF3 objectptr)
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_TakeOwnership(self, *args)


    def TakeNoOwnership(self, objectptr: 'itkCellInterfaceFCTI3FFULULULPF3MCULPF3') -> "void":
        """TakeNoOwnership(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceFCTI3FFULULULPF3MCULPF3 objectptr)"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_TakeNoOwnership(self, objectptr)


    def IsOwner(self) -> "bool":
        """IsOwner(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_IsOwner(self)


    def ReleaseOwnership(self) -> "itkCellInterfaceFCTI3FFULULULPF3MCULPF3 *":
        """ReleaseOwnership(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self) -> itkCellInterfaceFCTI3FFULULULPF3MCULPF3"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_ReleaseOwnership(self)


    def GetPointer(self) -> "itkCellInterfaceFCTI3FFULULULPF3MCULPF3 *":
        """GetPointer(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self) -> itkCellInterfaceFCTI3FFULULULPF3MCULPF3"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_GetPointer(self)


    def __eq__(self, r: 'itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """__eq__(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer___eq__(self, r)


    def __ne__(self, r: 'itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """__ne__(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer___ne__(self, r)


    def __lt__(self, r: 'itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """__lt__(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer___lt__(self, r)


    def __gt__(self, r: 'itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """__gt__(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer___gt__(self, r)


    def __le__(self, r: 'itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """__le__(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer___le__(self, r)


    def __ge__(self, r: 'itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """__ge__(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer___ge__(self, r)


    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceFCTI3FFULULULPF3MCULPF3::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self, unsigned long cellId, itkCellInterfaceFCTI3FFULULULPF3MCULPF3::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCommonEnums::CellGeometry":
        """
        GetType(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self) -> itkCommonEnums::CellGeometry

        Return the type of the cell
        (one of the CellGeometryEnum enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self, int dimension, unsigned long arg1, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self, unsigned long const * first)
        SetPointIds(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self) -> unsigned long
        PointIdsBegin(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self) -> unsigned long
        PointIdsEnd(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'float *', arg1: 'bool *', arg2: 'itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self, float * arg0, bool * arg1, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not nullptr, the flag is set to indicate whether the point is inside
        the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'float *', arg1: 'itkMapContainerULPF3', arg2: 'float *', arg3: 'float *', arg4: 'double *', arg5: 'float *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self, float * arg0, itkMapContainerULPF3 arg1, float * arg2, float * arg3, double * arg4, float * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not nullptr:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayF', arg1: 'itkArrayF') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self, itkArrayF arg0, itkArrayF arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float', arg3: 'float *', arg4: 'float *', arg5: 'float *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self, float * arg0, float * arg1, float arg2, float * arg3, float * arg4, float * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'float *') -> "float *":
        """
        GetBoundingBox(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self, float * arg0) -> float *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "float":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self) -> float

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float *', arg3: 'float *', arg4: 'float *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self, float * arg0, float * arg1, float * arg2, float * arg3, float * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_GetNameOfClass(self)

itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.__deref__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer___deref__, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.Reset = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_Reset, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.TakeOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_TakeOwnership, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.TakeNoOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_TakeNoOwnership, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.IsOwner = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_IsOwner, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.ReleaseOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_ReleaseOwnership, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.GetPointer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_GetPointer, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.__eq__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer___eq__, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.__ne__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer___ne__, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.__lt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer___lt__, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.__gt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer___gt__, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.__le__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer___le__, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.__ge__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer___ge__, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_Accept, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_GetType, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_MakeCopy, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_GetDimension, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_GetInterpolationOrder, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_GetNumberOfPoints, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_GetNumberOfBoundaryFeatures, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_GetBoundaryFeature, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_GetPointIds, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_SetPointIds, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_SetPointId, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_PointIdsBegin, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_PointIdsEnd, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_GetPointIdsContainer, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_SetPointIdsContainer, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_GetClosestBoundary, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_EvaluatePosition, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_EvaluateShapeFunctions, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_IntersectWithLine, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_GetBoundingBox, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_IntersectBoundingBoxWithLine, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_IsExplicitBoundary, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_AddUsingCell, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_RemoveUsingCell, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_IsUsingCell, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_GetNumberOfUsingCells, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_GetNameOfClass, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_swigregister = _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_swigregister
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_swigregister(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)

class itkCellInterfaceFCTI3FFULULULPF3VCULPF3(object):
    """


    An abstract interface for cells.

    Define an abstract interface for cells. Actual cell types derive from
    this class.

    Parameters:
    -----------

    TPixelType:  The type stored with an entity (cell, point, or
    boundary).

    TCellTraits:  Type information for cell.

    C++ includes: itkCellInterface.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceFCTI3FFULULULPF3VCULPF3::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceFCTI3FFULULULPF3VCULPF3 self, unsigned long cellId, itkCellInterfaceFCTI3FFULULULPF3VCULPF3::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCommonEnums::CellGeometry":
        """
        GetType(itkCellInterfaceFCTI3FFULULULPF3VCULPF3 self) -> itkCommonEnums::CellGeometry

        Return the type of the cell
        (one of the CellGeometryEnum enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceFCTI3FFULULULPF3VCULPF3 self, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceFCTI3FFULULULPF3VCULPF3 self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceFCTI3FFULULULPF3VCULPF3 self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceFCTI3FFULULULPF3VCULPF3 self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceFCTI3FFULULULPF3VCULPF3 self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceFCTI3FFULULULPF3VCULPF3 self, int dimension, unsigned long arg1, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceFCTI3FFULULULPF3VCULPF3 self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceFCTI3FFULULULPF3VCULPF3 self, unsigned long const * first)
        SetPointIds(itkCellInterfaceFCTI3FFULULULPF3VCULPF3 self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceFCTI3FFULULULPF3VCULPF3 self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceFCTI3FFULULULPF3VCULPF3 self) -> unsigned long
        PointIdsBegin(itkCellInterfaceFCTI3FFULULULPF3VCULPF3 self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceFCTI3FFULULULPF3VCULPF3 self) -> unsigned long
        PointIdsEnd(itkCellInterfaceFCTI3FFULULULPF3VCULPF3 self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceFCTI3FFULULULPF3VCULPF3 self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceFCTI3FFULULULPF3VCULPF3 self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'float *', arg1: 'bool *', arg2: 'itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceFCTI3FFULULULPF3VCULPF3 self, float * arg0, bool * arg1, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not nullptr, the flag is set to indicate whether the point is inside
        the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'float *', arg1: 'itkVectorContainerULPF3', arg2: 'float *', arg3: 'float *', arg4: 'double *', arg5: 'float *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceFCTI3FFULULULPF3VCULPF3 self, float * arg0, itkVectorContainerULPF3 arg1, float * arg2, float * arg3, double * arg4, float * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not nullptr:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayF', arg1: 'itkArrayF') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceFCTI3FFULULULPF3VCULPF3 self, itkArrayF arg0, itkArrayF arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float', arg3: 'float *', arg4: 'float *', arg5: 'float *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceFCTI3FFULULULPF3VCULPF3 self, float * arg0, float * arg1, float arg2, float * arg3, float * arg4, float * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'float *') -> "float *":
        """
        GetBoundingBox(itkCellInterfaceFCTI3FFULULULPF3VCULPF3 self, float * arg0) -> float *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "float":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceFCTI3FFULULULPF3VCULPF3 self) -> float

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float *', arg3: 'float *', arg4: 'float *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceFCTI3FFULULULPF3VCULPF3 self, float * arg0, float * arg1, float * arg2, float * arg3, float * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceFCTI3FFULULULPF3VCULPF3 self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceFCTI3FFULULULPF3VCULPF3 self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceFCTI3FFULULULPF3VCULPF3 self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceFCTI3FFULULULPF3VCULPF3 self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceFCTI3FFULULULPF3VCULPF3 self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceFCTI3FFULULULPF3VCULPF3 self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_GetNameOfClass(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceFCTI3FFULULULPF3VCULPF3
itkCellInterfaceFCTI3FFULULULPF3VCULPF3.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_Accept, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_GetType, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_MakeCopy, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_GetDimension, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_GetInterpolationOrder, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_GetNumberOfPoints, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_GetNumberOfBoundaryFeatures, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_GetBoundaryFeature, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_GetPointIds, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_SetPointIds, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_SetPointId, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_PointIdsBegin, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_PointIdsEnd, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_GetPointIdsContainer, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_SetPointIdsContainer, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_GetClosestBoundary, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_EvaluatePosition, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_EvaluateShapeFunctions, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_IntersectWithLine, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_GetBoundingBox, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_IntersectBoundingBoxWithLine, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_IsExplicitBoundary, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AddUsingCell, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_RemoveUsingCell, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_IsUsingCell, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_GetNumberOfUsingCells, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_GetNameOfClass, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_swigregister = _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_swigregister
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_swigregister(itkCellInterfaceFCTI3FFULULULPF3VCULPF3)

class itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer(object):
    """Proxy of C++ itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self) -> itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer
        __init__(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer p) -> itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer
        __init__(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceFCTI3FFULULULPF3VCULPF3 p, bool takeOwnership) -> itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer
        """
        _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_swiginit(self, _itkMeshBasePython.new_itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer(*args))
    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer

    def __deref__(self) -> "itkCellInterfaceFCTI3FFULULULPF3VCULPF3 *":
        """__deref__(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self) -> itkCellInterfaceFCTI3FFULULULPF3VCULPF3"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer___deref__(self)


    def Reset(self) -> "void":
        """Reset(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self)"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_Reset(self)


    def TakeOwnership(self, *args) -> "void":
        """
        TakeOwnership(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self)
        TakeOwnership(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceFCTI3FFULULULPF3VCULPF3 objectptr)
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_TakeOwnership(self, *args)


    def TakeNoOwnership(self, objectptr: 'itkCellInterfaceFCTI3FFULULULPF3VCULPF3') -> "void":
        """TakeNoOwnership(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceFCTI3FFULULULPF3VCULPF3 objectptr)"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_TakeNoOwnership(self, objectptr)


    def IsOwner(self) -> "bool":
        """IsOwner(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_IsOwner(self)


    def ReleaseOwnership(self) -> "itkCellInterfaceFCTI3FFULULULPF3VCULPF3 *":
        """ReleaseOwnership(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self) -> itkCellInterfaceFCTI3FFULULULPF3VCULPF3"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_ReleaseOwnership(self)


    def GetPointer(self) -> "itkCellInterfaceFCTI3FFULULULPF3VCULPF3 *":
        """GetPointer(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self) -> itkCellInterfaceFCTI3FFULULULPF3VCULPF3"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_GetPointer(self)


    def __eq__(self, r: 'itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """__eq__(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer___eq__(self, r)


    def __ne__(self, r: 'itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """__ne__(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer___ne__(self, r)


    def __lt__(self, r: 'itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """__lt__(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer___lt__(self, r)


    def __gt__(self, r: 'itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """__gt__(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer___gt__(self, r)


    def __le__(self, r: 'itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """__le__(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer___le__(self, r)


    def __ge__(self, r: 'itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """__ge__(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer___ge__(self, r)


    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceFCTI3FFULULULPF3VCULPF3::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self, unsigned long cellId, itkCellInterfaceFCTI3FFULULULPF3VCULPF3::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCommonEnums::CellGeometry":
        """
        GetType(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self) -> itkCommonEnums::CellGeometry

        Return the type of the cell
        (one of the CellGeometryEnum enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self, int dimension, unsigned long arg1, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self, unsigned long const * first)
        SetPointIds(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self) -> unsigned long
        PointIdsBegin(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self) -> unsigned long
        PointIdsEnd(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'float *', arg1: 'bool *', arg2: 'itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self, float * arg0, bool * arg1, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not nullptr, the flag is set to indicate whether the point is inside
        the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'float *', arg1: 'itkVectorContainerULPF3', arg2: 'float *', arg3: 'float *', arg4: 'double *', arg5: 'float *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self, float * arg0, itkVectorContainerULPF3 arg1, float * arg2, float * arg3, double * arg4, float * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not nullptr:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayF', arg1: 'itkArrayF') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self, itkArrayF arg0, itkArrayF arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float', arg3: 'float *', arg4: 'float *', arg5: 'float *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self, float * arg0, float * arg1, float arg2, float * arg3, float * arg4, float * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'float *') -> "float *":
        """
        GetBoundingBox(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self, float * arg0) -> float *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "float":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self) -> float

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float *', arg3: 'float *', arg4: 'float *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self, float * arg0, float * arg1, float * arg2, float * arg3, float * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_GetNameOfClass(self)

itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.__deref__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer___deref__, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.Reset = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_Reset, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.TakeOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_TakeOwnership, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.TakeNoOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_TakeNoOwnership, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.IsOwner = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_IsOwner, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.ReleaseOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_ReleaseOwnership, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.GetPointer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_GetPointer, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.__eq__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer___eq__, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.__ne__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer___ne__, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.__lt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer___lt__, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.__gt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer___gt__, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.__le__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer___le__, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.__ge__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer___ge__, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_Accept, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_GetType, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_MakeCopy, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_GetDimension, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_GetInterpolationOrder, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_GetNumberOfPoints, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_GetNumberOfBoundaryFeatures, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_GetBoundaryFeature, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_GetPointIds, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_SetPointIds, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_SetPointId, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_PointIdsBegin, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_PointIdsEnd, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_GetPointIdsContainer, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_SetPointIdsContainer, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_GetClosestBoundary, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_EvaluatePosition, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_EvaluateShapeFunctions, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_IntersectWithLine, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_GetBoundingBox, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_IntersectBoundingBoxWithLine, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_IsExplicitBoundary, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_AddUsingCell, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_RemoveUsingCell, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_IsUsingCell, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_GetNumberOfUsingCells, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_GetNameOfClass, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_swigregister = _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_swigregister
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_swigregister(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)

class itkCellInterfaceSSCTI2FFULULULPF2MCULPF2(object):
    """


    An abstract interface for cells.

    Define an abstract interface for cells. Actual cell types derive from
    this class.

    Parameters:
    -----------

    TPixelType:  The type stored with an entity (cell, point, or
    boundary).

    TCellTraits:  Type information for cell.

    C++ includes: itkCellInterface.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceSSCTI2FFULULULPF2MCULPF2::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2 self, unsigned long cellId, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCommonEnums::CellGeometry":
        """
        GetType(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2 self) -> itkCommonEnums::CellGeometry

        Return the type of the cell
        (one of the CellGeometryEnum enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2 self, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2 self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2 self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2 self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2 self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2 self, int dimension, unsigned long arg1, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2 self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2 self, unsigned long const * first)
        SetPointIds(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2 self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2 self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2 self) -> unsigned long
        PointIdsBegin(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2 self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2 self) -> unsigned long
        PointIdsEnd(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2 self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2 self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2 self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'float *', arg1: 'bool *', arg2: 'itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2 self, float * arg0, bool * arg1, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not nullptr, the flag is set to indicate whether the point is inside
        the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'float *', arg1: 'itkMapContainerULPF2', arg2: 'float *', arg3: 'float *', arg4: 'double *', arg5: 'float *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2 self, float * arg0, itkMapContainerULPF2 arg1, float * arg2, float * arg3, double * arg4, float * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not nullptr:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayF', arg1: 'itkArrayF') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2 self, itkArrayF arg0, itkArrayF arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float', arg3: 'float *', arg4: 'float *', arg5: 'float *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2 self, float * arg0, float * arg1, float arg2, float * arg3, float * arg4, float * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'float *') -> "float *":
        """
        GetBoundingBox(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2 self, float * arg0) -> float *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "float":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2 self) -> float

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float *', arg3: 'float *', arg4: 'float *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2 self, float * arg0, float * arg1, float * arg2, float * arg3, float * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2 self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2 self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2 self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2 self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2 self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2 self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_GetNameOfClass(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceSSCTI2FFULULULPF2MCULPF2
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_Accept, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_GetType, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_MakeCopy, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_GetDimension, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_GetInterpolationOrder, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_GetNumberOfPoints, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_GetNumberOfBoundaryFeatures, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_GetBoundaryFeature, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_GetPointIds, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_SetPointIds, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_SetPointId, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_PointIdsBegin, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_PointIdsEnd, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_GetPointIdsContainer, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_SetPointIdsContainer, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_GetClosestBoundary, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_EvaluatePosition, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_EvaluateShapeFunctions, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_IntersectWithLine, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_GetBoundingBox, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_IntersectBoundingBoxWithLine, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_IsExplicitBoundary, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AddUsingCell, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_RemoveUsingCell, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_IsUsingCell, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_GetNumberOfUsingCells, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_GetNameOfClass, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_swigregister = _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_swigregister
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_swigregister(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2)

class itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer(object):
    """Proxy of C++ itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer self) -> itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer
        __init__(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer p) -> itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer
        __init__(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2 p, bool takeOwnership) -> itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer
        """
        _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_swiginit(self, _itkMeshBasePython.new_itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer(*args))
    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer

    def __deref__(self) -> "itkCellInterfaceSSCTI2FFULULULPF2MCULPF2 *":
        """__deref__(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer self) -> itkCellInterfaceSSCTI2FFULULULPF2MCULPF2"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer___deref__(self)


    def Reset(self) -> "void":
        """Reset(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer self)"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_Reset(self)


    def TakeOwnership(self, *args) -> "void":
        """
        TakeOwnership(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer self)
        TakeOwnership(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2 objectptr)
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_TakeOwnership(self, *args)


    def TakeNoOwnership(self, objectptr: 'itkCellInterfaceSSCTI2FFULULULPF2MCULPF2') -> "void":
        """TakeNoOwnership(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2 objectptr)"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_TakeNoOwnership(self, objectptr)


    def IsOwner(self) -> "bool":
        """IsOwner(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer self) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_IsOwner(self)


    def ReleaseOwnership(self) -> "itkCellInterfaceSSCTI2FFULULULPF2MCULPF2 *":
        """ReleaseOwnership(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer self) -> itkCellInterfaceSSCTI2FFULULULPF2MCULPF2"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_ReleaseOwnership(self)


    def GetPointer(self) -> "itkCellInterfaceSSCTI2FFULULULPF2MCULPF2 *":
        """GetPointer(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer self) -> itkCellInterfaceSSCTI2FFULULULPF2MCULPF2"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_GetPointer(self)


    def __eq__(self, r: 'itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """__eq__(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer___eq__(self, r)


    def __ne__(self, r: 'itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """__ne__(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer___ne__(self, r)


    def __lt__(self, r: 'itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """__lt__(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer___lt__(self, r)


    def __gt__(self, r: 'itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """__gt__(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer___gt__(self, r)


    def __le__(self, r: 'itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """__le__(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer___le__(self, r)


    def __ge__(self, r: 'itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """__ge__(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer___ge__(self, r)


    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceSSCTI2FFULULULPF2MCULPF2::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer self, unsigned long cellId, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCommonEnums::CellGeometry":
        """
        GetType(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer self) -> itkCommonEnums::CellGeometry

        Return the type of the cell
        (one of the CellGeometryEnum enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer self, int dimension, unsigned long arg1, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer self, unsigned long const * first)
        SetPointIds(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer self) -> unsigned long
        PointIdsBegin(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer self) -> unsigned long
        PointIdsEnd(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'float *', arg1: 'bool *', arg2: 'itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer self, float * arg0, bool * arg1, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not nullptr, the flag is set to indicate whether the point is inside
        the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'float *', arg1: 'itkMapContainerULPF2', arg2: 'float *', arg3: 'float *', arg4: 'double *', arg5: 'float *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer self, float * arg0, itkMapContainerULPF2 arg1, float * arg2, float * arg3, double * arg4, float * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not nullptr:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayF', arg1: 'itkArrayF') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer self, itkArrayF arg0, itkArrayF arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float', arg3: 'float *', arg4: 'float *', arg5: 'float *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer self, float * arg0, float * arg1, float arg2, float * arg3, float * arg4, float * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'float *') -> "float *":
        """
        GetBoundingBox(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer self, float * arg0) -> float *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "float":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer self) -> float

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float *', arg3: 'float *', arg4: 'float *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer self, float * arg0, float * arg1, float * arg2, float * arg3, float * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_GetNameOfClass(self)

itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer.__deref__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer___deref__, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer.Reset = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_Reset, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer.TakeOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_TakeOwnership, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer.TakeNoOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_TakeNoOwnership, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer.IsOwner = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_IsOwner, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer.ReleaseOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_ReleaseOwnership, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer.GetPointer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_GetPointer, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer.__eq__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer___eq__, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer.__ne__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer___ne__, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer.__lt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer___lt__, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer.__gt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer___gt__, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer.__le__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer___le__, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer.__ge__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer___ge__, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_Accept, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_GetType, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_MakeCopy, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_GetDimension, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_GetInterpolationOrder, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_GetNumberOfPoints, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_GetNumberOfBoundaryFeatures, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_GetBoundaryFeature, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_GetPointIds, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_SetPointIds, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_SetPointId, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_PointIdsBegin, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_PointIdsEnd, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_GetPointIdsContainer, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_SetPointIdsContainer, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_GetClosestBoundary, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_EvaluatePosition, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_EvaluateShapeFunctions, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_IntersectWithLine, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_GetBoundingBox, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_IntersectBoundingBoxWithLine, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_IsExplicitBoundary, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_AddUsingCell, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_RemoveUsingCell, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_IsUsingCell, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_GetNumberOfUsingCells, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_GetNameOfClass, None, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_swigregister = _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_swigregister
itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer_swigregister(itkCellInterfaceSSCTI2FFULULULPF2MCULPF2_AutoPointer)

class itkCellInterfaceSSCTI2FFULULULPF2VCULPF2(object):
    """


    An abstract interface for cells.

    Define an abstract interface for cells. Actual cell types derive from
    this class.

    Parameters:
    -----------

    TPixelType:  The type stored with an entity (cell, point, or
    boundary).

    TCellTraits:  Type information for cell.

    C++ includes: itkCellInterface.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceSSCTI2FFULULULPF2VCULPF2::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2 self, unsigned long cellId, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCommonEnums::CellGeometry":
        """
        GetType(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2 self) -> itkCommonEnums::CellGeometry

        Return the type of the cell
        (one of the CellGeometryEnum enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2 self, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2 self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2 self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2 self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2 self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2 self, int dimension, unsigned long arg1, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2 self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2 self, unsigned long const * first)
        SetPointIds(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2 self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2 self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2 self) -> unsigned long
        PointIdsBegin(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2 self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2 self) -> unsigned long
        PointIdsEnd(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2 self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2 self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2 self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'float *', arg1: 'bool *', arg2: 'itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2 self, float * arg0, bool * arg1, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not nullptr, the flag is set to indicate whether the point is inside
        the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'float *', arg1: 'itkVectorContainerULPF2', arg2: 'float *', arg3: 'float *', arg4: 'double *', arg5: 'float *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2 self, float * arg0, itkVectorContainerULPF2 arg1, float * arg2, float * arg3, double * arg4, float * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not nullptr:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayF', arg1: 'itkArrayF') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2 self, itkArrayF arg0, itkArrayF arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float', arg3: 'float *', arg4: 'float *', arg5: 'float *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2 self, float * arg0, float * arg1, float arg2, float * arg3, float * arg4, float * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'float *') -> "float *":
        """
        GetBoundingBox(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2 self, float * arg0) -> float *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "float":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2 self) -> float

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float *', arg3: 'float *', arg4: 'float *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2 self, float * arg0, float * arg1, float * arg2, float * arg3, float * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2 self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2 self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2 self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2 self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2 self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2 self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_GetNameOfClass(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceSSCTI2FFULULULPF2VCULPF2
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_Accept, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_GetType, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_MakeCopy, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_GetDimension, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_GetInterpolationOrder, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_GetNumberOfPoints, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_GetNumberOfBoundaryFeatures, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_GetBoundaryFeature, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_GetPointIds, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_SetPointIds, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_SetPointId, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_PointIdsBegin, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_PointIdsEnd, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_GetPointIdsContainer, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_SetPointIdsContainer, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_GetClosestBoundary, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_EvaluatePosition, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_EvaluateShapeFunctions, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_IntersectWithLine, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_GetBoundingBox, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_IntersectBoundingBoxWithLine, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_IsExplicitBoundary, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AddUsingCell, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_RemoveUsingCell, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_IsUsingCell, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_GetNumberOfUsingCells, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_GetNameOfClass, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_swigregister = _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_swigregister
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_swigregister(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2)

class itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer(object):
    """Proxy of C++ itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer self) -> itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer
        __init__(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer p) -> itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer
        __init__(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2 p, bool takeOwnership) -> itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer
        """
        _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_swiginit(self, _itkMeshBasePython.new_itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer(*args))
    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer

    def __deref__(self) -> "itkCellInterfaceSSCTI2FFULULULPF2VCULPF2 *":
        """__deref__(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer self) -> itkCellInterfaceSSCTI2FFULULULPF2VCULPF2"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer___deref__(self)


    def Reset(self) -> "void":
        """Reset(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer self)"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_Reset(self)


    def TakeOwnership(self, *args) -> "void":
        """
        TakeOwnership(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer self)
        TakeOwnership(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2 objectptr)
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_TakeOwnership(self, *args)


    def TakeNoOwnership(self, objectptr: 'itkCellInterfaceSSCTI2FFULULULPF2VCULPF2') -> "void":
        """TakeNoOwnership(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2 objectptr)"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_TakeNoOwnership(self, objectptr)


    def IsOwner(self) -> "bool":
        """IsOwner(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer self) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_IsOwner(self)


    def ReleaseOwnership(self) -> "itkCellInterfaceSSCTI2FFULULULPF2VCULPF2 *":
        """ReleaseOwnership(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer self) -> itkCellInterfaceSSCTI2FFULULULPF2VCULPF2"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_ReleaseOwnership(self)


    def GetPointer(self) -> "itkCellInterfaceSSCTI2FFULULULPF2VCULPF2 *":
        """GetPointer(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer self) -> itkCellInterfaceSSCTI2FFULULULPF2VCULPF2"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_GetPointer(self)


    def __eq__(self, r: 'itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """__eq__(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer___eq__(self, r)


    def __ne__(self, r: 'itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """__ne__(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer___ne__(self, r)


    def __lt__(self, r: 'itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """__lt__(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer___lt__(self, r)


    def __gt__(self, r: 'itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """__gt__(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer___gt__(self, r)


    def __le__(self, r: 'itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """__le__(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer___le__(self, r)


    def __ge__(self, r: 'itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """__ge__(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer___ge__(self, r)


    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceSSCTI2FFULULULPF2VCULPF2::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer self, unsigned long cellId, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCommonEnums::CellGeometry":
        """
        GetType(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer self) -> itkCommonEnums::CellGeometry

        Return the type of the cell
        (one of the CellGeometryEnum enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer self, int dimension, unsigned long arg1, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer self, unsigned long const * first)
        SetPointIds(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer self) -> unsigned long
        PointIdsBegin(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer self) -> unsigned long
        PointIdsEnd(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'float *', arg1: 'bool *', arg2: 'itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer self, float * arg0, bool * arg1, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not nullptr, the flag is set to indicate whether the point is inside
        the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'float *', arg1: 'itkVectorContainerULPF2', arg2: 'float *', arg3: 'float *', arg4: 'double *', arg5: 'float *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer self, float * arg0, itkVectorContainerULPF2 arg1, float * arg2, float * arg3, double * arg4, float * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not nullptr:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayF', arg1: 'itkArrayF') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer self, itkArrayF arg0, itkArrayF arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float', arg3: 'float *', arg4: 'float *', arg5: 'float *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer self, float * arg0, float * arg1, float arg2, float * arg3, float * arg4, float * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'float *') -> "float *":
        """
        GetBoundingBox(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer self, float * arg0) -> float *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "float":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer self) -> float

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float *', arg3: 'float *', arg4: 'float *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer self, float * arg0, float * arg1, float * arg2, float * arg3, float * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_GetNameOfClass(self)

itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer.__deref__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer___deref__, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer.Reset = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_Reset, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer.TakeOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_TakeOwnership, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer.TakeNoOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_TakeNoOwnership, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer.IsOwner = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_IsOwner, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer.ReleaseOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_ReleaseOwnership, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer.GetPointer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_GetPointer, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer.__eq__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer___eq__, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer.__ne__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer___ne__, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer.__lt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer___lt__, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer.__gt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer___gt__, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer.__le__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer___le__, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer.__ge__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer___ge__, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_Accept, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_GetType, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_MakeCopy, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_GetDimension, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_GetInterpolationOrder, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_GetNumberOfPoints, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_GetNumberOfBoundaryFeatures, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_GetBoundaryFeature, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_GetPointIds, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_SetPointIds, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_SetPointId, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_PointIdsBegin, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_PointIdsEnd, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_GetPointIdsContainer, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_SetPointIdsContainer, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_GetClosestBoundary, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_EvaluatePosition, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_EvaluateShapeFunctions, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_IntersectWithLine, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_GetBoundingBox, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_IntersectBoundingBoxWithLine, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_IsExplicitBoundary, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_AddUsingCell, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_RemoveUsingCell, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_IsUsingCell, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_GetNumberOfUsingCells, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_GetNameOfClass, None, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_swigregister = _itkMeshBasePython.itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_swigregister
itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer_swigregister(itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer)

class itkCellInterfaceSSCTI3FFULULULPF3MCULPF3(object):
    """


    An abstract interface for cells.

    Define an abstract interface for cells. Actual cell types derive from
    this class.

    Parameters:
    -----------

    TPixelType:  The type stored with an entity (cell, point, or
    boundary).

    TCellTraits:  Type information for cell.

    C++ includes: itkCellInterface.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceSSCTI3FFULULULPF3MCULPF3::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3 self, unsigned long cellId, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCommonEnums::CellGeometry":
        """
        GetType(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3 self) -> itkCommonEnums::CellGeometry

        Return the type of the cell
        (one of the CellGeometryEnum enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3 self, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3 self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3 self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3 self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3 self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3 self, int dimension, unsigned long arg1, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3 self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3 self, unsigned long const * first)
        SetPointIds(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3 self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3 self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3 self) -> unsigned long
        PointIdsBegin(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3 self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3 self) -> unsigned long
        PointIdsEnd(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3 self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3 self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3 self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'float *', arg1: 'bool *', arg2: 'itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3 self, float * arg0, bool * arg1, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not nullptr, the flag is set to indicate whether the point is inside
        the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'float *', arg1: 'itkMapContainerULPF3', arg2: 'float *', arg3: 'float *', arg4: 'double *', arg5: 'float *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3 self, float * arg0, itkMapContainerULPF3 arg1, float * arg2, float * arg3, double * arg4, float * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not nullptr:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayF', arg1: 'itkArrayF') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3 self, itkArrayF arg0, itkArrayF arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float', arg3: 'float *', arg4: 'float *', arg5: 'float *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3 self, float * arg0, float * arg1, float arg2, float * arg3, float * arg4, float * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'float *') -> "float *":
        """
        GetBoundingBox(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3 self, float * arg0) -> float *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "float":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3 self) -> float

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float *', arg3: 'float *', arg4: 'float *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3 self, float * arg0, float * arg1, float * arg2, float * arg3, float * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3 self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3 self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3 self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3 self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3 self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3 self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_GetNameOfClass(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceSSCTI3FFULULULPF3MCULPF3
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_Accept, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_GetType, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_MakeCopy, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_GetDimension, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_GetInterpolationOrder, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_GetNumberOfPoints, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_GetNumberOfBoundaryFeatures, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_GetBoundaryFeature, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_GetPointIds, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_SetPointIds, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_SetPointId, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_PointIdsBegin, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_PointIdsEnd, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_GetPointIdsContainer, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_SetPointIdsContainer, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_GetClosestBoundary, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_EvaluatePosition, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_EvaluateShapeFunctions, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_IntersectWithLine, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_GetBoundingBox, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_IntersectBoundingBoxWithLine, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_IsExplicitBoundary, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AddUsingCell, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_RemoveUsingCell, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_IsUsingCell, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_GetNumberOfUsingCells, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_GetNameOfClass, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_swigregister = _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_swigregister
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_swigregister(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3)

class itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer(object):
    """Proxy of C++ itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer self) -> itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer
        __init__(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer p) -> itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer
        __init__(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3 p, bool takeOwnership) -> itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer
        """
        _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_swiginit(self, _itkMeshBasePython.new_itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer(*args))
    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer

    def __deref__(self) -> "itkCellInterfaceSSCTI3FFULULULPF3MCULPF3 *":
        """__deref__(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer self) -> itkCellInterfaceSSCTI3FFULULULPF3MCULPF3"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer___deref__(self)


    def Reset(self) -> "void":
        """Reset(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer self)"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_Reset(self)


    def TakeOwnership(self, *args) -> "void":
        """
        TakeOwnership(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer self)
        TakeOwnership(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3 objectptr)
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_TakeOwnership(self, *args)


    def TakeNoOwnership(self, objectptr: 'itkCellInterfaceSSCTI3FFULULULPF3MCULPF3') -> "void":
        """TakeNoOwnership(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3 objectptr)"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_TakeNoOwnership(self, objectptr)


    def IsOwner(self) -> "bool":
        """IsOwner(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer self) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_IsOwner(self)


    def ReleaseOwnership(self) -> "itkCellInterfaceSSCTI3FFULULULPF3MCULPF3 *":
        """ReleaseOwnership(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer self) -> itkCellInterfaceSSCTI3FFULULULPF3MCULPF3"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_ReleaseOwnership(self)


    def GetPointer(self) -> "itkCellInterfaceSSCTI3FFULULULPF3MCULPF3 *":
        """GetPointer(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer self) -> itkCellInterfaceSSCTI3FFULULULPF3MCULPF3"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_GetPointer(self)


    def __eq__(self, r: 'itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """__eq__(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer___eq__(self, r)


    def __ne__(self, r: 'itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """__ne__(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer___ne__(self, r)


    def __lt__(self, r: 'itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """__lt__(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer___lt__(self, r)


    def __gt__(self, r: 'itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """__gt__(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer___gt__(self, r)


    def __le__(self, r: 'itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """__le__(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer___le__(self, r)


    def __ge__(self, r: 'itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """__ge__(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer___ge__(self, r)


    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceSSCTI3FFULULULPF3MCULPF3::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer self, unsigned long cellId, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCommonEnums::CellGeometry":
        """
        GetType(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer self) -> itkCommonEnums::CellGeometry

        Return the type of the cell
        (one of the CellGeometryEnum enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer self, int dimension, unsigned long arg1, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer self, unsigned long const * first)
        SetPointIds(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer self) -> unsigned long
        PointIdsBegin(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer self) -> unsigned long
        PointIdsEnd(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'float *', arg1: 'bool *', arg2: 'itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer self, float * arg0, bool * arg1, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not nullptr, the flag is set to indicate whether the point is inside
        the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'float *', arg1: 'itkMapContainerULPF3', arg2: 'float *', arg3: 'float *', arg4: 'double *', arg5: 'float *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer self, float * arg0, itkMapContainerULPF3 arg1, float * arg2, float * arg3, double * arg4, float * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not nullptr:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayF', arg1: 'itkArrayF') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer self, itkArrayF arg0, itkArrayF arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float', arg3: 'float *', arg4: 'float *', arg5: 'float *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer self, float * arg0, float * arg1, float arg2, float * arg3, float * arg4, float * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'float *') -> "float *":
        """
        GetBoundingBox(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer self, float * arg0) -> float *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "float":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer self) -> float

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float *', arg3: 'float *', arg4: 'float *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer self, float * arg0, float * arg1, float * arg2, float * arg3, float * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_GetNameOfClass(self)

itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer.__deref__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer___deref__, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer.Reset = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_Reset, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer.TakeOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_TakeOwnership, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer.TakeNoOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_TakeNoOwnership, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer.IsOwner = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_IsOwner, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer.ReleaseOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_ReleaseOwnership, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer.GetPointer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_GetPointer, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer.__eq__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer___eq__, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer.__ne__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer___ne__, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer.__lt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer___lt__, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer.__gt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer___gt__, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer.__le__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer___le__, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer.__ge__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer___ge__, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_Accept, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_GetType, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_MakeCopy, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_GetDimension, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_GetInterpolationOrder, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_GetNumberOfPoints, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_GetNumberOfBoundaryFeatures, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_GetBoundaryFeature, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_GetPointIds, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_SetPointIds, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_SetPointId, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_PointIdsBegin, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_PointIdsEnd, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_GetPointIdsContainer, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_SetPointIdsContainer, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_GetClosestBoundary, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_EvaluatePosition, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_EvaluateShapeFunctions, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_IntersectWithLine, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_GetBoundingBox, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_IntersectBoundingBoxWithLine, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_IsExplicitBoundary, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_AddUsingCell, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_RemoveUsingCell, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_IsUsingCell, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_GetNumberOfUsingCells, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_GetNameOfClass, None, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_swigregister = _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_swigregister
itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer_swigregister(itkCellInterfaceSSCTI3FFULULULPF3MCULPF3_AutoPointer)

class itkCellInterfaceSSCTI3FFULULULPF3VCULPF3(object):
    """


    An abstract interface for cells.

    Define an abstract interface for cells. Actual cell types derive from
    this class.

    Parameters:
    -----------

    TPixelType:  The type stored with an entity (cell, point, or
    boundary).

    TCellTraits:  Type information for cell.

    C++ includes: itkCellInterface.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceSSCTI3FFULULULPF3VCULPF3::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3 self, unsigned long cellId, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCommonEnums::CellGeometry":
        """
        GetType(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3 self) -> itkCommonEnums::CellGeometry

        Return the type of the cell
        (one of the CellGeometryEnum enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3 self, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3 self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3 self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3 self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3 self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3 self, int dimension, unsigned long arg1, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3 self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3 self, unsigned long const * first)
        SetPointIds(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3 self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3 self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3 self) -> unsigned long
        PointIdsBegin(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3 self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3 self) -> unsigned long
        PointIdsEnd(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3 self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3 self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3 self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'float *', arg1: 'bool *', arg2: 'itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3 self, float * arg0, bool * arg1, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not nullptr, the flag is set to indicate whether the point is inside
        the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'float *', arg1: 'itkVectorContainerULPF3', arg2: 'float *', arg3: 'float *', arg4: 'double *', arg5: 'float *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3 self, float * arg0, itkVectorContainerULPF3 arg1, float * arg2, float * arg3, double * arg4, float * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not nullptr:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayF', arg1: 'itkArrayF') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3 self, itkArrayF arg0, itkArrayF arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float', arg3: 'float *', arg4: 'float *', arg5: 'float *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3 self, float * arg0, float * arg1, float arg2, float * arg3, float * arg4, float * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'float *') -> "float *":
        """
        GetBoundingBox(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3 self, float * arg0) -> float *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "float":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3 self) -> float

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float *', arg3: 'float *', arg4: 'float *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3 self, float * arg0, float * arg1, float * arg2, float * arg3, float * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3 self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3 self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3 self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3 self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3 self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3 self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_GetNameOfClass(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceSSCTI3FFULULULPF3VCULPF3
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_Accept, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_GetType, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_MakeCopy, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_GetDimension, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_GetInterpolationOrder, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_GetNumberOfPoints, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_GetNumberOfBoundaryFeatures, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_GetBoundaryFeature, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_GetPointIds, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_SetPointIds, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_SetPointId, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_PointIdsBegin, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_PointIdsEnd, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_GetPointIdsContainer, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_SetPointIdsContainer, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_GetClosestBoundary, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_EvaluatePosition, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_EvaluateShapeFunctions, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_IntersectWithLine, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_GetBoundingBox, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_IntersectBoundingBoxWithLine, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_IsExplicitBoundary, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AddUsingCell, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_RemoveUsingCell, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_IsUsingCell, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_GetNumberOfUsingCells, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_GetNameOfClass, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_swigregister = _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_swigregister
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_swigregister(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3)

class itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer(object):
    """Proxy of C++ itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer self) -> itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer
        __init__(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer p) -> itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer
        __init__(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3 p, bool takeOwnership) -> itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer
        """
        _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_swiginit(self, _itkMeshBasePython.new_itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer(*args))
    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer

    def __deref__(self) -> "itkCellInterfaceSSCTI3FFULULULPF3VCULPF3 *":
        """__deref__(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer self) -> itkCellInterfaceSSCTI3FFULULULPF3VCULPF3"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer___deref__(self)


    def Reset(self) -> "void":
        """Reset(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer self)"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_Reset(self)


    def TakeOwnership(self, *args) -> "void":
        """
        TakeOwnership(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer self)
        TakeOwnership(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3 objectptr)
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_TakeOwnership(self, *args)


    def TakeNoOwnership(self, objectptr: 'itkCellInterfaceSSCTI3FFULULULPF3VCULPF3') -> "void":
        """TakeNoOwnership(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3 objectptr)"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_TakeNoOwnership(self, objectptr)


    def IsOwner(self) -> "bool":
        """IsOwner(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer self) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_IsOwner(self)


    def ReleaseOwnership(self) -> "itkCellInterfaceSSCTI3FFULULULPF3VCULPF3 *":
        """ReleaseOwnership(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer self) -> itkCellInterfaceSSCTI3FFULULULPF3VCULPF3"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_ReleaseOwnership(self)


    def GetPointer(self) -> "itkCellInterfaceSSCTI3FFULULULPF3VCULPF3 *":
        """GetPointer(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer self) -> itkCellInterfaceSSCTI3FFULULULPF3VCULPF3"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_GetPointer(self)


    def __eq__(self, r: 'itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """__eq__(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer___eq__(self, r)


    def __ne__(self, r: 'itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """__ne__(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer___ne__(self, r)


    def __lt__(self, r: 'itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """__lt__(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer___lt__(self, r)


    def __gt__(self, r: 'itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """__gt__(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer___gt__(self, r)


    def __le__(self, r: 'itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """__le__(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer___le__(self, r)


    def __ge__(self, r: 'itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """__ge__(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer___ge__(self, r)


    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceSSCTI3FFULULULPF3VCULPF3::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer self, unsigned long cellId, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCommonEnums::CellGeometry":
        """
        GetType(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer self) -> itkCommonEnums::CellGeometry

        Return the type of the cell
        (one of the CellGeometryEnum enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer self, int dimension, unsigned long arg1, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer self, unsigned long const * first)
        SetPointIds(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer self) -> unsigned long
        PointIdsBegin(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer self) -> unsigned long
        PointIdsEnd(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'float *', arg1: 'bool *', arg2: 'itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer self, float * arg0, bool * arg1, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not nullptr, the flag is set to indicate whether the point is inside
        the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'float *', arg1: 'itkVectorContainerULPF3', arg2: 'float *', arg3: 'float *', arg4: 'double *', arg5: 'float *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer self, float * arg0, itkVectorContainerULPF3 arg1, float * arg2, float * arg3, double * arg4, float * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not nullptr:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayF', arg1: 'itkArrayF') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer self, itkArrayF arg0, itkArrayF arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float', arg3: 'float *', arg4: 'float *', arg5: 'float *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer self, float * arg0, float * arg1, float arg2, float * arg3, float * arg4, float * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'float *') -> "float *":
        """
        GetBoundingBox(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer self, float * arg0) -> float *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "float":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer self) -> float

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float *', arg3: 'float *', arg4: 'float *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer self, float * arg0, float * arg1, float * arg2, float * arg3, float * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_GetNameOfClass(self)

itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer.__deref__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer___deref__, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer.Reset = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_Reset, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer.TakeOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_TakeOwnership, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer.TakeNoOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_TakeNoOwnership, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer.IsOwner = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_IsOwner, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer.ReleaseOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_ReleaseOwnership, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer.GetPointer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_GetPointer, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer.__eq__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer___eq__, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer.__ne__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer___ne__, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer.__lt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer___lt__, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer.__gt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer___gt__, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer.__le__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer___le__, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer.__ge__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer___ge__, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_Accept, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_GetType, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_MakeCopy, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_GetDimension, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_GetInterpolationOrder, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_GetNumberOfPoints, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_GetNumberOfBoundaryFeatures, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_GetBoundaryFeature, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_GetPointIds, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_SetPointIds, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_SetPointId, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_PointIdsBegin, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_PointIdsEnd, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_GetPointIdsContainer, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_SetPointIdsContainer, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_GetClosestBoundary, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_EvaluatePosition, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_EvaluateShapeFunctions, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_IntersectWithLine, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_GetBoundingBox, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_IntersectBoundingBoxWithLine, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_IsExplicitBoundary, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_AddUsingCell, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_RemoveUsingCell, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_IsUsingCell, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_GetNumberOfUsingCells, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_GetNameOfClass, None, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_swigregister = _itkMeshBasePython.itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_swigregister
itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer_swigregister(itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer)

class itkCellInterfaceUCCTI2FFULULULPF2MCULPF2(object):
    """


    An abstract interface for cells.

    Define an abstract interface for cells. Actual cell types derive from
    this class.

    Parameters:
    -----------

    TPixelType:  The type stored with an entity (cell, point, or
    boundary).

    TCellTraits:  Type information for cell.

    C++ includes: itkCellInterface.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceUCCTI2FFULULULPF2MCULPF2::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2 self, unsigned long cellId, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCommonEnums::CellGeometry":
        """
        GetType(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2 self) -> itkCommonEnums::CellGeometry

        Return the type of the cell
        (one of the CellGeometryEnum enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2 self, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2 self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2 self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2 self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2 self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2 self, int dimension, unsigned long arg1, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2 self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2 self, unsigned long const * first)
        SetPointIds(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2 self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2 self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2 self) -> unsigned long
        PointIdsBegin(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2 self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2 self) -> unsigned long
        PointIdsEnd(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2 self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2 self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2 self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'float *', arg1: 'bool *', arg2: 'itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2 self, float * arg0, bool * arg1, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not nullptr, the flag is set to indicate whether the point is inside
        the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'float *', arg1: 'itkMapContainerULPF2', arg2: 'float *', arg3: 'float *', arg4: 'double *', arg5: 'float *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2 self, float * arg0, itkMapContainerULPF2 arg1, float * arg2, float * arg3, double * arg4, float * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not nullptr:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayF', arg1: 'itkArrayF') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2 self, itkArrayF arg0, itkArrayF arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float', arg3: 'float *', arg4: 'float *', arg5: 'float *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2 self, float * arg0, float * arg1, float arg2, float * arg3, float * arg4, float * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'float *') -> "float *":
        """
        GetBoundingBox(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2 self, float * arg0) -> float *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "float":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2 self) -> float

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float *', arg3: 'float *', arg4: 'float *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2 self, float * arg0, float * arg1, float * arg2, float * arg3, float * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2 self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2 self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2 self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2 self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2 self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2 self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_GetNameOfClass(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceUCCTI2FFULULULPF2MCULPF2
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_Accept, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_GetType, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_MakeCopy, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_GetDimension, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_GetInterpolationOrder, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_GetNumberOfPoints, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_GetNumberOfBoundaryFeatures, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_GetBoundaryFeature, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_GetPointIds, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_SetPointIds, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_SetPointId, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_PointIdsBegin, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_PointIdsEnd, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_GetPointIdsContainer, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_SetPointIdsContainer, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_GetClosestBoundary, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_EvaluatePosition, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_EvaluateShapeFunctions, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_IntersectWithLine, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_GetBoundingBox, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_IntersectBoundingBoxWithLine, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_IsExplicitBoundary, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AddUsingCell, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_RemoveUsingCell, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_IsUsingCell, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_GetNumberOfUsingCells, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_GetNameOfClass, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_swigregister = _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_swigregister
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_swigregister(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2)

class itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer(object):
    """Proxy of C++ itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer self) -> itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer
        __init__(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer p) -> itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer
        __init__(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2 p, bool takeOwnership) -> itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer
        """
        _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_swiginit(self, _itkMeshBasePython.new_itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer(*args))
    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer

    def __deref__(self) -> "itkCellInterfaceUCCTI2FFULULULPF2MCULPF2 *":
        """__deref__(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer self) -> itkCellInterfaceUCCTI2FFULULULPF2MCULPF2"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer___deref__(self)


    def Reset(self) -> "void":
        """Reset(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer self)"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_Reset(self)


    def TakeOwnership(self, *args) -> "void":
        """
        TakeOwnership(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer self)
        TakeOwnership(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2 objectptr)
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_TakeOwnership(self, *args)


    def TakeNoOwnership(self, objectptr: 'itkCellInterfaceUCCTI2FFULULULPF2MCULPF2') -> "void":
        """TakeNoOwnership(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2 objectptr)"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_TakeNoOwnership(self, objectptr)


    def IsOwner(self) -> "bool":
        """IsOwner(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer self) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_IsOwner(self)


    def ReleaseOwnership(self) -> "itkCellInterfaceUCCTI2FFULULULPF2MCULPF2 *":
        """ReleaseOwnership(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer self) -> itkCellInterfaceUCCTI2FFULULULPF2MCULPF2"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_ReleaseOwnership(self)


    def GetPointer(self) -> "itkCellInterfaceUCCTI2FFULULULPF2MCULPF2 *":
        """GetPointer(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer self) -> itkCellInterfaceUCCTI2FFULULULPF2MCULPF2"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_GetPointer(self)


    def __eq__(self, r: 'itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """__eq__(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer___eq__(self, r)


    def __ne__(self, r: 'itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """__ne__(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer___ne__(self, r)


    def __lt__(self, r: 'itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """__lt__(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer___lt__(self, r)


    def __gt__(self, r: 'itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """__gt__(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer___gt__(self, r)


    def __le__(self, r: 'itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """__le__(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer___le__(self, r)


    def __ge__(self, r: 'itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """__ge__(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer___ge__(self, r)


    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceUCCTI2FFULULULPF2MCULPF2::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer self, unsigned long cellId, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCommonEnums::CellGeometry":
        """
        GetType(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer self) -> itkCommonEnums::CellGeometry

        Return the type of the cell
        (one of the CellGeometryEnum enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer self, int dimension, unsigned long arg1, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer self, unsigned long const * first)
        SetPointIds(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer self) -> unsigned long
        PointIdsBegin(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer self) -> unsigned long
        PointIdsEnd(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'float *', arg1: 'bool *', arg2: 'itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer self, float * arg0, bool * arg1, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not nullptr, the flag is set to indicate whether the point is inside
        the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'float *', arg1: 'itkMapContainerULPF2', arg2: 'float *', arg3: 'float *', arg4: 'double *', arg5: 'float *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer self, float * arg0, itkMapContainerULPF2 arg1, float * arg2, float * arg3, double * arg4, float * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not nullptr:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayF', arg1: 'itkArrayF') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer self, itkArrayF arg0, itkArrayF arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float', arg3: 'float *', arg4: 'float *', arg5: 'float *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer self, float * arg0, float * arg1, float arg2, float * arg3, float * arg4, float * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'float *') -> "float *":
        """
        GetBoundingBox(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer self, float * arg0) -> float *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "float":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer self) -> float

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float *', arg3: 'float *', arg4: 'float *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer self, float * arg0, float * arg1, float * arg2, float * arg3, float * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_GetNameOfClass(self)

itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer.__deref__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer___deref__, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer.Reset = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_Reset, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer.TakeOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_TakeOwnership, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer.TakeNoOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_TakeNoOwnership, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer.IsOwner = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_IsOwner, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer.ReleaseOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_ReleaseOwnership, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer.GetPointer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_GetPointer, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer.__eq__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer___eq__, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer.__ne__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer___ne__, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer.__lt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer___lt__, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer.__gt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer___gt__, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer.__le__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer___le__, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer.__ge__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer___ge__, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_Accept, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_GetType, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_MakeCopy, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_GetDimension, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_GetInterpolationOrder, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_GetNumberOfPoints, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_GetNumberOfBoundaryFeatures, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_GetBoundaryFeature, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_GetPointIds, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_SetPointIds, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_SetPointId, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_PointIdsBegin, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_PointIdsEnd, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_GetPointIdsContainer, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_SetPointIdsContainer, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_GetClosestBoundary, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_EvaluatePosition, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_EvaluateShapeFunctions, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_IntersectWithLine, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_GetBoundingBox, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_IntersectBoundingBoxWithLine, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_IsExplicitBoundary, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_AddUsingCell, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_RemoveUsingCell, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_IsUsingCell, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_GetNumberOfUsingCells, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_GetNameOfClass, None, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_swigregister = _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_swigregister
itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer_swigregister(itkCellInterfaceUCCTI2FFULULULPF2MCULPF2_AutoPointer)

class itkCellInterfaceUCCTI2FFULULULPF2VCULPF2(object):
    """


    An abstract interface for cells.

    Define an abstract interface for cells. Actual cell types derive from
    this class.

    Parameters:
    -----------

    TPixelType:  The type stored with an entity (cell, point, or
    boundary).

    TCellTraits:  Type information for cell.

    C++ includes: itkCellInterface.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceUCCTI2FFULULULPF2VCULPF2::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2 self, unsigned long cellId, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCommonEnums::CellGeometry":
        """
        GetType(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2 self) -> itkCommonEnums::CellGeometry

        Return the type of the cell
        (one of the CellGeometryEnum enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2 self, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2 self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2 self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2 self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2 self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2 self, int dimension, unsigned long arg1, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2 self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2 self, unsigned long const * first)
        SetPointIds(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2 self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2 self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2 self) -> unsigned long
        PointIdsBegin(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2 self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2 self) -> unsigned long
        PointIdsEnd(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2 self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2 self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2 self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'float *', arg1: 'bool *', arg2: 'itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2 self, float * arg0, bool * arg1, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not nullptr, the flag is set to indicate whether the point is inside
        the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'float *', arg1: 'itkVectorContainerULPF2', arg2: 'float *', arg3: 'float *', arg4: 'double *', arg5: 'float *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2 self, float * arg0, itkVectorContainerULPF2 arg1, float * arg2, float * arg3, double * arg4, float * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not nullptr:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayF', arg1: 'itkArrayF') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2 self, itkArrayF arg0, itkArrayF arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float', arg3: 'float *', arg4: 'float *', arg5: 'float *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2 self, float * arg0, float * arg1, float arg2, float * arg3, float * arg4, float * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'float *') -> "float *":
        """
        GetBoundingBox(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2 self, float * arg0) -> float *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "float":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2 self) -> float

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float *', arg3: 'float *', arg4: 'float *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2 self, float * arg0, float * arg1, float * arg2, float * arg3, float * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2 self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2 self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2 self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2 self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2 self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2 self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_GetNameOfClass(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceUCCTI2FFULULULPF2VCULPF2
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_Accept, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_GetType, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_MakeCopy, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_GetDimension, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_GetInterpolationOrder, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_GetNumberOfPoints, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_GetNumberOfBoundaryFeatures, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_GetBoundaryFeature, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_GetPointIds, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_SetPointIds, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_SetPointId, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_PointIdsBegin, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_PointIdsEnd, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_GetPointIdsContainer, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_SetPointIdsContainer, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_GetClosestBoundary, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_EvaluatePosition, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_EvaluateShapeFunctions, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_IntersectWithLine, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_GetBoundingBox, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_IntersectBoundingBoxWithLine, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_IsExplicitBoundary, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AddUsingCell, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_RemoveUsingCell, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_IsUsingCell, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_GetNumberOfUsingCells, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_GetNameOfClass, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_swigregister = _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_swigregister
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_swigregister(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2)

class itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer(object):
    """Proxy of C++ itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer self) -> itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer
        __init__(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer p) -> itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer
        __init__(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2 p, bool takeOwnership) -> itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer
        """
        _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_swiginit(self, _itkMeshBasePython.new_itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer(*args))
    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer

    def __deref__(self) -> "itkCellInterfaceUCCTI2FFULULULPF2VCULPF2 *":
        """__deref__(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer self) -> itkCellInterfaceUCCTI2FFULULULPF2VCULPF2"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer___deref__(self)


    def Reset(self) -> "void":
        """Reset(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer self)"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_Reset(self)


    def TakeOwnership(self, *args) -> "void":
        """
        TakeOwnership(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer self)
        TakeOwnership(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2 objectptr)
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_TakeOwnership(self, *args)


    def TakeNoOwnership(self, objectptr: 'itkCellInterfaceUCCTI2FFULULULPF2VCULPF2') -> "void":
        """TakeNoOwnership(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2 objectptr)"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_TakeNoOwnership(self, objectptr)


    def IsOwner(self) -> "bool":
        """IsOwner(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer self) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_IsOwner(self)


    def ReleaseOwnership(self) -> "itkCellInterfaceUCCTI2FFULULULPF2VCULPF2 *":
        """ReleaseOwnership(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer self) -> itkCellInterfaceUCCTI2FFULULULPF2VCULPF2"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_ReleaseOwnership(self)


    def GetPointer(self) -> "itkCellInterfaceUCCTI2FFULULULPF2VCULPF2 *":
        """GetPointer(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer self) -> itkCellInterfaceUCCTI2FFULULULPF2VCULPF2"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_GetPointer(self)


    def __eq__(self, r: 'itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """__eq__(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer___eq__(self, r)


    def __ne__(self, r: 'itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """__ne__(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer___ne__(self, r)


    def __lt__(self, r: 'itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """__lt__(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer___lt__(self, r)


    def __gt__(self, r: 'itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """__gt__(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer___gt__(self, r)


    def __le__(self, r: 'itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """__le__(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer___le__(self, r)


    def __ge__(self, r: 'itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """__ge__(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer___ge__(self, r)


    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceUCCTI2FFULULULPF2VCULPF2::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer self, unsigned long cellId, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCommonEnums::CellGeometry":
        """
        GetType(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer self) -> itkCommonEnums::CellGeometry

        Return the type of the cell
        (one of the CellGeometryEnum enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer self, int dimension, unsigned long arg1, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer self, unsigned long const * first)
        SetPointIds(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer self) -> unsigned long
        PointIdsBegin(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer self) -> unsigned long
        PointIdsEnd(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'float *', arg1: 'bool *', arg2: 'itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer self, float * arg0, bool * arg1, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not nullptr, the flag is set to indicate whether the point is inside
        the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'float *', arg1: 'itkVectorContainerULPF2', arg2: 'float *', arg3: 'float *', arg4: 'double *', arg5: 'float *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer self, float * arg0, itkVectorContainerULPF2 arg1, float * arg2, float * arg3, double * arg4, float * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not nullptr:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayF', arg1: 'itkArrayF') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer self, itkArrayF arg0, itkArrayF arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float', arg3: 'float *', arg4: 'float *', arg5: 'float *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer self, float * arg0, float * arg1, float arg2, float * arg3, float * arg4, float * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'float *') -> "float *":
        """
        GetBoundingBox(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer self, float * arg0) -> float *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "float":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer self) -> float

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float *', arg3: 'float *', arg4: 'float *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer self, float * arg0, float * arg1, float * arg2, float * arg3, float * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_GetNameOfClass(self)

itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer.__deref__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer___deref__, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer.Reset = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_Reset, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer.TakeOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_TakeOwnership, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer.TakeNoOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_TakeNoOwnership, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer.IsOwner = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_IsOwner, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer.ReleaseOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_ReleaseOwnership, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer.GetPointer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_GetPointer, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer.__eq__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer___eq__, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer.__ne__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer___ne__, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer.__lt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer___lt__, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer.__gt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer___gt__, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer.__le__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer___le__, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer.__ge__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer___ge__, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_Accept, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_GetType, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_MakeCopy, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_GetDimension, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_GetInterpolationOrder, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_GetNumberOfPoints, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_GetNumberOfBoundaryFeatures, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_GetBoundaryFeature, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_GetPointIds, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_SetPointIds, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_SetPointId, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_PointIdsBegin, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_PointIdsEnd, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_GetPointIdsContainer, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_SetPointIdsContainer, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_GetClosestBoundary, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_EvaluatePosition, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_EvaluateShapeFunctions, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_IntersectWithLine, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_GetBoundingBox, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_IntersectBoundingBoxWithLine, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_IsExplicitBoundary, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_AddUsingCell, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_RemoveUsingCell, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_IsUsingCell, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_GetNumberOfUsingCells, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_GetNameOfClass, None, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_swigregister = _itkMeshBasePython.itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_swigregister
itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer_swigregister(itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer)

class itkCellInterfaceUCCTI3FFULULULPF3MCULPF3(object):
    """


    An abstract interface for cells.

    Define an abstract interface for cells. Actual cell types derive from
    this class.

    Parameters:
    -----------

    TPixelType:  The type stored with an entity (cell, point, or
    boundary).

    TCellTraits:  Type information for cell.

    C++ includes: itkCellInterface.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceUCCTI3FFULULULPF3MCULPF3::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3 self, unsigned long cellId, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCommonEnums::CellGeometry":
        """
        GetType(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3 self) -> itkCommonEnums::CellGeometry

        Return the type of the cell
        (one of the CellGeometryEnum enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3 self, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3 self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3 self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3 self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3 self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3 self, int dimension, unsigned long arg1, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3 self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3 self, unsigned long const * first)
        SetPointIds(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3 self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3 self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3 self) -> unsigned long
        PointIdsBegin(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3 self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3 self) -> unsigned long
        PointIdsEnd(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3 self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3 self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3 self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'float *', arg1: 'bool *', arg2: 'itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3 self, float * arg0, bool * arg1, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not nullptr, the flag is set to indicate whether the point is inside
        the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'float *', arg1: 'itkMapContainerULPF3', arg2: 'float *', arg3: 'float *', arg4: 'double *', arg5: 'float *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3 self, float * arg0, itkMapContainerULPF3 arg1, float * arg2, float * arg3, double * arg4, float * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not nullptr:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayF', arg1: 'itkArrayF') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3 self, itkArrayF arg0, itkArrayF arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float', arg3: 'float *', arg4: 'float *', arg5: 'float *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3 self, float * arg0, float * arg1, float arg2, float * arg3, float * arg4, float * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'float *') -> "float *":
        """
        GetBoundingBox(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3 self, float * arg0) -> float *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "float":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3 self) -> float

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float *', arg3: 'float *', arg4: 'float *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3 self, float * arg0, float * arg1, float * arg2, float * arg3, float * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3 self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3 self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3 self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3 self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3 self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3 self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_GetNameOfClass(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceUCCTI3FFULULULPF3MCULPF3
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_Accept, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_GetType, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_MakeCopy, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_GetDimension, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_GetInterpolationOrder, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_GetNumberOfPoints, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_GetNumberOfBoundaryFeatures, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_GetBoundaryFeature, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_GetPointIds, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_SetPointIds, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_SetPointId, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_PointIdsBegin, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_PointIdsEnd, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_GetPointIdsContainer, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_SetPointIdsContainer, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_GetClosestBoundary, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_EvaluatePosition, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_EvaluateShapeFunctions, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_IntersectWithLine, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_GetBoundingBox, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_IntersectBoundingBoxWithLine, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_IsExplicitBoundary, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AddUsingCell, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_RemoveUsingCell, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_IsUsingCell, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_GetNumberOfUsingCells, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_GetNameOfClass, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_swigregister = _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_swigregister
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_swigregister(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3)

class itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer(object):
    """Proxy of C++ itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer self) -> itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer
        __init__(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer p) -> itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer
        __init__(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3 p, bool takeOwnership) -> itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer
        """
        _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_swiginit(self, _itkMeshBasePython.new_itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer(*args))
    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer

    def __deref__(self) -> "itkCellInterfaceUCCTI3FFULULULPF3MCULPF3 *":
        """__deref__(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer self) -> itkCellInterfaceUCCTI3FFULULULPF3MCULPF3"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer___deref__(self)


    def Reset(self) -> "void":
        """Reset(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer self)"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_Reset(self)


    def TakeOwnership(self, *args) -> "void":
        """
        TakeOwnership(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer self)
        TakeOwnership(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3 objectptr)
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_TakeOwnership(self, *args)


    def TakeNoOwnership(self, objectptr: 'itkCellInterfaceUCCTI3FFULULULPF3MCULPF3') -> "void":
        """TakeNoOwnership(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3 objectptr)"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_TakeNoOwnership(self, objectptr)


    def IsOwner(self) -> "bool":
        """IsOwner(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer self) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_IsOwner(self)


    def ReleaseOwnership(self) -> "itkCellInterfaceUCCTI3FFULULULPF3MCULPF3 *":
        """ReleaseOwnership(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer self) -> itkCellInterfaceUCCTI3FFULULULPF3MCULPF3"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_ReleaseOwnership(self)


    def GetPointer(self) -> "itkCellInterfaceUCCTI3FFULULULPF3MCULPF3 *":
        """GetPointer(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer self) -> itkCellInterfaceUCCTI3FFULULULPF3MCULPF3"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_GetPointer(self)


    def __eq__(self, r: 'itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """__eq__(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer___eq__(self, r)


    def __ne__(self, r: 'itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """__ne__(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer___ne__(self, r)


    def __lt__(self, r: 'itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """__lt__(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer___lt__(self, r)


    def __gt__(self, r: 'itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """__gt__(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer___gt__(self, r)


    def __le__(self, r: 'itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """__le__(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer___le__(self, r)


    def __ge__(self, r: 'itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """__ge__(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer___ge__(self, r)


    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceUCCTI3FFULULULPF3MCULPF3::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer self, unsigned long cellId, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCommonEnums::CellGeometry":
        """
        GetType(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer self) -> itkCommonEnums::CellGeometry

        Return the type of the cell
        (one of the CellGeometryEnum enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer self, int dimension, unsigned long arg1, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer self, unsigned long const * first)
        SetPointIds(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer self) -> unsigned long
        PointIdsBegin(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer self) -> unsigned long
        PointIdsEnd(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'float *', arg1: 'bool *', arg2: 'itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer self, float * arg0, bool * arg1, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not nullptr, the flag is set to indicate whether the point is inside
        the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'float *', arg1: 'itkMapContainerULPF3', arg2: 'float *', arg3: 'float *', arg4: 'double *', arg5: 'float *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer self, float * arg0, itkMapContainerULPF3 arg1, float * arg2, float * arg3, double * arg4, float * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not nullptr:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayF', arg1: 'itkArrayF') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer self, itkArrayF arg0, itkArrayF arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float', arg3: 'float *', arg4: 'float *', arg5: 'float *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer self, float * arg0, float * arg1, float arg2, float * arg3, float * arg4, float * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'float *') -> "float *":
        """
        GetBoundingBox(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer self, float * arg0) -> float *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "float":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer self) -> float

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float *', arg3: 'float *', arg4: 'float *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer self, float * arg0, float * arg1, float * arg2, float * arg3, float * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_GetNameOfClass(self)

itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer.__deref__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer___deref__, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer.Reset = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_Reset, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer.TakeOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_TakeOwnership, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer.TakeNoOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_TakeNoOwnership, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer.IsOwner = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_IsOwner, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer.ReleaseOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_ReleaseOwnership, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer.GetPointer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_GetPointer, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer.__eq__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer___eq__, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer.__ne__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer___ne__, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer.__lt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer___lt__, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer.__gt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer___gt__, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer.__le__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer___le__, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer.__ge__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer___ge__, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_Accept, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_GetType, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_MakeCopy, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_GetDimension, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_GetInterpolationOrder, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_GetNumberOfPoints, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_GetNumberOfBoundaryFeatures, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_GetBoundaryFeature, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_GetPointIds, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_SetPointIds, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_SetPointId, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_PointIdsBegin, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_PointIdsEnd, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_GetPointIdsContainer, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_SetPointIdsContainer, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_GetClosestBoundary, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_EvaluatePosition, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_EvaluateShapeFunctions, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_IntersectWithLine, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_GetBoundingBox, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_IntersectBoundingBoxWithLine, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_IsExplicitBoundary, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_AddUsingCell, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_RemoveUsingCell, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_IsUsingCell, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_GetNumberOfUsingCells, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_GetNameOfClass, None, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_swigregister = _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_swigregister
itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer_swigregister(itkCellInterfaceUCCTI3FFULULULPF3MCULPF3_AutoPointer)

class itkCellInterfaceUCCTI3FFULULULPF3VCULPF3(object):
    """


    An abstract interface for cells.

    Define an abstract interface for cells. Actual cell types derive from
    this class.

    Parameters:
    -----------

    TPixelType:  The type stored with an entity (cell, point, or
    boundary).

    TCellTraits:  Type information for cell.

    C++ includes: itkCellInterface.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceUCCTI3FFULULULPF3VCULPF3::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3 self, unsigned long cellId, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCommonEnums::CellGeometry":
        """
        GetType(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3 self) -> itkCommonEnums::CellGeometry

        Return the type of the cell
        (one of the CellGeometryEnum enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3 self, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3 self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3 self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3 self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3 self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3 self, int dimension, unsigned long arg1, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3 self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3 self, unsigned long const * first)
        SetPointIds(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3 self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3 self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3 self) -> unsigned long
        PointIdsBegin(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3 self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3 self) -> unsigned long
        PointIdsEnd(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3 self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3 self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3 self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'float *', arg1: 'bool *', arg2: 'itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3 self, float * arg0, bool * arg1, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not nullptr, the flag is set to indicate whether the point is inside
        the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'float *', arg1: 'itkVectorContainerULPF3', arg2: 'float *', arg3: 'float *', arg4: 'double *', arg5: 'float *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3 self, float * arg0, itkVectorContainerULPF3 arg1, float * arg2, float * arg3, double * arg4, float * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not nullptr:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayF', arg1: 'itkArrayF') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3 self, itkArrayF arg0, itkArrayF arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float', arg3: 'float *', arg4: 'float *', arg5: 'float *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3 self, float * arg0, float * arg1, float arg2, float * arg3, float * arg4, float * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'float *') -> "float *":
        """
        GetBoundingBox(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3 self, float * arg0) -> float *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "float":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3 self) -> float

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float *', arg3: 'float *', arg4: 'float *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3 self, float * arg0, float * arg1, float * arg2, float * arg3, float * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3 self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3 self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3 self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3 self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3 self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3 self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_GetNameOfClass(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceUCCTI3FFULULULPF3VCULPF3
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_Accept, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_GetType, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_MakeCopy, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_GetDimension, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_GetInterpolationOrder, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_GetNumberOfPoints, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_GetNumberOfBoundaryFeatures, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_GetBoundaryFeature, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_GetPointIds, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_SetPointIds, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_SetPointId, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_PointIdsBegin, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_PointIdsEnd, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_GetPointIdsContainer, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_SetPointIdsContainer, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_GetClosestBoundary, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_EvaluatePosition, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_EvaluateShapeFunctions, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_IntersectWithLine, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_GetBoundingBox, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_IntersectBoundingBoxWithLine, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_IsExplicitBoundary, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AddUsingCell, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_RemoveUsingCell, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_IsUsingCell, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_GetNumberOfUsingCells, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_GetNameOfClass, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_swigregister = _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_swigregister
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_swigregister(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3)

class itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer(object):
    """Proxy of C++ itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer self) -> itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer
        __init__(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer p) -> itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer
        __init__(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3 p, bool takeOwnership) -> itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer
        """
        _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_swiginit(self, _itkMeshBasePython.new_itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer(*args))
    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer

    def __deref__(self) -> "itkCellInterfaceUCCTI3FFULULULPF3VCULPF3 *":
        """__deref__(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer self) -> itkCellInterfaceUCCTI3FFULULULPF3VCULPF3"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer___deref__(self)


    def Reset(self) -> "void":
        """Reset(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer self)"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_Reset(self)


    def TakeOwnership(self, *args) -> "void":
        """
        TakeOwnership(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer self)
        TakeOwnership(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3 objectptr)
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_TakeOwnership(self, *args)


    def TakeNoOwnership(self, objectptr: 'itkCellInterfaceUCCTI3FFULULULPF3VCULPF3') -> "void":
        """TakeNoOwnership(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3 objectptr)"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_TakeNoOwnership(self, objectptr)


    def IsOwner(self) -> "bool":
        """IsOwner(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer self) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_IsOwner(self)


    def ReleaseOwnership(self) -> "itkCellInterfaceUCCTI3FFULULULPF3VCULPF3 *":
        """ReleaseOwnership(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer self) -> itkCellInterfaceUCCTI3FFULULULPF3VCULPF3"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_ReleaseOwnership(self)


    def GetPointer(self) -> "itkCellInterfaceUCCTI3FFULULULPF3VCULPF3 *":
        """GetPointer(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer self) -> itkCellInterfaceUCCTI3FFULULULPF3VCULPF3"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_GetPointer(self)


    def __eq__(self, r: 'itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """__eq__(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer___eq__(self, r)


    def __ne__(self, r: 'itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """__ne__(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer___ne__(self, r)


    def __lt__(self, r: 'itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """__lt__(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer___lt__(self, r)


    def __gt__(self, r: 'itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """__gt__(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer___gt__(self, r)


    def __le__(self, r: 'itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """__le__(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer___le__(self, r)


    def __ge__(self, r: 'itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """__ge__(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer___ge__(self, r)


    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceUCCTI3FFULULULPF3VCULPF3::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer self, unsigned long cellId, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCommonEnums::CellGeometry":
        """
        GetType(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer self) -> itkCommonEnums::CellGeometry

        Return the type of the cell
        (one of the CellGeometryEnum enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer self, int dimension, unsigned long arg1, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer self, unsigned long const * first)
        SetPointIds(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer self) -> unsigned long
        PointIdsBegin(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer self) -> unsigned long
        PointIdsEnd(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'float *', arg1: 'bool *', arg2: 'itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer self, float * arg0, bool * arg1, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not nullptr, the flag is set to indicate whether the point is inside
        the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'float *', arg1: 'itkVectorContainerULPF3', arg2: 'float *', arg3: 'float *', arg4: 'double *', arg5: 'float *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer self, float * arg0, itkVectorContainerULPF3 arg1, float * arg2, float * arg3, double * arg4, float * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not nullptr:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayF', arg1: 'itkArrayF') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer self, itkArrayF arg0, itkArrayF arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float', arg3: 'float *', arg4: 'float *', arg5: 'float *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer self, float * arg0, float * arg1, float arg2, float * arg3, float * arg4, float * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'float *') -> "float *":
        """
        GetBoundingBox(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer self, float * arg0) -> float *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "float":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer self) -> float

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float *', arg3: 'float *', arg4: 'float *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer self, float * arg0, float * arg1, float * arg2, float * arg3, float * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_GetNameOfClass(self)

itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer.__deref__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer___deref__, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer.Reset = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_Reset, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer.TakeOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_TakeOwnership, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer.TakeNoOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_TakeNoOwnership, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer.IsOwner = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_IsOwner, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer.ReleaseOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_ReleaseOwnership, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer.GetPointer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_GetPointer, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer.__eq__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer___eq__, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer.__ne__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer___ne__, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer.__lt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer___lt__, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer.__gt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer___gt__, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer.__le__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer___le__, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer.__ge__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer___ge__, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_Accept, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_GetType, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_MakeCopy, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_GetDimension, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_GetInterpolationOrder, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_GetNumberOfPoints, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_GetNumberOfBoundaryFeatures, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_GetBoundaryFeature, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_GetPointIds, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_SetPointIds, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_SetPointId, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_PointIdsBegin, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_PointIdsEnd, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_GetPointIdsContainer, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_SetPointIdsContainer, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_GetClosestBoundary, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_EvaluatePosition, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_EvaluateShapeFunctions, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_IntersectWithLine, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_GetBoundingBox, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_IntersectBoundingBoxWithLine, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_IsExplicitBoundary, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_AddUsingCell, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_RemoveUsingCell, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_IsUsingCell, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_GetNumberOfUsingCells, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_GetNameOfClass, None, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_swigregister = _itkMeshBasePython.itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_swigregister
itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer_swigregister(itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer)

class itkCellInterfaceUSCTI2FFULULULPF2MCULPF2(object):
    """


    An abstract interface for cells.

    Define an abstract interface for cells. Actual cell types derive from
    this class.

    Parameters:
    -----------

    TPixelType:  The type stored with an entity (cell, point, or
    boundary).

    TCellTraits:  Type information for cell.

    C++ includes: itkCellInterface.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceUSCTI2FFULULULPF2MCULPF2::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2 self, unsigned long cellId, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCommonEnums::CellGeometry":
        """
        GetType(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2 self) -> itkCommonEnums::CellGeometry

        Return the type of the cell
        (one of the CellGeometryEnum enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2 self, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2 self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2 self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2 self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2 self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2 self, int dimension, unsigned long arg1, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2 self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2 self, unsigned long const * first)
        SetPointIds(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2 self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2 self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2 self) -> unsigned long
        PointIdsBegin(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2 self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2 self) -> unsigned long
        PointIdsEnd(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2 self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2 self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2 self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'float *', arg1: 'bool *', arg2: 'itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2 self, float * arg0, bool * arg1, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not nullptr, the flag is set to indicate whether the point is inside
        the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'float *', arg1: 'itkMapContainerULPF2', arg2: 'float *', arg3: 'float *', arg4: 'double *', arg5: 'float *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2 self, float * arg0, itkMapContainerULPF2 arg1, float * arg2, float * arg3, double * arg4, float * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not nullptr:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayF', arg1: 'itkArrayF') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2 self, itkArrayF arg0, itkArrayF arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float', arg3: 'float *', arg4: 'float *', arg5: 'float *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2 self, float * arg0, float * arg1, float arg2, float * arg3, float * arg4, float * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'float *') -> "float *":
        """
        GetBoundingBox(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2 self, float * arg0) -> float *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "float":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2 self) -> float

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float *', arg3: 'float *', arg4: 'float *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2 self, float * arg0, float * arg1, float * arg2, float * arg3, float * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2 self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2 self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2 self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2 self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2 self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2 self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_GetNameOfClass(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceUSCTI2FFULULULPF2MCULPF2
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_Accept, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_GetType, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_MakeCopy, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_GetDimension, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_GetInterpolationOrder, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_GetNumberOfPoints, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_GetNumberOfBoundaryFeatures, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_GetBoundaryFeature, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_GetPointIds, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_SetPointIds, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_SetPointId, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_PointIdsBegin, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_PointIdsEnd, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_GetPointIdsContainer, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_SetPointIdsContainer, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_GetClosestBoundary, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_EvaluatePosition, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_EvaluateShapeFunctions, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_IntersectWithLine, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_GetBoundingBox, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_IntersectBoundingBoxWithLine, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_IsExplicitBoundary, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AddUsingCell, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_RemoveUsingCell, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_IsUsingCell, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_GetNumberOfUsingCells, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_GetNameOfClass, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_swigregister = _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_swigregister
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_swigregister(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2)

class itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer(object):
    """Proxy of C++ itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer self) -> itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer
        __init__(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer p) -> itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer
        __init__(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2 p, bool takeOwnership) -> itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer
        """
        _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_swiginit(self, _itkMeshBasePython.new_itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer(*args))
    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer

    def __deref__(self) -> "itkCellInterfaceUSCTI2FFULULULPF2MCULPF2 *":
        """__deref__(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer self) -> itkCellInterfaceUSCTI2FFULULULPF2MCULPF2"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer___deref__(self)


    def Reset(self) -> "void":
        """Reset(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer self)"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_Reset(self)


    def TakeOwnership(self, *args) -> "void":
        """
        TakeOwnership(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer self)
        TakeOwnership(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2 objectptr)
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_TakeOwnership(self, *args)


    def TakeNoOwnership(self, objectptr: 'itkCellInterfaceUSCTI2FFULULULPF2MCULPF2') -> "void":
        """TakeNoOwnership(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2 objectptr)"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_TakeNoOwnership(self, objectptr)


    def IsOwner(self) -> "bool":
        """IsOwner(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer self) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_IsOwner(self)


    def ReleaseOwnership(self) -> "itkCellInterfaceUSCTI2FFULULULPF2MCULPF2 *":
        """ReleaseOwnership(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer self) -> itkCellInterfaceUSCTI2FFULULULPF2MCULPF2"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_ReleaseOwnership(self)


    def GetPointer(self) -> "itkCellInterfaceUSCTI2FFULULULPF2MCULPF2 *":
        """GetPointer(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer self) -> itkCellInterfaceUSCTI2FFULULULPF2MCULPF2"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_GetPointer(self)


    def __eq__(self, r: 'itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """__eq__(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer___eq__(self, r)


    def __ne__(self, r: 'itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """__ne__(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer___ne__(self, r)


    def __lt__(self, r: 'itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """__lt__(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer___lt__(self, r)


    def __gt__(self, r: 'itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """__gt__(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer___gt__(self, r)


    def __le__(self, r: 'itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """__le__(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer___le__(self, r)


    def __ge__(self, r: 'itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """__ge__(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer___ge__(self, r)


    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceUSCTI2FFULULULPF2MCULPF2::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer self, unsigned long cellId, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCommonEnums::CellGeometry":
        """
        GetType(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer self) -> itkCommonEnums::CellGeometry

        Return the type of the cell
        (one of the CellGeometryEnum enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer self, int dimension, unsigned long arg1, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer self, unsigned long const * first)
        SetPointIds(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer self) -> unsigned long
        PointIdsBegin(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer self) -> unsigned long
        PointIdsEnd(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'float *', arg1: 'bool *', arg2: 'itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer self, float * arg0, bool * arg1, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not nullptr, the flag is set to indicate whether the point is inside
        the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'float *', arg1: 'itkMapContainerULPF2', arg2: 'float *', arg3: 'float *', arg4: 'double *', arg5: 'float *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer self, float * arg0, itkMapContainerULPF2 arg1, float * arg2, float * arg3, double * arg4, float * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not nullptr:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayF', arg1: 'itkArrayF') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer self, itkArrayF arg0, itkArrayF arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float', arg3: 'float *', arg4: 'float *', arg5: 'float *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer self, float * arg0, float * arg1, float arg2, float * arg3, float * arg4, float * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'float *') -> "float *":
        """
        GetBoundingBox(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer self, float * arg0) -> float *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "float":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer self) -> float

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float *', arg3: 'float *', arg4: 'float *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer self, float * arg0, float * arg1, float * arg2, float * arg3, float * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_GetNameOfClass(self)

itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer.__deref__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer___deref__, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer.Reset = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_Reset, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer.TakeOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_TakeOwnership, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer.TakeNoOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_TakeNoOwnership, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer.IsOwner = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_IsOwner, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer.ReleaseOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_ReleaseOwnership, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer.GetPointer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_GetPointer, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer.__eq__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer___eq__, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer.__ne__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer___ne__, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer.__lt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer___lt__, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer.__gt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer___gt__, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer.__le__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer___le__, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer.__ge__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer___ge__, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_Accept, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_GetType, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_MakeCopy, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_GetDimension, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_GetInterpolationOrder, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_GetNumberOfPoints, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_GetNumberOfBoundaryFeatures, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_GetBoundaryFeature, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_GetPointIds, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_SetPointIds, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_SetPointId, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_PointIdsBegin, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_PointIdsEnd, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_GetPointIdsContainer, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_SetPointIdsContainer, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_GetClosestBoundary, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_EvaluatePosition, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_EvaluateShapeFunctions, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_IntersectWithLine, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_GetBoundingBox, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_IntersectBoundingBoxWithLine, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_IsExplicitBoundary, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_AddUsingCell, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_RemoveUsingCell, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_IsUsingCell, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_GetNumberOfUsingCells, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_GetNameOfClass, None, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_swigregister = _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_swigregister
itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer_swigregister(itkCellInterfaceUSCTI2FFULULULPF2MCULPF2_AutoPointer)

class itkCellInterfaceUSCTI2FFULULULPF2VCULPF2(object):
    """


    An abstract interface for cells.

    Define an abstract interface for cells. Actual cell types derive from
    this class.

    Parameters:
    -----------

    TPixelType:  The type stored with an entity (cell, point, or
    boundary).

    TCellTraits:  Type information for cell.

    C++ includes: itkCellInterface.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceUSCTI2FFULULULPF2VCULPF2::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2 self, unsigned long cellId, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCommonEnums::CellGeometry":
        """
        GetType(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2 self) -> itkCommonEnums::CellGeometry

        Return the type of the cell
        (one of the CellGeometryEnum enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2 self, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2 self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2 self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2 self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2 self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2 self, int dimension, unsigned long arg1, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2 self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2 self, unsigned long const * first)
        SetPointIds(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2 self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2 self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2 self) -> unsigned long
        PointIdsBegin(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2 self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2 self) -> unsigned long
        PointIdsEnd(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2 self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2 self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2 self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'float *', arg1: 'bool *', arg2: 'itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2 self, float * arg0, bool * arg1, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not nullptr, the flag is set to indicate whether the point is inside
        the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'float *', arg1: 'itkVectorContainerULPF2', arg2: 'float *', arg3: 'float *', arg4: 'double *', arg5: 'float *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2 self, float * arg0, itkVectorContainerULPF2 arg1, float * arg2, float * arg3, double * arg4, float * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not nullptr:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayF', arg1: 'itkArrayF') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2 self, itkArrayF arg0, itkArrayF arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float', arg3: 'float *', arg4: 'float *', arg5: 'float *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2 self, float * arg0, float * arg1, float arg2, float * arg3, float * arg4, float * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'float *') -> "float *":
        """
        GetBoundingBox(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2 self, float * arg0) -> float *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "float":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2 self) -> float

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float *', arg3: 'float *', arg4: 'float *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2 self, float * arg0, float * arg1, float * arg2, float * arg3, float * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2 self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2 self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2 self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2 self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2 self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2 self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_GetNameOfClass(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceUSCTI2FFULULULPF2VCULPF2
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_Accept, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_GetType, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_MakeCopy, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_GetDimension, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_GetInterpolationOrder, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_GetNumberOfPoints, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_GetNumberOfBoundaryFeatures, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_GetBoundaryFeature, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_GetPointIds, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_SetPointIds, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_SetPointId, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_PointIdsBegin, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_PointIdsEnd, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_GetPointIdsContainer, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_SetPointIdsContainer, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_GetClosestBoundary, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_EvaluatePosition, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_EvaluateShapeFunctions, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_IntersectWithLine, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_GetBoundingBox, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_IntersectBoundingBoxWithLine, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_IsExplicitBoundary, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AddUsingCell, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_RemoveUsingCell, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_IsUsingCell, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_GetNumberOfUsingCells, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_GetNameOfClass, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_swigregister = _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_swigregister
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_swigregister(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2)

class itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer(object):
    """Proxy of C++ itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer self) -> itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer
        __init__(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer p) -> itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer
        __init__(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2 p, bool takeOwnership) -> itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer
        """
        _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_swiginit(self, _itkMeshBasePython.new_itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer(*args))
    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer

    def __deref__(self) -> "itkCellInterfaceUSCTI2FFULULULPF2VCULPF2 *":
        """__deref__(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer self) -> itkCellInterfaceUSCTI2FFULULULPF2VCULPF2"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer___deref__(self)


    def Reset(self) -> "void":
        """Reset(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer self)"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_Reset(self)


    def TakeOwnership(self, *args) -> "void":
        """
        TakeOwnership(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer self)
        TakeOwnership(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2 objectptr)
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_TakeOwnership(self, *args)


    def TakeNoOwnership(self, objectptr: 'itkCellInterfaceUSCTI2FFULULULPF2VCULPF2') -> "void":
        """TakeNoOwnership(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2 objectptr)"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_TakeNoOwnership(self, objectptr)


    def IsOwner(self) -> "bool":
        """IsOwner(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer self) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_IsOwner(self)


    def ReleaseOwnership(self) -> "itkCellInterfaceUSCTI2FFULULULPF2VCULPF2 *":
        """ReleaseOwnership(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer self) -> itkCellInterfaceUSCTI2FFULULULPF2VCULPF2"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_ReleaseOwnership(self)


    def GetPointer(self) -> "itkCellInterfaceUSCTI2FFULULULPF2VCULPF2 *":
        """GetPointer(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer self) -> itkCellInterfaceUSCTI2FFULULULPF2VCULPF2"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_GetPointer(self)


    def __eq__(self, r: 'itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """__eq__(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer___eq__(self, r)


    def __ne__(self, r: 'itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """__ne__(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer___ne__(self, r)


    def __lt__(self, r: 'itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """__lt__(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer___lt__(self, r)


    def __gt__(self, r: 'itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """__gt__(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer___gt__(self, r)


    def __le__(self, r: 'itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """__le__(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer___le__(self, r)


    def __ge__(self, r: 'itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """__ge__(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer___ge__(self, r)


    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceUSCTI2FFULULULPF2VCULPF2::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer self, unsigned long cellId, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCommonEnums::CellGeometry":
        """
        GetType(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer self) -> itkCommonEnums::CellGeometry

        Return the type of the cell
        (one of the CellGeometryEnum enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer self, int dimension, unsigned long arg1, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer self, unsigned long const * first)
        SetPointIds(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer self) -> unsigned long
        PointIdsBegin(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer self) -> unsigned long
        PointIdsEnd(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'float *', arg1: 'bool *', arg2: 'itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer self, float * arg0, bool * arg1, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not nullptr, the flag is set to indicate whether the point is inside
        the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'float *', arg1: 'itkVectorContainerULPF2', arg2: 'float *', arg3: 'float *', arg4: 'double *', arg5: 'float *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer self, float * arg0, itkVectorContainerULPF2 arg1, float * arg2, float * arg3, double * arg4, float * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not nullptr:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayF', arg1: 'itkArrayF') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer self, itkArrayF arg0, itkArrayF arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float', arg3: 'float *', arg4: 'float *', arg5: 'float *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer self, float * arg0, float * arg1, float arg2, float * arg3, float * arg4, float * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'float *') -> "float *":
        """
        GetBoundingBox(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer self, float * arg0) -> float *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "float":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer self) -> float

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float *', arg3: 'float *', arg4: 'float *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer self, float * arg0, float * arg1, float * arg2, float * arg3, float * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_GetNameOfClass(self)

itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer.__deref__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer___deref__, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer.Reset = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_Reset, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer.TakeOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_TakeOwnership, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer.TakeNoOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_TakeNoOwnership, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer.IsOwner = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_IsOwner, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer.ReleaseOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_ReleaseOwnership, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer.GetPointer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_GetPointer, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer.__eq__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer___eq__, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer.__ne__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer___ne__, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer.__lt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer___lt__, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer.__gt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer___gt__, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer.__le__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer___le__, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer.__ge__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer___ge__, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_Accept, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_GetType, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_MakeCopy, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_GetDimension, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_GetInterpolationOrder, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_GetNumberOfPoints, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_GetNumberOfBoundaryFeatures, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_GetBoundaryFeature, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_GetPointIds, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_SetPointIds, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_SetPointId, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_PointIdsBegin, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_PointIdsEnd, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_GetPointIdsContainer, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_SetPointIdsContainer, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_GetClosestBoundary, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_EvaluatePosition, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_EvaluateShapeFunctions, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_IntersectWithLine, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_GetBoundingBox, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_IntersectBoundingBoxWithLine, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_IsExplicitBoundary, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_AddUsingCell, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_RemoveUsingCell, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_IsUsingCell, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_GetNumberOfUsingCells, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_GetNameOfClass, None, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_swigregister = _itkMeshBasePython.itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_swigregister
itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer_swigregister(itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer)

class itkCellInterfaceUSCTI3FFULULULPF3MCULPF3(object):
    """


    An abstract interface for cells.

    Define an abstract interface for cells. Actual cell types derive from
    this class.

    Parameters:
    -----------

    TPixelType:  The type stored with an entity (cell, point, or
    boundary).

    TCellTraits:  Type information for cell.

    C++ includes: itkCellInterface.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceUSCTI3FFULULULPF3MCULPF3::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3 self, unsigned long cellId, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCommonEnums::CellGeometry":
        """
        GetType(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3 self) -> itkCommonEnums::CellGeometry

        Return the type of the cell
        (one of the CellGeometryEnum enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3 self, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3 self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3 self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3 self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3 self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3 self, int dimension, unsigned long arg1, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3 self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3 self, unsigned long const * first)
        SetPointIds(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3 self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3 self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3 self) -> unsigned long
        PointIdsBegin(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3 self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3 self) -> unsigned long
        PointIdsEnd(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3 self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3 self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3 self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'float *', arg1: 'bool *', arg2: 'itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3 self, float * arg0, bool * arg1, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not nullptr, the flag is set to indicate whether the point is inside
        the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'float *', arg1: 'itkMapContainerULPF3', arg2: 'float *', arg3: 'float *', arg4: 'double *', arg5: 'float *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3 self, float * arg0, itkMapContainerULPF3 arg1, float * arg2, float * arg3, double * arg4, float * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not nullptr:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayF', arg1: 'itkArrayF') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3 self, itkArrayF arg0, itkArrayF arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float', arg3: 'float *', arg4: 'float *', arg5: 'float *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3 self, float * arg0, float * arg1, float arg2, float * arg3, float * arg4, float * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'float *') -> "float *":
        """
        GetBoundingBox(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3 self, float * arg0) -> float *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "float":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3 self) -> float

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float *', arg3: 'float *', arg4: 'float *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3 self, float * arg0, float * arg1, float * arg2, float * arg3, float * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3 self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3 self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3 self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3 self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3 self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3 self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_GetNameOfClass(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceUSCTI3FFULULULPF3MCULPF3
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_Accept, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_GetType, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_MakeCopy, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_GetDimension, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_GetInterpolationOrder, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_GetNumberOfPoints, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_GetNumberOfBoundaryFeatures, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_GetBoundaryFeature, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_GetPointIds, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_SetPointIds, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_SetPointId, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_PointIdsBegin, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_PointIdsEnd, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_GetPointIdsContainer, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_SetPointIdsContainer, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_GetClosestBoundary, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_EvaluatePosition, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_EvaluateShapeFunctions, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_IntersectWithLine, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_GetBoundingBox, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_IntersectBoundingBoxWithLine, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_IsExplicitBoundary, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AddUsingCell, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_RemoveUsingCell, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_IsUsingCell, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_GetNumberOfUsingCells, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_GetNameOfClass, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_swigregister = _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_swigregister
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_swigregister(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3)

class itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer(object):
    """Proxy of C++ itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer self) -> itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer
        __init__(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer p) -> itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer
        __init__(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3 p, bool takeOwnership) -> itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer
        """
        _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_swiginit(self, _itkMeshBasePython.new_itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer(*args))
    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer

    def __deref__(self) -> "itkCellInterfaceUSCTI3FFULULULPF3MCULPF3 *":
        """__deref__(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer self) -> itkCellInterfaceUSCTI3FFULULULPF3MCULPF3"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer___deref__(self)


    def Reset(self) -> "void":
        """Reset(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer self)"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_Reset(self)


    def TakeOwnership(self, *args) -> "void":
        """
        TakeOwnership(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer self)
        TakeOwnership(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3 objectptr)
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_TakeOwnership(self, *args)


    def TakeNoOwnership(self, objectptr: 'itkCellInterfaceUSCTI3FFULULULPF3MCULPF3') -> "void":
        """TakeNoOwnership(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3 objectptr)"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_TakeNoOwnership(self, objectptr)


    def IsOwner(self) -> "bool":
        """IsOwner(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer self) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_IsOwner(self)


    def ReleaseOwnership(self) -> "itkCellInterfaceUSCTI3FFULULULPF3MCULPF3 *":
        """ReleaseOwnership(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer self) -> itkCellInterfaceUSCTI3FFULULULPF3MCULPF3"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_ReleaseOwnership(self)


    def GetPointer(self) -> "itkCellInterfaceUSCTI3FFULULULPF3MCULPF3 *":
        """GetPointer(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer self) -> itkCellInterfaceUSCTI3FFULULULPF3MCULPF3"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_GetPointer(self)


    def __eq__(self, r: 'itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """__eq__(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer___eq__(self, r)


    def __ne__(self, r: 'itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """__ne__(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer___ne__(self, r)


    def __lt__(self, r: 'itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """__lt__(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer___lt__(self, r)


    def __gt__(self, r: 'itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """__gt__(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer___gt__(self, r)


    def __le__(self, r: 'itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """__le__(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer___le__(self, r)


    def __ge__(self, r: 'itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """__ge__(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer___ge__(self, r)


    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceUSCTI3FFULULULPF3MCULPF3::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer self, unsigned long cellId, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCommonEnums::CellGeometry":
        """
        GetType(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer self) -> itkCommonEnums::CellGeometry

        Return the type of the cell
        (one of the CellGeometryEnum enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer self, int dimension, unsigned long arg1, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer self, unsigned long const * first)
        SetPointIds(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer self) -> unsigned long
        PointIdsBegin(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer self) -> unsigned long
        PointIdsEnd(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'float *', arg1: 'bool *', arg2: 'itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer self, float * arg0, bool * arg1, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not nullptr, the flag is set to indicate whether the point is inside
        the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'float *', arg1: 'itkMapContainerULPF3', arg2: 'float *', arg3: 'float *', arg4: 'double *', arg5: 'float *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer self, float * arg0, itkMapContainerULPF3 arg1, float * arg2, float * arg3, double * arg4, float * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not nullptr:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayF', arg1: 'itkArrayF') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer self, itkArrayF arg0, itkArrayF arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float', arg3: 'float *', arg4: 'float *', arg5: 'float *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer self, float * arg0, float * arg1, float arg2, float * arg3, float * arg4, float * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'float *') -> "float *":
        """
        GetBoundingBox(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer self, float * arg0) -> float *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "float":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer self) -> float

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float *', arg3: 'float *', arg4: 'float *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer self, float * arg0, float * arg1, float * arg2, float * arg3, float * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_GetNameOfClass(self)

itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer.__deref__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer___deref__, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer.Reset = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_Reset, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer.TakeOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_TakeOwnership, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer.TakeNoOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_TakeNoOwnership, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer.IsOwner = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_IsOwner, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer.ReleaseOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_ReleaseOwnership, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer.GetPointer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_GetPointer, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer.__eq__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer___eq__, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer.__ne__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer___ne__, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer.__lt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer___lt__, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer.__gt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer___gt__, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer.__le__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer___le__, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer.__ge__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer___ge__, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_Accept, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_GetType, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_MakeCopy, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_GetDimension, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_GetInterpolationOrder, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_GetNumberOfPoints, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_GetNumberOfBoundaryFeatures, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_GetBoundaryFeature, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_GetPointIds, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_SetPointIds, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_SetPointId, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_PointIdsBegin, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_PointIdsEnd, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_GetPointIdsContainer, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_SetPointIdsContainer, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_GetClosestBoundary, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_EvaluatePosition, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_EvaluateShapeFunctions, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_IntersectWithLine, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_GetBoundingBox, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_IntersectBoundingBoxWithLine, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_IsExplicitBoundary, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_AddUsingCell, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_RemoveUsingCell, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_IsUsingCell, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_GetNumberOfUsingCells, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_GetNameOfClass, None, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_swigregister = _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_swigregister
itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer_swigregister(itkCellInterfaceUSCTI3FFULULULPF3MCULPF3_AutoPointer)

class itkCellInterfaceUSCTI3FFULULULPF3VCULPF3(object):
    """


    An abstract interface for cells.

    Define an abstract interface for cells. Actual cell types derive from
    this class.

    Parameters:
    -----------

    TPixelType:  The type stored with an entity (cell, point, or
    boundary).

    TCellTraits:  Type information for cell.

    C++ includes: itkCellInterface.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceUSCTI3FFULULULPF3VCULPF3::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3 self, unsigned long cellId, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCommonEnums::CellGeometry":
        """
        GetType(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3 self) -> itkCommonEnums::CellGeometry

        Return the type of the cell
        (one of the CellGeometryEnum enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3 self, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3 self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3 self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3 self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3 self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3 self, int dimension, unsigned long arg1, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3 self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3 self, unsigned long const * first)
        SetPointIds(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3 self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3 self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3 self) -> unsigned long
        PointIdsBegin(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3 self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3 self) -> unsigned long
        PointIdsEnd(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3 self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3 self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3 self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'float *', arg1: 'bool *', arg2: 'itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3 self, float * arg0, bool * arg1, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not nullptr, the flag is set to indicate whether the point is inside
        the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'float *', arg1: 'itkVectorContainerULPF3', arg2: 'float *', arg3: 'float *', arg4: 'double *', arg5: 'float *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3 self, float * arg0, itkVectorContainerULPF3 arg1, float * arg2, float * arg3, double * arg4, float * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not nullptr:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayF', arg1: 'itkArrayF') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3 self, itkArrayF arg0, itkArrayF arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float', arg3: 'float *', arg4: 'float *', arg5: 'float *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3 self, float * arg0, float * arg1, float arg2, float * arg3, float * arg4, float * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'float *') -> "float *":
        """
        GetBoundingBox(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3 self, float * arg0) -> float *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "float":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3 self) -> float

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float *', arg3: 'float *', arg4: 'float *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3 self, float * arg0, float * arg1, float * arg2, float * arg3, float * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3 self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3 self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3 self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3 self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3 self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3 self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_GetNameOfClass(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceUSCTI3FFULULULPF3VCULPF3
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_Accept, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_GetType, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_MakeCopy, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_GetDimension, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_GetInterpolationOrder, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_GetNumberOfPoints, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_GetNumberOfBoundaryFeatures, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_GetBoundaryFeature, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_GetPointIds, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_SetPointIds, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_SetPointId, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_PointIdsBegin, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_PointIdsEnd, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_GetPointIdsContainer, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_SetPointIdsContainer, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_GetClosestBoundary, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_EvaluatePosition, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_EvaluateShapeFunctions, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_IntersectWithLine, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_GetBoundingBox, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_IntersectBoundingBoxWithLine, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_IsExplicitBoundary, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AddUsingCell, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_RemoveUsingCell, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_IsUsingCell, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_GetNumberOfUsingCells, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_GetNameOfClass, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_swigregister = _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_swigregister
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_swigregister(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3)

class itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer(object):
    """Proxy of C++ itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer self) -> itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer
        __init__(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer p) -> itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer
        __init__(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3 p, bool takeOwnership) -> itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer
        """
        _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_swiginit(self, _itkMeshBasePython.new_itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer(*args))
    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer

    def __deref__(self) -> "itkCellInterfaceUSCTI3FFULULULPF3VCULPF3 *":
        """__deref__(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer self) -> itkCellInterfaceUSCTI3FFULULULPF3VCULPF3"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer___deref__(self)


    def Reset(self) -> "void":
        """Reset(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer self)"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_Reset(self)


    def TakeOwnership(self, *args) -> "void":
        """
        TakeOwnership(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer self)
        TakeOwnership(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3 objectptr)
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_TakeOwnership(self, *args)


    def TakeNoOwnership(self, objectptr: 'itkCellInterfaceUSCTI3FFULULULPF3VCULPF3') -> "void":
        """TakeNoOwnership(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3 objectptr)"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_TakeNoOwnership(self, objectptr)


    def IsOwner(self) -> "bool":
        """IsOwner(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer self) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_IsOwner(self)


    def ReleaseOwnership(self) -> "itkCellInterfaceUSCTI3FFULULULPF3VCULPF3 *":
        """ReleaseOwnership(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer self) -> itkCellInterfaceUSCTI3FFULULULPF3VCULPF3"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_ReleaseOwnership(self)


    def GetPointer(self) -> "itkCellInterfaceUSCTI3FFULULULPF3VCULPF3 *":
        """GetPointer(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer self) -> itkCellInterfaceUSCTI3FFULULULPF3VCULPF3"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_GetPointer(self)


    def __eq__(self, r: 'itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """__eq__(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer___eq__(self, r)


    def __ne__(self, r: 'itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """__ne__(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer___ne__(self, r)


    def __lt__(self, r: 'itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """__lt__(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer___lt__(self, r)


    def __gt__(self, r: 'itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """__gt__(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer___gt__(self, r)


    def __le__(self, r: 'itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """__le__(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer___le__(self, r)


    def __ge__(self, r: 'itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """__ge__(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer___ge__(self, r)


    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceUSCTI3FFULULULPF3VCULPF3::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer self, unsigned long cellId, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCommonEnums::CellGeometry":
        """
        GetType(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer self) -> itkCommonEnums::CellGeometry

        Return the type of the cell
        (one of the CellGeometryEnum enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer self, int dimension, unsigned long arg1, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer self, unsigned long const * first)
        SetPointIds(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer self) -> unsigned long
        PointIdsBegin(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer self) -> unsigned long
        PointIdsEnd(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'float *', arg1: 'bool *', arg2: 'itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer self, float * arg0, bool * arg1, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not nullptr, the flag is set to indicate whether the point is inside
        the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'float *', arg1: 'itkVectorContainerULPF3', arg2: 'float *', arg3: 'float *', arg4: 'double *', arg5: 'float *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer self, float * arg0, itkVectorContainerULPF3 arg1, float * arg2, float * arg3, double * arg4, float * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not nullptr:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayF', arg1: 'itkArrayF') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer self, itkArrayF arg0, itkArrayF arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float', arg3: 'float *', arg4: 'float *', arg5: 'float *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer self, float * arg0, float * arg1, float arg2, float * arg3, float * arg4, float * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'float *') -> "float *":
        """
        GetBoundingBox(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer self, float * arg0) -> float *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "float":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer self) -> float

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float *', arg3: 'float *', arg4: 'float *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer self, float * arg0, float * arg1, float * arg2, float * arg3, float * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not nullptr:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_GetNameOfClass(self)

itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer.__deref__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer___deref__, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer.Reset = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_Reset, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer.TakeOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_TakeOwnership, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer.TakeNoOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_TakeNoOwnership, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer.IsOwner = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_IsOwner, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer.ReleaseOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_ReleaseOwnership, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer.GetPointer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_GetPointer, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer.__eq__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer___eq__, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer.__ne__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer___ne__, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer.__lt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer___lt__, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer.__gt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer___gt__, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer.__le__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer___le__, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer.__ge__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer___ge__, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_Accept, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_GetType, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_MakeCopy, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_GetDimension, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_GetInterpolationOrder, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_GetNumberOfPoints, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_GetNumberOfBoundaryFeatures, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_GetBoundaryFeature, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_GetPointIds, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_SetPointIds, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_SetPointId, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_PointIdsBegin, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_PointIdsEnd, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_GetPointIdsContainer, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_SetPointIdsContainer, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_GetClosestBoundary, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_EvaluatePosition, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_EvaluateShapeFunctions, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_IntersectWithLine, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_GetBoundingBox, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_IntersectBoundingBoxWithLine, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_IsExplicitBoundary, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_AddUsingCell, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_RemoveUsingCell, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_IsUsingCell, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_GetNumberOfUsingCells, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_GetNameOfClass, None, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_swigregister = _itkMeshBasePython.itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_swigregister
itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer_swigregister(itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer)

class itkCellInterfaceVisitorDCTI2FFULULULPF2MCULPF2(ITKCommonBasePython.itkLightObject):
    """


    Abstract interface for a visitor class that can visit the cells in a
    Mesh.

    Define the abstract interface for a visitor class that can visit the
    cells in a Mesh. This follows the Visitor Design Pattern. To make this
    class easier to use, the CellInterfaceVisitorImplementation is
    provided as a templated class to implement the pure virtual functions
    of CellInterfaceVisitor.

    C++ includes: itkCellInterfaceVisitor.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def VisitFromCell(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceDCTI2FFULULULPF2MCULPF2') -> "void":
        """
        VisitFromCell(itkCellInterfaceVisitorDCTI2FFULULULPF2MCULPF2 self, unsigned long cellId, itkCellInterfaceDCTI2FFULULULPF2MCULPF2 arg1)

        This method is called
        by each cell as it visits this visitor. 
        """
        return _itkMeshBasePython.itkCellInterfaceVisitorDCTI2FFULULULPF2MCULPF2_VisitFromCell(self, cellId, arg1)


    def GetCellTopologyId(self) -> "itkCommonEnums::CellGeometry":
        """
        GetCellTopologyId(itkCellInterfaceVisitorDCTI2FFULULULPF2MCULPF2 self) -> itkCommonEnums::CellGeometry

        Return the index
        of the CellTopology. 
        """
        return _itkMeshBasePython.itkCellInterfaceVisitorDCTI2FFULULULPF2MCULPF2_GetCellTopologyId(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceVisitorDCTI2FFULULULPF2MCULPF2

    def cast(obj: 'itkLightObject') -> "itkCellInterfaceVisitorDCTI2FFULULULPF2MCULPF2 *":
        """cast(itkLightObject obj) -> itkCellInterfaceVisitorDCTI2FFULULULPF2MCULPF2"""
        return _itkMeshBasePython.itkCellInterfaceVisitorDCTI2FFULULULPF2MCULPF2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkCellInterfaceVisitorDCTI2FFULULULPF2MCULPF2

        Create a new object of the class itkCellInterfaceVisitorDCTI2FFULULULPF2MCULPF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkCellInterfaceVisitorDCTI2FFULULULPF2MCULPF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkCellInterfaceVisitorDCTI2FFULULULPF2MCULPF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkCellInterfaceVisitorDCTI2FFULULULPF2MCULPF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkCellInterfaceVisitorDCTI2FFULULULPF2MCULPF2.VisitFromCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceVisitorDCTI2FFULULULPF2MCULPF2_VisitFromCell, None, itkCellInterfaceVisitorDCTI2FFULULULPF2MCULPF2)
itkCellInterfaceVisitorDCTI2FFULULULPF2MCULPF2.GetCellTopologyId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceVisitorDCTI2FFULULULPF2MCULPF2_GetCellTopologyId, None, itkCellInterfaceVisitorDCTI2FFULULULPF2MCULPF2)
itkCellInterfaceVisitorDCTI2FFULULULPF2MCULPF2_swigregister = _itkMeshBasePython.itkCellInterfaceVisitorDCTI2FFULULULPF2MCULPF2_swigregister
itkCellInterfaceVisitorDCTI2FFULULULPF2MCULPF2_swigregister(itkCellInterfaceVisitorDCTI2FFULULULPF2MCULPF2)

def itkCellInterfaceVisitorDCTI2FFULULULPF2MCULPF2_cast(obj: 'itkLightObject') -> "itkCellInterfaceVisitorDCTI2FFULULULPF2MCULPF2 *":
    """itkCellInterfaceVisitorDCTI2FFULULULPF2MCULPF2_cast(itkLightObject obj) -> itkCellInterfaceVisitorDCTI2FFULULULPF2MCULPF2"""
    return _itkMeshBasePython.itkCellInterfaceVisitorDCTI2FFULULULPF2MCULPF2_cast(obj)

class itkCellInterfaceVisitorDCTI3FFULULULPF3MCULPF3(ITKCommonBasePython.itkLightObject):
    """


    Abstract interface for a visitor class that can visit the cells in a
    Mesh.

    Define the abstract interface for a visitor class that can visit the
    cells in a Mesh. This follows the Visitor Design Pattern. To make this
    class easier to use, the CellInterfaceVisitorImplementation is
    provided as a templated class to implement the pure virtual functions
    of CellInterfaceVisitor.

    C++ includes: itkCellInterfaceVisitor.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def VisitFromCell(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceDCTI3FFULULULPF3MCULPF3') -> "void":
        """
        VisitFromCell(itkCellInterfaceVisitorDCTI3FFULULULPF3MCULPF3 self, unsigned long cellId, itkCellInterfaceDCTI3FFULULULPF3MCULPF3 arg1)

        This method is called
        by each cell as it visits this visitor. 
        """
        return _itkMeshBasePython.itkCellInterfaceVisitorDCTI3FFULULULPF3MCULPF3_VisitFromCell(self, cellId, arg1)


    def GetCellTopologyId(self) -> "itkCommonEnums::CellGeometry":
        """
        GetCellTopologyId(itkCellInterfaceVisitorDCTI3FFULULULPF3MCULPF3 self) -> itkCommonEnums::CellGeometry

        Return the index
        of the CellTopology. 
        """
        return _itkMeshBasePython.itkCellInterfaceVisitorDCTI3FFULULULPF3MCULPF3_GetCellTopologyId(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceVisitorDCTI3FFULULULPF3MCULPF3

    def cast(obj: 'itkLightObject') -> "itkCellInterfaceVisitorDCTI3FFULULULPF3MCULPF3 *":
        """cast(itkLightObject obj) -> itkCellInterfaceVisitorDCTI3FFULULULPF3MCULPF3"""
        return _itkMeshBasePython.itkCellInterfaceVisitorDCTI3FFULULULPF3MCULPF3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkCellInterfaceVisitorDCTI3FFULULULPF3MCULPF3

        Create a new object of the class itkCellInterfaceVisitorDCTI3FFULULULPF3MCULPF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkCellInterfaceVisitorDCTI3FFULULULPF3MCULPF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkCellInterfaceVisitorDCTI3FFULULULPF3MCULPF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkCellInterfaceVisitorDCTI3FFULULULPF3MCULPF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkCellInterfaceVisitorDCTI3FFULULULPF3MCULPF3.VisitFromCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceVisitorDCTI3FFULULULPF3MCULPF3_VisitFromCell, None, itkCellInterfaceVisitorDCTI3FFULULULPF3MCULPF3)
itkCellInterfaceVisitorDCTI3FFULULULPF3MCULPF3.GetCellTopologyId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceVisitorDCTI3FFULULULPF3MCULPF3_GetCellTopologyId, None, itkCellInterfaceVisitorDCTI3FFULULULPF3MCULPF3)
itkCellInterfaceVisitorDCTI3FFULULULPF3MCULPF3_swigregister = _itkMeshBasePython.itkCellInterfaceVisitorDCTI3FFULULULPF3MCULPF3_swigregister
itkCellInterfaceVisitorDCTI3FFULULULPF3MCULPF3_swigregister(itkCellInterfaceVisitorDCTI3FFULULULPF3MCULPF3)

def itkCellInterfaceVisitorDCTI3FFULULULPF3MCULPF3_cast(obj: 'itkLightObject') -> "itkCellInterfaceVisitorDCTI3FFULULULPF3MCULPF3 *":
    """itkCellInterfaceVisitorDCTI3FFULULULPF3MCULPF3_cast(itkLightObject obj) -> itkCellInterfaceVisitorDCTI3FFULULULPF3MCULPF3"""
    return _itkMeshBasePython.itkCellInterfaceVisitorDCTI3FFULULULPF3MCULPF3_cast(obj)

class itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2(ITKCommonBasePython.itkLightObject):
    """


    Abstract interface for a visitor class that can visit the cells in a
    Mesh.

    Define the abstract interface for a visitor class that can visit the
    cells in a Mesh. This follows the Visitor Design Pattern. To make this
    class easier to use, the CellInterfaceVisitorImplementation is
    provided as a templated class to implement the pure virtual functions
    of CellInterfaceVisitor.

    C++ includes: itkCellInterfaceVisitor.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def VisitFromCell(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceFCTI2FFULULULPF2MCULPF2') -> "void":
        """
        VisitFromCell(itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2 self, unsigned long cellId, itkCellInterfaceFCTI2FFULULULPF2MCULPF2 arg1)

        This method is called
        by each cell as it visits this visitor. 
        """
        return _itkMeshBasePython.itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2_VisitFromCell(self, cellId, arg1)


    def GetCellTopologyId(self) -> "itkCommonEnums::CellGeometry":
        """
        GetCellTopologyId(itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2 self) -> itkCommonEnums::CellGeometry

        Return the index
        of the CellTopology. 
        """
        return _itkMeshBasePython.itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2_GetCellTopologyId(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2

    def cast(obj: 'itkLightObject') -> "itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2 *":
        """cast(itkLightObject obj) -> itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2"""
        return _itkMeshBasePython.itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2

        Create a new object of the class itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2.VisitFromCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2_VisitFromCell, None, itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2)
itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2.GetCellTopologyId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2_GetCellTopologyId, None, itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2)
itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2_swigregister = _itkMeshBasePython.itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2_swigregister
itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2_swigregister(itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2)

def itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2_cast(obj: 'itkLightObject') -> "itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2 *":
    """itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2_cast(itkLightObject obj) -> itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2"""
    return _itkMeshBasePython.itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2_cast(obj)

class itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3(ITKCommonBasePython.itkLightObject):
    """


    Abstract interface for a visitor class that can visit the cells in a
    Mesh.

    Define the abstract interface for a visitor class that can visit the
    cells in a Mesh. This follows the Visitor Design Pattern. To make this
    class easier to use, the CellInterfaceVisitorImplementation is
    provided as a templated class to implement the pure virtual functions
    of CellInterfaceVisitor.

    C++ includes: itkCellInterfaceVisitor.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def VisitFromCell(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceFCTI3FFULULULPF3MCULPF3') -> "void":
        """
        VisitFromCell(itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3 self, unsigned long cellId, itkCellInterfaceFCTI3FFULULULPF3MCULPF3 arg1)

        This method is called
        by each cell as it visits this visitor. 
        """
        return _itkMeshBasePython.itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3_VisitFromCell(self, cellId, arg1)


    def GetCellTopologyId(self) -> "itkCommonEnums::CellGeometry":
        """
        GetCellTopologyId(itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3 self) -> itkCommonEnums::CellGeometry

        Return the index
        of the CellTopology. 
        """
        return _itkMeshBasePython.itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3_GetCellTopologyId(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3

    def cast(obj: 'itkLightObject') -> "itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3 *":
        """cast(itkLightObject obj) -> itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3"""
        return _itkMeshBasePython.itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3

        Create a new object of the class itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3.VisitFromCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3_VisitFromCell, None, itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3)
itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3.GetCellTopologyId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3_GetCellTopologyId, None, itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3)
itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3_swigregister = _itkMeshBasePython.itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3_swigregister
itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3_swigregister(itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3)

def itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3_cast(obj: 'itkLightObject') -> "itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3 *":
    """itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3_cast(itkLightObject obj) -> itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3"""
    return _itkMeshBasePython.itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3_cast(obj)

class itkCellInterfaceVisitorSSCTI2FFULULULPF2MCULPF2(ITKCommonBasePython.itkLightObject):
    """


    Abstract interface for a visitor class that can visit the cells in a
    Mesh.

    Define the abstract interface for a visitor class that can visit the
    cells in a Mesh. This follows the Visitor Design Pattern. To make this
    class easier to use, the CellInterfaceVisitorImplementation is
    provided as a templated class to implement the pure virtual functions
    of CellInterfaceVisitor.

    C++ includes: itkCellInterfaceVisitor.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def VisitFromCell(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceSSCTI2FFULULULPF2MCULPF2') -> "void":
        """
        VisitFromCell(itkCellInterfaceVisitorSSCTI2FFULULULPF2MCULPF2 self, unsigned long cellId, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2 arg1)

        This method is called
        by each cell as it visits this visitor. 
        """
        return _itkMeshBasePython.itkCellInterfaceVisitorSSCTI2FFULULULPF2MCULPF2_VisitFromCell(self, cellId, arg1)


    def GetCellTopologyId(self) -> "itkCommonEnums::CellGeometry":
        """
        GetCellTopologyId(itkCellInterfaceVisitorSSCTI2FFULULULPF2MCULPF2 self) -> itkCommonEnums::CellGeometry

        Return the index
        of the CellTopology. 
        """
        return _itkMeshBasePython.itkCellInterfaceVisitorSSCTI2FFULULULPF2MCULPF2_GetCellTopologyId(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceVisitorSSCTI2FFULULULPF2MCULPF2

    def cast(obj: 'itkLightObject') -> "itkCellInterfaceVisitorSSCTI2FFULULULPF2MCULPF2 *":
        """cast(itkLightObject obj) -> itkCellInterfaceVisitorSSCTI2FFULULULPF2MCULPF2"""
        return _itkMeshBasePython.itkCellInterfaceVisitorSSCTI2FFULULULPF2MCULPF2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkCellInterfaceVisitorSSCTI2FFULULULPF2MCULPF2

        Create a new object of the class itkCellInterfaceVisitorSSCTI2FFULULULPF2MCULPF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkCellInterfaceVisitorSSCTI2FFULULULPF2MCULPF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkCellInterfaceVisitorSSCTI2FFULULULPF2MCULPF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkCellInterfaceVisitorSSCTI2FFULULULPF2MCULPF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkCellInterfaceVisitorSSCTI2FFULULULPF2MCULPF2.VisitFromCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceVisitorSSCTI2FFULULULPF2MCULPF2_VisitFromCell, None, itkCellInterfaceVisitorSSCTI2FFULULULPF2MCULPF2)
itkCellInterfaceVisitorSSCTI2FFULULULPF2MCULPF2.GetCellTopologyId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceVisitorSSCTI2FFULULULPF2MCULPF2_GetCellTopologyId, None, itkCellInterfaceVisitorSSCTI2FFULULULPF2MCULPF2)
itkCellInterfaceVisitorSSCTI2FFULULULPF2MCULPF2_swigregister = _itkMeshBasePython.itkCellInterfaceVisitorSSCTI2FFULULULPF2MCULPF2_swigregister
itkCellInterfaceVisitorSSCTI2FFULULULPF2MCULPF2_swigregister(itkCellInterfaceVisitorSSCTI2FFULULULPF2MCULPF2)

def itkCellInterfaceVisitorSSCTI2FFULULULPF2MCULPF2_cast(obj: 'itkLightObject') -> "itkCellInterfaceVisitorSSCTI2FFULULULPF2MCULPF2 *":
    """itkCellInterfaceVisitorSSCTI2FFULULULPF2MCULPF2_cast(itkLightObject obj) -> itkCellInterfaceVisitorSSCTI2FFULULULPF2MCULPF2"""
    return _itkMeshBasePython.itkCellInterfaceVisitorSSCTI2FFULULULPF2MCULPF2_cast(obj)

class itkCellInterfaceVisitorSSCTI3FFULULULPF3MCULPF3(ITKCommonBasePython.itkLightObject):
    """


    Abstract interface for a visitor class that can visit the cells in a
    Mesh.

    Define the abstract interface for a visitor class that can visit the
    cells in a Mesh. This follows the Visitor Design Pattern. To make this
    class easier to use, the CellInterfaceVisitorImplementation is
    provided as a templated class to implement the pure virtual functions
    of CellInterfaceVisitor.

    C++ includes: itkCellInterfaceVisitor.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def VisitFromCell(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceSSCTI3FFULULULPF3MCULPF3') -> "void":
        """
        VisitFromCell(itkCellInterfaceVisitorSSCTI3FFULULULPF3MCULPF3 self, unsigned long cellId, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3 arg1)

        This method is called
        by each cell as it visits this visitor. 
        """
        return _itkMeshBasePython.itkCellInterfaceVisitorSSCTI3FFULULULPF3MCULPF3_VisitFromCell(self, cellId, arg1)


    def GetCellTopologyId(self) -> "itkCommonEnums::CellGeometry":
        """
        GetCellTopologyId(itkCellInterfaceVisitorSSCTI3FFULULULPF3MCULPF3 self) -> itkCommonEnums::CellGeometry

        Return the index
        of the CellTopology. 
        """
        return _itkMeshBasePython.itkCellInterfaceVisitorSSCTI3FFULULULPF3MCULPF3_GetCellTopologyId(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceVisitorSSCTI3FFULULULPF3MCULPF3

    def cast(obj: 'itkLightObject') -> "itkCellInterfaceVisitorSSCTI3FFULULULPF3MCULPF3 *":
        """cast(itkLightObject obj) -> itkCellInterfaceVisitorSSCTI3FFULULULPF3MCULPF3"""
        return _itkMeshBasePython.itkCellInterfaceVisitorSSCTI3FFULULULPF3MCULPF3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkCellInterfaceVisitorSSCTI3FFULULULPF3MCULPF3

        Create a new object of the class itkCellInterfaceVisitorSSCTI3FFULULULPF3MCULPF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkCellInterfaceVisitorSSCTI3FFULULULPF3MCULPF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkCellInterfaceVisitorSSCTI3FFULULULPF3MCULPF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkCellInterfaceVisitorSSCTI3FFULULULPF3MCULPF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkCellInterfaceVisitorSSCTI3FFULULULPF3MCULPF3.VisitFromCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceVisitorSSCTI3FFULULULPF3MCULPF3_VisitFromCell, None, itkCellInterfaceVisitorSSCTI3FFULULULPF3MCULPF3)
itkCellInterfaceVisitorSSCTI3FFULULULPF3MCULPF3.GetCellTopologyId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceVisitorSSCTI3FFULULULPF3MCULPF3_GetCellTopologyId, None, itkCellInterfaceVisitorSSCTI3FFULULULPF3MCULPF3)
itkCellInterfaceVisitorSSCTI3FFULULULPF3MCULPF3_swigregister = _itkMeshBasePython.itkCellInterfaceVisitorSSCTI3FFULULULPF3MCULPF3_swigregister
itkCellInterfaceVisitorSSCTI3FFULULULPF3MCULPF3_swigregister(itkCellInterfaceVisitorSSCTI3FFULULULPF3MCULPF3)

def itkCellInterfaceVisitorSSCTI3FFULULULPF3MCULPF3_cast(obj: 'itkLightObject') -> "itkCellInterfaceVisitorSSCTI3FFULULULPF3MCULPF3 *":
    """itkCellInterfaceVisitorSSCTI3FFULULULPF3MCULPF3_cast(itkLightObject obj) -> itkCellInterfaceVisitorSSCTI3FFULULULPF3MCULPF3"""
    return _itkMeshBasePython.itkCellInterfaceVisitorSSCTI3FFULULULPF3MCULPF3_cast(obj)

class itkCellInterfaceVisitorUCCTI2FFULULULPF2MCULPF2(ITKCommonBasePython.itkLightObject):
    """


    Abstract interface for a visitor class that can visit the cells in a
    Mesh.

    Define the abstract interface for a visitor class that can visit the
    cells in a Mesh. This follows the Visitor Design Pattern. To make this
    class easier to use, the CellInterfaceVisitorImplementation is
    provided as a templated class to implement the pure virtual functions
    of CellInterfaceVisitor.

    C++ includes: itkCellInterfaceVisitor.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def VisitFromCell(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceUCCTI2FFULULULPF2MCULPF2') -> "void":
        """
        VisitFromCell(itkCellInterfaceVisitorUCCTI2FFULULULPF2MCULPF2 self, unsigned long cellId, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2 arg1)

        This method is called
        by each cell as it visits this visitor. 
        """
        return _itkMeshBasePython.itkCellInterfaceVisitorUCCTI2FFULULULPF2MCULPF2_VisitFromCell(self, cellId, arg1)


    def GetCellTopologyId(self) -> "itkCommonEnums::CellGeometry":
        """
        GetCellTopologyId(itkCellInterfaceVisitorUCCTI2FFULULULPF2MCULPF2 self) -> itkCommonEnums::CellGeometry

        Return the index
        of the CellTopology. 
        """
        return _itkMeshBasePython.itkCellInterfaceVisitorUCCTI2FFULULULPF2MCULPF2_GetCellTopologyId(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceVisitorUCCTI2FFULULULPF2MCULPF2

    def cast(obj: 'itkLightObject') -> "itkCellInterfaceVisitorUCCTI2FFULULULPF2MCULPF2 *":
        """cast(itkLightObject obj) -> itkCellInterfaceVisitorUCCTI2FFULULULPF2MCULPF2"""
        return _itkMeshBasePython.itkCellInterfaceVisitorUCCTI2FFULULULPF2MCULPF2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkCellInterfaceVisitorUCCTI2FFULULULPF2MCULPF2

        Create a new object of the class itkCellInterfaceVisitorUCCTI2FFULULULPF2MCULPF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkCellInterfaceVisitorUCCTI2FFULULULPF2MCULPF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkCellInterfaceVisitorUCCTI2FFULULULPF2MCULPF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkCellInterfaceVisitorUCCTI2FFULULULPF2MCULPF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkCellInterfaceVisitorUCCTI2FFULULULPF2MCULPF2.VisitFromCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceVisitorUCCTI2FFULULULPF2MCULPF2_VisitFromCell, None, itkCellInterfaceVisitorUCCTI2FFULULULPF2MCULPF2)
itkCellInterfaceVisitorUCCTI2FFULULULPF2MCULPF2.GetCellTopologyId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceVisitorUCCTI2FFULULULPF2MCULPF2_GetCellTopologyId, None, itkCellInterfaceVisitorUCCTI2FFULULULPF2MCULPF2)
itkCellInterfaceVisitorUCCTI2FFULULULPF2MCULPF2_swigregister = _itkMeshBasePython.itkCellInterfaceVisitorUCCTI2FFULULULPF2MCULPF2_swigregister
itkCellInterfaceVisitorUCCTI2FFULULULPF2MCULPF2_swigregister(itkCellInterfaceVisitorUCCTI2FFULULULPF2MCULPF2)

def itkCellInterfaceVisitorUCCTI2FFULULULPF2MCULPF2_cast(obj: 'itkLightObject') -> "itkCellInterfaceVisitorUCCTI2FFULULULPF2MCULPF2 *":
    """itkCellInterfaceVisitorUCCTI2FFULULULPF2MCULPF2_cast(itkLightObject obj) -> itkCellInterfaceVisitorUCCTI2FFULULULPF2MCULPF2"""
    return _itkMeshBasePython.itkCellInterfaceVisitorUCCTI2FFULULULPF2MCULPF2_cast(obj)

class itkCellInterfaceVisitorUCCTI3FFULULULPF3MCULPF3(ITKCommonBasePython.itkLightObject):
    """


    Abstract interface for a visitor class that can visit the cells in a
    Mesh.

    Define the abstract interface for a visitor class that can visit the
    cells in a Mesh. This follows the Visitor Design Pattern. To make this
    class easier to use, the CellInterfaceVisitorImplementation is
    provided as a templated class to implement the pure virtual functions
    of CellInterfaceVisitor.

    C++ includes: itkCellInterfaceVisitor.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def VisitFromCell(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceUCCTI3FFULULULPF3MCULPF3') -> "void":
        """
        VisitFromCell(itkCellInterfaceVisitorUCCTI3FFULULULPF3MCULPF3 self, unsigned long cellId, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3 arg1)

        This method is called
        by each cell as it visits this visitor. 
        """
        return _itkMeshBasePython.itkCellInterfaceVisitorUCCTI3FFULULULPF3MCULPF3_VisitFromCell(self, cellId, arg1)


    def GetCellTopologyId(self) -> "itkCommonEnums::CellGeometry":
        """
        GetCellTopologyId(itkCellInterfaceVisitorUCCTI3FFULULULPF3MCULPF3 self) -> itkCommonEnums::CellGeometry

        Return the index
        of the CellTopology. 
        """
        return _itkMeshBasePython.itkCellInterfaceVisitorUCCTI3FFULULULPF3MCULPF3_GetCellTopologyId(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceVisitorUCCTI3FFULULULPF3MCULPF3

    def cast(obj: 'itkLightObject') -> "itkCellInterfaceVisitorUCCTI3FFULULULPF3MCULPF3 *":
        """cast(itkLightObject obj) -> itkCellInterfaceVisitorUCCTI3FFULULULPF3MCULPF3"""
        return _itkMeshBasePython.itkCellInterfaceVisitorUCCTI3FFULULULPF3MCULPF3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkCellInterfaceVisitorUCCTI3FFULULULPF3MCULPF3

        Create a new object of the class itkCellInterfaceVisitorUCCTI3FFULULULPF3MCULPF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkCellInterfaceVisitorUCCTI3FFULULULPF3MCULPF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkCellInterfaceVisitorUCCTI3FFULULULPF3MCULPF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkCellInterfaceVisitorUCCTI3FFULULULPF3MCULPF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkCellInterfaceVisitorUCCTI3FFULULULPF3MCULPF3.VisitFromCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceVisitorUCCTI3FFULULULPF3MCULPF3_VisitFromCell, None, itkCellInterfaceVisitorUCCTI3FFULULULPF3MCULPF3)
itkCellInterfaceVisitorUCCTI3FFULULULPF3MCULPF3.GetCellTopologyId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceVisitorUCCTI3FFULULULPF3MCULPF3_GetCellTopologyId, None, itkCellInterfaceVisitorUCCTI3FFULULULPF3MCULPF3)
itkCellInterfaceVisitorUCCTI3FFULULULPF3MCULPF3_swigregister = _itkMeshBasePython.itkCellInterfaceVisitorUCCTI3FFULULULPF3MCULPF3_swigregister
itkCellInterfaceVisitorUCCTI3FFULULULPF3MCULPF3_swigregister(itkCellInterfaceVisitorUCCTI3FFULULULPF3MCULPF3)

def itkCellInterfaceVisitorUCCTI3FFULULULPF3MCULPF3_cast(obj: 'itkLightObject') -> "itkCellInterfaceVisitorUCCTI3FFULULULPF3MCULPF3 *":
    """itkCellInterfaceVisitorUCCTI3FFULULULPF3MCULPF3_cast(itkLightObject obj) -> itkCellInterfaceVisitorUCCTI3FFULULULPF3MCULPF3"""
    return _itkMeshBasePython.itkCellInterfaceVisitorUCCTI3FFULULULPF3MCULPF3_cast(obj)

class itkCellInterfaceVisitorUSCTI2FFULULULPF2MCULPF2(ITKCommonBasePython.itkLightObject):
    """


    Abstract interface for a visitor class that can visit the cells in a
    Mesh.

    Define the abstract interface for a visitor class that can visit the
    cells in a Mesh. This follows the Visitor Design Pattern. To make this
    class easier to use, the CellInterfaceVisitorImplementation is
    provided as a templated class to implement the pure virtual functions
    of CellInterfaceVisitor.

    C++ includes: itkCellInterfaceVisitor.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def VisitFromCell(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceUSCTI2FFULULULPF2MCULPF2') -> "void":
        """
        VisitFromCell(itkCellInterfaceVisitorUSCTI2FFULULULPF2MCULPF2 self, unsigned long cellId, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2 arg1)

        This method is called
        by each cell as it visits this visitor. 
        """
        return _itkMeshBasePython.itkCellInterfaceVisitorUSCTI2FFULULULPF2MCULPF2_VisitFromCell(self, cellId, arg1)


    def GetCellTopologyId(self) -> "itkCommonEnums::CellGeometry":
        """
        GetCellTopologyId(itkCellInterfaceVisitorUSCTI2FFULULULPF2MCULPF2 self) -> itkCommonEnums::CellGeometry

        Return the index
        of the CellTopology. 
        """
        return _itkMeshBasePython.itkCellInterfaceVisitorUSCTI2FFULULULPF2MCULPF2_GetCellTopologyId(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceVisitorUSCTI2FFULULULPF2MCULPF2

    def cast(obj: 'itkLightObject') -> "itkCellInterfaceVisitorUSCTI2FFULULULPF2MCULPF2 *":
        """cast(itkLightObject obj) -> itkCellInterfaceVisitorUSCTI2FFULULULPF2MCULPF2"""
        return _itkMeshBasePython.itkCellInterfaceVisitorUSCTI2FFULULULPF2MCULPF2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkCellInterfaceVisitorUSCTI2FFULULULPF2MCULPF2

        Create a new object of the class itkCellInterfaceVisitorUSCTI2FFULULULPF2MCULPF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkCellInterfaceVisitorUSCTI2FFULULULPF2MCULPF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkCellInterfaceVisitorUSCTI2FFULULULPF2MCULPF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkCellInterfaceVisitorUSCTI2FFULULULPF2MCULPF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkCellInterfaceVisitorUSCTI2FFULULULPF2MCULPF2.VisitFromCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceVisitorUSCTI2FFULULULPF2MCULPF2_VisitFromCell, None, itkCellInterfaceVisitorUSCTI2FFULULULPF2MCULPF2)
itkCellInterfaceVisitorUSCTI2FFULULULPF2MCULPF2.GetCellTopologyId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceVisitorUSCTI2FFULULULPF2MCULPF2_GetCellTopologyId, None, itkCellInterfaceVisitorUSCTI2FFULULULPF2MCULPF2)
itkCellInterfaceVisitorUSCTI2FFULULULPF2MCULPF2_swigregister = _itkMeshBasePython.itkCellInterfaceVisitorUSCTI2FFULULULPF2MCULPF2_swigregister
itkCellInterfaceVisitorUSCTI2FFULULULPF2MCULPF2_swigregister(itkCellInterfaceVisitorUSCTI2FFULULULPF2MCULPF2)

def itkCellInterfaceVisitorUSCTI2FFULULULPF2MCULPF2_cast(obj: 'itkLightObject') -> "itkCellInterfaceVisitorUSCTI2FFULULULPF2MCULPF2 *":
    """itkCellInterfaceVisitorUSCTI2FFULULULPF2MCULPF2_cast(itkLightObject obj) -> itkCellInterfaceVisitorUSCTI2FFULULULPF2MCULPF2"""
    return _itkMeshBasePython.itkCellInterfaceVisitorUSCTI2FFULULULPF2MCULPF2_cast(obj)

class itkCellInterfaceVisitorUSCTI3FFULULULPF3MCULPF3(ITKCommonBasePython.itkLightObject):
    """


    Abstract interface for a visitor class that can visit the cells in a
    Mesh.

    Define the abstract interface for a visitor class that can visit the
    cells in a Mesh. This follows the Visitor Design Pattern. To make this
    class easier to use, the CellInterfaceVisitorImplementation is
    provided as a templated class to implement the pure virtual functions
    of CellInterfaceVisitor.

    C++ includes: itkCellInterfaceVisitor.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def VisitFromCell(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceUSCTI3FFULULULPF3MCULPF3') -> "void":
        """
        VisitFromCell(itkCellInterfaceVisitorUSCTI3FFULULULPF3MCULPF3 self, unsigned long cellId, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3 arg1)

        This method is called
        by each cell as it visits this visitor. 
        """
        return _itkMeshBasePython.itkCellInterfaceVisitorUSCTI3FFULULULPF3MCULPF3_VisitFromCell(self, cellId, arg1)


    def GetCellTopologyId(self) -> "itkCommonEnums::CellGeometry":
        """
        GetCellTopologyId(itkCellInterfaceVisitorUSCTI3FFULULULPF3MCULPF3 self) -> itkCommonEnums::CellGeometry

        Return the index
        of the CellTopology. 
        """
        return _itkMeshBasePython.itkCellInterfaceVisitorUSCTI3FFULULULPF3MCULPF3_GetCellTopologyId(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceVisitorUSCTI3FFULULULPF3MCULPF3

    def cast(obj: 'itkLightObject') -> "itkCellInterfaceVisitorUSCTI3FFULULULPF3MCULPF3 *":
        """cast(itkLightObject obj) -> itkCellInterfaceVisitorUSCTI3FFULULULPF3MCULPF3"""
        return _itkMeshBasePython.itkCellInterfaceVisitorUSCTI3FFULULULPF3MCULPF3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkCellInterfaceVisitorUSCTI3FFULULULPF3MCULPF3

        Create a new object of the class itkCellInterfaceVisitorUSCTI3FFULULULPF3MCULPF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkCellInterfaceVisitorUSCTI3FFULULULPF3MCULPF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkCellInterfaceVisitorUSCTI3FFULULULPF3MCULPF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkCellInterfaceVisitorUSCTI3FFULULULPF3MCULPF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkCellInterfaceVisitorUSCTI3FFULULULPF3MCULPF3.VisitFromCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceVisitorUSCTI3FFULULULPF3MCULPF3_VisitFromCell, None, itkCellInterfaceVisitorUSCTI3FFULULULPF3MCULPF3)
itkCellInterfaceVisitorUSCTI3FFULULULPF3MCULPF3.GetCellTopologyId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceVisitorUSCTI3FFULULULPF3MCULPF3_GetCellTopologyId, None, itkCellInterfaceVisitorUSCTI3FFULULULPF3MCULPF3)
itkCellInterfaceVisitorUSCTI3FFULULULPF3MCULPF3_swigregister = _itkMeshBasePython.itkCellInterfaceVisitorUSCTI3FFULULULPF3MCULPF3_swigregister
itkCellInterfaceVisitorUSCTI3FFULULULPF3MCULPF3_swigregister(itkCellInterfaceVisitorUSCTI3FFULULULPF3MCULPF3)

def itkCellInterfaceVisitorUSCTI3FFULULULPF3MCULPF3_cast(obj: 'itkLightObject') -> "itkCellInterfaceVisitorUSCTI3FFULULULPF3MCULPF3 *":
    """itkCellInterfaceVisitorUSCTI3FFULULULPF3MCULPF3_cast(itkLightObject obj) -> itkCellInterfaceVisitorUSCTI3FFULULULPF3MCULPF3"""
    return _itkMeshBasePython.itkCellInterfaceVisitorUSCTI3FFULULULPF3MCULPF3_cast(obj)

class itkCellTraitsInfo2FFULULULPF2MCULPF2(object):
    """Proxy of C++ itkCellTraitsInfo2FFULULULPF2MCULPF2 class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkCellTraitsInfo2FFULULULPF2MCULPF2 self) -> itkCellTraitsInfo2FFULULULPF2MCULPF2
        __init__(itkCellTraitsInfo2FFULULULPF2MCULPF2 self, itkCellTraitsInfo2FFULULULPF2MCULPF2 arg0) -> itkCellTraitsInfo2FFULULULPF2MCULPF2
        """
        _itkMeshBasePython.itkCellTraitsInfo2FFULULULPF2MCULPF2_swiginit(self, _itkMeshBasePython.new_itkCellTraitsInfo2FFULULULPF2MCULPF2(*args))
    __swig_destroy__ = _itkMeshBasePython.delete_itkCellTraitsInfo2FFULULULPF2MCULPF2
itkCellTraitsInfo2FFULULULPF2MCULPF2_swigregister = _itkMeshBasePython.itkCellTraitsInfo2FFULULULPF2MCULPF2_swigregister
itkCellTraitsInfo2FFULULULPF2MCULPF2_swigregister(itkCellTraitsInfo2FFULULULPF2MCULPF2)

class itkCellTraitsInfo2FFULULULPF2VCULPF2(object):
    """Proxy of C++ itkCellTraitsInfo2FFULULULPF2VCULPF2 class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkCellTraitsInfo2FFULULULPF2VCULPF2 self) -> itkCellTraitsInfo2FFULULULPF2VCULPF2
        __init__(itkCellTraitsInfo2FFULULULPF2VCULPF2 self, itkCellTraitsInfo2FFULULULPF2VCULPF2 arg0) -> itkCellTraitsInfo2FFULULULPF2VCULPF2
        """
        _itkMeshBasePython.itkCellTraitsInfo2FFULULULPF2VCULPF2_swiginit(self, _itkMeshBasePython.new_itkCellTraitsInfo2FFULULULPF2VCULPF2(*args))
    __swig_destroy__ = _itkMeshBasePython.delete_itkCellTraitsInfo2FFULULULPF2VCULPF2
itkCellTraitsInfo2FFULULULPF2VCULPF2_swigregister = _itkMeshBasePython.itkCellTraitsInfo2FFULULULPF2VCULPF2_swigregister
itkCellTraitsInfo2FFULULULPF2VCULPF2_swigregister(itkCellTraitsInfo2FFULULULPF2VCULPF2)

class itkCellTraitsInfo3FFULULULPF3MCULPF3(object):
    """Proxy of C++ itkCellTraitsInfo3FFULULULPF3MCULPF3 class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkCellTraitsInfo3FFULULULPF3MCULPF3 self) -> itkCellTraitsInfo3FFULULULPF3MCULPF3
        __init__(itkCellTraitsInfo3FFULULULPF3MCULPF3 self, itkCellTraitsInfo3FFULULULPF3MCULPF3 arg0) -> itkCellTraitsInfo3FFULULULPF3MCULPF3
        """
        _itkMeshBasePython.itkCellTraitsInfo3FFULULULPF3MCULPF3_swiginit(self, _itkMeshBasePython.new_itkCellTraitsInfo3FFULULULPF3MCULPF3(*args))
    __swig_destroy__ = _itkMeshBasePython.delete_itkCellTraitsInfo3FFULULULPF3MCULPF3
itkCellTraitsInfo3FFULULULPF3MCULPF3_swigregister = _itkMeshBasePython.itkCellTraitsInfo3FFULULULPF3MCULPF3_swigregister
itkCellTraitsInfo3FFULULULPF3MCULPF3_swigregister(itkCellTraitsInfo3FFULULULPF3MCULPF3)

class itkCellTraitsInfo3FFULULULPF3VCULPF3(object):
    """Proxy of C++ itkCellTraitsInfo3FFULULULPF3VCULPF3 class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkCellTraitsInfo3FFULULULPF3VCULPF3 self) -> itkCellTraitsInfo3FFULULULPF3VCULPF3
        __init__(itkCellTraitsInfo3FFULULULPF3VCULPF3 self, itkCellTraitsInfo3FFULULULPF3VCULPF3 arg0) -> itkCellTraitsInfo3FFULULULPF3VCULPF3
        """
        _itkMeshBasePython.itkCellTraitsInfo3FFULULULPF3VCULPF3_swiginit(self, _itkMeshBasePython.new_itkCellTraitsInfo3FFULULULPF3VCULPF3(*args))
    __swig_destroy__ = _itkMeshBasePython.delete_itkCellTraitsInfo3FFULULULPF3VCULPF3
itkCellTraitsInfo3FFULULULPF3VCULPF3_swigregister = _itkMeshBasePython.itkCellTraitsInfo3FFULULULPF3VCULPF3_swigregister
itkCellTraitsInfo3FFULULULPF3VCULPF3_swigregister(itkCellTraitsInfo3FFULULULPF3VCULPF3)

class itkMapContainerULCIDCTI2FFULULULPF2MCULPF2(ITKCommonBasePython.itkObject):
    """


    A wrapper of the STL "map" container.

    Define a front-end to the STL "map" container that conforms to the
    IndexedContainerInterface. This is a full-fleged Object, so there are
    events, modification time, debug, and reference count information.

    Parameters:
    -----------

    TElementIdentifier:  A type that shall be used to index the container.
    It must have a < operator defined for ordering.

    TElement:  The element type stored in the container.

    C++ includes: itkMapContainer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkMapContainerULCIDCTI2FFULULULPF2MCULPF2 self) -> itkMapContainerULCIDCTI2FFULULULPF2MCULPF2
        __init__(itkMapContainerULCIDCTI2FFULULULPF2MCULPF2 self, std::less< unsigned long > const & comp) -> itkMapContainerULCIDCTI2FFULULULPF2MCULPF2



        A wrapper of the STL "map" container.

        Define a front-end to the STL "map" container that conforms to the
        IndexedContainerInterface. This is a full-fleged Object, so there are
        events, modification time, debug, and reference count information.

        Parameters:
        -----------

        TElementIdentifier:  A type that shall be used to index the container.
        It must have a < operator defined for ordering.

        TElement:  The element type stored in the container.

        C++ includes: itkMapContainer.h 
        """
        _itkMeshBasePython.itkMapContainerULCIDCTI2FFULULULPF2MCULPF2_swiginit(self, _itkMeshBasePython.new_itkMapContainerULCIDCTI2FFULULULPF2MCULPF2(*args))

    def __New_orig__() -> "itkMapContainerULCIDCTI2FFULULULPF2MCULPF2_Pointer":
        """__New_orig__() -> itkMapContainerULCIDCTI2FFULULULPF2MCULPF2_Pointer"""
        return _itkMeshBasePython.itkMapContainerULCIDCTI2FFULULULPF2MCULPF2___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkMapContainerULCIDCTI2FFULULULPF2MCULPF2_Pointer":
        """Clone(itkMapContainerULCIDCTI2FFULULULPF2MCULPF2 self) -> itkMapContainerULCIDCTI2FFULULULPF2MCULPF2_Pointer"""
        return _itkMeshBasePython.itkMapContainerULCIDCTI2FFULULULPF2MCULPF2_Clone(self)


    def CastToSTLContainer(self) -> "std::map< unsigned long,itkCellInterfaceDCTI2FFULULULPF2MCULPF2 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceDCTI2FFULULULPF2MCULPF2 * > > > &":
        """
        CastToSTLContainer(itkMapContainerULCIDCTI2FFULULULPF2MCULPF2 self) -> std::map< unsigned long,itkCellInterfaceDCTI2FFULULULPF2MCULPF2 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceDCTI2FFULULULPF2MCULPF2 * > > > &

        Cast the
        container to a STL container type 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI2FFULULULPF2MCULPF2_CastToSTLContainer(self)


    def CastToSTLConstContainer(self) -> "std::map< unsigned long,itkCellInterfaceDCTI2FFULULULPF2MCULPF2 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceDCTI2FFULULULPF2MCULPF2 * > > > const &":
        """
        CastToSTLConstContainer(itkMapContainerULCIDCTI2FFULULULPF2MCULPF2 self) -> std::map< unsigned long,itkCellInterfaceDCTI2FFULULULPF2MCULPF2 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceDCTI2FFULULULPF2MCULPF2 * > > > const &

        Cast the
        container to a const STL container type 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI2FFULULULPF2MCULPF2_CastToSTLConstContainer(self)


    def ElementAt(self, *args) -> "itkCellInterfaceDCTI2FFULULULPF2MCULPF2 *const &":
        """
        ElementAt(itkMapContainerULCIDCTI2FFULULULPF2MCULPF2 self, unsigned long arg0) -> itkCellInterfaceDCTI2FFULULULPF2MCULPF2
        ElementAt(itkMapContainerULCIDCTI2FFULULULPF2MCULPF2 self, unsigned long arg0) -> itkCellInterfaceDCTI2FFULULULPF2MCULPF2

        Get a reference to the
        element at the given index. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI2FFULULULPF2MCULPF2_ElementAt(self, *args)


    def CreateElementAt(self, arg0: 'unsigned long') -> "itkCellInterfaceDCTI2FFULULULPF2MCULPF2 *&":
        """
        CreateElementAt(itkMapContainerULCIDCTI2FFULULULPF2MCULPF2 self, unsigned long arg0) -> itkCellInterfaceDCTI2FFULULULPF2MCULPF2 *&

        Get a reference to
        the element at the given index. If the index does not exist, it is
        created automatically.

        It is assumed that the value of the element is modified through the
        reference. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI2FFULULULPF2MCULPF2_CreateElementAt(self, arg0)


    def GetElement(self, arg0: 'unsigned long') -> "itkCellInterfaceDCTI2FFULULULPF2MCULPF2 *":
        """
        GetElement(itkMapContainerULCIDCTI2FFULULULPF2MCULPF2 self, unsigned long arg0) -> itkCellInterfaceDCTI2FFULULULPF2MCULPF2

        Get the element at the
        specified index. There is no check for existence performed. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI2FFULULULPF2MCULPF2_GetElement(self, arg0)


    def SetElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI2FFULULULPF2MCULPF2') -> "void":
        """
        SetElement(itkMapContainerULCIDCTI2FFULULULPF2MCULPF2 self, unsigned long arg0, itkCellInterfaceDCTI2FFULULULPF2MCULPF2 arg1)

        Set the given index
        value to the given element. If the index doesn't exist, it is
        automatically created. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI2FFULULULPF2MCULPF2_SetElement(self, arg0, arg1)


    def InsertElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI2FFULULULPF2MCULPF2') -> "void":
        """
        InsertElement(itkMapContainerULCIDCTI2FFULULULPF2MCULPF2 self, unsigned long arg0, itkCellInterfaceDCTI2FFULULULPF2MCULPF2 arg1)

        Set the given index
        value to the given element. If the index doesn't exist, it is
        automatically created. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI2FFULULULPF2MCULPF2_InsertElement(self, arg0, arg1)


    def IndexExists(self, arg0: 'unsigned long') -> "bool":
        """
        IndexExists(itkMapContainerULCIDCTI2FFULULULPF2MCULPF2 self, unsigned long arg0) -> bool

        Check if the STL map
        has an entry corresponding to the given index. The count will be
        either 1 or 0. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI2FFULULULPF2MCULPF2_IndexExists(self, arg0)


    def GetElementIfIndexExists(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI2FFULULULPF2MCULPF2 **') -> "bool":
        """
        GetElementIfIndexExists(itkMapContainerULCIDCTI2FFULULULPF2MCULPF2 self, unsigned long arg0, itkCellInterfaceDCTI2FFULULULPF2MCULPF2 ** arg1) -> bool

        If the
        given index doesn't exist in the map, return false. Otherwise, set the
        element through the pointer (if it isn't null), and return true. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI2FFULULULPF2MCULPF2_GetElementIfIndexExists(self, arg0, arg1)


    def CreateIndex(self, arg0: 'unsigned long') -> "void":
        """
        CreateIndex(itkMapContainerULCIDCTI2FFULULULPF2MCULPF2 self, unsigned long arg0)

        The map will create an
        entry for a given index through the indexing operator. Whether or not
        it is created, it will be assigned to the default element. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI2FFULULULPF2MCULPF2_CreateIndex(self, arg0)


    def DeleteIndex(self, arg0: 'unsigned long') -> "void":
        """
        DeleteIndex(itkMapContainerULCIDCTI2FFULULULPF2MCULPF2 self, unsigned long arg0)

        Delete the entry in the
        STL map corresponding to the given identifier. If the entry does not
        exist, nothing happens. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI2FFULULULPF2MCULPF2_DeleteIndex(self, arg0)


    def Size(self) -> "unsigned long":
        """
        Size(itkMapContainerULCIDCTI2FFULULULPF2MCULPF2 self) -> unsigned long

        Get the number of elements
        currently stored in the map. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI2FFULULULPF2MCULPF2_Size(self)


    def Reserve(self, arg0: 'unsigned long') -> "void":
        """
        Reserve(itkMapContainerULCIDCTI2FFULULULPF2MCULPF2 self, unsigned long arg0)

        Tell the container to
        allocate enough memory to allow at least as many elements as the size
        given to be stored. This is NOT guaranteed to actually allocate any
        memory, but is useful if the implementation of the container allocates
        contiguous storage. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI2FFULULULPF2MCULPF2_Reserve(self, arg0)


    def Squeeze(self) -> "void":
        """
        Squeeze(itkMapContainerULCIDCTI2FFULULULPF2MCULPF2 self)

        Tell the container to try
        to minimize its memory usage for storage of the current number of
        elements. This is NOT guaranteed to decrease memory usage. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI2FFULULULPF2MCULPF2_Squeeze(self)


    def Initialize(self) -> "void":
        """
        Initialize(itkMapContainerULCIDCTI2FFULULULPF2MCULPF2 self)

        Tell the container to
        release any memory it may have allocated and return itself to its
        initial state. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI2FFULULULPF2MCULPF2_Initialize(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkMapContainerULCIDCTI2FFULULULPF2MCULPF2

    def cast(obj: 'itkLightObject') -> "itkMapContainerULCIDCTI2FFULULULPF2MCULPF2 *":
        """cast(itkLightObject obj) -> itkMapContainerULCIDCTI2FFULULULPF2MCULPF2"""
        return _itkMeshBasePython.itkMapContainerULCIDCTI2FFULULULPF2MCULPF2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkMapContainerULCIDCTI2FFULULULPF2MCULPF2

        Create a new object of the class itkMapContainerULCIDCTI2FFULULULPF2MCULPF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMapContainerULCIDCTI2FFULULULPF2MCULPF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkMapContainerULCIDCTI2FFULULULPF2MCULPF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkMapContainerULCIDCTI2FFULULULPF2MCULPF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkMapContainerULCIDCTI2FFULULULPF2MCULPF2.Clone = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI2FFULULULPF2MCULPF2_Clone, None, itkMapContainerULCIDCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIDCTI2FFULULULPF2MCULPF2.CastToSTLContainer = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI2FFULULULPF2MCULPF2_CastToSTLContainer, None, itkMapContainerULCIDCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIDCTI2FFULULULPF2MCULPF2.CastToSTLConstContainer = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI2FFULULULPF2MCULPF2_CastToSTLConstContainer, None, itkMapContainerULCIDCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIDCTI2FFULULULPF2MCULPF2.ElementAt = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI2FFULULULPF2MCULPF2_ElementAt, None, itkMapContainerULCIDCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIDCTI2FFULULULPF2MCULPF2.CreateElementAt = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI2FFULULULPF2MCULPF2_CreateElementAt, None, itkMapContainerULCIDCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIDCTI2FFULULULPF2MCULPF2.GetElement = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI2FFULULULPF2MCULPF2_GetElement, None, itkMapContainerULCIDCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIDCTI2FFULULULPF2MCULPF2.SetElement = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI2FFULULULPF2MCULPF2_SetElement, None, itkMapContainerULCIDCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIDCTI2FFULULULPF2MCULPF2.InsertElement = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI2FFULULULPF2MCULPF2_InsertElement, None, itkMapContainerULCIDCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIDCTI2FFULULULPF2MCULPF2.IndexExists = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI2FFULULULPF2MCULPF2_IndexExists, None, itkMapContainerULCIDCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIDCTI2FFULULULPF2MCULPF2.GetElementIfIndexExists = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI2FFULULULPF2MCULPF2_GetElementIfIndexExists, None, itkMapContainerULCIDCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIDCTI2FFULULULPF2MCULPF2.CreateIndex = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI2FFULULULPF2MCULPF2_CreateIndex, None, itkMapContainerULCIDCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIDCTI2FFULULULPF2MCULPF2.DeleteIndex = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI2FFULULULPF2MCULPF2_DeleteIndex, None, itkMapContainerULCIDCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIDCTI2FFULULULPF2MCULPF2.Size = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI2FFULULULPF2MCULPF2_Size, None, itkMapContainerULCIDCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIDCTI2FFULULULPF2MCULPF2.Reserve = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI2FFULULULPF2MCULPF2_Reserve, None, itkMapContainerULCIDCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIDCTI2FFULULULPF2MCULPF2.Squeeze = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI2FFULULULPF2MCULPF2_Squeeze, None, itkMapContainerULCIDCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIDCTI2FFULULULPF2MCULPF2.Initialize = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI2FFULULULPF2MCULPF2_Initialize, None, itkMapContainerULCIDCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIDCTI2FFULULULPF2MCULPF2_swigregister = _itkMeshBasePython.itkMapContainerULCIDCTI2FFULULULPF2MCULPF2_swigregister
itkMapContainerULCIDCTI2FFULULULPF2MCULPF2_swigregister(itkMapContainerULCIDCTI2FFULULULPF2MCULPF2)

def itkMapContainerULCIDCTI2FFULULULPF2MCULPF2___New_orig__() -> "itkMapContainerULCIDCTI2FFULULULPF2MCULPF2_Pointer":
    """itkMapContainerULCIDCTI2FFULULULPF2MCULPF2___New_orig__() -> itkMapContainerULCIDCTI2FFULULULPF2MCULPF2_Pointer"""
    return _itkMeshBasePython.itkMapContainerULCIDCTI2FFULULULPF2MCULPF2___New_orig__()

def itkMapContainerULCIDCTI2FFULULULPF2MCULPF2_cast(obj: 'itkLightObject') -> "itkMapContainerULCIDCTI2FFULULULPF2MCULPF2 *":
    """itkMapContainerULCIDCTI2FFULULULPF2MCULPF2_cast(itkLightObject obj) -> itkMapContainerULCIDCTI2FFULULULPF2MCULPF2"""
    return _itkMeshBasePython.itkMapContainerULCIDCTI2FFULULULPF2MCULPF2_cast(obj)

class itkMapContainerULCIDCTI3FFULULULPF3MCULPF3(ITKCommonBasePython.itkObject):
    """


    A wrapper of the STL "map" container.

    Define a front-end to the STL "map" container that conforms to the
    IndexedContainerInterface. This is a full-fleged Object, so there are
    events, modification time, debug, and reference count information.

    Parameters:
    -----------

    TElementIdentifier:  A type that shall be used to index the container.
    It must have a < operator defined for ordering.

    TElement:  The element type stored in the container.

    C++ includes: itkMapContainer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkMapContainerULCIDCTI3FFULULULPF3MCULPF3 self) -> itkMapContainerULCIDCTI3FFULULULPF3MCULPF3
        __init__(itkMapContainerULCIDCTI3FFULULULPF3MCULPF3 self, std::less< unsigned long > const & comp) -> itkMapContainerULCIDCTI3FFULULULPF3MCULPF3



        A wrapper of the STL "map" container.

        Define a front-end to the STL "map" container that conforms to the
        IndexedContainerInterface. This is a full-fleged Object, so there are
        events, modification time, debug, and reference count information.

        Parameters:
        -----------

        TElementIdentifier:  A type that shall be used to index the container.
        It must have a < operator defined for ordering.

        TElement:  The element type stored in the container.

        C++ includes: itkMapContainer.h 
        """
        _itkMeshBasePython.itkMapContainerULCIDCTI3FFULULULPF3MCULPF3_swiginit(self, _itkMeshBasePython.new_itkMapContainerULCIDCTI3FFULULULPF3MCULPF3(*args))

    def __New_orig__() -> "itkMapContainerULCIDCTI3FFULULULPF3MCULPF3_Pointer":
        """__New_orig__() -> itkMapContainerULCIDCTI3FFULULULPF3MCULPF3_Pointer"""
        return _itkMeshBasePython.itkMapContainerULCIDCTI3FFULULULPF3MCULPF3___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkMapContainerULCIDCTI3FFULULULPF3MCULPF3_Pointer":
        """Clone(itkMapContainerULCIDCTI3FFULULULPF3MCULPF3 self) -> itkMapContainerULCIDCTI3FFULULULPF3MCULPF3_Pointer"""
        return _itkMeshBasePython.itkMapContainerULCIDCTI3FFULULULPF3MCULPF3_Clone(self)


    def CastToSTLContainer(self) -> "std::map< unsigned long,itkCellInterfaceDCTI3FFULULULPF3MCULPF3 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceDCTI3FFULULULPF3MCULPF3 * > > > &":
        """
        CastToSTLContainer(itkMapContainerULCIDCTI3FFULULULPF3MCULPF3 self) -> std::map< unsigned long,itkCellInterfaceDCTI3FFULULULPF3MCULPF3 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceDCTI3FFULULULPF3MCULPF3 * > > > &

        Cast the
        container to a STL container type 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI3FFULULULPF3MCULPF3_CastToSTLContainer(self)


    def CastToSTLConstContainer(self) -> "std::map< unsigned long,itkCellInterfaceDCTI3FFULULULPF3MCULPF3 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceDCTI3FFULULULPF3MCULPF3 * > > > const &":
        """
        CastToSTLConstContainer(itkMapContainerULCIDCTI3FFULULULPF3MCULPF3 self) -> std::map< unsigned long,itkCellInterfaceDCTI3FFULULULPF3MCULPF3 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceDCTI3FFULULULPF3MCULPF3 * > > > const &

        Cast the
        container to a const STL container type 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI3FFULULULPF3MCULPF3_CastToSTLConstContainer(self)


    def ElementAt(self, *args) -> "itkCellInterfaceDCTI3FFULULULPF3MCULPF3 *const &":
        """
        ElementAt(itkMapContainerULCIDCTI3FFULULULPF3MCULPF3 self, unsigned long arg0) -> itkCellInterfaceDCTI3FFULULULPF3MCULPF3
        ElementAt(itkMapContainerULCIDCTI3FFULULULPF3MCULPF3 self, unsigned long arg0) -> itkCellInterfaceDCTI3FFULULULPF3MCULPF3

        Get a reference to the
        element at the given index. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI3FFULULULPF3MCULPF3_ElementAt(self, *args)


    def CreateElementAt(self, arg0: 'unsigned long') -> "itkCellInterfaceDCTI3FFULULULPF3MCULPF3 *&":
        """
        CreateElementAt(itkMapContainerULCIDCTI3FFULULULPF3MCULPF3 self, unsigned long arg0) -> itkCellInterfaceDCTI3FFULULULPF3MCULPF3 *&

        Get a reference to
        the element at the given index. If the index does not exist, it is
        created automatically.

        It is assumed that the value of the element is modified through the
        reference. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI3FFULULULPF3MCULPF3_CreateElementAt(self, arg0)


    def GetElement(self, arg0: 'unsigned long') -> "itkCellInterfaceDCTI3FFULULULPF3MCULPF3 *":
        """
        GetElement(itkMapContainerULCIDCTI3FFULULULPF3MCULPF3 self, unsigned long arg0) -> itkCellInterfaceDCTI3FFULULULPF3MCULPF3

        Get the element at the
        specified index. There is no check for existence performed. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI3FFULULULPF3MCULPF3_GetElement(self, arg0)


    def SetElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI3FFULULULPF3MCULPF3') -> "void":
        """
        SetElement(itkMapContainerULCIDCTI3FFULULULPF3MCULPF3 self, unsigned long arg0, itkCellInterfaceDCTI3FFULULULPF3MCULPF3 arg1)

        Set the given index
        value to the given element. If the index doesn't exist, it is
        automatically created. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI3FFULULULPF3MCULPF3_SetElement(self, arg0, arg1)


    def InsertElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI3FFULULULPF3MCULPF3') -> "void":
        """
        InsertElement(itkMapContainerULCIDCTI3FFULULULPF3MCULPF3 self, unsigned long arg0, itkCellInterfaceDCTI3FFULULULPF3MCULPF3 arg1)

        Set the given index
        value to the given element. If the index doesn't exist, it is
        automatically created. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI3FFULULULPF3MCULPF3_InsertElement(self, arg0, arg1)


    def IndexExists(self, arg0: 'unsigned long') -> "bool":
        """
        IndexExists(itkMapContainerULCIDCTI3FFULULULPF3MCULPF3 self, unsigned long arg0) -> bool

        Check if the STL map
        has an entry corresponding to the given index. The count will be
        either 1 or 0. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI3FFULULULPF3MCULPF3_IndexExists(self, arg0)


    def GetElementIfIndexExists(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI3FFULULULPF3MCULPF3 **') -> "bool":
        """
        GetElementIfIndexExists(itkMapContainerULCIDCTI3FFULULULPF3MCULPF3 self, unsigned long arg0, itkCellInterfaceDCTI3FFULULULPF3MCULPF3 ** arg1) -> bool

        If the
        given index doesn't exist in the map, return false. Otherwise, set the
        element through the pointer (if it isn't null), and return true. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI3FFULULULPF3MCULPF3_GetElementIfIndexExists(self, arg0, arg1)


    def CreateIndex(self, arg0: 'unsigned long') -> "void":
        """
        CreateIndex(itkMapContainerULCIDCTI3FFULULULPF3MCULPF3 self, unsigned long arg0)

        The map will create an
        entry for a given index through the indexing operator. Whether or not
        it is created, it will be assigned to the default element. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI3FFULULULPF3MCULPF3_CreateIndex(self, arg0)


    def DeleteIndex(self, arg0: 'unsigned long') -> "void":
        """
        DeleteIndex(itkMapContainerULCIDCTI3FFULULULPF3MCULPF3 self, unsigned long arg0)

        Delete the entry in the
        STL map corresponding to the given identifier. If the entry does not
        exist, nothing happens. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI3FFULULULPF3MCULPF3_DeleteIndex(self, arg0)


    def Size(self) -> "unsigned long":
        """
        Size(itkMapContainerULCIDCTI3FFULULULPF3MCULPF3 self) -> unsigned long

        Get the number of elements
        currently stored in the map. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI3FFULULULPF3MCULPF3_Size(self)


    def Reserve(self, arg0: 'unsigned long') -> "void":
        """
        Reserve(itkMapContainerULCIDCTI3FFULULULPF3MCULPF3 self, unsigned long arg0)

        Tell the container to
        allocate enough memory to allow at least as many elements as the size
        given to be stored. This is NOT guaranteed to actually allocate any
        memory, but is useful if the implementation of the container allocates
        contiguous storage. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI3FFULULULPF3MCULPF3_Reserve(self, arg0)


    def Squeeze(self) -> "void":
        """
        Squeeze(itkMapContainerULCIDCTI3FFULULULPF3MCULPF3 self)

        Tell the container to try
        to minimize its memory usage for storage of the current number of
        elements. This is NOT guaranteed to decrease memory usage. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI3FFULULULPF3MCULPF3_Squeeze(self)


    def Initialize(self) -> "void":
        """
        Initialize(itkMapContainerULCIDCTI3FFULULULPF3MCULPF3 self)

        Tell the container to
        release any memory it may have allocated and return itself to its
        initial state. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI3FFULULULPF3MCULPF3_Initialize(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkMapContainerULCIDCTI3FFULULULPF3MCULPF3

    def cast(obj: 'itkLightObject') -> "itkMapContainerULCIDCTI3FFULULULPF3MCULPF3 *":
        """cast(itkLightObject obj) -> itkMapContainerULCIDCTI3FFULULULPF3MCULPF3"""
        return _itkMeshBasePython.itkMapContainerULCIDCTI3FFULULULPF3MCULPF3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkMapContainerULCIDCTI3FFULULULPF3MCULPF3

        Create a new object of the class itkMapContainerULCIDCTI3FFULULULPF3MCULPF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMapContainerULCIDCTI3FFULULULPF3MCULPF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkMapContainerULCIDCTI3FFULULULPF3MCULPF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkMapContainerULCIDCTI3FFULULULPF3MCULPF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkMapContainerULCIDCTI3FFULULULPF3MCULPF3.Clone = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI3FFULULULPF3MCULPF3_Clone, None, itkMapContainerULCIDCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIDCTI3FFULULULPF3MCULPF3.CastToSTLContainer = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI3FFULULULPF3MCULPF3_CastToSTLContainer, None, itkMapContainerULCIDCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIDCTI3FFULULULPF3MCULPF3.CastToSTLConstContainer = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI3FFULULULPF3MCULPF3_CastToSTLConstContainer, None, itkMapContainerULCIDCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIDCTI3FFULULULPF3MCULPF3.ElementAt = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI3FFULULULPF3MCULPF3_ElementAt, None, itkMapContainerULCIDCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIDCTI3FFULULULPF3MCULPF3.CreateElementAt = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI3FFULULULPF3MCULPF3_CreateElementAt, None, itkMapContainerULCIDCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIDCTI3FFULULULPF3MCULPF3.GetElement = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI3FFULULULPF3MCULPF3_GetElement, None, itkMapContainerULCIDCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIDCTI3FFULULULPF3MCULPF3.SetElement = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI3FFULULULPF3MCULPF3_SetElement, None, itkMapContainerULCIDCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIDCTI3FFULULULPF3MCULPF3.InsertElement = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI3FFULULULPF3MCULPF3_InsertElement, None, itkMapContainerULCIDCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIDCTI3FFULULULPF3MCULPF3.IndexExists = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI3FFULULULPF3MCULPF3_IndexExists, None, itkMapContainerULCIDCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIDCTI3FFULULULPF3MCULPF3.GetElementIfIndexExists = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI3FFULULULPF3MCULPF3_GetElementIfIndexExists, None, itkMapContainerULCIDCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIDCTI3FFULULULPF3MCULPF3.CreateIndex = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI3FFULULULPF3MCULPF3_CreateIndex, None, itkMapContainerULCIDCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIDCTI3FFULULULPF3MCULPF3.DeleteIndex = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI3FFULULULPF3MCULPF3_DeleteIndex, None, itkMapContainerULCIDCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIDCTI3FFULULULPF3MCULPF3.Size = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI3FFULULULPF3MCULPF3_Size, None, itkMapContainerULCIDCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIDCTI3FFULULULPF3MCULPF3.Reserve = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI3FFULULULPF3MCULPF3_Reserve, None, itkMapContainerULCIDCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIDCTI3FFULULULPF3MCULPF3.Squeeze = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI3FFULULULPF3MCULPF3_Squeeze, None, itkMapContainerULCIDCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIDCTI3FFULULULPF3MCULPF3.Initialize = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI3FFULULULPF3MCULPF3_Initialize, None, itkMapContainerULCIDCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIDCTI3FFULULULPF3MCULPF3_swigregister = _itkMeshBasePython.itkMapContainerULCIDCTI3FFULULULPF3MCULPF3_swigregister
itkMapContainerULCIDCTI3FFULULULPF3MCULPF3_swigregister(itkMapContainerULCIDCTI3FFULULULPF3MCULPF3)

def itkMapContainerULCIDCTI3FFULULULPF3MCULPF3___New_orig__() -> "itkMapContainerULCIDCTI3FFULULULPF3MCULPF3_Pointer":
    """itkMapContainerULCIDCTI3FFULULULPF3MCULPF3___New_orig__() -> itkMapContainerULCIDCTI3FFULULULPF3MCULPF3_Pointer"""
    return _itkMeshBasePython.itkMapContainerULCIDCTI3FFULULULPF3MCULPF3___New_orig__()

def itkMapContainerULCIDCTI3FFULULULPF3MCULPF3_cast(obj: 'itkLightObject') -> "itkMapContainerULCIDCTI3FFULULULPF3MCULPF3 *":
    """itkMapContainerULCIDCTI3FFULULULPF3MCULPF3_cast(itkLightObject obj) -> itkMapContainerULCIDCTI3FFULULULPF3MCULPF3"""
    return _itkMeshBasePython.itkMapContainerULCIDCTI3FFULULULPF3MCULPF3_cast(obj)

class itkMapContainerULCIFCTI2FFULULULPF2MCULPF2(ITKCommonBasePython.itkObject):
    """


    A wrapper of the STL "map" container.

    Define a front-end to the STL "map" container that conforms to the
    IndexedContainerInterface. This is a full-fleged Object, so there are
    events, modification time, debug, and reference count information.

    Parameters:
    -----------

    TElementIdentifier:  A type that shall be used to index the container.
    It must have a < operator defined for ordering.

    TElement:  The element type stored in the container.

    C++ includes: itkMapContainer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkMapContainerULCIFCTI2FFULULULPF2MCULPF2 self) -> itkMapContainerULCIFCTI2FFULULULPF2MCULPF2
        __init__(itkMapContainerULCIFCTI2FFULULULPF2MCULPF2 self, std::less< unsigned long > const & comp) -> itkMapContainerULCIFCTI2FFULULULPF2MCULPF2



        A wrapper of the STL "map" container.

        Define a front-end to the STL "map" container that conforms to the
        IndexedContainerInterface. This is a full-fleged Object, so there are
        events, modification time, debug, and reference count information.

        Parameters:
        -----------

        TElementIdentifier:  A type that shall be used to index the container.
        It must have a < operator defined for ordering.

        TElement:  The element type stored in the container.

        C++ includes: itkMapContainer.h 
        """
        _itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_swiginit(self, _itkMeshBasePython.new_itkMapContainerULCIFCTI2FFULULULPF2MCULPF2(*args))

    def __New_orig__() -> "itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_Pointer":
        """__New_orig__() -> itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_Pointer"""
        return _itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_Pointer":
        """Clone(itkMapContainerULCIFCTI2FFULULULPF2MCULPF2 self) -> itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_Pointer"""
        return _itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_Clone(self)


    def CastToSTLContainer(self) -> "std::map< unsigned long,itkCellInterfaceFCTI2FFULULULPF2MCULPF2 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceFCTI2FFULULULPF2MCULPF2 * > > > &":
        """
        CastToSTLContainer(itkMapContainerULCIFCTI2FFULULULPF2MCULPF2 self) -> std::map< unsigned long,itkCellInterfaceFCTI2FFULULULPF2MCULPF2 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceFCTI2FFULULULPF2MCULPF2 * > > > &

        Cast the
        container to a STL container type 
        """
        return _itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_CastToSTLContainer(self)


    def CastToSTLConstContainer(self) -> "std::map< unsigned long,itkCellInterfaceFCTI2FFULULULPF2MCULPF2 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceFCTI2FFULULULPF2MCULPF2 * > > > const &":
        """
        CastToSTLConstContainer(itkMapContainerULCIFCTI2FFULULULPF2MCULPF2 self) -> std::map< unsigned long,itkCellInterfaceFCTI2FFULULULPF2MCULPF2 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceFCTI2FFULULULPF2MCULPF2 * > > > const &

        Cast the
        container to a const STL container type 
        """
        return _itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_CastToSTLConstContainer(self)


    def ElementAt(self, *args) -> "itkCellInterfaceFCTI2FFULULULPF2MCULPF2 *const &":
        """
        ElementAt(itkMapContainerULCIFCTI2FFULULULPF2MCULPF2 self, unsigned long arg0) -> itkCellInterfaceFCTI2FFULULULPF2MCULPF2
        ElementAt(itkMapContainerULCIFCTI2FFULULULPF2MCULPF2 self, unsigned long arg0) -> itkCellInterfaceFCTI2FFULULULPF2MCULPF2

        Get a reference to the
        element at the given index. 
        """
        return _itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_ElementAt(self, *args)


    def CreateElementAt(self, arg0: 'unsigned long') -> "itkCellInterfaceFCTI2FFULULULPF2MCULPF2 *&":
        """
        CreateElementAt(itkMapContainerULCIFCTI2FFULULULPF2MCULPF2 self, unsigned long arg0) -> itkCellInterfaceFCTI2FFULULULPF2MCULPF2 *&

        Get a reference to
        the element at the given index. If the index does not exist, it is
        created automatically.

        It is assumed that the value of the element is modified through the
        reference. 
        """
        return _itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_CreateElementAt(self, arg0)


    def GetElement(self, arg0: 'unsigned long') -> "itkCellInterfaceFCTI2FFULULULPF2MCULPF2 *":
        """
        GetElement(itkMapContainerULCIFCTI2FFULULULPF2MCULPF2 self, unsigned long arg0) -> itkCellInterfaceFCTI2FFULULULPF2MCULPF2

        Get the element at the
        specified index. There is no check for existence performed. 
        """
        return _itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_GetElement(self, arg0)


    def SetElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceFCTI2FFULULULPF2MCULPF2') -> "void":
        """
        SetElement(itkMapContainerULCIFCTI2FFULULULPF2MCULPF2 self, unsigned long arg0, itkCellInterfaceFCTI2FFULULULPF2MCULPF2 arg1)

        Set the given index
        value to the given element. If the index doesn't exist, it is
        automatically created. 
        """
        return _itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_SetElement(self, arg0, arg1)


    def InsertElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceFCTI2FFULULULPF2MCULPF2') -> "void":
        """
        InsertElement(itkMapContainerULCIFCTI2FFULULULPF2MCULPF2 self, unsigned long arg0, itkCellInterfaceFCTI2FFULULULPF2MCULPF2 arg1)

        Set the given index
        value to the given element. If the index doesn't exist, it is
        automatically created. 
        """
        return _itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_InsertElement(self, arg0, arg1)


    def IndexExists(self, arg0: 'unsigned long') -> "bool":
        """
        IndexExists(itkMapContainerULCIFCTI2FFULULULPF2MCULPF2 self, unsigned long arg0) -> bool

        Check if the STL map
        has an entry corresponding to the given index. The count will be
        either 1 or 0. 
        """
        return _itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_IndexExists(self, arg0)


    def GetElementIfIndexExists(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceFCTI2FFULULULPF2MCULPF2 **') -> "bool":
        """
        GetElementIfIndexExists(itkMapContainerULCIFCTI2FFULULULPF2MCULPF2 self, unsigned long arg0, itkCellInterfaceFCTI2FFULULULPF2MCULPF2 ** arg1) -> bool

        If the
        given index doesn't exist in the map, return false. Otherwise, set the
        element through the pointer (if it isn't null), and return true. 
        """
        return _itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_GetElementIfIndexExists(self, arg0, arg1)


    def CreateIndex(self, arg0: 'unsigned long') -> "void":
        """
        CreateIndex(itkMapContainerULCIFCTI2FFULULULPF2MCULPF2 self, unsigned long arg0)

        The map will create an
        entry for a given index through the indexing operator. Whether or not
        it is created, it will be assigned to the default element. 
        """
        return _itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_CreateIndex(self, arg0)


    def DeleteIndex(self, arg0: 'unsigned long') -> "void":
        """
        DeleteIndex(itkMapContainerULCIFCTI2FFULULULPF2MCULPF2 self, unsigned long arg0)

        Delete the entry in the
        STL map corresponding to the given identifier. If the entry does not
        exist, nothing happens. 
        """
        return _itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_DeleteIndex(self, arg0)


    def Size(self) -> "unsigned long":
        """
        Size(itkMapContainerULCIFCTI2FFULULULPF2MCULPF2 self) -> unsigned long

        Get the number of elements
        currently stored in the map. 
        """
        return _itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_Size(self)


    def Reserve(self, arg0: 'unsigned long') -> "void":
        """
        Reserve(itkMapContainerULCIFCTI2FFULULULPF2MCULPF2 self, unsigned long arg0)

        Tell the container to
        allocate enough memory to allow at least as many elements as the size
        given to be stored. This is NOT guaranteed to actually allocate any
        memory, but is useful if the implementation of the container allocates
        contiguous storage. 
        """
        return _itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_Reserve(self, arg0)


    def Squeeze(self) -> "void":
        """
        Squeeze(itkMapContainerULCIFCTI2FFULULULPF2MCULPF2 self)

        Tell the container to try
        to minimize its memory usage for storage of the current number of
        elements. This is NOT guaranteed to decrease memory usage. 
        """
        return _itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_Squeeze(self)


    def Initialize(self) -> "void":
        """
        Initialize(itkMapContainerULCIFCTI2FFULULULPF2MCULPF2 self)

        Tell the container to
        release any memory it may have allocated and return itself to its
        initial state. 
        """
        return _itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_Initialize(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkMapContainerULCIFCTI2FFULULULPF2MCULPF2

    def cast(obj: 'itkLightObject') -> "itkMapContainerULCIFCTI2FFULULULPF2MCULPF2 *":
        """cast(itkLightObject obj) -> itkMapContainerULCIFCTI2FFULULULPF2MCULPF2"""
        return _itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkMapContainerULCIFCTI2FFULULULPF2MCULPF2

        Create a new object of the class itkMapContainerULCIFCTI2FFULULULPF2MCULPF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMapContainerULCIFCTI2FFULULULPF2MCULPF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkMapContainerULCIFCTI2FFULULULPF2MCULPF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkMapContainerULCIFCTI2FFULULULPF2MCULPF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkMapContainerULCIFCTI2FFULULULPF2MCULPF2.Clone = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_Clone, None, itkMapContainerULCIFCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIFCTI2FFULULULPF2MCULPF2.CastToSTLContainer = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_CastToSTLContainer, None, itkMapContainerULCIFCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIFCTI2FFULULULPF2MCULPF2.CastToSTLConstContainer = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_CastToSTLConstContainer, None, itkMapContainerULCIFCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIFCTI2FFULULULPF2MCULPF2.ElementAt = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_ElementAt, None, itkMapContainerULCIFCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIFCTI2FFULULULPF2MCULPF2.CreateElementAt = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_CreateElementAt, None, itkMapContainerULCIFCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIFCTI2FFULULULPF2MCULPF2.GetElement = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_GetElement, None, itkMapContainerULCIFCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIFCTI2FFULULULPF2MCULPF2.SetElement = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_SetElement, None, itkMapContainerULCIFCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIFCTI2FFULULULPF2MCULPF2.InsertElement = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_InsertElement, None, itkMapContainerULCIFCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIFCTI2FFULULULPF2MCULPF2.IndexExists = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_IndexExists, None, itkMapContainerULCIFCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIFCTI2FFULULULPF2MCULPF2.GetElementIfIndexExists = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_GetElementIfIndexExists, None, itkMapContainerULCIFCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIFCTI2FFULULULPF2MCULPF2.CreateIndex = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_CreateIndex, None, itkMapContainerULCIFCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIFCTI2FFULULULPF2MCULPF2.DeleteIndex = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_DeleteIndex, None, itkMapContainerULCIFCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIFCTI2FFULULULPF2MCULPF2.Size = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_Size, None, itkMapContainerULCIFCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIFCTI2FFULULULPF2MCULPF2.Reserve = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_Reserve, None, itkMapContainerULCIFCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIFCTI2FFULULULPF2MCULPF2.Squeeze = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_Squeeze, None, itkMapContainerULCIFCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIFCTI2FFULULULPF2MCULPF2.Initialize = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_Initialize, None, itkMapContainerULCIFCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_swigregister = _itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_swigregister
itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_swigregister(itkMapContainerULCIFCTI2FFULULULPF2MCULPF2)

def itkMapContainerULCIFCTI2FFULULULPF2MCULPF2___New_orig__() -> "itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_Pointer":
    """itkMapContainerULCIFCTI2FFULULULPF2MCULPF2___New_orig__() -> itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_Pointer"""
    return _itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2___New_orig__()

def itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_cast(obj: 'itkLightObject') -> "itkMapContainerULCIFCTI2FFULULULPF2MCULPF2 *":
    """itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_cast(itkLightObject obj) -> itkMapContainerULCIFCTI2FFULULULPF2MCULPF2"""
    return _itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_cast(obj)

class itkMapContainerULCIFCTI3FFULULULPF3MCULPF3(ITKCommonBasePython.itkObject):
    """


    A wrapper of the STL "map" container.

    Define a front-end to the STL "map" container that conforms to the
    IndexedContainerInterface. This is a full-fleged Object, so there are
    events, modification time, debug, and reference count information.

    Parameters:
    -----------

    TElementIdentifier:  A type that shall be used to index the container.
    It must have a < operator defined for ordering.

    TElement:  The element type stored in the container.

    C++ includes: itkMapContainer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkMapContainerULCIFCTI3FFULULULPF3MCULPF3 self) -> itkMapContainerULCIFCTI3FFULULULPF3MCULPF3
        __init__(itkMapContainerULCIFCTI3FFULULULPF3MCULPF3 self, std::less< unsigned long > const & comp) -> itkMapContainerULCIFCTI3FFULULULPF3MCULPF3



        A wrapper of the STL "map" container.

        Define a front-end to the STL "map" container that conforms to the
        IndexedContainerInterface. This is a full-fleged Object, so there are
        events, modification time, debug, and reference count information.

        Parameters:
        -----------

        TElementIdentifier:  A type that shall be used to index the container.
        It must have a < operator defined for ordering.

        TElement:  The element type stored in the container.

        C++ includes: itkMapContainer.h 
        """
        _itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_swiginit(self, _itkMeshBasePython.new_itkMapContainerULCIFCTI3FFULULULPF3MCULPF3(*args))

    def __New_orig__() -> "itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_Pointer":
        """__New_orig__() -> itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_Pointer"""
        return _itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_Pointer":
        """Clone(itkMapContainerULCIFCTI3FFULULULPF3MCULPF3 self) -> itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_Pointer"""
        return _itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_Clone(self)


    def CastToSTLContainer(self) -> "std::map< unsigned long,itkCellInterfaceFCTI3FFULULULPF3MCULPF3 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceFCTI3FFULULULPF3MCULPF3 * > > > &":
        """
        CastToSTLContainer(itkMapContainerULCIFCTI3FFULULULPF3MCULPF3 self) -> std::map< unsigned long,itkCellInterfaceFCTI3FFULULULPF3MCULPF3 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceFCTI3FFULULULPF3MCULPF3 * > > > &

        Cast the
        container to a STL container type 
        """
        return _itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_CastToSTLContainer(self)


    def CastToSTLConstContainer(self) -> "std::map< unsigned long,itkCellInterfaceFCTI3FFULULULPF3MCULPF3 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceFCTI3FFULULULPF3MCULPF3 * > > > const &":
        """
        CastToSTLConstContainer(itkMapContainerULCIFCTI3FFULULULPF3MCULPF3 self) -> std::map< unsigned long,itkCellInterfaceFCTI3FFULULULPF3MCULPF3 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceFCTI3FFULULULPF3MCULPF3 * > > > const &

        Cast the
        container to a const STL container type 
        """
        return _itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_CastToSTLConstContainer(self)


    def ElementAt(self, *args) -> "itkCellInterfaceFCTI3FFULULULPF3MCULPF3 *const &":
        """
        ElementAt(itkMapContainerULCIFCTI3FFULULULPF3MCULPF3 self, unsigned long arg0) -> itkCellInterfaceFCTI3FFULULULPF3MCULPF3
        ElementAt(itkMapContainerULCIFCTI3FFULULULPF3MCULPF3 self, unsigned long arg0) -> itkCellInterfaceFCTI3FFULULULPF3MCULPF3

        Get a reference to the
        element at the given index. 
        """
        return _itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_ElementAt(self, *args)


    def CreateElementAt(self, arg0: 'unsigned long') -> "itkCellInterfaceFCTI3FFULULULPF3MCULPF3 *&":
        """
        CreateElementAt(itkMapContainerULCIFCTI3FFULULULPF3MCULPF3 self, unsigned long arg0) -> itkCellInterfaceFCTI3FFULULULPF3MCULPF3 *&

        Get a reference to
        the element at the given index. If the index does not exist, it is
        created automatically.

        It is assumed that the value of the element is modified through the
        reference. 
        """
        return _itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_CreateElementAt(self, arg0)


    def GetElement(self, arg0: 'unsigned long') -> "itkCellInterfaceFCTI3FFULULULPF3MCULPF3 *":
        """
        GetElement(itkMapContainerULCIFCTI3FFULULULPF3MCULPF3 self, unsigned long arg0) -> itkCellInterfaceFCTI3FFULULULPF3MCULPF3

        Get the element at the
        specified index. There is no check for existence performed. 
        """
        return _itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_GetElement(self, arg0)


    def SetElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceFCTI3FFULULULPF3MCULPF3') -> "void":
        """
        SetElement(itkMapContainerULCIFCTI3FFULULULPF3MCULPF3 self, unsigned long arg0, itkCellInterfaceFCTI3FFULULULPF3MCULPF3 arg1)

        Set the given index
        value to the given element. If the index doesn't exist, it is
        automatically created. 
        """
        return _itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_SetElement(self, arg0, arg1)


    def InsertElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceFCTI3FFULULULPF3MCULPF3') -> "void":
        """
        InsertElement(itkMapContainerULCIFCTI3FFULULULPF3MCULPF3 self, unsigned long arg0, itkCellInterfaceFCTI3FFULULULPF3MCULPF3 arg1)

        Set the given index
        value to the given element. If the index doesn't exist, it is
        automatically created. 
        """
        return _itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_InsertElement(self, arg0, arg1)


    def IndexExists(self, arg0: 'unsigned long') -> "bool":
        """
        IndexExists(itkMapContainerULCIFCTI3FFULULULPF3MCULPF3 self, unsigned long arg0) -> bool

        Check if the STL map
        has an entry corresponding to the given index. The count will be
        either 1 or 0. 
        """
        return _itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_IndexExists(self, arg0)


    def GetElementIfIndexExists(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceFCTI3FFULULULPF3MCULPF3 **') -> "bool":
        """
        GetElementIfIndexExists(itkMapContainerULCIFCTI3FFULULULPF3MCULPF3 self, unsigned long arg0, itkCellInterfaceFCTI3FFULULULPF3MCULPF3 ** arg1) -> bool

        If the
        given index doesn't exist in the map, return false. Otherwise, set the
        element through the pointer (if it isn't null), and return true. 
        """
        return _itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_GetElementIfIndexExists(self, arg0, arg1)


    def CreateIndex(self, arg0: 'unsigned long') -> "void":
        """
        CreateIndex(itkMapContainerULCIFCTI3FFULULULPF3MCULPF3 self, unsigned long arg0)

        The map will create an
        entry for a given index through the indexing operator. Whether or not
        it is created, it will be assigned to the default element. 
        """
        return _itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_CreateIndex(self, arg0)


    def DeleteIndex(self, arg0: 'unsigned long') -> "void":
        """
        DeleteIndex(itkMapContainerULCIFCTI3FFULULULPF3MCULPF3 self, unsigned long arg0)

        Delete the entry in the
        STL map corresponding to the given identifier. If the entry does not
        exist, nothing happens. 
        """
        return _itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_DeleteIndex(self, arg0)


    def Size(self) -> "unsigned long":
        """
        Size(itkMapContainerULCIFCTI3FFULULULPF3MCULPF3 self) -> unsigned long

        Get the number of elements
        currently stored in the map. 
        """
        return _itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_Size(self)


    def Reserve(self, arg0: 'unsigned long') -> "void":
        """
        Reserve(itkMapContainerULCIFCTI3FFULULULPF3MCULPF3 self, unsigned long arg0)

        Tell the container to
        allocate enough memory to allow at least as many elements as the size
        given to be stored. This is NOT guaranteed to actually allocate any
        memory, but is useful if the implementation of the container allocates
        contiguous storage. 
        """
        return _itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_Reserve(self, arg0)


    def Squeeze(self) -> "void":
        """
        Squeeze(itkMapContainerULCIFCTI3FFULULULPF3MCULPF3 self)

        Tell the container to try
        to minimize its memory usage for storage of the current number of
        elements. This is NOT guaranteed to decrease memory usage. 
        """
        return _itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_Squeeze(self)


    def Initialize(self) -> "void":
        """
        Initialize(itkMapContainerULCIFCTI3FFULULULPF3MCULPF3 self)

        Tell the container to
        release any memory it may have allocated and return itself to its
        initial state. 
        """
        return _itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_Initialize(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkMapContainerULCIFCTI3FFULULULPF3MCULPF3

    def cast(obj: 'itkLightObject') -> "itkMapContainerULCIFCTI3FFULULULPF3MCULPF3 *":
        """cast(itkLightObject obj) -> itkMapContainerULCIFCTI3FFULULULPF3MCULPF3"""
        return _itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkMapContainerULCIFCTI3FFULULULPF3MCULPF3

        Create a new object of the class itkMapContainerULCIFCTI3FFULULULPF3MCULPF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMapContainerULCIFCTI3FFULULULPF3MCULPF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkMapContainerULCIFCTI3FFULULULPF3MCULPF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkMapContainerULCIFCTI3FFULULULPF3MCULPF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkMapContainerULCIFCTI3FFULULULPF3MCULPF3.Clone = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_Clone, None, itkMapContainerULCIFCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIFCTI3FFULULULPF3MCULPF3.CastToSTLContainer = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_CastToSTLContainer, None, itkMapContainerULCIFCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIFCTI3FFULULULPF3MCULPF3.CastToSTLConstContainer = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_CastToSTLConstContainer, None, itkMapContainerULCIFCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIFCTI3FFULULULPF3MCULPF3.ElementAt = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_ElementAt, None, itkMapContainerULCIFCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIFCTI3FFULULULPF3MCULPF3.CreateElementAt = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_CreateElementAt, None, itkMapContainerULCIFCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIFCTI3FFULULULPF3MCULPF3.GetElement = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_GetElement, None, itkMapContainerULCIFCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIFCTI3FFULULULPF3MCULPF3.SetElement = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_SetElement, None, itkMapContainerULCIFCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIFCTI3FFULULULPF3MCULPF3.InsertElement = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_InsertElement, None, itkMapContainerULCIFCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIFCTI3FFULULULPF3MCULPF3.IndexExists = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_IndexExists, None, itkMapContainerULCIFCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIFCTI3FFULULULPF3MCULPF3.GetElementIfIndexExists = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_GetElementIfIndexExists, None, itkMapContainerULCIFCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIFCTI3FFULULULPF3MCULPF3.CreateIndex = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_CreateIndex, None, itkMapContainerULCIFCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIFCTI3FFULULULPF3MCULPF3.DeleteIndex = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_DeleteIndex, None, itkMapContainerULCIFCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIFCTI3FFULULULPF3MCULPF3.Size = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_Size, None, itkMapContainerULCIFCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIFCTI3FFULULULPF3MCULPF3.Reserve = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_Reserve, None, itkMapContainerULCIFCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIFCTI3FFULULULPF3MCULPF3.Squeeze = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_Squeeze, None, itkMapContainerULCIFCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIFCTI3FFULULULPF3MCULPF3.Initialize = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_Initialize, None, itkMapContainerULCIFCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_swigregister = _itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_swigregister
itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_swigregister(itkMapContainerULCIFCTI3FFULULULPF3MCULPF3)

def itkMapContainerULCIFCTI3FFULULULPF3MCULPF3___New_orig__() -> "itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_Pointer":
    """itkMapContainerULCIFCTI3FFULULULPF3MCULPF3___New_orig__() -> itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_Pointer"""
    return _itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3___New_orig__()

def itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_cast(obj: 'itkLightObject') -> "itkMapContainerULCIFCTI3FFULULULPF3MCULPF3 *":
    """itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_cast(itkLightObject obj) -> itkMapContainerULCIFCTI3FFULULULPF3MCULPF3"""
    return _itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_cast(obj)

class itkMapContainerULCISSCTI2FFULULULPF2MCULPF2(ITKCommonBasePython.itkObject):
    """


    A wrapper of the STL "map" container.

    Define a front-end to the STL "map" container that conforms to the
    IndexedContainerInterface. This is a full-fleged Object, so there are
    events, modification time, debug, and reference count information.

    Parameters:
    -----------

    TElementIdentifier:  A type that shall be used to index the container.
    It must have a < operator defined for ordering.

    TElement:  The element type stored in the container.

    C++ includes: itkMapContainer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkMapContainerULCISSCTI2FFULULULPF2MCULPF2 self) -> itkMapContainerULCISSCTI2FFULULULPF2MCULPF2
        __init__(itkMapContainerULCISSCTI2FFULULULPF2MCULPF2 self, std::less< unsigned long > const & comp) -> itkMapContainerULCISSCTI2FFULULULPF2MCULPF2



        A wrapper of the STL "map" container.

        Define a front-end to the STL "map" container that conforms to the
        IndexedContainerInterface. This is a full-fleged Object, so there are
        events, modification time, debug, and reference count information.

        Parameters:
        -----------

        TElementIdentifier:  A type that shall be used to index the container.
        It must have a < operator defined for ordering.

        TElement:  The element type stored in the container.

        C++ includes: itkMapContainer.h 
        """
        _itkMeshBasePython.itkMapContainerULCISSCTI2FFULULULPF2MCULPF2_swiginit(self, _itkMeshBasePython.new_itkMapContainerULCISSCTI2FFULULULPF2MCULPF2(*args))

    def __New_orig__() -> "itkMapContainerULCISSCTI2FFULULULPF2MCULPF2_Pointer":
        """__New_orig__() -> itkMapContainerULCISSCTI2FFULULULPF2MCULPF2_Pointer"""
        return _itkMeshBasePython.itkMapContainerULCISSCTI2FFULULULPF2MCULPF2___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkMapContainerULCISSCTI2FFULULULPF2MCULPF2_Pointer":
        """Clone(itkMapContainerULCISSCTI2FFULULULPF2MCULPF2 self) -> itkMapContainerULCISSCTI2FFULULULPF2MCULPF2_Pointer"""
        return _itkMeshBasePython.itkMapContainerULCISSCTI2FFULULULPF2MCULPF2_Clone(self)


    def CastToSTLContainer(self) -> "std::map< unsigned long,itkCellInterfaceSSCTI2FFULULULPF2MCULPF2 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceSSCTI2FFULULULPF2MCULPF2 * > > > &":
        """
        CastToSTLContainer(itkMapContainerULCISSCTI2FFULULULPF2MCULPF2 self) -> std::map< unsigned long,itkCellInterfaceSSCTI2FFULULULPF2MCULPF2 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceSSCTI2FFULULULPF2MCULPF2 * > > > &

        Cast the
        container to a STL container type 
        """
        return _itkMeshBasePython.itkMapContainerULCISSCTI2FFULULULPF2MCULPF2_CastToSTLContainer(self)


    def CastToSTLConstContainer(self) -> "std::map< unsigned long,itkCellInterfaceSSCTI2FFULULULPF2MCULPF2 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceSSCTI2FFULULULPF2MCULPF2 * > > > const &":
        """
        CastToSTLConstContainer(itkMapContainerULCISSCTI2FFULULULPF2MCULPF2 self) -> std::map< unsigned long,itkCellInterfaceSSCTI2FFULULULPF2MCULPF2 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceSSCTI2FFULULULPF2MCULPF2 * > > > const &

        Cast the
        container to a const STL container type 
        """
        return _itkMeshBasePython.itkMapContainerULCISSCTI2FFULULULPF2MCULPF2_CastToSTLConstContainer(self)


    def ElementAt(self, *args) -> "itkCellInterfaceSSCTI2FFULULULPF2MCULPF2 *const &":
        """
        ElementAt(itkMapContainerULCISSCTI2FFULULULPF2MCULPF2 self, unsigned long arg0) -> itkCellInterfaceSSCTI2FFULULULPF2MCULPF2
        ElementAt(itkMapContainerULCISSCTI2FFULULULPF2MCULPF2 self, unsigned long arg0) -> itkCellInterfaceSSCTI2FFULULULPF2MCULPF2

        Get a reference to the
        element at the given index. 
        """
        return _itkMeshBasePython.itkMapContainerULCISSCTI2FFULULULPF2MCULPF2_ElementAt(self, *args)


    def CreateElementAt(self, arg0: 'unsigned long') -> "itkCellInterfaceSSCTI2FFULULULPF2MCULPF2 *&":
        """
        CreateElementAt(itkMapContainerULCISSCTI2FFULULULPF2MCULPF2 self, unsigned long arg0) -> itkCellInterfaceSSCTI2FFULULULPF2MCULPF2 *&

        Get a reference to
        the element at the given index. If the index does not exist, it is
        created automatically.

        It is assumed that the value of the element is modified through the
        reference. 
        """
        return _itkMeshBasePython.itkMapContainerULCISSCTI2FFULULULPF2MCULPF2_CreateElementAt(self, arg0)


    def GetElement(self, arg0: 'unsigned long') -> "itkCellInterfaceSSCTI2FFULULULPF2MCULPF2 *":
        """
        GetElement(itkMapContainerULCISSCTI2FFULULULPF2MCULPF2 self, unsigned long arg0) -> itkCellInterfaceSSCTI2FFULULULPF2MCULPF2

        Get the element at the
        specified index. There is no check for existence performed. 
        """
        return _itkMeshBasePython.itkMapContainerULCISSCTI2FFULULULPF2MCULPF2_GetElement(self, arg0)


    def SetElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceSSCTI2FFULULULPF2MCULPF2') -> "void":
        """
        SetElement(itkMapContainerULCISSCTI2FFULULULPF2MCULPF2 self, unsigned long arg0, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2 arg1)

        Set the given index
        value to the given element. If the index doesn't exist, it is
        automatically created. 
        """
        return _itkMeshBasePython.itkMapContainerULCISSCTI2FFULULULPF2MCULPF2_SetElement(self, arg0, arg1)


    def InsertElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceSSCTI2FFULULULPF2MCULPF2') -> "void":
        """
        InsertElement(itkMapContainerULCISSCTI2FFULULULPF2MCULPF2 self, unsigned long arg0, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2 arg1)

        Set the given index
        value to the given element. If the index doesn't exist, it is
        automatically created. 
        """
        return _itkMeshBasePython.itkMapContainerULCISSCTI2FFULULULPF2MCULPF2_InsertElement(self, arg0, arg1)


    def IndexExists(self, arg0: 'unsigned long') -> "bool":
        """
        IndexExists(itkMapContainerULCISSCTI2FFULULULPF2MCULPF2 self, unsigned long arg0) -> bool

        Check if the STL map
        has an entry corresponding to the given index. The count will be
        either 1 or 0. 
        """
        return _itkMeshBasePython.itkMapContainerULCISSCTI2FFULULULPF2MCULPF2_IndexExists(self, arg0)


    def GetElementIfIndexExists(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceSSCTI2FFULULULPF2MCULPF2 **') -> "bool":
        """
        GetElementIfIndexExists(itkMapContainerULCISSCTI2FFULULULPF2MCULPF2 self, unsigned long arg0, itkCellInterfaceSSCTI2FFULULULPF2MCULPF2 ** arg1) -> bool

        If the
        given index doesn't exist in the map, return false. Otherwise, set the
        element through the pointer (if it isn't null), and return true. 
        """
        return _itkMeshBasePython.itkMapContainerULCISSCTI2FFULULULPF2MCULPF2_GetElementIfIndexExists(self, arg0, arg1)


    def CreateIndex(self, arg0: 'unsigned long') -> "void":
        """
        CreateIndex(itkMapContainerULCISSCTI2FFULULULPF2MCULPF2 self, unsigned long arg0)

        The map will create an
        entry for a given index through the indexing operator. Whether or not
        it is created, it will be assigned to the default element. 
        """
        return _itkMeshBasePython.itkMapContainerULCISSCTI2FFULULULPF2MCULPF2_CreateIndex(self, arg0)


    def DeleteIndex(self, arg0: 'unsigned long') -> "void":
        """
        DeleteIndex(itkMapContainerULCISSCTI2FFULULULPF2MCULPF2 self, unsigned long arg0)

        Delete the entry in the
        STL map corresponding to the given identifier. If the entry does not
        exist, nothing happens. 
        """
        return _itkMeshBasePython.itkMapContainerULCISSCTI2FFULULULPF2MCULPF2_DeleteIndex(self, arg0)


    def Size(self) -> "unsigned long":
        """
        Size(itkMapContainerULCISSCTI2FFULULULPF2MCULPF2 self) -> unsigned long

        Get the number of elements
        currently stored in the map. 
        """
        return _itkMeshBasePython.itkMapContainerULCISSCTI2FFULULULPF2MCULPF2_Size(self)


    def Reserve(self, arg0: 'unsigned long') -> "void":
        """
        Reserve(itkMapContainerULCISSCTI2FFULULULPF2MCULPF2 self, unsigned long arg0)

        Tell the container to
        allocate enough memory to allow at least as many elements as the size
        given to be stored. This is NOT guaranteed to actually allocate any
        memory, but is useful if the implementation of the container allocates
        contiguous storage. 
        """
        return _itkMeshBasePython.itkMapContainerULCISSCTI2FFULULULPF2MCULPF2_Reserve(self, arg0)


    def Squeeze(self) -> "void":
        """
        Squeeze(itkMapContainerULCISSCTI2FFULULULPF2MCULPF2 self)

        Tell the container to try
        to minimize its memory usage for storage of the current number of
        elements. This is NOT guaranteed to decrease memory usage. 
        """
        return _itkMeshBasePython.itkMapContainerULCISSCTI2FFULULULPF2MCULPF2_Squeeze(self)


    def Initialize(self) -> "void":
        """
        Initialize(itkMapContainerULCISSCTI2FFULULULPF2MCULPF2 self)

        Tell the container to
        release any memory it may have allocated and return itself to its
        initial state. 
        """
        return _itkMeshBasePython.itkMapContainerULCISSCTI2FFULULULPF2MCULPF2_Initialize(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkMapContainerULCISSCTI2FFULULULPF2MCULPF2

    def cast(obj: 'itkLightObject') -> "itkMapContainerULCISSCTI2FFULULULPF2MCULPF2 *":
        """cast(itkLightObject obj) -> itkMapContainerULCISSCTI2FFULULULPF2MCULPF2"""
        return _itkMeshBasePython.itkMapContainerULCISSCTI2FFULULULPF2MCULPF2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkMapContainerULCISSCTI2FFULULULPF2MCULPF2

        Create a new object of the class itkMapContainerULCISSCTI2FFULULULPF2MCULPF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMapContainerULCISSCTI2FFULULULPF2MCULPF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkMapContainerULCISSCTI2FFULULULPF2MCULPF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkMapContainerULCISSCTI2FFULULULPF2MCULPF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkMapContainerULCISSCTI2FFULULULPF2MCULPF2.Clone = new_instancemethod(_itkMeshBasePython.itkMapContainerULCISSCTI2FFULULULPF2MCULPF2_Clone, None, itkMapContainerULCISSCTI2FFULULULPF2MCULPF2)
itkMapContainerULCISSCTI2FFULULULPF2MCULPF2.CastToSTLContainer = new_instancemethod(_itkMeshBasePython.itkMapContainerULCISSCTI2FFULULULPF2MCULPF2_CastToSTLContainer, None, itkMapContainerULCISSCTI2FFULULULPF2MCULPF2)
itkMapContainerULCISSCTI2FFULULULPF2MCULPF2.CastToSTLConstContainer = new_instancemethod(_itkMeshBasePython.itkMapContainerULCISSCTI2FFULULULPF2MCULPF2_CastToSTLConstContainer, None, itkMapContainerULCISSCTI2FFULULULPF2MCULPF2)
itkMapContainerULCISSCTI2FFULULULPF2MCULPF2.ElementAt = new_instancemethod(_itkMeshBasePython.itkMapContainerULCISSCTI2FFULULULPF2MCULPF2_ElementAt, None, itkMapContainerULCISSCTI2FFULULULPF2MCULPF2)
itkMapContainerULCISSCTI2FFULULULPF2MCULPF2.CreateElementAt = new_instancemethod(_itkMeshBasePython.itkMapContainerULCISSCTI2FFULULULPF2MCULPF2_CreateElementAt, None, itkMapContainerULCISSCTI2FFULULULPF2MCULPF2)
itkMapContainerULCISSCTI2FFULULULPF2MCULPF2.GetElement = new_instancemethod(_itkMeshBasePython.itkMapContainerULCISSCTI2FFULULULPF2MCULPF2_GetElement, None, itkMapContainerULCISSCTI2FFULULULPF2MCULPF2)
itkMapContainerULCISSCTI2FFULULULPF2MCULPF2.SetElement = new_instancemethod(_itkMeshBasePython.itkMapContainerULCISSCTI2FFULULULPF2MCULPF2_SetElement, None, itkMapContainerULCISSCTI2FFULULULPF2MCULPF2)
itkMapContainerULCISSCTI2FFULULULPF2MCULPF2.InsertElement = new_instancemethod(_itkMeshBasePython.itkMapContainerULCISSCTI2FFULULULPF2MCULPF2_InsertElement, None, itkMapContainerULCISSCTI2FFULULULPF2MCULPF2)
itkMapContainerULCISSCTI2FFULULULPF2MCULPF2.IndexExists = new_instancemethod(_itkMeshBasePython.itkMapContainerULCISSCTI2FFULULULPF2MCULPF2_IndexExists, None, itkMapContainerULCISSCTI2FFULULULPF2MCULPF2)
itkMapContainerULCISSCTI2FFULULULPF2MCULPF2.GetElementIfIndexExists = new_instancemethod(_itkMeshBasePython.itkMapContainerULCISSCTI2FFULULULPF2MCULPF2_GetElementIfIndexExists, None, itkMapContainerULCISSCTI2FFULULULPF2MCULPF2)
itkMapContainerULCISSCTI2FFULULULPF2MCULPF2.CreateIndex = new_instancemethod(_itkMeshBasePython.itkMapContainerULCISSCTI2FFULULULPF2MCULPF2_CreateIndex, None, itkMapContainerULCISSCTI2FFULULULPF2MCULPF2)
itkMapContainerULCISSCTI2FFULULULPF2MCULPF2.DeleteIndex = new_instancemethod(_itkMeshBasePython.itkMapContainerULCISSCTI2FFULULULPF2MCULPF2_DeleteIndex, None, itkMapContainerULCISSCTI2FFULULULPF2MCULPF2)
itkMapContainerULCISSCTI2FFULULULPF2MCULPF2.Size = new_instancemethod(_itkMeshBasePython.itkMapContainerULCISSCTI2FFULULULPF2MCULPF2_Size, None, itkMapContainerULCISSCTI2FFULULULPF2MCULPF2)
itkMapContainerULCISSCTI2FFULULULPF2MCULPF2.Reserve = new_instancemethod(_itkMeshBasePython.itkMapContainerULCISSCTI2FFULULULPF2MCULPF2_Reserve, None, itkMapContainerULCISSCTI2FFULULULPF2MCULPF2)
itkMapContainerULCISSCTI2FFULULULPF2MCULPF2.Squeeze = new_instancemethod(_itkMeshBasePython.itkMapContainerULCISSCTI2FFULULULPF2MCULPF2_Squeeze, None, itkMapContainerULCISSCTI2FFULULULPF2MCULPF2)
itkMapContainerULCISSCTI2FFULULULPF2MCULPF2.Initialize = new_instancemethod(_itkMeshBasePython.itkMapContainerULCISSCTI2FFULULULPF2MCULPF2_Initialize, None, itkMapContainerULCISSCTI2FFULULULPF2MCULPF2)
itkMapContainerULCISSCTI2FFULULULPF2MCULPF2_swigregister = _itkMeshBasePython.itkMapContainerULCISSCTI2FFULULULPF2MCULPF2_swigregister
itkMapContainerULCISSCTI2FFULULULPF2MCULPF2_swigregister(itkMapContainerULCISSCTI2FFULULULPF2MCULPF2)

def itkMapContainerULCISSCTI2FFULULULPF2MCULPF2___New_orig__() -> "itkMapContainerULCISSCTI2FFULULULPF2MCULPF2_Pointer":
    """itkMapContainerULCISSCTI2FFULULULPF2MCULPF2___New_orig__() -> itkMapContainerULCISSCTI2FFULULULPF2MCULPF2_Pointer"""
    return _itkMeshBasePython.itkMapContainerULCISSCTI2FFULULULPF2MCULPF2___New_orig__()

def itkMapContainerULCISSCTI2FFULULULPF2MCULPF2_cast(obj: 'itkLightObject') -> "itkMapContainerULCISSCTI2FFULULULPF2MCULPF2 *":
    """itkMapContainerULCISSCTI2FFULULULPF2MCULPF2_cast(itkLightObject obj) -> itkMapContainerULCISSCTI2FFULULULPF2MCULPF2"""
    return _itkMeshBasePython.itkMapContainerULCISSCTI2FFULULULPF2MCULPF2_cast(obj)

class itkMapContainerULCISSCTI3FFULULULPF3MCULPF3(ITKCommonBasePython.itkObject):
    """


    A wrapper of the STL "map" container.

    Define a front-end to the STL "map" container that conforms to the
    IndexedContainerInterface. This is a full-fleged Object, so there are
    events, modification time, debug, and reference count information.

    Parameters:
    -----------

    TElementIdentifier:  A type that shall be used to index the container.
    It must have a < operator defined for ordering.

    TElement:  The element type stored in the container.

    C++ includes: itkMapContainer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkMapContainerULCISSCTI3FFULULULPF3MCULPF3 self) -> itkMapContainerULCISSCTI3FFULULULPF3MCULPF3
        __init__(itkMapContainerULCISSCTI3FFULULULPF3MCULPF3 self, std::less< unsigned long > const & comp) -> itkMapContainerULCISSCTI3FFULULULPF3MCULPF3



        A wrapper of the STL "map" container.

        Define a front-end to the STL "map" container that conforms to the
        IndexedContainerInterface. This is a full-fleged Object, so there are
        events, modification time, debug, and reference count information.

        Parameters:
        -----------

        TElementIdentifier:  A type that shall be used to index the container.
        It must have a < operator defined for ordering.

        TElement:  The element type stored in the container.

        C++ includes: itkMapContainer.h 
        """
        _itkMeshBasePython.itkMapContainerULCISSCTI3FFULULULPF3MCULPF3_swiginit(self, _itkMeshBasePython.new_itkMapContainerULCISSCTI3FFULULULPF3MCULPF3(*args))

    def __New_orig__() -> "itkMapContainerULCISSCTI3FFULULULPF3MCULPF3_Pointer":
        """__New_orig__() -> itkMapContainerULCISSCTI3FFULULULPF3MCULPF3_Pointer"""
        return _itkMeshBasePython.itkMapContainerULCISSCTI3FFULULULPF3MCULPF3___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkMapContainerULCISSCTI3FFULULULPF3MCULPF3_Pointer":
        """Clone(itkMapContainerULCISSCTI3FFULULULPF3MCULPF3 self) -> itkMapContainerULCISSCTI3FFULULULPF3MCULPF3_Pointer"""
        return _itkMeshBasePython.itkMapContainerULCISSCTI3FFULULULPF3MCULPF3_Clone(self)


    def CastToSTLContainer(self) -> "std::map< unsigned long,itkCellInterfaceSSCTI3FFULULULPF3MCULPF3 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceSSCTI3FFULULULPF3MCULPF3 * > > > &":
        """
        CastToSTLContainer(itkMapContainerULCISSCTI3FFULULULPF3MCULPF3 self) -> std::map< unsigned long,itkCellInterfaceSSCTI3FFULULULPF3MCULPF3 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceSSCTI3FFULULULPF3MCULPF3 * > > > &

        Cast the
        container to a STL container type 
        """
        return _itkMeshBasePython.itkMapContainerULCISSCTI3FFULULULPF3MCULPF3_CastToSTLContainer(self)


    def CastToSTLConstContainer(self) -> "std::map< unsigned long,itkCellInterfaceSSCTI3FFULULULPF3MCULPF3 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceSSCTI3FFULULULPF3MCULPF3 * > > > const &":
        """
        CastToSTLConstContainer(itkMapContainerULCISSCTI3FFULULULPF3MCULPF3 self) -> std::map< unsigned long,itkCellInterfaceSSCTI3FFULULULPF3MCULPF3 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceSSCTI3FFULULULPF3MCULPF3 * > > > const &

        Cast the
        container to a const STL container type 
        """
        return _itkMeshBasePython.itkMapContainerULCISSCTI3FFULULULPF3MCULPF3_CastToSTLConstContainer(self)


    def ElementAt(self, *args) -> "itkCellInterfaceSSCTI3FFULULULPF3MCULPF3 *const &":
        """
        ElementAt(itkMapContainerULCISSCTI3FFULULULPF3MCULPF3 self, unsigned long arg0) -> itkCellInterfaceSSCTI3FFULULULPF3MCULPF3
        ElementAt(itkMapContainerULCISSCTI3FFULULULPF3MCULPF3 self, unsigned long arg0) -> itkCellInterfaceSSCTI3FFULULULPF3MCULPF3

        Get a reference to the
        element at the given index. 
        """
        return _itkMeshBasePython.itkMapContainerULCISSCTI3FFULULULPF3MCULPF3_ElementAt(self, *args)


    def CreateElementAt(self, arg0: 'unsigned long') -> "itkCellInterfaceSSCTI3FFULULULPF3MCULPF3 *&":
        """
        CreateElementAt(itkMapContainerULCISSCTI3FFULULULPF3MCULPF3 self, unsigned long arg0) -> itkCellInterfaceSSCTI3FFULULULPF3MCULPF3 *&

        Get a reference to
        the element at the given index. If the index does not exist, it is
        created automatically.

        It is assumed that the value of the element is modified through the
        reference. 
        """
        return _itkMeshBasePython.itkMapContainerULCISSCTI3FFULULULPF3MCULPF3_CreateElementAt(self, arg0)


    def GetElement(self, arg0: 'unsigned long') -> "itkCellInterfaceSSCTI3FFULULULPF3MCULPF3 *":
        """
        GetElement(itkMapContainerULCISSCTI3FFULULULPF3MCULPF3 self, unsigned long arg0) -> itkCellInterfaceSSCTI3FFULULULPF3MCULPF3

        Get the element at the
        specified index. There is no check for existence performed. 
        """
        return _itkMeshBasePython.itkMapContainerULCISSCTI3FFULULULPF3MCULPF3_GetElement(self, arg0)


    def SetElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceSSCTI3FFULULULPF3MCULPF3') -> "void":
        """
        SetElement(itkMapContainerULCISSCTI3FFULULULPF3MCULPF3 self, unsigned long arg0, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3 arg1)

        Set the given index
        value to the given element. If the index doesn't exist, it is
        automatically created. 
        """
        return _itkMeshBasePython.itkMapContainerULCISSCTI3FFULULULPF3MCULPF3_SetElement(self, arg0, arg1)


    def InsertElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceSSCTI3FFULULULPF3MCULPF3') -> "void":
        """
        InsertElement(itkMapContainerULCISSCTI3FFULULULPF3MCULPF3 self, unsigned long arg0, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3 arg1)

        Set the given index
        value to the given element. If the index doesn't exist, it is
        automatically created. 
        """
        return _itkMeshBasePython.itkMapContainerULCISSCTI3FFULULULPF3MCULPF3_InsertElement(self, arg0, arg1)


    def IndexExists(self, arg0: 'unsigned long') -> "bool":
        """
        IndexExists(itkMapContainerULCISSCTI3FFULULULPF3MCULPF3 self, unsigned long arg0) -> bool

        Check if the STL map
        has an entry corresponding to the given index. The count will be
        either 1 or 0. 
        """
        return _itkMeshBasePython.itkMapContainerULCISSCTI3FFULULULPF3MCULPF3_IndexExists(self, arg0)


    def GetElementIfIndexExists(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceSSCTI3FFULULULPF3MCULPF3 **') -> "bool":
        """
        GetElementIfIndexExists(itkMapContainerULCISSCTI3FFULULULPF3MCULPF3 self, unsigned long arg0, itkCellInterfaceSSCTI3FFULULULPF3MCULPF3 ** arg1) -> bool

        If the
        given index doesn't exist in the map, return false. Otherwise, set the
        element through the pointer (if it isn't null), and return true. 
        """
        return _itkMeshBasePython.itkMapContainerULCISSCTI3FFULULULPF3MCULPF3_GetElementIfIndexExists(self, arg0, arg1)


    def CreateIndex(self, arg0: 'unsigned long') -> "void":
        """
        CreateIndex(itkMapContainerULCISSCTI3FFULULULPF3MCULPF3 self, unsigned long arg0)

        The map will create an
        entry for a given index through the indexing operator. Whether or not
        it is created, it will be assigned to the default element. 
        """
        return _itkMeshBasePython.itkMapContainerULCISSCTI3FFULULULPF3MCULPF3_CreateIndex(self, arg0)


    def DeleteIndex(self, arg0: 'unsigned long') -> "void":
        """
        DeleteIndex(itkMapContainerULCISSCTI3FFULULULPF3MCULPF3 self, unsigned long arg0)

        Delete the entry in the
        STL map corresponding to the given identifier. If the entry does not
        exist, nothing happens. 
        """
        return _itkMeshBasePython.itkMapContainerULCISSCTI3FFULULULPF3MCULPF3_DeleteIndex(self, arg0)


    def Size(self) -> "unsigned long":
        """
        Size(itkMapContainerULCISSCTI3FFULULULPF3MCULPF3 self) -> unsigned long

        Get the number of elements
        currently stored in the map. 
        """
        return _itkMeshBasePython.itkMapContainerULCISSCTI3FFULULULPF3MCULPF3_Size(self)


    def Reserve(self, arg0: 'unsigned long') -> "void":
        """
        Reserve(itkMapContainerULCISSCTI3FFULULULPF3MCULPF3 self, unsigned long arg0)

        Tell the container to
        allocate enough memory to allow at least as many elements as the size
        given to be stored. This is NOT guaranteed to actually allocate any
        memory, but is useful if the implementation of the container allocates
        contiguous storage. 
        """
        return _itkMeshBasePython.itkMapContainerULCISSCTI3FFULULULPF3MCULPF3_Reserve(self, arg0)


    def Squeeze(self) -> "void":
        """
        Squeeze(itkMapContainerULCISSCTI3FFULULULPF3MCULPF3 self)

        Tell the container to try
        to minimize its memory usage for storage of the current number of
        elements. This is NOT guaranteed to decrease memory usage. 
        """
        return _itkMeshBasePython.itkMapContainerULCISSCTI3FFULULULPF3MCULPF3_Squeeze(self)


    def Initialize(self) -> "void":
        """
        Initialize(itkMapContainerULCISSCTI3FFULULULPF3MCULPF3 self)

        Tell the container to
        release any memory it may have allocated and return itself to its
        initial state. 
        """
        return _itkMeshBasePython.itkMapContainerULCISSCTI3FFULULULPF3MCULPF3_Initialize(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkMapContainerULCISSCTI3FFULULULPF3MCULPF3

    def cast(obj: 'itkLightObject') -> "itkMapContainerULCISSCTI3FFULULULPF3MCULPF3 *":
        """cast(itkLightObject obj) -> itkMapContainerULCISSCTI3FFULULULPF3MCULPF3"""
        return _itkMeshBasePython.itkMapContainerULCISSCTI3FFULULULPF3MCULPF3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkMapContainerULCISSCTI3FFULULULPF3MCULPF3

        Create a new object of the class itkMapContainerULCISSCTI3FFULULULPF3MCULPF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMapContainerULCISSCTI3FFULULULPF3MCULPF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkMapContainerULCISSCTI3FFULULULPF3MCULPF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkMapContainerULCISSCTI3FFULULULPF3MCULPF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkMapContainerULCISSCTI3FFULULULPF3MCULPF3.Clone = new_instancemethod(_itkMeshBasePython.itkMapContainerULCISSCTI3FFULULULPF3MCULPF3_Clone, None, itkMapContainerULCISSCTI3FFULULULPF3MCULPF3)
itkMapContainerULCISSCTI3FFULULULPF3MCULPF3.CastToSTLContainer = new_instancemethod(_itkMeshBasePython.itkMapContainerULCISSCTI3FFULULULPF3MCULPF3_CastToSTLContainer, None, itkMapContainerULCISSCTI3FFULULULPF3MCULPF3)
itkMapContainerULCISSCTI3FFULULULPF3MCULPF3.CastToSTLConstContainer = new_instancemethod(_itkMeshBasePython.itkMapContainerULCISSCTI3FFULULULPF3MCULPF3_CastToSTLConstContainer, None, itkMapContainerULCISSCTI3FFULULULPF3MCULPF3)
itkMapContainerULCISSCTI3FFULULULPF3MCULPF3.ElementAt = new_instancemethod(_itkMeshBasePython.itkMapContainerULCISSCTI3FFULULULPF3MCULPF3_ElementAt, None, itkMapContainerULCISSCTI3FFULULULPF3MCULPF3)
itkMapContainerULCISSCTI3FFULULULPF3MCULPF3.CreateElementAt = new_instancemethod(_itkMeshBasePython.itkMapContainerULCISSCTI3FFULULULPF3MCULPF3_CreateElementAt, None, itkMapContainerULCISSCTI3FFULULULPF3MCULPF3)
itkMapContainerULCISSCTI3FFULULULPF3MCULPF3.GetElement = new_instancemethod(_itkMeshBasePython.itkMapContainerULCISSCTI3FFULULULPF3MCULPF3_GetElement, None, itkMapContainerULCISSCTI3FFULULULPF3MCULPF3)
itkMapContainerULCISSCTI3FFULULULPF3MCULPF3.SetElement = new_instancemethod(_itkMeshBasePython.itkMapContainerULCISSCTI3FFULULULPF3MCULPF3_SetElement, None, itkMapContainerULCISSCTI3FFULULULPF3MCULPF3)
itkMapContainerULCISSCTI3FFULULULPF3MCULPF3.InsertElement = new_instancemethod(_itkMeshBasePython.itkMapContainerULCISSCTI3FFULULULPF3MCULPF3_InsertElement, None, itkMapContainerULCISSCTI3FFULULULPF3MCULPF3)
itkMapContainerULCISSCTI3FFULULULPF3MCULPF3.IndexExists = new_instancemethod(_itkMeshBasePython.itkMapContainerULCISSCTI3FFULULULPF3MCULPF3_IndexExists, None, itkMapContainerULCISSCTI3FFULULULPF3MCULPF3)
itkMapContainerULCISSCTI3FFULULULPF3MCULPF3.GetElementIfIndexExists = new_instancemethod(_itkMeshBasePython.itkMapContainerULCISSCTI3FFULULULPF3MCULPF3_GetElementIfIndexExists, None, itkMapContainerULCISSCTI3FFULULULPF3MCULPF3)
itkMapContainerULCISSCTI3FFULULULPF3MCULPF3.CreateIndex = new_instancemethod(_itkMeshBasePython.itkMapContainerULCISSCTI3FFULULULPF3MCULPF3_CreateIndex, None, itkMapContainerULCISSCTI3FFULULULPF3MCULPF3)
itkMapContainerULCISSCTI3FFULULULPF3MCULPF3.DeleteIndex = new_instancemethod(_itkMeshBasePython.itkMapContainerULCISSCTI3FFULULULPF3MCULPF3_DeleteIndex, None, itkMapContainerULCISSCTI3FFULULULPF3MCULPF3)
itkMapContainerULCISSCTI3FFULULULPF3MCULPF3.Size = new_instancemethod(_itkMeshBasePython.itkMapContainerULCISSCTI3FFULULULPF3MCULPF3_Size, None, itkMapContainerULCISSCTI3FFULULULPF3MCULPF3)
itkMapContainerULCISSCTI3FFULULULPF3MCULPF3.Reserve = new_instancemethod(_itkMeshBasePython.itkMapContainerULCISSCTI3FFULULULPF3MCULPF3_Reserve, None, itkMapContainerULCISSCTI3FFULULULPF3MCULPF3)
itkMapContainerULCISSCTI3FFULULULPF3MCULPF3.Squeeze = new_instancemethod(_itkMeshBasePython.itkMapContainerULCISSCTI3FFULULULPF3MCULPF3_Squeeze, None, itkMapContainerULCISSCTI3FFULULULPF3MCULPF3)
itkMapContainerULCISSCTI3FFULULULPF3MCULPF3.Initialize = new_instancemethod(_itkMeshBasePython.itkMapContainerULCISSCTI3FFULULULPF3MCULPF3_Initialize, None, itkMapContainerULCISSCTI3FFULULULPF3MCULPF3)
itkMapContainerULCISSCTI3FFULULULPF3MCULPF3_swigregister = _itkMeshBasePython.itkMapContainerULCISSCTI3FFULULULPF3MCULPF3_swigregister
itkMapContainerULCISSCTI3FFULULULPF3MCULPF3_swigregister(itkMapContainerULCISSCTI3FFULULULPF3MCULPF3)

def itkMapContainerULCISSCTI3FFULULULPF3MCULPF3___New_orig__() -> "itkMapContainerULCISSCTI3FFULULULPF3MCULPF3_Pointer":
    """itkMapContainerULCISSCTI3FFULULULPF3MCULPF3___New_orig__() -> itkMapContainerULCISSCTI3FFULULULPF3MCULPF3_Pointer"""
    return _itkMeshBasePython.itkMapContainerULCISSCTI3FFULULULPF3MCULPF3___New_orig__()

def itkMapContainerULCISSCTI3FFULULULPF3MCULPF3_cast(obj: 'itkLightObject') -> "itkMapContainerULCISSCTI3FFULULULPF3MCULPF3 *":
    """itkMapContainerULCISSCTI3FFULULULPF3MCULPF3_cast(itkLightObject obj) -> itkMapContainerULCISSCTI3FFULULULPF3MCULPF3"""
    return _itkMeshBasePython.itkMapContainerULCISSCTI3FFULULULPF3MCULPF3_cast(obj)

class itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2(ITKCommonBasePython.itkObject):
    """


    A wrapper of the STL "map" container.

    Define a front-end to the STL "map" container that conforms to the
    IndexedContainerInterface. This is a full-fleged Object, so there are
    events, modification time, debug, and reference count information.

    Parameters:
    -----------

    TElementIdentifier:  A type that shall be used to index the container.
    It must have a < operator defined for ordering.

    TElement:  The element type stored in the container.

    C++ includes: itkMapContainer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2 self) -> itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2
        __init__(itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2 self, std::less< unsigned long > const & comp) -> itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2



        A wrapper of the STL "map" container.

        Define a front-end to the STL "map" container that conforms to the
        IndexedContainerInterface. This is a full-fleged Object, so there are
        events, modification time, debug, and reference count information.

        Parameters:
        -----------

        TElementIdentifier:  A type that shall be used to index the container.
        It must have a < operator defined for ordering.

        TElement:  The element type stored in the container.

        C++ includes: itkMapContainer.h 
        """
        _itkMeshBasePython.itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2_swiginit(self, _itkMeshBasePython.new_itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2(*args))

    def __New_orig__() -> "itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2_Pointer":
        """__New_orig__() -> itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2_Pointer"""
        return _itkMeshBasePython.itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2_Pointer":
        """Clone(itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2 self) -> itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2_Pointer"""
        return _itkMeshBasePython.itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2_Clone(self)


    def CastToSTLContainer(self) -> "std::map< unsigned long,itkCellInterfaceUCCTI2FFULULULPF2MCULPF2 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceUCCTI2FFULULULPF2MCULPF2 * > > > &":
        """
        CastToSTLContainer(itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2 self) -> std::map< unsigned long,itkCellInterfaceUCCTI2FFULULULPF2MCULPF2 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceUCCTI2FFULULULPF2MCULPF2 * > > > &

        Cast the
        container to a STL container type 
        """
        return _itkMeshBasePython.itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2_CastToSTLContainer(self)


    def CastToSTLConstContainer(self) -> "std::map< unsigned long,itkCellInterfaceUCCTI2FFULULULPF2MCULPF2 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceUCCTI2FFULULULPF2MCULPF2 * > > > const &":
        """
        CastToSTLConstContainer(itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2 self) -> std::map< unsigned long,itkCellInterfaceUCCTI2FFULULULPF2MCULPF2 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceUCCTI2FFULULULPF2MCULPF2 * > > > const &

        Cast the
        container to a const STL container type 
        """
        return _itkMeshBasePython.itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2_CastToSTLConstContainer(self)


    def ElementAt(self, *args) -> "itkCellInterfaceUCCTI2FFULULULPF2MCULPF2 *const &":
        """
        ElementAt(itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2 self, unsigned long arg0) -> itkCellInterfaceUCCTI2FFULULULPF2MCULPF2
        ElementAt(itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2 self, unsigned long arg0) -> itkCellInterfaceUCCTI2FFULULULPF2MCULPF2

        Get a reference to the
        element at the given index. 
        """
        return _itkMeshBasePython.itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2_ElementAt(self, *args)


    def CreateElementAt(self, arg0: 'unsigned long') -> "itkCellInterfaceUCCTI2FFULULULPF2MCULPF2 *&":
        """
        CreateElementAt(itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2 self, unsigned long arg0) -> itkCellInterfaceUCCTI2FFULULULPF2MCULPF2 *&

        Get a reference to
        the element at the given index. If the index does not exist, it is
        created automatically.

        It is assumed that the value of the element is modified through the
        reference. 
        """
        return _itkMeshBasePython.itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2_CreateElementAt(self, arg0)


    def GetElement(self, arg0: 'unsigned long') -> "itkCellInterfaceUCCTI2FFULULULPF2MCULPF2 *":
        """
        GetElement(itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2 self, unsigned long arg0) -> itkCellInterfaceUCCTI2FFULULULPF2MCULPF2

        Get the element at the
        specified index. There is no check for existence performed. 
        """
        return _itkMeshBasePython.itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2_GetElement(self, arg0)


    def SetElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceUCCTI2FFULULULPF2MCULPF2') -> "void":
        """
        SetElement(itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2 self, unsigned long arg0, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2 arg1)

        Set the given index
        value to the given element. If the index doesn't exist, it is
        automatically created. 
        """
        return _itkMeshBasePython.itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2_SetElement(self, arg0, arg1)


    def InsertElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceUCCTI2FFULULULPF2MCULPF2') -> "void":
        """
        InsertElement(itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2 self, unsigned long arg0, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2 arg1)

        Set the given index
        value to the given element. If the index doesn't exist, it is
        automatically created. 
        """
        return _itkMeshBasePython.itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2_InsertElement(self, arg0, arg1)


    def IndexExists(self, arg0: 'unsigned long') -> "bool":
        """
        IndexExists(itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2 self, unsigned long arg0) -> bool

        Check if the STL map
        has an entry corresponding to the given index. The count will be
        either 1 or 0. 
        """
        return _itkMeshBasePython.itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2_IndexExists(self, arg0)


    def GetElementIfIndexExists(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceUCCTI2FFULULULPF2MCULPF2 **') -> "bool":
        """
        GetElementIfIndexExists(itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2 self, unsigned long arg0, itkCellInterfaceUCCTI2FFULULULPF2MCULPF2 ** arg1) -> bool

        If the
        given index doesn't exist in the map, return false. Otherwise, set the
        element through the pointer (if it isn't null), and return true. 
        """
        return _itkMeshBasePython.itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2_GetElementIfIndexExists(self, arg0, arg1)


    def CreateIndex(self, arg0: 'unsigned long') -> "void":
        """
        CreateIndex(itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2 self, unsigned long arg0)

        The map will create an
        entry for a given index through the indexing operator. Whether or not
        it is created, it will be assigned to the default element. 
        """
        return _itkMeshBasePython.itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2_CreateIndex(self, arg0)


    def DeleteIndex(self, arg0: 'unsigned long') -> "void":
        """
        DeleteIndex(itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2 self, unsigned long arg0)

        Delete the entry in the
        STL map corresponding to the given identifier. If the entry does not
        exist, nothing happens. 
        """
        return _itkMeshBasePython.itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2_DeleteIndex(self, arg0)


    def Size(self) -> "unsigned long":
        """
        Size(itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2 self) -> unsigned long

        Get the number of elements
        currently stored in the map. 
        """
        return _itkMeshBasePython.itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2_Size(self)


    def Reserve(self, arg0: 'unsigned long') -> "void":
        """
        Reserve(itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2 self, unsigned long arg0)

        Tell the container to
        allocate enough memory to allow at least as many elements as the size
        given to be stored. This is NOT guaranteed to actually allocate any
        memory, but is useful if the implementation of the container allocates
        contiguous storage. 
        """
        return _itkMeshBasePython.itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2_Reserve(self, arg0)


    def Squeeze(self) -> "void":
        """
        Squeeze(itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2 self)

        Tell the container to try
        to minimize its memory usage for storage of the current number of
        elements. This is NOT guaranteed to decrease memory usage. 
        """
        return _itkMeshBasePython.itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2_Squeeze(self)


    def Initialize(self) -> "void":
        """
        Initialize(itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2 self)

        Tell the container to
        release any memory it may have allocated and return itself to its
        initial state. 
        """
        return _itkMeshBasePython.itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2_Initialize(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2

    def cast(obj: 'itkLightObject') -> "itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2 *":
        """cast(itkLightObject obj) -> itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2"""
        return _itkMeshBasePython.itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2

        Create a new object of the class itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2.Clone = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2_Clone, None, itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2.CastToSTLContainer = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2_CastToSTLContainer, None, itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2.CastToSTLConstContainer = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2_CastToSTLConstContainer, None, itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2.ElementAt = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2_ElementAt, None, itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2.CreateElementAt = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2_CreateElementAt, None, itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2.GetElement = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2_GetElement, None, itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2.SetElement = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2_SetElement, None, itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2.InsertElement = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2_InsertElement, None, itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2.IndexExists = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2_IndexExists, None, itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2.GetElementIfIndexExists = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2_GetElementIfIndexExists, None, itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2.CreateIndex = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2_CreateIndex, None, itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2.DeleteIndex = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2_DeleteIndex, None, itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2.Size = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2_Size, None, itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2.Reserve = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2_Reserve, None, itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2.Squeeze = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2_Squeeze, None, itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2.Initialize = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2_Initialize, None, itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2_swigregister = _itkMeshBasePython.itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2_swigregister
itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2_swigregister(itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2)

def itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2___New_orig__() -> "itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2_Pointer":
    """itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2___New_orig__() -> itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2_Pointer"""
    return _itkMeshBasePython.itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2___New_orig__()

def itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2_cast(obj: 'itkLightObject') -> "itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2 *":
    """itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2_cast(itkLightObject obj) -> itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2"""
    return _itkMeshBasePython.itkMapContainerULCIUCCTI2FFULULULPF2MCULPF2_cast(obj)

class itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3(ITKCommonBasePython.itkObject):
    """


    A wrapper of the STL "map" container.

    Define a front-end to the STL "map" container that conforms to the
    IndexedContainerInterface. This is a full-fleged Object, so there are
    events, modification time, debug, and reference count information.

    Parameters:
    -----------

    TElementIdentifier:  A type that shall be used to index the container.
    It must have a < operator defined for ordering.

    TElement:  The element type stored in the container.

    C++ includes: itkMapContainer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3 self) -> itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3
        __init__(itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3 self, std::less< unsigned long > const & comp) -> itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3



        A wrapper of the STL "map" container.

        Define a front-end to the STL "map" container that conforms to the
        IndexedContainerInterface. This is a full-fleged Object, so there are
        events, modification time, debug, and reference count information.

        Parameters:
        -----------

        TElementIdentifier:  A type that shall be used to index the container.
        It must have a < operator defined for ordering.

        TElement:  The element type stored in the container.

        C++ includes: itkMapContainer.h 
        """
        _itkMeshBasePython.itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3_swiginit(self, _itkMeshBasePython.new_itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3(*args))

    def __New_orig__() -> "itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3_Pointer":
        """__New_orig__() -> itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3_Pointer"""
        return _itkMeshBasePython.itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3_Pointer":
        """Clone(itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3 self) -> itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3_Pointer"""
        return _itkMeshBasePython.itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3_Clone(self)


    def CastToSTLContainer(self) -> "std::map< unsigned long,itkCellInterfaceUCCTI3FFULULULPF3MCULPF3 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceUCCTI3FFULULULPF3MCULPF3 * > > > &":
        """
        CastToSTLContainer(itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3 self) -> std::map< unsigned long,itkCellInterfaceUCCTI3FFULULULPF3MCULPF3 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceUCCTI3FFULULULPF3MCULPF3 * > > > &

        Cast the
        container to a STL container type 
        """
        return _itkMeshBasePython.itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3_CastToSTLContainer(self)


    def CastToSTLConstContainer(self) -> "std::map< unsigned long,itkCellInterfaceUCCTI3FFULULULPF3MCULPF3 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceUCCTI3FFULULULPF3MCULPF3 * > > > const &":
        """
        CastToSTLConstContainer(itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3 self) -> std::map< unsigned long,itkCellInterfaceUCCTI3FFULULULPF3MCULPF3 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceUCCTI3FFULULULPF3MCULPF3 * > > > const &

        Cast the
        container to a const STL container type 
        """
        return _itkMeshBasePython.itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3_CastToSTLConstContainer(self)


    def ElementAt(self, *args) -> "itkCellInterfaceUCCTI3FFULULULPF3MCULPF3 *const &":
        """
        ElementAt(itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3 self, unsigned long arg0) -> itkCellInterfaceUCCTI3FFULULULPF3MCULPF3
        ElementAt(itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3 self, unsigned long arg0) -> itkCellInterfaceUCCTI3FFULULULPF3MCULPF3

        Get a reference to the
        element at the given index. 
        """
        return _itkMeshBasePython.itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3_ElementAt(self, *args)


    def CreateElementAt(self, arg0: 'unsigned long') -> "itkCellInterfaceUCCTI3FFULULULPF3MCULPF3 *&":
        """
        CreateElementAt(itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3 self, unsigned long arg0) -> itkCellInterfaceUCCTI3FFULULULPF3MCULPF3 *&

        Get a reference to
        the element at the given index. If the index does not exist, it is
        created automatically.

        It is assumed that the value of the element is modified through the
        reference. 
        """
        return _itkMeshBasePython.itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3_CreateElementAt(self, arg0)


    def GetElement(self, arg0: 'unsigned long') -> "itkCellInterfaceUCCTI3FFULULULPF3MCULPF3 *":
        """
        GetElement(itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3 self, unsigned long arg0) -> itkCellInterfaceUCCTI3FFULULULPF3MCULPF3

        Get the element at the
        specified index. There is no check for existence performed. 
        """
        return _itkMeshBasePython.itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3_GetElement(self, arg0)


    def SetElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceUCCTI3FFULULULPF3MCULPF3') -> "void":
        """
        SetElement(itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3 self, unsigned long arg0, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3 arg1)

        Set the given index
        value to the given element. If the index doesn't exist, it is
        automatically created. 
        """
        return _itkMeshBasePython.itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3_SetElement(self, arg0, arg1)


    def InsertElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceUCCTI3FFULULULPF3MCULPF3') -> "void":
        """
        InsertElement(itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3 self, unsigned long arg0, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3 arg1)

        Set the given index
        value to the given element. If the index doesn't exist, it is
        automatically created. 
        """
        return _itkMeshBasePython.itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3_InsertElement(self, arg0, arg1)


    def IndexExists(self, arg0: 'unsigned long') -> "bool":
        """
        IndexExists(itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3 self, unsigned long arg0) -> bool

        Check if the STL map
        has an entry corresponding to the given index. The count will be
        either 1 or 0. 
        """
        return _itkMeshBasePython.itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3_IndexExists(self, arg0)


    def GetElementIfIndexExists(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceUCCTI3FFULULULPF3MCULPF3 **') -> "bool":
        """
        GetElementIfIndexExists(itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3 self, unsigned long arg0, itkCellInterfaceUCCTI3FFULULULPF3MCULPF3 ** arg1) -> bool

        If the
        given index doesn't exist in the map, return false. Otherwise, set the
        element through the pointer (if it isn't null), and return true. 
        """
        return _itkMeshBasePython.itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3_GetElementIfIndexExists(self, arg0, arg1)


    def CreateIndex(self, arg0: 'unsigned long') -> "void":
        """
        CreateIndex(itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3 self, unsigned long arg0)

        The map will create an
        entry for a given index through the indexing operator. Whether or not
        it is created, it will be assigned to the default element. 
        """
        return _itkMeshBasePython.itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3_CreateIndex(self, arg0)


    def DeleteIndex(self, arg0: 'unsigned long') -> "void":
        """
        DeleteIndex(itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3 self, unsigned long arg0)

        Delete the entry in the
        STL map corresponding to the given identifier. If the entry does not
        exist, nothing happens. 
        """
        return _itkMeshBasePython.itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3_DeleteIndex(self, arg0)


    def Size(self) -> "unsigned long":
        """
        Size(itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3 self) -> unsigned long

        Get the number of elements
        currently stored in the map. 
        """
        return _itkMeshBasePython.itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3_Size(self)


    def Reserve(self, arg0: 'unsigned long') -> "void":
        """
        Reserve(itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3 self, unsigned long arg0)

        Tell the container to
        allocate enough memory to allow at least as many elements as the size
        given to be stored. This is NOT guaranteed to actually allocate any
        memory, but is useful if the implementation of the container allocates
        contiguous storage. 
        """
        return _itkMeshBasePython.itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3_Reserve(self, arg0)


    def Squeeze(self) -> "void":
        """
        Squeeze(itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3 self)

        Tell the container to try
        to minimize its memory usage for storage of the current number of
        elements. This is NOT guaranteed to decrease memory usage. 
        """
        return _itkMeshBasePython.itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3_Squeeze(self)


    def Initialize(self) -> "void":
        """
        Initialize(itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3 self)

        Tell the container to
        release any memory it may have allocated and return itself to its
        initial state. 
        """
        return _itkMeshBasePython.itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3_Initialize(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3

    def cast(obj: 'itkLightObject') -> "itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3 *":
        """cast(itkLightObject obj) -> itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3"""
        return _itkMeshBasePython.itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3

        Create a new object of the class itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3.Clone = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3_Clone, None, itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3.CastToSTLContainer = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3_CastToSTLContainer, None, itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3.CastToSTLConstContainer = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3_CastToSTLConstContainer, None, itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3.ElementAt = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3_ElementAt, None, itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3.CreateElementAt = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3_CreateElementAt, None, itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3.GetElement = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3_GetElement, None, itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3.SetElement = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3_SetElement, None, itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3.InsertElement = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3_InsertElement, None, itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3.IndexExists = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3_IndexExists, None, itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3.GetElementIfIndexExists = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3_GetElementIfIndexExists, None, itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3.CreateIndex = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3_CreateIndex, None, itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3.DeleteIndex = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3_DeleteIndex, None, itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3.Size = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3_Size, None, itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3.Reserve = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3_Reserve, None, itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3.Squeeze = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3_Squeeze, None, itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3.Initialize = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3_Initialize, None, itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3_swigregister = _itkMeshBasePython.itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3_swigregister
itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3_swigregister(itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3)

def itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3___New_orig__() -> "itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3_Pointer":
    """itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3___New_orig__() -> itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3_Pointer"""
    return _itkMeshBasePython.itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3___New_orig__()

def itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3_cast(obj: 'itkLightObject') -> "itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3 *":
    """itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3_cast(itkLightObject obj) -> itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3"""
    return _itkMeshBasePython.itkMapContainerULCIUCCTI3FFULULULPF3MCULPF3_cast(obj)

class itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2(ITKCommonBasePython.itkObject):
    """


    A wrapper of the STL "map" container.

    Define a front-end to the STL "map" container that conforms to the
    IndexedContainerInterface. This is a full-fleged Object, so there are
    events, modification time, debug, and reference count information.

    Parameters:
    -----------

    TElementIdentifier:  A type that shall be used to index the container.
    It must have a < operator defined for ordering.

    TElement:  The element type stored in the container.

    C++ includes: itkMapContainer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2 self) -> itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2
        __init__(itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2 self, std::less< unsigned long > const & comp) -> itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2



        A wrapper of the STL "map" container.

        Define a front-end to the STL "map" container that conforms to the
        IndexedContainerInterface. This is a full-fleged Object, so there are
        events, modification time, debug, and reference count information.

        Parameters:
        -----------

        TElementIdentifier:  A type that shall be used to index the container.
        It must have a < operator defined for ordering.

        TElement:  The element type stored in the container.

        C++ includes: itkMapContainer.h 
        """
        _itkMeshBasePython.itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2_swiginit(self, _itkMeshBasePython.new_itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2(*args))

    def __New_orig__() -> "itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2_Pointer":
        """__New_orig__() -> itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2_Pointer"""
        return _itkMeshBasePython.itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2_Pointer":
        """Clone(itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2 self) -> itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2_Pointer"""
        return _itkMeshBasePython.itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2_Clone(self)


    def CastToSTLContainer(self) -> "std::map< unsigned long,itkCellInterfaceUSCTI2FFULULULPF2MCULPF2 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceUSCTI2FFULULULPF2MCULPF2 * > > > &":
        """
        CastToSTLContainer(itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2 self) -> std::map< unsigned long,itkCellInterfaceUSCTI2FFULULULPF2MCULPF2 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceUSCTI2FFULULULPF2MCULPF2 * > > > &

        Cast the
        container to a STL container type 
        """
        return _itkMeshBasePython.itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2_CastToSTLContainer(self)


    def CastToSTLConstContainer(self) -> "std::map< unsigned long,itkCellInterfaceUSCTI2FFULULULPF2MCULPF2 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceUSCTI2FFULULULPF2MCULPF2 * > > > const &":
        """
        CastToSTLConstContainer(itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2 self) -> std::map< unsigned long,itkCellInterfaceUSCTI2FFULULULPF2MCULPF2 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceUSCTI2FFULULULPF2MCULPF2 * > > > const &

        Cast the
        container to a const STL container type 
        """
        return _itkMeshBasePython.itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2_CastToSTLConstContainer(self)


    def ElementAt(self, *args) -> "itkCellInterfaceUSCTI2FFULULULPF2MCULPF2 *const &":
        """
        ElementAt(itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2 self, unsigned long arg0) -> itkCellInterfaceUSCTI2FFULULULPF2MCULPF2
        ElementAt(itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2 self, unsigned long arg0) -> itkCellInterfaceUSCTI2FFULULULPF2MCULPF2

        Get a reference to the
        element at the given index. 
        """
        return _itkMeshBasePython.itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2_ElementAt(self, *args)


    def CreateElementAt(self, arg0: 'unsigned long') -> "itkCellInterfaceUSCTI2FFULULULPF2MCULPF2 *&":
        """
        CreateElementAt(itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2 self, unsigned long arg0) -> itkCellInterfaceUSCTI2FFULULULPF2MCULPF2 *&

        Get a reference to
        the element at the given index. If the index does not exist, it is
        created automatically.

        It is assumed that the value of the element is modified through the
        reference. 
        """
        return _itkMeshBasePython.itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2_CreateElementAt(self, arg0)


    def GetElement(self, arg0: 'unsigned long') -> "itkCellInterfaceUSCTI2FFULULULPF2MCULPF2 *":
        """
        GetElement(itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2 self, unsigned long arg0) -> itkCellInterfaceUSCTI2FFULULULPF2MCULPF2

        Get the element at the
        specified index. There is no check for existence performed. 
        """
        return _itkMeshBasePython.itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2_GetElement(self, arg0)


    def SetElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceUSCTI2FFULULULPF2MCULPF2') -> "void":
        """
        SetElement(itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2 self, unsigned long arg0, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2 arg1)

        Set the given index
        value to the given element. If the index doesn't exist, it is
        automatically created. 
        """
        return _itkMeshBasePython.itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2_SetElement(self, arg0, arg1)


    def InsertElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceUSCTI2FFULULULPF2MCULPF2') -> "void":
        """
        InsertElement(itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2 self, unsigned long arg0, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2 arg1)

        Set the given index
        value to the given element. If the index doesn't exist, it is
        automatically created. 
        """
        return _itkMeshBasePython.itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2_InsertElement(self, arg0, arg1)


    def IndexExists(self, arg0: 'unsigned long') -> "bool":
        """
        IndexExists(itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2 self, unsigned long arg0) -> bool

        Check if the STL map
        has an entry corresponding to the given index. The count will be
        either 1 or 0. 
        """
        return _itkMeshBasePython.itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2_IndexExists(self, arg0)


    def GetElementIfIndexExists(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceUSCTI2FFULULULPF2MCULPF2 **') -> "bool":
        """
        GetElementIfIndexExists(itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2 self, unsigned long arg0, itkCellInterfaceUSCTI2FFULULULPF2MCULPF2 ** arg1) -> bool

        If the
        given index doesn't exist in the map, return false. Otherwise, set the
        element through the pointer (if it isn't null), and return true. 
        """
        return _itkMeshBasePython.itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2_GetElementIfIndexExists(self, arg0, arg1)


    def CreateIndex(self, arg0: 'unsigned long') -> "void":
        """
        CreateIndex(itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2 self, unsigned long arg0)

        The map will create an
        entry for a given index through the indexing operator. Whether or not
        it is created, it will be assigned to the default element. 
        """
        return _itkMeshBasePython.itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2_CreateIndex(self, arg0)


    def DeleteIndex(self, arg0: 'unsigned long') -> "void":
        """
        DeleteIndex(itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2 self, unsigned long arg0)

        Delete the entry in the
        STL map corresponding to the given identifier. If the entry does not
        exist, nothing happens. 
        """
        return _itkMeshBasePython.itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2_DeleteIndex(self, arg0)


    def Size(self) -> "unsigned long":
        """
        Size(itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2 self) -> unsigned long

        Get the number of elements
        currently stored in the map. 
        """
        return _itkMeshBasePython.itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2_Size(self)


    def Reserve(self, arg0: 'unsigned long') -> "void":
        """
        Reserve(itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2 self, unsigned long arg0)

        Tell the container to
        allocate enough memory to allow at least as many elements as the size
        given to be stored. This is NOT guaranteed to actually allocate any
        memory, but is useful if the implementation of the container allocates
        contiguous storage. 
        """
        return _itkMeshBasePython.itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2_Reserve(self, arg0)


    def Squeeze(self) -> "void":
        """
        Squeeze(itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2 self)

        Tell the container to try
        to minimize its memory usage for storage of the current number of
        elements. This is NOT guaranteed to decrease memory usage. 
        """
        return _itkMeshBasePython.itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2_Squeeze(self)


    def Initialize(self) -> "void":
        """
        Initialize(itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2 self)

        Tell the container to
        release any memory it may have allocated and return itself to its
        initial state. 
        """
        return _itkMeshBasePython.itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2_Initialize(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2

    def cast(obj: 'itkLightObject') -> "itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2 *":
        """cast(itkLightObject obj) -> itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2"""
        return _itkMeshBasePython.itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2

        Create a new object of the class itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2.Clone = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2_Clone, None, itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2.CastToSTLContainer = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2_CastToSTLContainer, None, itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2.CastToSTLConstContainer = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2_CastToSTLConstContainer, None, itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2.ElementAt = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2_ElementAt, None, itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2.CreateElementAt = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2_CreateElementAt, None, itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2.GetElement = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2_GetElement, None, itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2.SetElement = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2_SetElement, None, itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2.InsertElement = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2_InsertElement, None, itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2.IndexExists = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2_IndexExists, None, itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2.GetElementIfIndexExists = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2_GetElementIfIndexExists, None, itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2.CreateIndex = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2_CreateIndex, None, itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2.DeleteIndex = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2_DeleteIndex, None, itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2.Size = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2_Size, None, itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2.Reserve = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2_Reserve, None, itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2.Squeeze = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2_Squeeze, None, itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2.Initialize = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2_Initialize, None, itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2_swigregister = _itkMeshBasePython.itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2_swigregister
itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2_swigregister(itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2)

def itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2___New_orig__() -> "itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2_Pointer":
    """itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2___New_orig__() -> itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2_Pointer"""
    return _itkMeshBasePython.itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2___New_orig__()

def itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2_cast(obj: 'itkLightObject') -> "itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2 *":
    """itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2_cast(itkLightObject obj) -> itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2"""
    return _itkMeshBasePython.itkMapContainerULCIUSCTI2FFULULULPF2MCULPF2_cast(obj)

class itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3(ITKCommonBasePython.itkObject):
    """


    A wrapper of the STL "map" container.

    Define a front-end to the STL "map" container that conforms to the
    IndexedContainerInterface. This is a full-fleged Object, so there are
    events, modification time, debug, and reference count information.

    Parameters:
    -----------

    TElementIdentifier:  A type that shall be used to index the container.
    It must have a < operator defined for ordering.

    TElement:  The element type stored in the container.

    C++ includes: itkMapContainer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3 self) -> itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3
        __init__(itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3 self, std::less< unsigned long > const & comp) -> itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3



        A wrapper of the STL "map" container.

        Define a front-end to the STL "map" container that conforms to the
        IndexedContainerInterface. This is a full-fleged Object, so there are
        events, modification time, debug, and reference count information.

        Parameters:
        -----------

        TElementIdentifier:  A type that shall be used to index the container.
        It must have a < operator defined for ordering.

        TElement:  The element type stored in the container.

        C++ includes: itkMapContainer.h 
        """
        _itkMeshBasePython.itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3_swiginit(self, _itkMeshBasePython.new_itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3(*args))

    def __New_orig__() -> "itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3_Pointer":
        """__New_orig__() -> itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3_Pointer"""
        return _itkMeshBasePython.itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3_Pointer":
        """Clone(itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3 self) -> itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3_Pointer"""
        return _itkMeshBasePython.itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3_Clone(self)


    def CastToSTLContainer(self) -> "std::map< unsigned long,itkCellInterfaceUSCTI3FFULULULPF3MCULPF3 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceUSCTI3FFULULULPF3MCULPF3 * > > > &":
        """
        CastToSTLContainer(itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3 self) -> std::map< unsigned long,itkCellInterfaceUSCTI3FFULULULPF3MCULPF3 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceUSCTI3FFULULULPF3MCULPF3 * > > > &

        Cast the
        container to a STL container type 
        """
        return _itkMeshBasePython.itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3_CastToSTLContainer(self)


    def CastToSTLConstContainer(self) -> "std::map< unsigned long,itkCellInterfaceUSCTI3FFULULULPF3MCULPF3 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceUSCTI3FFULULULPF3MCULPF3 * > > > const &":
        """
        CastToSTLConstContainer(itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3 self) -> std::map< unsigned long,itkCellInterfaceUSCTI3FFULULULPF3MCULPF3 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceUSCTI3FFULULULPF3MCULPF3 * > > > const &

        Cast the
        container to a const STL container type 
        """
        return _itkMeshBasePython.itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3_CastToSTLConstContainer(self)


    def ElementAt(self, *args) -> "itkCellInterfaceUSCTI3FFULULULPF3MCULPF3 *const &":
        """
        ElementAt(itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3 self, unsigned long arg0) -> itkCellInterfaceUSCTI3FFULULULPF3MCULPF3
        ElementAt(itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3 self, unsigned long arg0) -> itkCellInterfaceUSCTI3FFULULULPF3MCULPF3

        Get a reference to the
        element at the given index. 
        """
        return _itkMeshBasePython.itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3_ElementAt(self, *args)


    def CreateElementAt(self, arg0: 'unsigned long') -> "itkCellInterfaceUSCTI3FFULULULPF3MCULPF3 *&":
        """
        CreateElementAt(itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3 self, unsigned long arg0) -> itkCellInterfaceUSCTI3FFULULULPF3MCULPF3 *&

        Get a reference to
        the element at the given index. If the index does not exist, it is
        created automatically.

        It is assumed that the value of the element is modified through the
        reference. 
        """
        return _itkMeshBasePython.itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3_CreateElementAt(self, arg0)


    def GetElement(self, arg0: 'unsigned long') -> "itkCellInterfaceUSCTI3FFULULULPF3MCULPF3 *":
        """
        GetElement(itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3 self, unsigned long arg0) -> itkCellInterfaceUSCTI3FFULULULPF3MCULPF3

        Get the element at the
        specified index. There is no check for existence performed. 
        """
        return _itkMeshBasePython.itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3_GetElement(self, arg0)


    def SetElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceUSCTI3FFULULULPF3MCULPF3') -> "void":
        """
        SetElement(itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3 self, unsigned long arg0, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3 arg1)

        Set the given index
        value to the given element. If the index doesn't exist, it is
        automatically created. 
        """
        return _itkMeshBasePython.itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3_SetElement(self, arg0, arg1)


    def InsertElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceUSCTI3FFULULULPF3MCULPF3') -> "void":
        """
        InsertElement(itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3 self, unsigned long arg0, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3 arg1)

        Set the given index
        value to the given element. If the index doesn't exist, it is
        automatically created. 
        """
        return _itkMeshBasePython.itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3_InsertElement(self, arg0, arg1)


    def IndexExists(self, arg0: 'unsigned long') -> "bool":
        """
        IndexExists(itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3 self, unsigned long arg0) -> bool

        Check if the STL map
        has an entry corresponding to the given index. The count will be
        either 1 or 0. 
        """
        return _itkMeshBasePython.itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3_IndexExists(self, arg0)


    def GetElementIfIndexExists(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceUSCTI3FFULULULPF3MCULPF3 **') -> "bool":
        """
        GetElementIfIndexExists(itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3 self, unsigned long arg0, itkCellInterfaceUSCTI3FFULULULPF3MCULPF3 ** arg1) -> bool

        If the
        given index doesn't exist in the map, return false. Otherwise, set the
        element through the pointer (if it isn't null), and return true. 
        """
        return _itkMeshBasePython.itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3_GetElementIfIndexExists(self, arg0, arg1)


    def CreateIndex(self, arg0: 'unsigned long') -> "void":
        """
        CreateIndex(itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3 self, unsigned long arg0)

        The map will create an
        entry for a given index through the indexing operator. Whether or not
        it is created, it will be assigned to the default element. 
        """
        return _itkMeshBasePython.itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3_CreateIndex(self, arg0)


    def DeleteIndex(self, arg0: 'unsigned long') -> "void":
        """
        DeleteIndex(itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3 self, unsigned long arg0)

        Delete the entry in the
        STL map corresponding to the given identifier. If the entry does not
        exist, nothing happens. 
        """
        return _itkMeshBasePython.itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3_DeleteIndex(self, arg0)


    def Size(self) -> "unsigned long":
        """
        Size(itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3 self) -> unsigned long

        Get the number of elements
        currently stored in the map. 
        """
        return _itkMeshBasePython.itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3_Size(self)


    def Reserve(self, arg0: 'unsigned long') -> "void":
        """
        Reserve(itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3 self, unsigned long arg0)

        Tell the container to
        allocate enough memory to allow at least as many elements as the size
        given to be stored. This is NOT guaranteed to actually allocate any
        memory, but is useful if the implementation of the container allocates
        contiguous storage. 
        """
        return _itkMeshBasePython.itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3_Reserve(self, arg0)


    def Squeeze(self) -> "void":
        """
        Squeeze(itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3 self)

        Tell the container to try
        to minimize its memory usage for storage of the current number of
        elements. This is NOT guaranteed to decrease memory usage. 
        """
        return _itkMeshBasePython.itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3_Squeeze(self)


    def Initialize(self) -> "void":
        """
        Initialize(itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3 self)

        Tell the container to
        release any memory it may have allocated and return itself to its
        initial state. 
        """
        return _itkMeshBasePython.itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3_Initialize(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3

    def cast(obj: 'itkLightObject') -> "itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3 *":
        """cast(itkLightObject obj) -> itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3"""
        return _itkMeshBasePython.itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3

        Create a new object of the class itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3.Clone = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3_Clone, None, itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3.CastToSTLContainer = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3_CastToSTLContainer, None, itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3.CastToSTLConstContainer = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3_CastToSTLConstContainer, None, itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3.ElementAt = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3_ElementAt, None, itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3.CreateElementAt = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3_CreateElementAt, None, itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3.GetElement = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3_GetElement, None, itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3.SetElement = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3_SetElement, None, itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3.InsertElement = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3_InsertElement, None, itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3.IndexExists = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3_IndexExists, None, itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3.GetElementIfIndexExists = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3_GetElementIfIndexExists, None, itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3.CreateIndex = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3_CreateIndex, None, itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3.DeleteIndex = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3_DeleteIndex, None, itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3.Size = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3_Size, None, itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3.Reserve = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3_Reserve, None, itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3.Squeeze = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3_Squeeze, None, itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3.Initialize = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3_Initialize, None, itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3_swigregister = _itkMeshBasePython.itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3_swigregister
itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3_swigregister(itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3)

def itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3___New_orig__() -> "itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3_Pointer":
    """itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3___New_orig__() -> itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3_Pointer"""
    return _itkMeshBasePython.itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3___New_orig__()

def itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3_cast(obj: 'itkLightObject') -> "itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3 *":
    """itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3_cast(itkLightObject obj) -> itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3"""
    return _itkMeshBasePython.itkMapContainerULCIUSCTI3FFULULULPF3MCULPF3_cast(obj)

class itkMeshD2(itkPointSetPython.itkPointSetD2):
    """


    Implements the N-dimensional mesh structure.

    Overview  Mesh implements the N-dimensional mesh structure for ITK. It
    provides an API to perform operations on points, cells, boundaries,
    etc., but does not tie down the underlying implementation and storage.
    A "MeshTraits" structure is used to define the container and
    identifier types that will be used to access the mesh. See
    DefaultStaticMeshTraits for the set of type definitions needed. All
    types that are defined in the "MeshTraits" structure will have
    duplicate type alias in the resulting mesh itself.  Mesh is an
    adaptive, evolving structure. Typically points and cells are created,
    with the cells referring to their defining points. If additional
    topological information is required, then BuildCellLinks() is called
    and links from the points back to the cells that use them are created.
    This allows implicit topological information about the faces to a cell
    can be determined by intersection the sets of cells that use the
    points defining the face. This is an inherent assumption on the
    manifold relationship of the cells in the mesh.) In some cases, either
    because the mesh is non-manifold, because we wish to explicitly store
    information with the faces and edges of the mesh, or because
    performance requirements demand that boundaries are explicitly
    represented (the set intersection does not need to be performed); then
    Mesh can be further extended by adding explicit boundary assignments.

    Usage  Mesh has three template parameters. The first is the pixel
    type, or the type of data stored (optionally) with points, cells,
    and/or boundaries. The second is the geometric dimension of the points
    defining the mesh. This also limits the maximum topological dimension
    of the cells that can be inserted. The third template parameter is the
    "MeshTraits" structure controlling type information for the mesh.
    Most users will be happy with the defaults, and will not have to worry
    about this third argument.  One of the most important parts of using
    this mesh is how to create cells to insert into it. The cells for the
    mesh take two template parameters. The first is the pixel type, and
    should correspond exactly to that type given to the mesh. The second
    is a "CellTraits" which holds a sub-set of the "MeshTraits"
    structure definitions, and is also a member of them. Any cell which is
    to be inserted to a mesh should have MeshTraits::CellTraits as its
    second template parameter.

    Template parameters for Mesh:

    TPixelType = The type stored as data for an entity (cell, point, or
    boundary).

    TMeshTraits = Type information structure for the mesh.

    References No reference information is available.

    C++ includes: itkMesh.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkMeshD2_Pointer":
        """__New_orig__() -> itkMeshD2_Pointer"""
        return _itkMeshBasePython.itkMeshD2___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkMeshD2_Pointer":
        """Clone(itkMeshD2 self) -> itkMeshD2_Pointer"""
        return _itkMeshBasePython.itkMeshD2_Clone(self)


    def GetNumberOfCells(self) -> "unsigned long":
        """
        GetNumberOfCells(itkMeshD2 self) -> unsigned long

        Mesh-level
        operation interface. 
        """
        return _itkMeshBasePython.itkMeshD2_GetNumberOfCells(self)


    def PassStructure(self, inputMesh: 'itkMeshD2') -> "void":
        """
        PassStructure(itkMeshD2 self, itkMeshD2 inputMesh)

        PointSet-level
        operation interface. 
        """
        return _itkMeshBasePython.itkMeshD2_PassStructure(self, inputMesh)


    def GetBoundingBox(self) -> "itkBoundingBoxUL2FVCULPF2 const *":
        """
        GetBoundingBox(itkMeshD2 self) -> itkBoundingBoxUL2FVCULPF2

        Get the bounding box
        of the mesh. The methods return a pointer to the user-supplied
        bounding box as a convenience. 
        """
        return _itkMeshBasePython.itkMeshD2_GetBoundingBox(self)


    def SetCellLinks(self, arg0: 'itkVectorContainerULSUL') -> "void":
        """
        SetCellLinks(itkMeshD2 self, itkVectorContainerULSUL arg0)

        Access
        m_CellsLinksContainer, which contains parent cell links for each
        point. Since a point can be used by multiple cells, each point
        identifier accesses another container which holds the cell identifiers

        """
        return _itkMeshBasePython.itkMeshD2_SetCellLinks(self, arg0)


    def GetCellLinks(self, *args) -> "itkVectorContainerULSUL const *":
        """
        GetCellLinks(itkMeshD2 self) -> itkVectorContainerULSUL
        GetCellLinks(itkMeshD2 self) -> itkVectorContainerULSUL
        """
        return _itkMeshBasePython.itkMeshD2_GetCellLinks(self, *args)


    def SetCells(self, arg0: 'itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2') -> "void":
        """
        SetCells(itkMeshD2 self, itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2 arg0)

        Access m_CellsContainer,
        which holds cells used by the mesh. Individual cells are accessed
        through cell identifiers. 
        """
        return _itkMeshBasePython.itkMeshD2_SetCells(self, arg0)


    def GetCells(self, *args) -> "itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2 const *":
        """
        GetCells(itkMeshD2 self) -> itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2
        GetCells(itkMeshD2 self) -> itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2
        """
        return _itkMeshBasePython.itkMeshD2_GetCells(self, *args)


    def DeleteUnusedCellData(self) -> "void":
        """
        DeleteUnusedCellData(itkMeshD2 self)

        Delete entries
        in m_CellDataContainer which do not have a corresponding entry in
        m_CellsContainer. 
        """
        return _itkMeshBasePython.itkMeshD2_DeleteUnusedCellData(self)


    def SetCell(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer') -> "void":
        """
        SetCell(itkMeshD2 self, unsigned long arg0, itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer arg1)

        Access routines to fill the
        Cells container (m_CellsContainer), and get information from it. If
        SetCell is used to overwrite a cell currently in the mesh, it is the
        caller's responsibility to release the memory for the cell currently
        at the CellIdentifier position prior to calling SetCell. 
        """
        return _itkMeshBasePython.itkMeshD2_SetCell(self, arg0, arg1)


    def GetCell(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """GetCell(itkMeshD2 self, unsigned long arg0, itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer arg1) -> bool"""
        return _itkMeshBasePython.itkMeshD2_GetCell(self, arg0, arg1)


    def SetCellData(self, *args) -> "void":
        """
        SetCellData(itkMeshD2 self, itkVectorContainerULD arg0)
        SetCellData(itkMeshD2 self, unsigned long arg0, double arg1)

        Access routines to fill
        the CellData container, and get information from it. 
        """
        return _itkMeshBasePython.itkMeshD2_SetCellData(self, *args)


    def GetCellData(self, *args) -> "bool":
        """
        GetCellData(itkMeshD2 self) -> itkVectorContainerULD
        GetCellData(itkMeshD2 self) -> itkVectorContainerULD
        GetCellData(itkMeshD2 self, unsigned long arg0, double * arg1) -> bool
        """
        return _itkMeshBasePython.itkMeshD2_GetCellData(self, *args)


    def SetBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long', boundaryId: 'unsigned long') -> "void":
        """
        SetBoundaryAssignment(itkMeshD2 self, int dimension, unsigned long cellId, unsigned long featureId, unsigned long boundaryId)

        Explicitly
        assign boundaryId as a part of the boundary of cellId. The identifiers
        boundaryId and cellId must identify cell objects already in the mesh.
        The dimension of boundaryId must be specified by dimension, and a
        unique CellFeatureIdentifier featureId must be assigned for each
        distinct boundary feature of a given dimension. CellFeatureIdentifier
        is equivalent to IdentifierType by default, and this type alias will
        not typically need to be changed. The UsingCells list of boundaryId is
        automatically updated to include cellId. 
        """
        return _itkMeshBasePython.itkMeshD2_SetBoundaryAssignment(self, dimension, cellId, featureId, boundaryId)


    def GetBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long', boundaryId: 'unsigned long *') -> "bool":
        """
        GetBoundaryAssignment(itkMeshD2 self, int dimension, unsigned long cellId, unsigned long featureId, unsigned long * boundaryId) -> bool

        For the given
        cellId, get the identifier of a particular boundary feature of the
        given dimension. The featureId determines which boundary feature of
        the specified dimension is returned. For instance, if dimension is 1
        and featureId is 0, then GetBoundaryAssignment finds the 0th edge of
        the given cell. The return value indicates whether a feature of the
        appropriate dimension and featureId exists. If it does not, the
        BoundaryIdentifier pointer is left unchanged. 
        """
        return _itkMeshBasePython.itkMeshD2_GetBoundaryAssignment(self, dimension, cellId, featureId, boundaryId)


    def RemoveBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long') -> "bool":
        """RemoveBoundaryAssignment(itkMeshD2 self, int dimension, unsigned long cellId, unsigned long featureId) -> bool"""
        return _itkMeshBasePython.itkMeshD2_RemoveBoundaryAssignment(self, dimension, cellId, featureId)


    def GetNumberOfCellBoundaryFeatures(self, dimension: 'int', arg1: 'unsigned long') -> "unsigned long":
        """
        GetNumberOfCellBoundaryFeatures(itkMeshD2 self, int dimension, unsigned long arg1) -> unsigned long

        Interface to cells. 
        """
        return _itkMeshBasePython.itkMeshD2_GetNumberOfCellBoundaryFeatures(self, dimension, arg1)


    def GetCellBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', arg3: 'itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """
        GetCellBoundaryFeature(itkMeshD2 self, int dimension, unsigned long arg1, unsigned long arg2, itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer arg3) -> bool

        Get the
        boundary feature of the given dimension of the given cell
        corresponding to the given feature identifier. 
        """
        return _itkMeshBasePython.itkMeshD2_GetCellBoundaryFeature(self, dimension, arg1, arg2, arg3)


    def GetCellBoundaryFeatureNeighbors(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', cellSet: 'setUL') -> "unsigned long":
        """
        GetCellBoundaryFeatureNeighbors(itkMeshD2 self, int dimension, unsigned long arg1, unsigned long arg2, setUL cellSet) -> unsigned long

        Get
        the set of cells neighboring the given cell across the given boundary
        feature. Returns the number of neighbors found. If cellSet is not
        nullptr, the set of cell pointers is filled in with identifiers of the
        neighboring cells. 
        """
        return _itkMeshBasePython.itkMeshD2_GetCellBoundaryFeatureNeighbors(self, dimension, arg1, arg2, cellSet)


    def GetCellNeighbors(self, cellId: 'unsigned long', cellSet: 'setUL') -> "unsigned long":
        """
        GetCellNeighbors(itkMeshD2 self, unsigned long cellId, setUL cellSet) -> unsigned long

        Get the set of
        cells having the given cell as part of their boundary. Returns the
        number of neighbors found. If cellSet is not nullptr, the set of cell
        pointers is filled in with identifiers of the neighboring cells. 
        """
        return _itkMeshBasePython.itkMeshD2_GetCellNeighbors(self, cellId, cellSet)


    def GetAssignedCellBoundaryIfOneExists(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', arg3: 'itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """
        GetAssignedCellBoundaryIfOneExists(itkMeshD2 self, int dimension, unsigned long arg1, unsigned long arg2, itkCellInterfaceDCTI2FFULULULPF2VCULPF2_AutoPointer arg3) -> bool

        Check if there is an explicitly assigned boundary feature for the
        given dimension and cell- and cell-feature-identifiers. If there is, a
        pointer to it is given back through boundary (if boundary != nullptr)
        and true is returned. Otherwise, false is returned. 
        """
        return _itkMeshBasePython.itkMeshD2_GetAssignedCellBoundaryIfOneExists(self, dimension, arg1, arg2, arg3)


    def BuildCellLinks(self) -> "void":
        """
        BuildCellLinks(itkMeshD2 self)

        Dynamically build
        the links from points back to their using cells. This information is
        stored in the cell links container, not in the points. 
        """
        return _itkMeshBasePython.itkMeshD2_BuildCellLinks(self)


    def Accept(self, mv: 'itkCellInterfaceDCTI2FFULULULPF2VCULPF2::MultiVisitor *') -> "void":
        """
        Accept(itkMeshD2 self, itkCellInterfaceDCTI2FFULULULPF2VCULPF2::MultiVisitor * mv)

        This method iterates over
        all the cells in the mesh and has each cell Accept the MultiVisitor.
        See MultiVisitor for more information. (Note, this follows the Visitor
        Design Pattern.) 
        """
        return _itkMeshBasePython.itkMeshD2_Accept(self, mv)


    def SetCellsAllocationMethod(self, _arg: 'itkMeshEnums::MeshClassCellsAllocationMethod const') -> "void":
        """
        SetCellsAllocationMethod(itkMeshD2 self, itkMeshEnums::MeshClassCellsAllocationMethod const _arg)

        Set/Get
        the identification of the method used to allocate cells WARNING:
        Failure to call this method correctly will lead to memory leaks and/or
        segmentation faults because the cell memory will not be erased or will
        be erased with an improper method. 
        """
        return _itkMeshBasePython.itkMeshD2_SetCellsAllocationMethod(self, _arg)


    def GetCellsAllocationMethod(self) -> "itkMeshEnums::MeshClassCellsAllocationMethod const &":
        """GetCellsAllocationMethod(itkMeshD2 self) -> itkMeshEnums::MeshClassCellsAllocationMethod const &"""
        return _itkMeshBasePython.itkMeshD2_GetCellsAllocationMethod(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkMeshD2

    def cast(obj: 'itkLightObject') -> "itkMeshD2 *":
        """cast(itkLightObject obj) -> itkMeshD2"""
        return _itkMeshBasePython.itkMeshD2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkMeshD2

        Create a new object of the class itkMeshD2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMeshD2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkMeshD2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkMeshD2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkMeshD2.Clone = new_instancemethod(_itkMeshBasePython.itkMeshD2_Clone, None, itkMeshD2)
itkMeshD2.GetNumberOfCells = new_instancemethod(_itkMeshBasePython.itkMeshD2_GetNumberOfCells, None, itkMeshD2)
itkMeshD2.PassStructure = new_instancemethod(_itkMeshBasePython.itkMeshD2_PassStructure, None, itkMeshD2)
itkMeshD2.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkMeshD2_GetBoundingBox, None, itkMeshD2)
itkMeshD2.SetCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshD2_SetCellLinks, None, itkMeshD2)
itkMeshD2.GetCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshD2_GetCellLinks, None, itkMeshD2)
itkMeshD2.SetCells = new_instancemethod(_itkMeshBasePython.itkMeshD2_SetCells, None, itkMeshD2)
itkMeshD2.GetCells = new_instancemethod(_itkMeshBasePython.itkMeshD2_GetCells, None, itkMeshD2)
itkMeshD2.DeleteUnusedCellData = new_instancemethod(_itkMeshBasePython.itkMeshD2_DeleteUnusedCellData, None, itkMeshD2)
itkMeshD2.SetCell = new_instancemethod(_itkMeshBasePython.itkMeshD2_SetCell, None, itkMeshD2)
itkMeshD2.GetCell = new_instancemethod(_itkMeshBasePython.itkMeshD2_GetCell, None, itkMeshD2)
itkMeshD2.SetCellData = new_instancemethod(_itkMeshBasePython.itkMeshD2_SetCellData, None, itkMeshD2)
itkMeshD2.GetCellData = new_instancemethod(_itkMeshBasePython.itkMeshD2_GetCellData, None, itkMeshD2)
itkMeshD2.SetBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshD2_SetBoundaryAssignment, None, itkMeshD2)
itkMeshD2.GetBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshD2_GetBoundaryAssignment, None, itkMeshD2)
itkMeshD2.RemoveBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshD2_RemoveBoundaryAssignment, None, itkMeshD2)
itkMeshD2.GetNumberOfCellBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkMeshD2_GetNumberOfCellBoundaryFeatures, None, itkMeshD2)
itkMeshD2.GetCellBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkMeshD2_GetCellBoundaryFeature, None, itkMeshD2)
itkMeshD2.GetCellBoundaryFeatureNeighbors = new_instancemethod(_itkMeshBasePython.itkMeshD2_GetCellBoundaryFeatureNeighbors, None, itkMeshD2)
itkMeshD2.GetCellNeighbors = new_instancemethod(_itkMeshBasePython.itkMeshD2_GetCellNeighbors, None, itkMeshD2)
itkMeshD2.GetAssignedCellBoundaryIfOneExists = new_instancemethod(_itkMeshBasePython.itkMeshD2_GetAssignedCellBoundaryIfOneExists, None, itkMeshD2)
itkMeshD2.BuildCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshD2_BuildCellLinks, None, itkMeshD2)
itkMeshD2.Accept = new_instancemethod(_itkMeshBasePython.itkMeshD2_Accept, None, itkMeshD2)
itkMeshD2.SetCellsAllocationMethod = new_instancemethod(_itkMeshBasePython.itkMeshD2_SetCellsAllocationMethod, None, itkMeshD2)
itkMeshD2.GetCellsAllocationMethod = new_instancemethod(_itkMeshBasePython.itkMeshD2_GetCellsAllocationMethod, None, itkMeshD2)
itkMeshD2_swigregister = _itkMeshBasePython.itkMeshD2_swigregister
itkMeshD2_swigregister(itkMeshD2)

def itkMeshD2___New_orig__() -> "itkMeshD2_Pointer":
    """itkMeshD2___New_orig__() -> itkMeshD2_Pointer"""
    return _itkMeshBasePython.itkMeshD2___New_orig__()

def itkMeshD2_cast(obj: 'itkLightObject') -> "itkMeshD2 *":
    """itkMeshD2_cast(itkLightObject obj) -> itkMeshD2"""
    return _itkMeshBasePython.itkMeshD2_cast(obj)

class itkMeshD3(itkPointSetPython.itkPointSetD3):
    """


    Implements the N-dimensional mesh structure.

    Overview  Mesh implements the N-dimensional mesh structure for ITK. It
    provides an API to perform operations on points, cells, boundaries,
    etc., but does not tie down the underlying implementation and storage.
    A "MeshTraits" structure is used to define the container and
    identifier types that will be used to access the mesh. See
    DefaultStaticMeshTraits for the set of type definitions needed. All
    types that are defined in the "MeshTraits" structure will have
    duplicate type alias in the resulting mesh itself.  Mesh is an
    adaptive, evolving structure. Typically points and cells are created,
    with the cells referring to their defining points. If additional
    topological information is required, then BuildCellLinks() is called
    and links from the points back to the cells that use them are created.
    This allows implicit topological information about the faces to a cell
    can be determined by intersection the sets of cells that use the
    points defining the face. This is an inherent assumption on the
    manifold relationship of the cells in the mesh.) In some cases, either
    because the mesh is non-manifold, because we wish to explicitly store
    information with the faces and edges of the mesh, or because
    performance requirements demand that boundaries are explicitly
    represented (the set intersection does not need to be performed); then
    Mesh can be further extended by adding explicit boundary assignments.

    Usage  Mesh has three template parameters. The first is the pixel
    type, or the type of data stored (optionally) with points, cells,
    and/or boundaries. The second is the geometric dimension of the points
    defining the mesh. This also limits the maximum topological dimension
    of the cells that can be inserted. The third template parameter is the
    "MeshTraits" structure controlling type information for the mesh.
    Most users will be happy with the defaults, and will not have to worry
    about this third argument.  One of the most important parts of using
    this mesh is how to create cells to insert into it. The cells for the
    mesh take two template parameters. The first is the pixel type, and
    should correspond exactly to that type given to the mesh. The second
    is a "CellTraits" which holds a sub-set of the "MeshTraits"
    structure definitions, and is also a member of them. Any cell which is
    to be inserted to a mesh should have MeshTraits::CellTraits as its
    second template parameter.

    Template parameters for Mesh:

    TPixelType = The type stored as data for an entity (cell, point, or
    boundary).

    TMeshTraits = Type information structure for the mesh.

    References No reference information is available.

    C++ includes: itkMesh.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkMeshD3_Pointer":
        """__New_orig__() -> itkMeshD3_Pointer"""
        return _itkMeshBasePython.itkMeshD3___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkMeshD3_Pointer":
        """Clone(itkMeshD3 self) -> itkMeshD3_Pointer"""
        return _itkMeshBasePython.itkMeshD3_Clone(self)


    def GetNumberOfCells(self) -> "unsigned long":
        """
        GetNumberOfCells(itkMeshD3 self) -> unsigned long

        Mesh-level
        operation interface. 
        """
        return _itkMeshBasePython.itkMeshD3_GetNumberOfCells(self)


    def PassStructure(self, inputMesh: 'itkMeshD3') -> "void":
        """
        PassStructure(itkMeshD3 self, itkMeshD3 inputMesh)

        PointSet-level
        operation interface. 
        """
        return _itkMeshBasePython.itkMeshD3_PassStructure(self, inputMesh)


    def GetBoundingBox(self) -> "itkBoundingBoxUL3FVCULPF3 const *":
        """
        GetBoundingBox(itkMeshD3 self) -> itkBoundingBoxUL3FVCULPF3

        Get the bounding box
        of the mesh. The methods return a pointer to the user-supplied
        bounding box as a convenience. 
        """
        return _itkMeshBasePython.itkMeshD3_GetBoundingBox(self)


    def SetCellLinks(self, arg0: 'itkVectorContainerULSUL') -> "void":
        """
        SetCellLinks(itkMeshD3 self, itkVectorContainerULSUL arg0)

        Access
        m_CellsLinksContainer, which contains parent cell links for each
        point. Since a point can be used by multiple cells, each point
        identifier accesses another container which holds the cell identifiers

        """
        return _itkMeshBasePython.itkMeshD3_SetCellLinks(self, arg0)


    def GetCellLinks(self, *args) -> "itkVectorContainerULSUL const *":
        """
        GetCellLinks(itkMeshD3 self) -> itkVectorContainerULSUL
        GetCellLinks(itkMeshD3 self) -> itkVectorContainerULSUL
        """
        return _itkMeshBasePython.itkMeshD3_GetCellLinks(self, *args)


    def SetCells(self, arg0: 'itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3') -> "void":
        """
        SetCells(itkMeshD3 self, itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3 arg0)

        Access m_CellsContainer,
        which holds cells used by the mesh. Individual cells are accessed
        through cell identifiers. 
        """
        return _itkMeshBasePython.itkMeshD3_SetCells(self, arg0)


    def GetCells(self, *args) -> "itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3 const *":
        """
        GetCells(itkMeshD3 self) -> itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3
        GetCells(itkMeshD3 self) -> itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3
        """
        return _itkMeshBasePython.itkMeshD3_GetCells(self, *args)


    def DeleteUnusedCellData(self) -> "void":
        """
        DeleteUnusedCellData(itkMeshD3 self)

        Delete entries
        in m_CellDataContainer which do not have a corresponding entry in
        m_CellsContainer. 
        """
        return _itkMeshBasePython.itkMeshD3_DeleteUnusedCellData(self)


    def SetCell(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer') -> "void":
        """
        SetCell(itkMeshD3 self, unsigned long arg0, itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer arg1)

        Access routines to fill the
        Cells container (m_CellsContainer), and get information from it. If
        SetCell is used to overwrite a cell currently in the mesh, it is the
        caller's responsibility to release the memory for the cell currently
        at the CellIdentifier position prior to calling SetCell. 
        """
        return _itkMeshBasePython.itkMeshD3_SetCell(self, arg0, arg1)


    def GetCell(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """GetCell(itkMeshD3 self, unsigned long arg0, itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer arg1) -> bool"""
        return _itkMeshBasePython.itkMeshD3_GetCell(self, arg0, arg1)


    def SetCellData(self, *args) -> "void":
        """
        SetCellData(itkMeshD3 self, itkVectorContainerULD arg0)
        SetCellData(itkMeshD3 self, unsigned long arg0, double arg1)

        Access routines to fill
        the CellData container, and get information from it. 
        """
        return _itkMeshBasePython.itkMeshD3_SetCellData(self, *args)


    def GetCellData(self, *args) -> "bool":
        """
        GetCellData(itkMeshD3 self) -> itkVectorContainerULD
        GetCellData(itkMeshD3 self) -> itkVectorContainerULD
        GetCellData(itkMeshD3 self, unsigned long arg0, double * arg1) -> bool
        """
        return _itkMeshBasePython.itkMeshD3_GetCellData(self, *args)


    def SetBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long', boundaryId: 'unsigned long') -> "void":
        """
        SetBoundaryAssignment(itkMeshD3 self, int dimension, unsigned long cellId, unsigned long featureId, unsigned long boundaryId)

        Explicitly
        assign boundaryId as a part of the boundary of cellId. The identifiers
        boundaryId and cellId must identify cell objects already in the mesh.
        The dimension of boundaryId must be specified by dimension, and a
        unique CellFeatureIdentifier featureId must be assigned for each
        distinct boundary feature of a given dimension. CellFeatureIdentifier
        is equivalent to IdentifierType by default, and this type alias will
        not typically need to be changed. The UsingCells list of boundaryId is
        automatically updated to include cellId. 
        """
        return _itkMeshBasePython.itkMeshD3_SetBoundaryAssignment(self, dimension, cellId, featureId, boundaryId)


    def GetBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long', boundaryId: 'unsigned long *') -> "bool":
        """
        GetBoundaryAssignment(itkMeshD3 self, int dimension, unsigned long cellId, unsigned long featureId, unsigned long * boundaryId) -> bool

        For the given
        cellId, get the identifier of a particular boundary feature of the
        given dimension. The featureId determines which boundary feature of
        the specified dimension is returned. For instance, if dimension is 1
        and featureId is 0, then GetBoundaryAssignment finds the 0th edge of
        the given cell. The return value indicates whether a feature of the
        appropriate dimension and featureId exists. If it does not, the
        BoundaryIdentifier pointer is left unchanged. 
        """
        return _itkMeshBasePython.itkMeshD3_GetBoundaryAssignment(self, dimension, cellId, featureId, boundaryId)


    def RemoveBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long') -> "bool":
        """RemoveBoundaryAssignment(itkMeshD3 self, int dimension, unsigned long cellId, unsigned long featureId) -> bool"""
        return _itkMeshBasePython.itkMeshD3_RemoveBoundaryAssignment(self, dimension, cellId, featureId)


    def GetNumberOfCellBoundaryFeatures(self, dimension: 'int', arg1: 'unsigned long') -> "unsigned long":
        """
        GetNumberOfCellBoundaryFeatures(itkMeshD3 self, int dimension, unsigned long arg1) -> unsigned long

        Interface to cells. 
        """
        return _itkMeshBasePython.itkMeshD3_GetNumberOfCellBoundaryFeatures(self, dimension, arg1)


    def GetCellBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', arg3: 'itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """
        GetCellBoundaryFeature(itkMeshD3 self, int dimension, unsigned long arg1, unsigned long arg2, itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer arg3) -> bool

        Get the
        boundary feature of the given dimension of the given cell
        corresponding to the given feature identifier. 
        """
        return _itkMeshBasePython.itkMeshD3_GetCellBoundaryFeature(self, dimension, arg1, arg2, arg3)


    def GetCellBoundaryFeatureNeighbors(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', cellSet: 'setUL') -> "unsigned long":
        """
        GetCellBoundaryFeatureNeighbors(itkMeshD3 self, int dimension, unsigned long arg1, unsigned long arg2, setUL cellSet) -> unsigned long

        Get
        the set of cells neighboring the given cell across the given boundary
        feature. Returns the number of neighbors found. If cellSet is not
        nullptr, the set of cell pointers is filled in with identifiers of the
        neighboring cells. 
        """
        return _itkMeshBasePython.itkMeshD3_GetCellBoundaryFeatureNeighbors(self, dimension, arg1, arg2, cellSet)


    def GetCellNeighbors(self, cellId: 'unsigned long', cellSet: 'setUL') -> "unsigned long":
        """
        GetCellNeighbors(itkMeshD3 self, unsigned long cellId, setUL cellSet) -> unsigned long

        Get the set of
        cells having the given cell as part of their boundary. Returns the
        number of neighbors found. If cellSet is not nullptr, the set of cell
        pointers is filled in with identifiers of the neighboring cells. 
        """
        return _itkMeshBasePython.itkMeshD3_GetCellNeighbors(self, cellId, cellSet)


    def GetAssignedCellBoundaryIfOneExists(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', arg3: 'itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """
        GetAssignedCellBoundaryIfOneExists(itkMeshD3 self, int dimension, unsigned long arg1, unsigned long arg2, itkCellInterfaceDCTI3FFULULULPF3VCULPF3_AutoPointer arg3) -> bool

        Check if there is an explicitly assigned boundary feature for the
        given dimension and cell- and cell-feature-identifiers. If there is, a
        pointer to it is given back through boundary (if boundary != nullptr)
        and true is returned. Otherwise, false is returned. 
        """
        return _itkMeshBasePython.itkMeshD3_GetAssignedCellBoundaryIfOneExists(self, dimension, arg1, arg2, arg3)


    def BuildCellLinks(self) -> "void":
        """
        BuildCellLinks(itkMeshD3 self)

        Dynamically build
        the links from points back to their using cells. This information is
        stored in the cell links container, not in the points. 
        """
        return _itkMeshBasePython.itkMeshD3_BuildCellLinks(self)


    def Accept(self, mv: 'itkCellInterfaceDCTI3FFULULULPF3VCULPF3::MultiVisitor *') -> "void":
        """
        Accept(itkMeshD3 self, itkCellInterfaceDCTI3FFULULULPF3VCULPF3::MultiVisitor * mv)

        This method iterates over
        all the cells in the mesh and has each cell Accept the MultiVisitor.
        See MultiVisitor for more information. (Note, this follows the Visitor
        Design Pattern.) 
        """
        return _itkMeshBasePython.itkMeshD3_Accept(self, mv)


    def SetCellsAllocationMethod(self, _arg: 'itkMeshEnums::MeshClassCellsAllocationMethod const') -> "void":
        """
        SetCellsAllocationMethod(itkMeshD3 self, itkMeshEnums::MeshClassCellsAllocationMethod const _arg)

        Set/Get
        the identification of the method used to allocate cells WARNING:
        Failure to call this method correctly will lead to memory leaks and/or
        segmentation faults because the cell memory will not be erased or will
        be erased with an improper method. 
        """
        return _itkMeshBasePython.itkMeshD3_SetCellsAllocationMethod(self, _arg)


    def GetCellsAllocationMethod(self) -> "itkMeshEnums::MeshClassCellsAllocationMethod const &":
        """GetCellsAllocationMethod(itkMeshD3 self) -> itkMeshEnums::MeshClassCellsAllocationMethod const &"""
        return _itkMeshBasePython.itkMeshD3_GetCellsAllocationMethod(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkMeshD3

    def cast(obj: 'itkLightObject') -> "itkMeshD3 *":
        """cast(itkLightObject obj) -> itkMeshD3"""
        return _itkMeshBasePython.itkMeshD3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkMeshD3

        Create a new object of the class itkMeshD3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMeshD3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkMeshD3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkMeshD3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkMeshD3.Clone = new_instancemethod(_itkMeshBasePython.itkMeshD3_Clone, None, itkMeshD3)
itkMeshD3.GetNumberOfCells = new_instancemethod(_itkMeshBasePython.itkMeshD3_GetNumberOfCells, None, itkMeshD3)
itkMeshD3.PassStructure = new_instancemethod(_itkMeshBasePython.itkMeshD3_PassStructure, None, itkMeshD3)
itkMeshD3.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkMeshD3_GetBoundingBox, None, itkMeshD3)
itkMeshD3.SetCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshD3_SetCellLinks, None, itkMeshD3)
itkMeshD3.GetCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshD3_GetCellLinks, None, itkMeshD3)
itkMeshD3.SetCells = new_instancemethod(_itkMeshBasePython.itkMeshD3_SetCells, None, itkMeshD3)
itkMeshD3.GetCells = new_instancemethod(_itkMeshBasePython.itkMeshD3_GetCells, None, itkMeshD3)
itkMeshD3.DeleteUnusedCellData = new_instancemethod(_itkMeshBasePython.itkMeshD3_DeleteUnusedCellData, None, itkMeshD3)
itkMeshD3.SetCell = new_instancemethod(_itkMeshBasePython.itkMeshD3_SetCell, None, itkMeshD3)
itkMeshD3.GetCell = new_instancemethod(_itkMeshBasePython.itkMeshD3_GetCell, None, itkMeshD3)
itkMeshD3.SetCellData = new_instancemethod(_itkMeshBasePython.itkMeshD3_SetCellData, None, itkMeshD3)
itkMeshD3.GetCellData = new_instancemethod(_itkMeshBasePython.itkMeshD3_GetCellData, None, itkMeshD3)
itkMeshD3.SetBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshD3_SetBoundaryAssignment, None, itkMeshD3)
itkMeshD3.GetBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshD3_GetBoundaryAssignment, None, itkMeshD3)
itkMeshD3.RemoveBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshD3_RemoveBoundaryAssignment, None, itkMeshD3)
itkMeshD3.GetNumberOfCellBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkMeshD3_GetNumberOfCellBoundaryFeatures, None, itkMeshD3)
itkMeshD3.GetCellBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkMeshD3_GetCellBoundaryFeature, None, itkMeshD3)
itkMeshD3.GetCellBoundaryFeatureNeighbors = new_instancemethod(_itkMeshBasePython.itkMeshD3_GetCellBoundaryFeatureNeighbors, None, itkMeshD3)
itkMeshD3.GetCellNeighbors = new_instancemethod(_itkMeshBasePython.itkMeshD3_GetCellNeighbors, None, itkMeshD3)
itkMeshD3.GetAssignedCellBoundaryIfOneExists = new_instancemethod(_itkMeshBasePython.itkMeshD3_GetAssignedCellBoundaryIfOneExists, None, itkMeshD3)
itkMeshD3.BuildCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshD3_BuildCellLinks, None, itkMeshD3)
itkMeshD3.Accept = new_instancemethod(_itkMeshBasePython.itkMeshD3_Accept, None, itkMeshD3)
itkMeshD3.SetCellsAllocationMethod = new_instancemethod(_itkMeshBasePython.itkMeshD3_SetCellsAllocationMethod, None, itkMeshD3)
itkMeshD3.GetCellsAllocationMethod = new_instancemethod(_itkMeshBasePython.itkMeshD3_GetCellsAllocationMethod, None, itkMeshD3)
itkMeshD3_swigregister = _itkMeshBasePython.itkMeshD3_swigregister
itkMeshD3_swigregister(itkMeshD3)

def itkMeshD3___New_orig__() -> "itkMeshD3_Pointer":
    """itkMeshD3___New_orig__() -> itkMeshD3_Pointer"""
    return _itkMeshBasePython.itkMeshD3___New_orig__()

def itkMeshD3_cast(obj: 'itkLightObject') -> "itkMeshD3 *":
    """itkMeshD3_cast(itkLightObject obj) -> itkMeshD3"""
    return _itkMeshBasePython.itkMeshD3_cast(obj)

class itkMeshF2(itkPointSetPython.itkPointSetF2):
    """


    Implements the N-dimensional mesh structure.

    Overview  Mesh implements the N-dimensional mesh structure for ITK. It
    provides an API to perform operations on points, cells, boundaries,
    etc., but does not tie down the underlying implementation and storage.
    A "MeshTraits" structure is used to define the container and
    identifier types that will be used to access the mesh. See
    DefaultStaticMeshTraits for the set of type definitions needed. All
    types that are defined in the "MeshTraits" structure will have
    duplicate type alias in the resulting mesh itself.  Mesh is an
    adaptive, evolving structure. Typically points and cells are created,
    with the cells referring to their defining points. If additional
    topological information is required, then BuildCellLinks() is called
    and links from the points back to the cells that use them are created.
    This allows implicit topological information about the faces to a cell
    can be determined by intersection the sets of cells that use the
    points defining the face. This is an inherent assumption on the
    manifold relationship of the cells in the mesh.) In some cases, either
    because the mesh is non-manifold, because we wish to explicitly store
    information with the faces and edges of the mesh, or because
    performance requirements demand that boundaries are explicitly
    represented (the set intersection does not need to be performed); then
    Mesh can be further extended by adding explicit boundary assignments.

    Usage  Mesh has three template parameters. The first is the pixel
    type, or the type of data stored (optionally) with points, cells,
    and/or boundaries. The second is the geometric dimension of the points
    defining the mesh. This also limits the maximum topological dimension
    of the cells that can be inserted. The third template parameter is the
    "MeshTraits" structure controlling type information for the mesh.
    Most users will be happy with the defaults, and will not have to worry
    about this third argument.  One of the most important parts of using
    this mesh is how to create cells to insert into it. The cells for the
    mesh take two template parameters. The first is the pixel type, and
    should correspond exactly to that type given to the mesh. The second
    is a "CellTraits" which holds a sub-set of the "MeshTraits"
    structure definitions, and is also a member of them. Any cell which is
    to be inserted to a mesh should have MeshTraits::CellTraits as its
    second template parameter.

    Template parameters for Mesh:

    TPixelType = The type stored as data for an entity (cell, point, or
    boundary).

    TMeshTraits = Type information structure for the mesh.

    References No reference information is available.

    C++ includes: itkMesh.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkMeshF2_Pointer":
        """__New_orig__() -> itkMeshF2_Pointer"""
        return _itkMeshBasePython.itkMeshF2___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkMeshF2_Pointer":
        """Clone(itkMeshF2 self) -> itkMeshF2_Pointer"""
        return _itkMeshBasePython.itkMeshF2_Clone(self)


    def GetNumberOfCells(self) -> "unsigned long":
        """
        GetNumberOfCells(itkMeshF2 self) -> unsigned long

        Mesh-level
        operation interface. 
        """
        return _itkMeshBasePython.itkMeshF2_GetNumberOfCells(self)


    def PassStructure(self, inputMesh: 'itkMeshF2') -> "void":
        """
        PassStructure(itkMeshF2 self, itkMeshF2 inputMesh)

        PointSet-level
        operation interface. 
        """
        return _itkMeshBasePython.itkMeshF2_PassStructure(self, inputMesh)


    def GetBoundingBox(self) -> "itkBoundingBoxUL2FVCULPF2 const *":
        """
        GetBoundingBox(itkMeshF2 self) -> itkBoundingBoxUL2FVCULPF2

        Get the bounding box
        of the mesh. The methods return a pointer to the user-supplied
        bounding box as a convenience. 
        """
        return _itkMeshBasePython.itkMeshF2_GetBoundingBox(self)


    def SetCellLinks(self, arg0: 'itkVectorContainerULSUL') -> "void":
        """
        SetCellLinks(itkMeshF2 self, itkVectorContainerULSUL arg0)

        Access
        m_CellsLinksContainer, which contains parent cell links for each
        point. Since a point can be used by multiple cells, each point
        identifier accesses another container which holds the cell identifiers

        """
        return _itkMeshBasePython.itkMeshF2_SetCellLinks(self, arg0)


    def GetCellLinks(self, *args) -> "itkVectorContainerULSUL const *":
        """
        GetCellLinks(itkMeshF2 self) -> itkVectorContainerULSUL
        GetCellLinks(itkMeshF2 self) -> itkVectorContainerULSUL
        """
        return _itkMeshBasePython.itkMeshF2_GetCellLinks(self, *args)


    def SetCells(self, arg0: 'itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2') -> "void":
        """
        SetCells(itkMeshF2 self, itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2 arg0)

        Access m_CellsContainer,
        which holds cells used by the mesh. Individual cells are accessed
        through cell identifiers. 
        """
        return _itkMeshBasePython.itkMeshF2_SetCells(self, arg0)


    def GetCells(self, *args) -> "itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2 const *":
        """
        GetCells(itkMeshF2 self) -> itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2
        GetCells(itkMeshF2 self) -> itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2
        """
        return _itkMeshBasePython.itkMeshF2_GetCells(self, *args)


    def DeleteUnusedCellData(self) -> "void":
        """
        DeleteUnusedCellData(itkMeshF2 self)

        Delete entries
        in m_CellDataContainer which do not have a corresponding entry in
        m_CellsContainer. 
        """
        return _itkMeshBasePython.itkMeshF2_DeleteUnusedCellData(self)


    def SetCell(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer') -> "void":
        """
        SetCell(itkMeshF2 self, unsigned long arg0, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer arg1)

        Access routines to fill the
        Cells container (m_CellsContainer), and get information from it. If
        SetCell is used to overwrite a cell currently in the mesh, it is the
        caller's responsibility to release the memory for the cell currently
        at the CellIdentifier position prior to calling SetCell. 
        """
        return _itkMeshBasePython.itkMeshF2_SetCell(self, arg0, arg1)


    def GetCell(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """GetCell(itkMeshF2 self, unsigned long arg0, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer arg1) -> bool"""
        return _itkMeshBasePython.itkMeshF2_GetCell(self, arg0, arg1)


    def SetCellData(self, *args) -> "void":
        """
        SetCellData(itkMeshF2 self, itkVectorContainerULF arg0)
        SetCellData(itkMeshF2 self, unsigned long arg0, float arg1)

        Access routines to fill
        the CellData container, and get information from it. 
        """
        return _itkMeshBasePython.itkMeshF2_SetCellData(self, *args)


    def GetCellData(self, *args) -> "bool":
        """
        GetCellData(itkMeshF2 self) -> itkVectorContainerULF
        GetCellData(itkMeshF2 self) -> itkVectorContainerULF
        GetCellData(itkMeshF2 self, unsigned long arg0, float * arg1) -> bool
        """
        return _itkMeshBasePython.itkMeshF2_GetCellData(self, *args)


    def SetBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long', boundaryId: 'unsigned long') -> "void":
        """
        SetBoundaryAssignment(itkMeshF2 self, int dimension, unsigned long cellId, unsigned long featureId, unsigned long boundaryId)

        Explicitly
        assign boundaryId as a part of the boundary of cellId. The identifiers
        boundaryId and cellId must identify cell objects already in the mesh.
        The dimension of boundaryId must be specified by dimension, and a
        unique CellFeatureIdentifier featureId must be assigned for each
        distinct boundary feature of a given dimension. CellFeatureIdentifier
        is equivalent to IdentifierType by default, and this type alias will
        not typically need to be changed. The UsingCells list of boundaryId is
        automatically updated to include cellId. 
        """
        return _itkMeshBasePython.itkMeshF2_SetBoundaryAssignment(self, dimension, cellId, featureId, boundaryId)


    def GetBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long', boundaryId: 'unsigned long *') -> "bool":
        """
        GetBoundaryAssignment(itkMeshF2 self, int dimension, unsigned long cellId, unsigned long featureId, unsigned long * boundaryId) -> bool

        For the given
        cellId, get the identifier of a particular boundary feature of the
        given dimension. The featureId determines which boundary feature of
        the specified dimension is returned. For instance, if dimension is 1
        and featureId is 0, then GetBoundaryAssignment finds the 0th edge of
        the given cell. The return value indicates whether a feature of the
        appropriate dimension and featureId exists. If it does not, the
        BoundaryIdentifier pointer is left unchanged. 
        """
        return _itkMeshBasePython.itkMeshF2_GetBoundaryAssignment(self, dimension, cellId, featureId, boundaryId)


    def RemoveBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long') -> "bool":
        """RemoveBoundaryAssignment(itkMeshF2 self, int dimension, unsigned long cellId, unsigned long featureId) -> bool"""
        return _itkMeshBasePython.itkMeshF2_RemoveBoundaryAssignment(self, dimension, cellId, featureId)


    def GetNumberOfCellBoundaryFeatures(self, dimension: 'int', arg1: 'unsigned long') -> "unsigned long":
        """
        GetNumberOfCellBoundaryFeatures(itkMeshF2 self, int dimension, unsigned long arg1) -> unsigned long

        Interface to cells. 
        """
        return _itkMeshBasePython.itkMeshF2_GetNumberOfCellBoundaryFeatures(self, dimension, arg1)


    def GetCellBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', arg3: 'itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """
        GetCellBoundaryFeature(itkMeshF2 self, int dimension, unsigned long arg1, unsigned long arg2, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer arg3) -> bool

        Get the
        boundary feature of the given dimension of the given cell
        corresponding to the given feature identifier. 
        """
        return _itkMeshBasePython.itkMeshF2_GetCellBoundaryFeature(self, dimension, arg1, arg2, arg3)


    def GetCellBoundaryFeatureNeighbors(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', cellSet: 'setUL') -> "unsigned long":
        """
        GetCellBoundaryFeatureNeighbors(itkMeshF2 self, int dimension, unsigned long arg1, unsigned long arg2, setUL cellSet) -> unsigned long

        Get
        the set of cells neighboring the given cell across the given boundary
        feature. Returns the number of neighbors found. If cellSet is not
        nullptr, the set of cell pointers is filled in with identifiers of the
        neighboring cells. 
        """
        return _itkMeshBasePython.itkMeshF2_GetCellBoundaryFeatureNeighbors(self, dimension, arg1, arg2, cellSet)


    def GetCellNeighbors(self, cellId: 'unsigned long', cellSet: 'setUL') -> "unsigned long":
        """
        GetCellNeighbors(itkMeshF2 self, unsigned long cellId, setUL cellSet) -> unsigned long

        Get the set of
        cells having the given cell as part of their boundary. Returns the
        number of neighbors found. If cellSet is not nullptr, the set of cell
        pointers is filled in with identifiers of the neighboring cells. 
        """
        return _itkMeshBasePython.itkMeshF2_GetCellNeighbors(self, cellId, cellSet)


    def GetAssignedCellBoundaryIfOneExists(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', arg3: 'itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """
        GetAssignedCellBoundaryIfOneExists(itkMeshF2 self, int dimension, unsigned long arg1, unsigned long arg2, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer arg3) -> bool

        Check if there is an explicitly assigned boundary feature for the
        given dimension and cell- and cell-feature-identifiers. If there is, a
        pointer to it is given back through boundary (if boundary != nullptr)
        and true is returned. Otherwise, false is returned. 
        """
        return _itkMeshBasePython.itkMeshF2_GetAssignedCellBoundaryIfOneExists(self, dimension, arg1, arg2, arg3)


    def BuildCellLinks(self) -> "void":
        """
        BuildCellLinks(itkMeshF2 self)

        Dynamically build
        the links from points back to their using cells. This information is
        stored in the cell links container, not in the points. 
        """
        return _itkMeshBasePython.itkMeshF2_BuildCellLinks(self)


    def Accept(self, mv: 'itkCellInterfaceFCTI2FFULULULPF2VCULPF2::MultiVisitor *') -> "void":
        """
        Accept(itkMeshF2 self, itkCellInterfaceFCTI2FFULULULPF2VCULPF2::MultiVisitor * mv)

        This method iterates over
        all the cells in the mesh and has each cell Accept the MultiVisitor.
        See MultiVisitor for more information. (Note, this follows the Visitor
        Design Pattern.) 
        """
        return _itkMeshBasePython.itkMeshF2_Accept(self, mv)


    def SetCellsAllocationMethod(self, _arg: 'itkMeshEnums::MeshClassCellsAllocationMethod const') -> "void":
        """
        SetCellsAllocationMethod(itkMeshF2 self, itkMeshEnums::MeshClassCellsAllocationMethod const _arg)

        Set/Get
        the identification of the method used to allocate cells WARNING:
        Failure to call this method correctly will lead to memory leaks and/or
        segmentation faults because the cell memory will not be erased or will
        be erased with an improper method. 
        """
        return _itkMeshBasePython.itkMeshF2_SetCellsAllocationMethod(self, _arg)


    def GetCellsAllocationMethod(self) -> "itkMeshEnums::MeshClassCellsAllocationMethod const &":
        """GetCellsAllocationMethod(itkMeshF2 self) -> itkMeshEnums::MeshClassCellsAllocationMethod const &"""
        return _itkMeshBasePython.itkMeshF2_GetCellsAllocationMethod(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkMeshF2

    def cast(obj: 'itkLightObject') -> "itkMeshF2 *":
        """cast(itkLightObject obj) -> itkMeshF2"""
        return _itkMeshBasePython.itkMeshF2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkMeshF2

        Create a new object of the class itkMeshF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMeshF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkMeshF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkMeshF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkMeshF2.Clone = new_instancemethod(_itkMeshBasePython.itkMeshF2_Clone, None, itkMeshF2)
itkMeshF2.GetNumberOfCells = new_instancemethod(_itkMeshBasePython.itkMeshF2_GetNumberOfCells, None, itkMeshF2)
itkMeshF2.PassStructure = new_instancemethod(_itkMeshBasePython.itkMeshF2_PassStructure, None, itkMeshF2)
itkMeshF2.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkMeshF2_GetBoundingBox, None, itkMeshF2)
itkMeshF2.SetCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshF2_SetCellLinks, None, itkMeshF2)
itkMeshF2.GetCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshF2_GetCellLinks, None, itkMeshF2)
itkMeshF2.SetCells = new_instancemethod(_itkMeshBasePython.itkMeshF2_SetCells, None, itkMeshF2)
itkMeshF2.GetCells = new_instancemethod(_itkMeshBasePython.itkMeshF2_GetCells, None, itkMeshF2)
itkMeshF2.DeleteUnusedCellData = new_instancemethod(_itkMeshBasePython.itkMeshF2_DeleteUnusedCellData, None, itkMeshF2)
itkMeshF2.SetCell = new_instancemethod(_itkMeshBasePython.itkMeshF2_SetCell, None, itkMeshF2)
itkMeshF2.GetCell = new_instancemethod(_itkMeshBasePython.itkMeshF2_GetCell, None, itkMeshF2)
itkMeshF2.SetCellData = new_instancemethod(_itkMeshBasePython.itkMeshF2_SetCellData, None, itkMeshF2)
itkMeshF2.GetCellData = new_instancemethod(_itkMeshBasePython.itkMeshF2_GetCellData, None, itkMeshF2)
itkMeshF2.SetBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshF2_SetBoundaryAssignment, None, itkMeshF2)
itkMeshF2.GetBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshF2_GetBoundaryAssignment, None, itkMeshF2)
itkMeshF2.RemoveBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshF2_RemoveBoundaryAssignment, None, itkMeshF2)
itkMeshF2.GetNumberOfCellBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkMeshF2_GetNumberOfCellBoundaryFeatures, None, itkMeshF2)
itkMeshF2.GetCellBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkMeshF2_GetCellBoundaryFeature, None, itkMeshF2)
itkMeshF2.GetCellBoundaryFeatureNeighbors = new_instancemethod(_itkMeshBasePython.itkMeshF2_GetCellBoundaryFeatureNeighbors, None, itkMeshF2)
itkMeshF2.GetCellNeighbors = new_instancemethod(_itkMeshBasePython.itkMeshF2_GetCellNeighbors, None, itkMeshF2)
itkMeshF2.GetAssignedCellBoundaryIfOneExists = new_instancemethod(_itkMeshBasePython.itkMeshF2_GetAssignedCellBoundaryIfOneExists, None, itkMeshF2)
itkMeshF2.BuildCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshF2_BuildCellLinks, None, itkMeshF2)
itkMeshF2.Accept = new_instancemethod(_itkMeshBasePython.itkMeshF2_Accept, None, itkMeshF2)
itkMeshF2.SetCellsAllocationMethod = new_instancemethod(_itkMeshBasePython.itkMeshF2_SetCellsAllocationMethod, None, itkMeshF2)
itkMeshF2.GetCellsAllocationMethod = new_instancemethod(_itkMeshBasePython.itkMeshF2_GetCellsAllocationMethod, None, itkMeshF2)
itkMeshF2_swigregister = _itkMeshBasePython.itkMeshF2_swigregister
itkMeshF2_swigregister(itkMeshF2)

def itkMeshF2___New_orig__() -> "itkMeshF2_Pointer":
    """itkMeshF2___New_orig__() -> itkMeshF2_Pointer"""
    return _itkMeshBasePython.itkMeshF2___New_orig__()

def itkMeshF2_cast(obj: 'itkLightObject') -> "itkMeshF2 *":
    """itkMeshF2_cast(itkLightObject obj) -> itkMeshF2"""
    return _itkMeshBasePython.itkMeshF2_cast(obj)

class itkMeshF3(itkPointSetPython.itkPointSetF3):
    """


    Implements the N-dimensional mesh structure.

    Overview  Mesh implements the N-dimensional mesh structure for ITK. It
    provides an API to perform operations on points, cells, boundaries,
    etc., but does not tie down the underlying implementation and storage.
    A "MeshTraits" structure is used to define the container and
    identifier types that will be used to access the mesh. See
    DefaultStaticMeshTraits for the set of type definitions needed. All
    types that are defined in the "MeshTraits" structure will have
    duplicate type alias in the resulting mesh itself.  Mesh is an
    adaptive, evolving structure. Typically points and cells are created,
    with the cells referring to their defining points. If additional
    topological information is required, then BuildCellLinks() is called
    and links from the points back to the cells that use them are created.
    This allows implicit topological information about the faces to a cell
    can be determined by intersection the sets of cells that use the
    points defining the face. This is an inherent assumption on the
    manifold relationship of the cells in the mesh.) In some cases, either
    because the mesh is non-manifold, because we wish to explicitly store
    information with the faces and edges of the mesh, or because
    performance requirements demand that boundaries are explicitly
    represented (the set intersection does not need to be performed); then
    Mesh can be further extended by adding explicit boundary assignments.

    Usage  Mesh has three template parameters. The first is the pixel
    type, or the type of data stored (optionally) with points, cells,
    and/or boundaries. The second is the geometric dimension of the points
    defining the mesh. This also limits the maximum topological dimension
    of the cells that can be inserted. The third template parameter is the
    "MeshTraits" structure controlling type information for the mesh.
    Most users will be happy with the defaults, and will not have to worry
    about this third argument.  One of the most important parts of using
    this mesh is how to create cells to insert into it. The cells for the
    mesh take two template parameters. The first is the pixel type, and
    should correspond exactly to that type given to the mesh. The second
    is a "CellTraits" which holds a sub-set of the "MeshTraits"
    structure definitions, and is also a member of them. Any cell which is
    to be inserted to a mesh should have MeshTraits::CellTraits as its
    second template parameter.

    Template parameters for Mesh:

    TPixelType = The type stored as data for an entity (cell, point, or
    boundary).

    TMeshTraits = Type information structure for the mesh.

    References No reference information is available.

    C++ includes: itkMesh.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkMeshF3_Pointer":
        """__New_orig__() -> itkMeshF3_Pointer"""
        return _itkMeshBasePython.itkMeshF3___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkMeshF3_Pointer":
        """Clone(itkMeshF3 self) -> itkMeshF3_Pointer"""
        return _itkMeshBasePython.itkMeshF3_Clone(self)


    def GetNumberOfCells(self) -> "unsigned long":
        """
        GetNumberOfCells(itkMeshF3 self) -> unsigned long

        Mesh-level
        operation interface. 
        """
        return _itkMeshBasePython.itkMeshF3_GetNumberOfCells(self)


    def PassStructure(self, inputMesh: 'itkMeshF3') -> "void":
        """
        PassStructure(itkMeshF3 self, itkMeshF3 inputMesh)

        PointSet-level
        operation interface. 
        """
        return _itkMeshBasePython.itkMeshF3_PassStructure(self, inputMesh)


    def GetBoundingBox(self) -> "itkBoundingBoxUL3FVCULPF3 const *":
        """
        GetBoundingBox(itkMeshF3 self) -> itkBoundingBoxUL3FVCULPF3

        Get the bounding box
        of the mesh. The methods return a pointer to the user-supplied
        bounding box as a convenience. 
        """
        return _itkMeshBasePython.itkMeshF3_GetBoundingBox(self)


    def SetCellLinks(self, arg0: 'itkVectorContainerULSUL') -> "void":
        """
        SetCellLinks(itkMeshF3 self, itkVectorContainerULSUL arg0)

        Access
        m_CellsLinksContainer, which contains parent cell links for each
        point. Since a point can be used by multiple cells, each point
        identifier accesses another container which holds the cell identifiers

        """
        return _itkMeshBasePython.itkMeshF3_SetCellLinks(self, arg0)


    def GetCellLinks(self, *args) -> "itkVectorContainerULSUL const *":
        """
        GetCellLinks(itkMeshF3 self) -> itkVectorContainerULSUL
        GetCellLinks(itkMeshF3 self) -> itkVectorContainerULSUL
        """
        return _itkMeshBasePython.itkMeshF3_GetCellLinks(self, *args)


    def SetCells(self, arg0: 'itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3') -> "void":
        """
        SetCells(itkMeshF3 self, itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3 arg0)

        Access m_CellsContainer,
        which holds cells used by the mesh. Individual cells are accessed
        through cell identifiers. 
        """
        return _itkMeshBasePython.itkMeshF3_SetCells(self, arg0)


    def GetCells(self, *args) -> "itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3 const *":
        """
        GetCells(itkMeshF3 self) -> itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3
        GetCells(itkMeshF3 self) -> itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3
        """
        return _itkMeshBasePython.itkMeshF3_GetCells(self, *args)


    def DeleteUnusedCellData(self) -> "void":
        """
        DeleteUnusedCellData(itkMeshF3 self)

        Delete entries
        in m_CellDataContainer which do not have a corresponding entry in
        m_CellsContainer. 
        """
        return _itkMeshBasePython.itkMeshF3_DeleteUnusedCellData(self)


    def SetCell(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer') -> "void":
        """
        SetCell(itkMeshF3 self, unsigned long arg0, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer arg1)

        Access routines to fill the
        Cells container (m_CellsContainer), and get information from it. If
        SetCell is used to overwrite a cell currently in the mesh, it is the
        caller's responsibility to release the memory for the cell currently
        at the CellIdentifier position prior to calling SetCell. 
        """
        return _itkMeshBasePython.itkMeshF3_SetCell(self, arg0, arg1)


    def GetCell(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """GetCell(itkMeshF3 self, unsigned long arg0, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer arg1) -> bool"""
        return _itkMeshBasePython.itkMeshF3_GetCell(self, arg0, arg1)


    def SetCellData(self, *args) -> "void":
        """
        SetCellData(itkMeshF3 self, itkVectorContainerULF arg0)
        SetCellData(itkMeshF3 self, unsigned long arg0, float arg1)

        Access routines to fill
        the CellData container, and get information from it. 
        """
        return _itkMeshBasePython.itkMeshF3_SetCellData(self, *args)


    def GetCellData(self, *args) -> "bool":
        """
        GetCellData(itkMeshF3 self) -> itkVectorContainerULF
        GetCellData(itkMeshF3 self) -> itkVectorContainerULF
        GetCellData(itkMeshF3 self, unsigned long arg0, float * arg1) -> bool
        """
        return _itkMeshBasePython.itkMeshF3_GetCellData(self, *args)


    def SetBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long', boundaryId: 'unsigned long') -> "void":
        """
        SetBoundaryAssignment(itkMeshF3 self, int dimension, unsigned long cellId, unsigned long featureId, unsigned long boundaryId)

        Explicitly
        assign boundaryId as a part of the boundary of cellId. The identifiers
        boundaryId and cellId must identify cell objects already in the mesh.
        The dimension of boundaryId must be specified by dimension, and a
        unique CellFeatureIdentifier featureId must be assigned for each
        distinct boundary feature of a given dimension. CellFeatureIdentifier
        is equivalent to IdentifierType by default, and this type alias will
        not typically need to be changed. The UsingCells list of boundaryId is
        automatically updated to include cellId. 
        """
        return _itkMeshBasePython.itkMeshF3_SetBoundaryAssignment(self, dimension, cellId, featureId, boundaryId)


    def GetBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long', boundaryId: 'unsigned long *') -> "bool":
        """
        GetBoundaryAssignment(itkMeshF3 self, int dimension, unsigned long cellId, unsigned long featureId, unsigned long * boundaryId) -> bool

        For the given
        cellId, get the identifier of a particular boundary feature of the
        given dimension. The featureId determines which boundary feature of
        the specified dimension is returned. For instance, if dimension is 1
        and featureId is 0, then GetBoundaryAssignment finds the 0th edge of
        the given cell. The return value indicates whether a feature of the
        appropriate dimension and featureId exists. If it does not, the
        BoundaryIdentifier pointer is left unchanged. 
        """
        return _itkMeshBasePython.itkMeshF3_GetBoundaryAssignment(self, dimension, cellId, featureId, boundaryId)


    def RemoveBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long') -> "bool":
        """RemoveBoundaryAssignment(itkMeshF3 self, int dimension, unsigned long cellId, unsigned long featureId) -> bool"""
        return _itkMeshBasePython.itkMeshF3_RemoveBoundaryAssignment(self, dimension, cellId, featureId)


    def GetNumberOfCellBoundaryFeatures(self, dimension: 'int', arg1: 'unsigned long') -> "unsigned long":
        """
        GetNumberOfCellBoundaryFeatures(itkMeshF3 self, int dimension, unsigned long arg1) -> unsigned long

        Interface to cells. 
        """
        return _itkMeshBasePython.itkMeshF3_GetNumberOfCellBoundaryFeatures(self, dimension, arg1)


    def GetCellBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', arg3: 'itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """
        GetCellBoundaryFeature(itkMeshF3 self, int dimension, unsigned long arg1, unsigned long arg2, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer arg3) -> bool

        Get the
        boundary feature of the given dimension of the given cell
        corresponding to the given feature identifier. 
        """
        return _itkMeshBasePython.itkMeshF3_GetCellBoundaryFeature(self, dimension, arg1, arg2, arg3)


    def GetCellBoundaryFeatureNeighbors(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', cellSet: 'setUL') -> "unsigned long":
        """
        GetCellBoundaryFeatureNeighbors(itkMeshF3 self, int dimension, unsigned long arg1, unsigned long arg2, setUL cellSet) -> unsigned long

        Get
        the set of cells neighboring the given cell across the given boundary
        feature. Returns the number of neighbors found. If cellSet is not
        nullptr, the set of cell pointers is filled in with identifiers of the
        neighboring cells. 
        """
        return _itkMeshBasePython.itkMeshF3_GetCellBoundaryFeatureNeighbors(self, dimension, arg1, arg2, cellSet)


    def GetCellNeighbors(self, cellId: 'unsigned long', cellSet: 'setUL') -> "unsigned long":
        """
        GetCellNeighbors(itkMeshF3 self, unsigned long cellId, setUL cellSet) -> unsigned long

        Get the set of
        cells having the given cell as part of their boundary. Returns the
        number of neighbors found. If cellSet is not nullptr, the set of cell
        pointers is filled in with identifiers of the neighboring cells. 
        """
        return _itkMeshBasePython.itkMeshF3_GetCellNeighbors(self, cellId, cellSet)


    def GetAssignedCellBoundaryIfOneExists(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', arg3: 'itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """
        GetAssignedCellBoundaryIfOneExists(itkMeshF3 self, int dimension, unsigned long arg1, unsigned long arg2, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer arg3) -> bool

        Check if there is an explicitly assigned boundary feature for the
        given dimension and cell- and cell-feature-identifiers. If there is, a
        pointer to it is given back through boundary (if boundary != nullptr)
        and true is returned. Otherwise, false is returned. 
        """
        return _itkMeshBasePython.itkMeshF3_GetAssignedCellBoundaryIfOneExists(self, dimension, arg1, arg2, arg3)


    def BuildCellLinks(self) -> "void":
        """
        BuildCellLinks(itkMeshF3 self)

        Dynamically build
        the links from points back to their using cells. This information is
        stored in the cell links container, not in the points. 
        """
        return _itkMeshBasePython.itkMeshF3_BuildCellLinks(self)


    def Accept(self, mv: 'itkCellInterfaceFCTI3FFULULULPF3VCULPF3::MultiVisitor *') -> "void":
        """
        Accept(itkMeshF3 self, itkCellInterfaceFCTI3FFULULULPF3VCULPF3::MultiVisitor * mv)

        This method iterates over
        all the cells in the mesh and has each cell Accept the MultiVisitor.
        See MultiVisitor for more information. (Note, this follows the Visitor
        Design Pattern.) 
        """
        return _itkMeshBasePython.itkMeshF3_Accept(self, mv)


    def SetCellsAllocationMethod(self, _arg: 'itkMeshEnums::MeshClassCellsAllocationMethod const') -> "void":
        """
        SetCellsAllocationMethod(itkMeshF3 self, itkMeshEnums::MeshClassCellsAllocationMethod const _arg)

        Set/Get
        the identification of the method used to allocate cells WARNING:
        Failure to call this method correctly will lead to memory leaks and/or
        segmentation faults because the cell memory will not be erased or will
        be erased with an improper method. 
        """
        return _itkMeshBasePython.itkMeshF3_SetCellsAllocationMethod(self, _arg)


    def GetCellsAllocationMethod(self) -> "itkMeshEnums::MeshClassCellsAllocationMethod const &":
        """GetCellsAllocationMethod(itkMeshF3 self) -> itkMeshEnums::MeshClassCellsAllocationMethod const &"""
        return _itkMeshBasePython.itkMeshF3_GetCellsAllocationMethod(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkMeshF3

    def cast(obj: 'itkLightObject') -> "itkMeshF3 *":
        """cast(itkLightObject obj) -> itkMeshF3"""
        return _itkMeshBasePython.itkMeshF3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkMeshF3

        Create a new object of the class itkMeshF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMeshF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkMeshF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkMeshF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkMeshF3.Clone = new_instancemethod(_itkMeshBasePython.itkMeshF3_Clone, None, itkMeshF3)
itkMeshF3.GetNumberOfCells = new_instancemethod(_itkMeshBasePython.itkMeshF3_GetNumberOfCells, None, itkMeshF3)
itkMeshF3.PassStructure = new_instancemethod(_itkMeshBasePython.itkMeshF3_PassStructure, None, itkMeshF3)
itkMeshF3.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkMeshF3_GetBoundingBox, None, itkMeshF3)
itkMeshF3.SetCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshF3_SetCellLinks, None, itkMeshF3)
itkMeshF3.GetCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshF3_GetCellLinks, None, itkMeshF3)
itkMeshF3.SetCells = new_instancemethod(_itkMeshBasePython.itkMeshF3_SetCells, None, itkMeshF3)
itkMeshF3.GetCells = new_instancemethod(_itkMeshBasePython.itkMeshF3_GetCells, None, itkMeshF3)
itkMeshF3.DeleteUnusedCellData = new_instancemethod(_itkMeshBasePython.itkMeshF3_DeleteUnusedCellData, None, itkMeshF3)
itkMeshF3.SetCell = new_instancemethod(_itkMeshBasePython.itkMeshF3_SetCell, None, itkMeshF3)
itkMeshF3.GetCell = new_instancemethod(_itkMeshBasePython.itkMeshF3_GetCell, None, itkMeshF3)
itkMeshF3.SetCellData = new_instancemethod(_itkMeshBasePython.itkMeshF3_SetCellData, None, itkMeshF3)
itkMeshF3.GetCellData = new_instancemethod(_itkMeshBasePython.itkMeshF3_GetCellData, None, itkMeshF3)
itkMeshF3.SetBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshF3_SetBoundaryAssignment, None, itkMeshF3)
itkMeshF3.GetBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshF3_GetBoundaryAssignment, None, itkMeshF3)
itkMeshF3.RemoveBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshF3_RemoveBoundaryAssignment, None, itkMeshF3)
itkMeshF3.GetNumberOfCellBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkMeshF3_GetNumberOfCellBoundaryFeatures, None, itkMeshF3)
itkMeshF3.GetCellBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkMeshF3_GetCellBoundaryFeature, None, itkMeshF3)
itkMeshF3.GetCellBoundaryFeatureNeighbors = new_instancemethod(_itkMeshBasePython.itkMeshF3_GetCellBoundaryFeatureNeighbors, None, itkMeshF3)
itkMeshF3.GetCellNeighbors = new_instancemethod(_itkMeshBasePython.itkMeshF3_GetCellNeighbors, None, itkMeshF3)
itkMeshF3.GetAssignedCellBoundaryIfOneExists = new_instancemethod(_itkMeshBasePython.itkMeshF3_GetAssignedCellBoundaryIfOneExists, None, itkMeshF3)
itkMeshF3.BuildCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshF3_BuildCellLinks, None, itkMeshF3)
itkMeshF3.Accept = new_instancemethod(_itkMeshBasePython.itkMeshF3_Accept, None, itkMeshF3)
itkMeshF3.SetCellsAllocationMethod = new_instancemethod(_itkMeshBasePython.itkMeshF3_SetCellsAllocationMethod, None, itkMeshF3)
itkMeshF3.GetCellsAllocationMethod = new_instancemethod(_itkMeshBasePython.itkMeshF3_GetCellsAllocationMethod, None, itkMeshF3)
itkMeshF3_swigregister = _itkMeshBasePython.itkMeshF3_swigregister
itkMeshF3_swigregister(itkMeshF3)

def itkMeshF3___New_orig__() -> "itkMeshF3_Pointer":
    """itkMeshF3___New_orig__() -> itkMeshF3_Pointer"""
    return _itkMeshBasePython.itkMeshF3___New_orig__()

def itkMeshF3_cast(obj: 'itkLightObject') -> "itkMeshF3 *":
    """itkMeshF3_cast(itkLightObject obj) -> itkMeshF3"""
    return _itkMeshBasePython.itkMeshF3_cast(obj)

class itkMeshSS2(itkPointSetPython.itkPointSetSS2):
    """


    Implements the N-dimensional mesh structure.

    Overview  Mesh implements the N-dimensional mesh structure for ITK. It
    provides an API to perform operations on points, cells, boundaries,
    etc., but does not tie down the underlying implementation and storage.
    A "MeshTraits" structure is used to define the container and
    identifier types that will be used to access the mesh. See
    DefaultStaticMeshTraits for the set of type definitions needed. All
    types that are defined in the "MeshTraits" structure will have
    duplicate type alias in the resulting mesh itself.  Mesh is an
    adaptive, evolving structure. Typically points and cells are created,
    with the cells referring to their defining points. If additional
    topological information is required, then BuildCellLinks() is called
    and links from the points back to the cells that use them are created.
    This allows implicit topological information about the faces to a cell
    can be determined by intersection the sets of cells that use the
    points defining the face. This is an inherent assumption on the
    manifold relationship of the cells in the mesh.) In some cases, either
    because the mesh is non-manifold, because we wish to explicitly store
    information with the faces and edges of the mesh, or because
    performance requirements demand that boundaries are explicitly
    represented (the set intersection does not need to be performed); then
    Mesh can be further extended by adding explicit boundary assignments.

    Usage  Mesh has three template parameters. The first is the pixel
    type, or the type of data stored (optionally) with points, cells,
    and/or boundaries. The second is the geometric dimension of the points
    defining the mesh. This also limits the maximum topological dimension
    of the cells that can be inserted. The third template parameter is the
    "MeshTraits" structure controlling type information for the mesh.
    Most users will be happy with the defaults, and will not have to worry
    about this third argument.  One of the most important parts of using
    this mesh is how to create cells to insert into it. The cells for the
    mesh take two template parameters. The first is the pixel type, and
    should correspond exactly to that type given to the mesh. The second
    is a "CellTraits" which holds a sub-set of the "MeshTraits"
    structure definitions, and is also a member of them. Any cell which is
    to be inserted to a mesh should have MeshTraits::CellTraits as its
    second template parameter.

    Template parameters for Mesh:

    TPixelType = The type stored as data for an entity (cell, point, or
    boundary).

    TMeshTraits = Type information structure for the mesh.

    References No reference information is available.

    C++ includes: itkMesh.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkMeshSS2_Pointer":
        """__New_orig__() -> itkMeshSS2_Pointer"""
        return _itkMeshBasePython.itkMeshSS2___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkMeshSS2_Pointer":
        """Clone(itkMeshSS2 self) -> itkMeshSS2_Pointer"""
        return _itkMeshBasePython.itkMeshSS2_Clone(self)


    def GetNumberOfCells(self) -> "unsigned long":
        """
        GetNumberOfCells(itkMeshSS2 self) -> unsigned long

        Mesh-level
        operation interface. 
        """
        return _itkMeshBasePython.itkMeshSS2_GetNumberOfCells(self)


    def PassStructure(self, inputMesh: 'itkMeshSS2') -> "void":
        """
        PassStructure(itkMeshSS2 self, itkMeshSS2 inputMesh)

        PointSet-level
        operation interface. 
        """
        return _itkMeshBasePython.itkMeshSS2_PassStructure(self, inputMesh)


    def GetBoundingBox(self) -> "itkBoundingBoxUL2FVCULPF2 const *":
        """
        GetBoundingBox(itkMeshSS2 self) -> itkBoundingBoxUL2FVCULPF2

        Get the bounding box
        of the mesh. The methods return a pointer to the user-supplied
        bounding box as a convenience. 
        """
        return _itkMeshBasePython.itkMeshSS2_GetBoundingBox(self)


    def SetCellLinks(self, arg0: 'itkVectorContainerULSUL') -> "void":
        """
        SetCellLinks(itkMeshSS2 self, itkVectorContainerULSUL arg0)

        Access
        m_CellsLinksContainer, which contains parent cell links for each
        point. Since a point can be used by multiple cells, each point
        identifier accesses another container which holds the cell identifiers

        """
        return _itkMeshBasePython.itkMeshSS2_SetCellLinks(self, arg0)


    def GetCellLinks(self, *args) -> "itkVectorContainerULSUL const *":
        """
        GetCellLinks(itkMeshSS2 self) -> itkVectorContainerULSUL
        GetCellLinks(itkMeshSS2 self) -> itkVectorContainerULSUL
        """
        return _itkMeshBasePython.itkMeshSS2_GetCellLinks(self, *args)


    def SetCells(self, arg0: 'itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2') -> "void":
        """
        SetCells(itkMeshSS2 self, itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2 arg0)

        Access m_CellsContainer,
        which holds cells used by the mesh. Individual cells are accessed
        through cell identifiers. 
        """
        return _itkMeshBasePython.itkMeshSS2_SetCells(self, arg0)


    def GetCells(self, *args) -> "itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2 const *":
        """
        GetCells(itkMeshSS2 self) -> itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2
        GetCells(itkMeshSS2 self) -> itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2
        """
        return _itkMeshBasePython.itkMeshSS2_GetCells(self, *args)


    def DeleteUnusedCellData(self) -> "void":
        """
        DeleteUnusedCellData(itkMeshSS2 self)

        Delete entries
        in m_CellDataContainer which do not have a corresponding entry in
        m_CellsContainer. 
        """
        return _itkMeshBasePython.itkMeshSS2_DeleteUnusedCellData(self)


    def SetCell(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer') -> "void":
        """
        SetCell(itkMeshSS2 self, unsigned long arg0, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer arg1)

        Access routines to fill the
        Cells container (m_CellsContainer), and get information from it. If
        SetCell is used to overwrite a cell currently in the mesh, it is the
        caller's responsibility to release the memory for the cell currently
        at the CellIdentifier position prior to calling SetCell. 
        """
        return _itkMeshBasePython.itkMeshSS2_SetCell(self, arg0, arg1)


    def GetCell(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """GetCell(itkMeshSS2 self, unsigned long arg0, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer arg1) -> bool"""
        return _itkMeshBasePython.itkMeshSS2_GetCell(self, arg0, arg1)


    def SetCellData(self, *args) -> "void":
        """
        SetCellData(itkMeshSS2 self, itkVectorContainerULSS arg0)
        SetCellData(itkMeshSS2 self, unsigned long arg0, short arg1)

        Access routines to fill
        the CellData container, and get information from it. 
        """
        return _itkMeshBasePython.itkMeshSS2_SetCellData(self, *args)


    def GetCellData(self, *args) -> "bool":
        """
        GetCellData(itkMeshSS2 self) -> itkVectorContainerULSS
        GetCellData(itkMeshSS2 self) -> itkVectorContainerULSS
        GetCellData(itkMeshSS2 self, unsigned long arg0, short * arg1) -> bool
        """
        return _itkMeshBasePython.itkMeshSS2_GetCellData(self, *args)


    def SetBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long', boundaryId: 'unsigned long') -> "void":
        """
        SetBoundaryAssignment(itkMeshSS2 self, int dimension, unsigned long cellId, unsigned long featureId, unsigned long boundaryId)

        Explicitly
        assign boundaryId as a part of the boundary of cellId. The identifiers
        boundaryId and cellId must identify cell objects already in the mesh.
        The dimension of boundaryId must be specified by dimension, and a
        unique CellFeatureIdentifier featureId must be assigned for each
        distinct boundary feature of a given dimension. CellFeatureIdentifier
        is equivalent to IdentifierType by default, and this type alias will
        not typically need to be changed. The UsingCells list of boundaryId is
        automatically updated to include cellId. 
        """
        return _itkMeshBasePython.itkMeshSS2_SetBoundaryAssignment(self, dimension, cellId, featureId, boundaryId)


    def GetBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long', boundaryId: 'unsigned long *') -> "bool":
        """
        GetBoundaryAssignment(itkMeshSS2 self, int dimension, unsigned long cellId, unsigned long featureId, unsigned long * boundaryId) -> bool

        For the given
        cellId, get the identifier of a particular boundary feature of the
        given dimension. The featureId determines which boundary feature of
        the specified dimension is returned. For instance, if dimension is 1
        and featureId is 0, then GetBoundaryAssignment finds the 0th edge of
        the given cell. The return value indicates whether a feature of the
        appropriate dimension and featureId exists. If it does not, the
        BoundaryIdentifier pointer is left unchanged. 
        """
        return _itkMeshBasePython.itkMeshSS2_GetBoundaryAssignment(self, dimension, cellId, featureId, boundaryId)


    def RemoveBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long') -> "bool":
        """RemoveBoundaryAssignment(itkMeshSS2 self, int dimension, unsigned long cellId, unsigned long featureId) -> bool"""
        return _itkMeshBasePython.itkMeshSS2_RemoveBoundaryAssignment(self, dimension, cellId, featureId)


    def GetNumberOfCellBoundaryFeatures(self, dimension: 'int', arg1: 'unsigned long') -> "unsigned long":
        """
        GetNumberOfCellBoundaryFeatures(itkMeshSS2 self, int dimension, unsigned long arg1) -> unsigned long

        Interface to cells. 
        """
        return _itkMeshBasePython.itkMeshSS2_GetNumberOfCellBoundaryFeatures(self, dimension, arg1)


    def GetCellBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', arg3: 'itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """
        GetCellBoundaryFeature(itkMeshSS2 self, int dimension, unsigned long arg1, unsigned long arg2, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer arg3) -> bool

        Get the
        boundary feature of the given dimension of the given cell
        corresponding to the given feature identifier. 
        """
        return _itkMeshBasePython.itkMeshSS2_GetCellBoundaryFeature(self, dimension, arg1, arg2, arg3)


    def GetCellBoundaryFeatureNeighbors(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', cellSet: 'setUL') -> "unsigned long":
        """
        GetCellBoundaryFeatureNeighbors(itkMeshSS2 self, int dimension, unsigned long arg1, unsigned long arg2, setUL cellSet) -> unsigned long

        Get
        the set of cells neighboring the given cell across the given boundary
        feature. Returns the number of neighbors found. If cellSet is not
        nullptr, the set of cell pointers is filled in with identifiers of the
        neighboring cells. 
        """
        return _itkMeshBasePython.itkMeshSS2_GetCellBoundaryFeatureNeighbors(self, dimension, arg1, arg2, cellSet)


    def GetCellNeighbors(self, cellId: 'unsigned long', cellSet: 'setUL') -> "unsigned long":
        """
        GetCellNeighbors(itkMeshSS2 self, unsigned long cellId, setUL cellSet) -> unsigned long

        Get the set of
        cells having the given cell as part of their boundary. Returns the
        number of neighbors found. If cellSet is not nullptr, the set of cell
        pointers is filled in with identifiers of the neighboring cells. 
        """
        return _itkMeshBasePython.itkMeshSS2_GetCellNeighbors(self, cellId, cellSet)


    def GetAssignedCellBoundaryIfOneExists(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', arg3: 'itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """
        GetAssignedCellBoundaryIfOneExists(itkMeshSS2 self, int dimension, unsigned long arg1, unsigned long arg2, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2_AutoPointer arg3) -> bool

        Check if there is an explicitly assigned boundary feature for the
        given dimension and cell- and cell-feature-identifiers. If there is, a
        pointer to it is given back through boundary (if boundary != nullptr)
        and true is returned. Otherwise, false is returned. 
        """
        return _itkMeshBasePython.itkMeshSS2_GetAssignedCellBoundaryIfOneExists(self, dimension, arg1, arg2, arg3)


    def BuildCellLinks(self) -> "void":
        """
        BuildCellLinks(itkMeshSS2 self)

        Dynamically build
        the links from points back to their using cells. This information is
        stored in the cell links container, not in the points. 
        """
        return _itkMeshBasePython.itkMeshSS2_BuildCellLinks(self)


    def Accept(self, mv: 'itkCellInterfaceSSCTI2FFULULULPF2VCULPF2::MultiVisitor *') -> "void":
        """
        Accept(itkMeshSS2 self, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2::MultiVisitor * mv)

        This method iterates over
        all the cells in the mesh and has each cell Accept the MultiVisitor.
        See MultiVisitor for more information. (Note, this follows the Visitor
        Design Pattern.) 
        """
        return _itkMeshBasePython.itkMeshSS2_Accept(self, mv)


    def SetCellsAllocationMethod(self, _arg: 'itkMeshEnums::MeshClassCellsAllocationMethod const') -> "void":
        """
        SetCellsAllocationMethod(itkMeshSS2 self, itkMeshEnums::MeshClassCellsAllocationMethod const _arg)

        Set/Get
        the identification of the method used to allocate cells WARNING:
        Failure to call this method correctly will lead to memory leaks and/or
        segmentation faults because the cell memory will not be erased or will
        be erased with an improper method. 
        """
        return _itkMeshBasePython.itkMeshSS2_SetCellsAllocationMethod(self, _arg)


    def GetCellsAllocationMethod(self) -> "itkMeshEnums::MeshClassCellsAllocationMethod const &":
        """GetCellsAllocationMethod(itkMeshSS2 self) -> itkMeshEnums::MeshClassCellsAllocationMethod const &"""
        return _itkMeshBasePython.itkMeshSS2_GetCellsAllocationMethod(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkMeshSS2

    def cast(obj: 'itkLightObject') -> "itkMeshSS2 *":
        """cast(itkLightObject obj) -> itkMeshSS2"""
        return _itkMeshBasePython.itkMeshSS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkMeshSS2

        Create a new object of the class itkMeshSS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMeshSS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkMeshSS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkMeshSS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkMeshSS2.Clone = new_instancemethod(_itkMeshBasePython.itkMeshSS2_Clone, None, itkMeshSS2)
itkMeshSS2.GetNumberOfCells = new_instancemethod(_itkMeshBasePython.itkMeshSS2_GetNumberOfCells, None, itkMeshSS2)
itkMeshSS2.PassStructure = new_instancemethod(_itkMeshBasePython.itkMeshSS2_PassStructure, None, itkMeshSS2)
itkMeshSS2.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkMeshSS2_GetBoundingBox, None, itkMeshSS2)
itkMeshSS2.SetCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshSS2_SetCellLinks, None, itkMeshSS2)
itkMeshSS2.GetCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshSS2_GetCellLinks, None, itkMeshSS2)
itkMeshSS2.SetCells = new_instancemethod(_itkMeshBasePython.itkMeshSS2_SetCells, None, itkMeshSS2)
itkMeshSS2.GetCells = new_instancemethod(_itkMeshBasePython.itkMeshSS2_GetCells, None, itkMeshSS2)
itkMeshSS2.DeleteUnusedCellData = new_instancemethod(_itkMeshBasePython.itkMeshSS2_DeleteUnusedCellData, None, itkMeshSS2)
itkMeshSS2.SetCell = new_instancemethod(_itkMeshBasePython.itkMeshSS2_SetCell, None, itkMeshSS2)
itkMeshSS2.GetCell = new_instancemethod(_itkMeshBasePython.itkMeshSS2_GetCell, None, itkMeshSS2)
itkMeshSS2.SetCellData = new_instancemethod(_itkMeshBasePython.itkMeshSS2_SetCellData, None, itkMeshSS2)
itkMeshSS2.GetCellData = new_instancemethod(_itkMeshBasePython.itkMeshSS2_GetCellData, None, itkMeshSS2)
itkMeshSS2.SetBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshSS2_SetBoundaryAssignment, None, itkMeshSS2)
itkMeshSS2.GetBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshSS2_GetBoundaryAssignment, None, itkMeshSS2)
itkMeshSS2.RemoveBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshSS2_RemoveBoundaryAssignment, None, itkMeshSS2)
itkMeshSS2.GetNumberOfCellBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkMeshSS2_GetNumberOfCellBoundaryFeatures, None, itkMeshSS2)
itkMeshSS2.GetCellBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkMeshSS2_GetCellBoundaryFeature, None, itkMeshSS2)
itkMeshSS2.GetCellBoundaryFeatureNeighbors = new_instancemethod(_itkMeshBasePython.itkMeshSS2_GetCellBoundaryFeatureNeighbors, None, itkMeshSS2)
itkMeshSS2.GetCellNeighbors = new_instancemethod(_itkMeshBasePython.itkMeshSS2_GetCellNeighbors, None, itkMeshSS2)
itkMeshSS2.GetAssignedCellBoundaryIfOneExists = new_instancemethod(_itkMeshBasePython.itkMeshSS2_GetAssignedCellBoundaryIfOneExists, None, itkMeshSS2)
itkMeshSS2.BuildCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshSS2_BuildCellLinks, None, itkMeshSS2)
itkMeshSS2.Accept = new_instancemethod(_itkMeshBasePython.itkMeshSS2_Accept, None, itkMeshSS2)
itkMeshSS2.SetCellsAllocationMethod = new_instancemethod(_itkMeshBasePython.itkMeshSS2_SetCellsAllocationMethod, None, itkMeshSS2)
itkMeshSS2.GetCellsAllocationMethod = new_instancemethod(_itkMeshBasePython.itkMeshSS2_GetCellsAllocationMethod, None, itkMeshSS2)
itkMeshSS2_swigregister = _itkMeshBasePython.itkMeshSS2_swigregister
itkMeshSS2_swigregister(itkMeshSS2)

def itkMeshSS2___New_orig__() -> "itkMeshSS2_Pointer":
    """itkMeshSS2___New_orig__() -> itkMeshSS2_Pointer"""
    return _itkMeshBasePython.itkMeshSS2___New_orig__()

def itkMeshSS2_cast(obj: 'itkLightObject') -> "itkMeshSS2 *":
    """itkMeshSS2_cast(itkLightObject obj) -> itkMeshSS2"""
    return _itkMeshBasePython.itkMeshSS2_cast(obj)

class itkMeshSS3(itkPointSetPython.itkPointSetSS3):
    """


    Implements the N-dimensional mesh structure.

    Overview  Mesh implements the N-dimensional mesh structure for ITK. It
    provides an API to perform operations on points, cells, boundaries,
    etc., but does not tie down the underlying implementation and storage.
    A "MeshTraits" structure is used to define the container and
    identifier types that will be used to access the mesh. See
    DefaultStaticMeshTraits for the set of type definitions needed. All
    types that are defined in the "MeshTraits" structure will have
    duplicate type alias in the resulting mesh itself.  Mesh is an
    adaptive, evolving structure. Typically points and cells are created,
    with the cells referring to their defining points. If additional
    topological information is required, then BuildCellLinks() is called
    and links from the points back to the cells that use them are created.
    This allows implicit topological information about the faces to a cell
    can be determined by intersection the sets of cells that use the
    points defining the face. This is an inherent assumption on the
    manifold relationship of the cells in the mesh.) In some cases, either
    because the mesh is non-manifold, because we wish to explicitly store
    information with the faces and edges of the mesh, or because
    performance requirements demand that boundaries are explicitly
    represented (the set intersection does not need to be performed); then
    Mesh can be further extended by adding explicit boundary assignments.

    Usage  Mesh has three template parameters. The first is the pixel
    type, or the type of data stored (optionally) with points, cells,
    and/or boundaries. The second is the geometric dimension of the points
    defining the mesh. This also limits the maximum topological dimension
    of the cells that can be inserted. The third template parameter is the
    "MeshTraits" structure controlling type information for the mesh.
    Most users will be happy with the defaults, and will not have to worry
    about this third argument.  One of the most important parts of using
    this mesh is how to create cells to insert into it. The cells for the
    mesh take two template parameters. The first is the pixel type, and
    should correspond exactly to that type given to the mesh. The second
    is a "CellTraits" which holds a sub-set of the "MeshTraits"
    structure definitions, and is also a member of them. Any cell which is
    to be inserted to a mesh should have MeshTraits::CellTraits as its
    second template parameter.

    Template parameters for Mesh:

    TPixelType = The type stored as data for an entity (cell, point, or
    boundary).

    TMeshTraits = Type information structure for the mesh.

    References No reference information is available.

    C++ includes: itkMesh.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkMeshSS3_Pointer":
        """__New_orig__() -> itkMeshSS3_Pointer"""
        return _itkMeshBasePython.itkMeshSS3___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkMeshSS3_Pointer":
        """Clone(itkMeshSS3 self) -> itkMeshSS3_Pointer"""
        return _itkMeshBasePython.itkMeshSS3_Clone(self)


    def GetNumberOfCells(self) -> "unsigned long":
        """
        GetNumberOfCells(itkMeshSS3 self) -> unsigned long

        Mesh-level
        operation interface. 
        """
        return _itkMeshBasePython.itkMeshSS3_GetNumberOfCells(self)


    def PassStructure(self, inputMesh: 'itkMeshSS3') -> "void":
        """
        PassStructure(itkMeshSS3 self, itkMeshSS3 inputMesh)

        PointSet-level
        operation interface. 
        """
        return _itkMeshBasePython.itkMeshSS3_PassStructure(self, inputMesh)


    def GetBoundingBox(self) -> "itkBoundingBoxUL3FVCULPF3 const *":
        """
        GetBoundingBox(itkMeshSS3 self) -> itkBoundingBoxUL3FVCULPF3

        Get the bounding box
        of the mesh. The methods return a pointer to the user-supplied
        bounding box as a convenience. 
        """
        return _itkMeshBasePython.itkMeshSS3_GetBoundingBox(self)


    def SetCellLinks(self, arg0: 'itkVectorContainerULSUL') -> "void":
        """
        SetCellLinks(itkMeshSS3 self, itkVectorContainerULSUL arg0)

        Access
        m_CellsLinksContainer, which contains parent cell links for each
        point. Since a point can be used by multiple cells, each point
        identifier accesses another container which holds the cell identifiers

        """
        return _itkMeshBasePython.itkMeshSS3_SetCellLinks(self, arg0)


    def GetCellLinks(self, *args) -> "itkVectorContainerULSUL const *":
        """
        GetCellLinks(itkMeshSS3 self) -> itkVectorContainerULSUL
        GetCellLinks(itkMeshSS3 self) -> itkVectorContainerULSUL
        """
        return _itkMeshBasePython.itkMeshSS3_GetCellLinks(self, *args)


    def SetCells(self, arg0: 'itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3') -> "void":
        """
        SetCells(itkMeshSS3 self, itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3 arg0)

        Access m_CellsContainer,
        which holds cells used by the mesh. Individual cells are accessed
        through cell identifiers. 
        """
        return _itkMeshBasePython.itkMeshSS3_SetCells(self, arg0)


    def GetCells(self, *args) -> "itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3 const *":
        """
        GetCells(itkMeshSS3 self) -> itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3
        GetCells(itkMeshSS3 self) -> itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3
        """
        return _itkMeshBasePython.itkMeshSS3_GetCells(self, *args)


    def DeleteUnusedCellData(self) -> "void":
        """
        DeleteUnusedCellData(itkMeshSS3 self)

        Delete entries
        in m_CellDataContainer which do not have a corresponding entry in
        m_CellsContainer. 
        """
        return _itkMeshBasePython.itkMeshSS3_DeleteUnusedCellData(self)


    def SetCell(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer') -> "void":
        """
        SetCell(itkMeshSS3 self, unsigned long arg0, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer arg1)

        Access routines to fill the
        Cells container (m_CellsContainer), and get information from it. If
        SetCell is used to overwrite a cell currently in the mesh, it is the
        caller's responsibility to release the memory for the cell currently
        at the CellIdentifier position prior to calling SetCell. 
        """
        return _itkMeshBasePython.itkMeshSS3_SetCell(self, arg0, arg1)


    def GetCell(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """GetCell(itkMeshSS3 self, unsigned long arg0, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer arg1) -> bool"""
        return _itkMeshBasePython.itkMeshSS3_GetCell(self, arg0, arg1)


    def SetCellData(self, *args) -> "void":
        """
        SetCellData(itkMeshSS3 self, itkVectorContainerULSS arg0)
        SetCellData(itkMeshSS3 self, unsigned long arg0, short arg1)

        Access routines to fill
        the CellData container, and get information from it. 
        """
        return _itkMeshBasePython.itkMeshSS3_SetCellData(self, *args)


    def GetCellData(self, *args) -> "bool":
        """
        GetCellData(itkMeshSS3 self) -> itkVectorContainerULSS
        GetCellData(itkMeshSS3 self) -> itkVectorContainerULSS
        GetCellData(itkMeshSS3 self, unsigned long arg0, short * arg1) -> bool
        """
        return _itkMeshBasePython.itkMeshSS3_GetCellData(self, *args)


    def SetBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long', boundaryId: 'unsigned long') -> "void":
        """
        SetBoundaryAssignment(itkMeshSS3 self, int dimension, unsigned long cellId, unsigned long featureId, unsigned long boundaryId)

        Explicitly
        assign boundaryId as a part of the boundary of cellId. The identifiers
        boundaryId and cellId must identify cell objects already in the mesh.
        The dimension of boundaryId must be specified by dimension, and a
        unique CellFeatureIdentifier featureId must be assigned for each
        distinct boundary feature of a given dimension. CellFeatureIdentifier
        is equivalent to IdentifierType by default, and this type alias will
        not typically need to be changed. The UsingCells list of boundaryId is
        automatically updated to include cellId. 
        """
        return _itkMeshBasePython.itkMeshSS3_SetBoundaryAssignment(self, dimension, cellId, featureId, boundaryId)


    def GetBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long', boundaryId: 'unsigned long *') -> "bool":
        """
        GetBoundaryAssignment(itkMeshSS3 self, int dimension, unsigned long cellId, unsigned long featureId, unsigned long * boundaryId) -> bool

        For the given
        cellId, get the identifier of a particular boundary feature of the
        given dimension. The featureId determines which boundary feature of
        the specified dimension is returned. For instance, if dimension is 1
        and featureId is 0, then GetBoundaryAssignment finds the 0th edge of
        the given cell. The return value indicates whether a feature of the
        appropriate dimension and featureId exists. If it does not, the
        BoundaryIdentifier pointer is left unchanged. 
        """
        return _itkMeshBasePython.itkMeshSS3_GetBoundaryAssignment(self, dimension, cellId, featureId, boundaryId)


    def RemoveBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long') -> "bool":
        """RemoveBoundaryAssignment(itkMeshSS3 self, int dimension, unsigned long cellId, unsigned long featureId) -> bool"""
        return _itkMeshBasePython.itkMeshSS3_RemoveBoundaryAssignment(self, dimension, cellId, featureId)


    def GetNumberOfCellBoundaryFeatures(self, dimension: 'int', arg1: 'unsigned long') -> "unsigned long":
        """
        GetNumberOfCellBoundaryFeatures(itkMeshSS3 self, int dimension, unsigned long arg1) -> unsigned long

        Interface to cells. 
        """
        return _itkMeshBasePython.itkMeshSS3_GetNumberOfCellBoundaryFeatures(self, dimension, arg1)


    def GetCellBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', arg3: 'itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """
        GetCellBoundaryFeature(itkMeshSS3 self, int dimension, unsigned long arg1, unsigned long arg2, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer arg3) -> bool

        Get the
        boundary feature of the given dimension of the given cell
        corresponding to the given feature identifier. 
        """
        return _itkMeshBasePython.itkMeshSS3_GetCellBoundaryFeature(self, dimension, arg1, arg2, arg3)


    def GetCellBoundaryFeatureNeighbors(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', cellSet: 'setUL') -> "unsigned long":
        """
        GetCellBoundaryFeatureNeighbors(itkMeshSS3 self, int dimension, unsigned long arg1, unsigned long arg2, setUL cellSet) -> unsigned long

        Get
        the set of cells neighboring the given cell across the given boundary
        feature. Returns the number of neighbors found. If cellSet is not
        nullptr, the set of cell pointers is filled in with identifiers of the
        neighboring cells. 
        """
        return _itkMeshBasePython.itkMeshSS3_GetCellBoundaryFeatureNeighbors(self, dimension, arg1, arg2, cellSet)


    def GetCellNeighbors(self, cellId: 'unsigned long', cellSet: 'setUL') -> "unsigned long":
        """
        GetCellNeighbors(itkMeshSS3 self, unsigned long cellId, setUL cellSet) -> unsigned long

        Get the set of
        cells having the given cell as part of their boundary. Returns the
        number of neighbors found. If cellSet is not nullptr, the set of cell
        pointers is filled in with identifiers of the neighboring cells. 
        """
        return _itkMeshBasePython.itkMeshSS3_GetCellNeighbors(self, cellId, cellSet)


    def GetAssignedCellBoundaryIfOneExists(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', arg3: 'itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """
        GetAssignedCellBoundaryIfOneExists(itkMeshSS3 self, int dimension, unsigned long arg1, unsigned long arg2, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3_AutoPointer arg3) -> bool

        Check if there is an explicitly assigned boundary feature for the
        given dimension and cell- and cell-feature-identifiers. If there is, a
        pointer to it is given back through boundary (if boundary != nullptr)
        and true is returned. Otherwise, false is returned. 
        """
        return _itkMeshBasePython.itkMeshSS3_GetAssignedCellBoundaryIfOneExists(self, dimension, arg1, arg2, arg3)


    def BuildCellLinks(self) -> "void":
        """
        BuildCellLinks(itkMeshSS3 self)

        Dynamically build
        the links from points back to their using cells. This information is
        stored in the cell links container, not in the points. 
        """
        return _itkMeshBasePython.itkMeshSS3_BuildCellLinks(self)


    def Accept(self, mv: 'itkCellInterfaceSSCTI3FFULULULPF3VCULPF3::MultiVisitor *') -> "void":
        """
        Accept(itkMeshSS3 self, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3::MultiVisitor * mv)

        This method iterates over
        all the cells in the mesh and has each cell Accept the MultiVisitor.
        See MultiVisitor for more information. (Note, this follows the Visitor
        Design Pattern.) 
        """
        return _itkMeshBasePython.itkMeshSS3_Accept(self, mv)


    def SetCellsAllocationMethod(self, _arg: 'itkMeshEnums::MeshClassCellsAllocationMethod const') -> "void":
        """
        SetCellsAllocationMethod(itkMeshSS3 self, itkMeshEnums::MeshClassCellsAllocationMethod const _arg)

        Set/Get
        the identification of the method used to allocate cells WARNING:
        Failure to call this method correctly will lead to memory leaks and/or
        segmentation faults because the cell memory will not be erased or will
        be erased with an improper method. 
        """
        return _itkMeshBasePython.itkMeshSS3_SetCellsAllocationMethod(self, _arg)


    def GetCellsAllocationMethod(self) -> "itkMeshEnums::MeshClassCellsAllocationMethod const &":
        """GetCellsAllocationMethod(itkMeshSS3 self) -> itkMeshEnums::MeshClassCellsAllocationMethod const &"""
        return _itkMeshBasePython.itkMeshSS3_GetCellsAllocationMethod(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkMeshSS3

    def cast(obj: 'itkLightObject') -> "itkMeshSS3 *":
        """cast(itkLightObject obj) -> itkMeshSS3"""
        return _itkMeshBasePython.itkMeshSS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkMeshSS3

        Create a new object of the class itkMeshSS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMeshSS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkMeshSS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkMeshSS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkMeshSS3.Clone = new_instancemethod(_itkMeshBasePython.itkMeshSS3_Clone, None, itkMeshSS3)
itkMeshSS3.GetNumberOfCells = new_instancemethod(_itkMeshBasePython.itkMeshSS3_GetNumberOfCells, None, itkMeshSS3)
itkMeshSS3.PassStructure = new_instancemethod(_itkMeshBasePython.itkMeshSS3_PassStructure, None, itkMeshSS3)
itkMeshSS3.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkMeshSS3_GetBoundingBox, None, itkMeshSS3)
itkMeshSS3.SetCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshSS3_SetCellLinks, None, itkMeshSS3)
itkMeshSS3.GetCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshSS3_GetCellLinks, None, itkMeshSS3)
itkMeshSS3.SetCells = new_instancemethod(_itkMeshBasePython.itkMeshSS3_SetCells, None, itkMeshSS3)
itkMeshSS3.GetCells = new_instancemethod(_itkMeshBasePython.itkMeshSS3_GetCells, None, itkMeshSS3)
itkMeshSS3.DeleteUnusedCellData = new_instancemethod(_itkMeshBasePython.itkMeshSS3_DeleteUnusedCellData, None, itkMeshSS3)
itkMeshSS3.SetCell = new_instancemethod(_itkMeshBasePython.itkMeshSS3_SetCell, None, itkMeshSS3)
itkMeshSS3.GetCell = new_instancemethod(_itkMeshBasePython.itkMeshSS3_GetCell, None, itkMeshSS3)
itkMeshSS3.SetCellData = new_instancemethod(_itkMeshBasePython.itkMeshSS3_SetCellData, None, itkMeshSS3)
itkMeshSS3.GetCellData = new_instancemethod(_itkMeshBasePython.itkMeshSS3_GetCellData, None, itkMeshSS3)
itkMeshSS3.SetBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshSS3_SetBoundaryAssignment, None, itkMeshSS3)
itkMeshSS3.GetBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshSS3_GetBoundaryAssignment, None, itkMeshSS3)
itkMeshSS3.RemoveBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshSS3_RemoveBoundaryAssignment, None, itkMeshSS3)
itkMeshSS3.GetNumberOfCellBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkMeshSS3_GetNumberOfCellBoundaryFeatures, None, itkMeshSS3)
itkMeshSS3.GetCellBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkMeshSS3_GetCellBoundaryFeature, None, itkMeshSS3)
itkMeshSS3.GetCellBoundaryFeatureNeighbors = new_instancemethod(_itkMeshBasePython.itkMeshSS3_GetCellBoundaryFeatureNeighbors, None, itkMeshSS3)
itkMeshSS3.GetCellNeighbors = new_instancemethod(_itkMeshBasePython.itkMeshSS3_GetCellNeighbors, None, itkMeshSS3)
itkMeshSS3.GetAssignedCellBoundaryIfOneExists = new_instancemethod(_itkMeshBasePython.itkMeshSS3_GetAssignedCellBoundaryIfOneExists, None, itkMeshSS3)
itkMeshSS3.BuildCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshSS3_BuildCellLinks, None, itkMeshSS3)
itkMeshSS3.Accept = new_instancemethod(_itkMeshBasePython.itkMeshSS3_Accept, None, itkMeshSS3)
itkMeshSS3.SetCellsAllocationMethod = new_instancemethod(_itkMeshBasePython.itkMeshSS3_SetCellsAllocationMethod, None, itkMeshSS3)
itkMeshSS3.GetCellsAllocationMethod = new_instancemethod(_itkMeshBasePython.itkMeshSS3_GetCellsAllocationMethod, None, itkMeshSS3)
itkMeshSS3_swigregister = _itkMeshBasePython.itkMeshSS3_swigregister
itkMeshSS3_swigregister(itkMeshSS3)

def itkMeshSS3___New_orig__() -> "itkMeshSS3_Pointer":
    """itkMeshSS3___New_orig__() -> itkMeshSS3_Pointer"""
    return _itkMeshBasePython.itkMeshSS3___New_orig__()

def itkMeshSS3_cast(obj: 'itkLightObject') -> "itkMeshSS3 *":
    """itkMeshSS3_cast(itkLightObject obj) -> itkMeshSS3"""
    return _itkMeshBasePython.itkMeshSS3_cast(obj)

class itkMeshUC2(itkPointSetPython.itkPointSetUC2):
    """


    Implements the N-dimensional mesh structure.

    Overview  Mesh implements the N-dimensional mesh structure for ITK. It
    provides an API to perform operations on points, cells, boundaries,
    etc., but does not tie down the underlying implementation and storage.
    A "MeshTraits" structure is used to define the container and
    identifier types that will be used to access the mesh. See
    DefaultStaticMeshTraits for the set of type definitions needed. All
    types that are defined in the "MeshTraits" structure will have
    duplicate type alias in the resulting mesh itself.  Mesh is an
    adaptive, evolving structure. Typically points and cells are created,
    with the cells referring to their defining points. If additional
    topological information is required, then BuildCellLinks() is called
    and links from the points back to the cells that use them are created.
    This allows implicit topological information about the faces to a cell
    can be determined by intersection the sets of cells that use the
    points defining the face. This is an inherent assumption on the
    manifold relationship of the cells in the mesh.) In some cases, either
    because the mesh is non-manifold, because we wish to explicitly store
    information with the faces and edges of the mesh, or because
    performance requirements demand that boundaries are explicitly
    represented (the set intersection does not need to be performed); then
    Mesh can be further extended by adding explicit boundary assignments.

    Usage  Mesh has three template parameters. The first is the pixel
    type, or the type of data stored (optionally) with points, cells,
    and/or boundaries. The second is the geometric dimension of the points
    defining the mesh. This also limits the maximum topological dimension
    of the cells that can be inserted. The third template parameter is the
    "MeshTraits" structure controlling type information for the mesh.
    Most users will be happy with the defaults, and will not have to worry
    about this third argument.  One of the most important parts of using
    this mesh is how to create cells to insert into it. The cells for the
    mesh take two template parameters. The first is the pixel type, and
    should correspond exactly to that type given to the mesh. The second
    is a "CellTraits" which holds a sub-set of the "MeshTraits"
    structure definitions, and is also a member of them. Any cell which is
    to be inserted to a mesh should have MeshTraits::CellTraits as its
    second template parameter.

    Template parameters for Mesh:

    TPixelType = The type stored as data for an entity (cell, point, or
    boundary).

    TMeshTraits = Type information structure for the mesh.

    References No reference information is available.

    C++ includes: itkMesh.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkMeshUC2_Pointer":
        """__New_orig__() -> itkMeshUC2_Pointer"""
        return _itkMeshBasePython.itkMeshUC2___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkMeshUC2_Pointer":
        """Clone(itkMeshUC2 self) -> itkMeshUC2_Pointer"""
        return _itkMeshBasePython.itkMeshUC2_Clone(self)


    def GetNumberOfCells(self) -> "unsigned long":
        """
        GetNumberOfCells(itkMeshUC2 self) -> unsigned long

        Mesh-level
        operation interface. 
        """
        return _itkMeshBasePython.itkMeshUC2_GetNumberOfCells(self)


    def PassStructure(self, inputMesh: 'itkMeshUC2') -> "void":
        """
        PassStructure(itkMeshUC2 self, itkMeshUC2 inputMesh)

        PointSet-level
        operation interface. 
        """
        return _itkMeshBasePython.itkMeshUC2_PassStructure(self, inputMesh)


    def GetBoundingBox(self) -> "itkBoundingBoxUL2FVCULPF2 const *":
        """
        GetBoundingBox(itkMeshUC2 self) -> itkBoundingBoxUL2FVCULPF2

        Get the bounding box
        of the mesh. The methods return a pointer to the user-supplied
        bounding box as a convenience. 
        """
        return _itkMeshBasePython.itkMeshUC2_GetBoundingBox(self)


    def SetCellLinks(self, arg0: 'itkVectorContainerULSUL') -> "void":
        """
        SetCellLinks(itkMeshUC2 self, itkVectorContainerULSUL arg0)

        Access
        m_CellsLinksContainer, which contains parent cell links for each
        point. Since a point can be used by multiple cells, each point
        identifier accesses another container which holds the cell identifiers

        """
        return _itkMeshBasePython.itkMeshUC2_SetCellLinks(self, arg0)


    def GetCellLinks(self, *args) -> "itkVectorContainerULSUL const *":
        """
        GetCellLinks(itkMeshUC2 self) -> itkVectorContainerULSUL
        GetCellLinks(itkMeshUC2 self) -> itkVectorContainerULSUL
        """
        return _itkMeshBasePython.itkMeshUC2_GetCellLinks(self, *args)


    def SetCells(self, arg0: 'itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2') -> "void":
        """
        SetCells(itkMeshUC2 self, itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2 arg0)

        Access m_CellsContainer,
        which holds cells used by the mesh. Individual cells are accessed
        through cell identifiers. 
        """
        return _itkMeshBasePython.itkMeshUC2_SetCells(self, arg0)


    def GetCells(self, *args) -> "itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2 const *":
        """
        GetCells(itkMeshUC2 self) -> itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2
        GetCells(itkMeshUC2 self) -> itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2
        """
        return _itkMeshBasePython.itkMeshUC2_GetCells(self, *args)


    def DeleteUnusedCellData(self) -> "void":
        """
        DeleteUnusedCellData(itkMeshUC2 self)

        Delete entries
        in m_CellDataContainer which do not have a corresponding entry in
        m_CellsContainer. 
        """
        return _itkMeshBasePython.itkMeshUC2_DeleteUnusedCellData(self)


    def SetCell(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer') -> "void":
        """
        SetCell(itkMeshUC2 self, unsigned long arg0, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer arg1)

        Access routines to fill the
        Cells container (m_CellsContainer), and get information from it. If
        SetCell is used to overwrite a cell currently in the mesh, it is the
        caller's responsibility to release the memory for the cell currently
        at the CellIdentifier position prior to calling SetCell. 
        """
        return _itkMeshBasePython.itkMeshUC2_SetCell(self, arg0, arg1)


    def GetCell(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """GetCell(itkMeshUC2 self, unsigned long arg0, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer arg1) -> bool"""
        return _itkMeshBasePython.itkMeshUC2_GetCell(self, arg0, arg1)


    def SetCellData(self, *args) -> "void":
        """
        SetCellData(itkMeshUC2 self, itkVectorContainerULUC arg0)
        SetCellData(itkMeshUC2 self, unsigned long arg0, unsigned char arg1)

        Access routines to fill
        the CellData container, and get information from it. 
        """
        return _itkMeshBasePython.itkMeshUC2_SetCellData(self, *args)


    def GetCellData(self, *args) -> "bool":
        """
        GetCellData(itkMeshUC2 self) -> itkVectorContainerULUC
        GetCellData(itkMeshUC2 self) -> itkVectorContainerULUC
        GetCellData(itkMeshUC2 self, unsigned long arg0, unsigned char * arg1) -> bool
        """
        return _itkMeshBasePython.itkMeshUC2_GetCellData(self, *args)


    def SetBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long', boundaryId: 'unsigned long') -> "void":
        """
        SetBoundaryAssignment(itkMeshUC2 self, int dimension, unsigned long cellId, unsigned long featureId, unsigned long boundaryId)

        Explicitly
        assign boundaryId as a part of the boundary of cellId. The identifiers
        boundaryId and cellId must identify cell objects already in the mesh.
        The dimension of boundaryId must be specified by dimension, and a
        unique CellFeatureIdentifier featureId must be assigned for each
        distinct boundary feature of a given dimension. CellFeatureIdentifier
        is equivalent to IdentifierType by default, and this type alias will
        not typically need to be changed. The UsingCells list of boundaryId is
        automatically updated to include cellId. 
        """
        return _itkMeshBasePython.itkMeshUC2_SetBoundaryAssignment(self, dimension, cellId, featureId, boundaryId)


    def GetBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long', boundaryId: 'unsigned long *') -> "bool":
        """
        GetBoundaryAssignment(itkMeshUC2 self, int dimension, unsigned long cellId, unsigned long featureId, unsigned long * boundaryId) -> bool

        For the given
        cellId, get the identifier of a particular boundary feature of the
        given dimension. The featureId determines which boundary feature of
        the specified dimension is returned. For instance, if dimension is 1
        and featureId is 0, then GetBoundaryAssignment finds the 0th edge of
        the given cell. The return value indicates whether a feature of the
        appropriate dimension and featureId exists. If it does not, the
        BoundaryIdentifier pointer is left unchanged. 
        """
        return _itkMeshBasePython.itkMeshUC2_GetBoundaryAssignment(self, dimension, cellId, featureId, boundaryId)


    def RemoveBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long') -> "bool":
        """RemoveBoundaryAssignment(itkMeshUC2 self, int dimension, unsigned long cellId, unsigned long featureId) -> bool"""
        return _itkMeshBasePython.itkMeshUC2_RemoveBoundaryAssignment(self, dimension, cellId, featureId)


    def GetNumberOfCellBoundaryFeatures(self, dimension: 'int', arg1: 'unsigned long') -> "unsigned long":
        """
        GetNumberOfCellBoundaryFeatures(itkMeshUC2 self, int dimension, unsigned long arg1) -> unsigned long

        Interface to cells. 
        """
        return _itkMeshBasePython.itkMeshUC2_GetNumberOfCellBoundaryFeatures(self, dimension, arg1)


    def GetCellBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', arg3: 'itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """
        GetCellBoundaryFeature(itkMeshUC2 self, int dimension, unsigned long arg1, unsigned long arg2, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer arg3) -> bool

        Get the
        boundary feature of the given dimension of the given cell
        corresponding to the given feature identifier. 
        """
        return _itkMeshBasePython.itkMeshUC2_GetCellBoundaryFeature(self, dimension, arg1, arg2, arg3)


    def GetCellBoundaryFeatureNeighbors(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', cellSet: 'setUL') -> "unsigned long":
        """
        GetCellBoundaryFeatureNeighbors(itkMeshUC2 self, int dimension, unsigned long arg1, unsigned long arg2, setUL cellSet) -> unsigned long

        Get
        the set of cells neighboring the given cell across the given boundary
        feature. Returns the number of neighbors found. If cellSet is not
        nullptr, the set of cell pointers is filled in with identifiers of the
        neighboring cells. 
        """
        return _itkMeshBasePython.itkMeshUC2_GetCellBoundaryFeatureNeighbors(self, dimension, arg1, arg2, cellSet)


    def GetCellNeighbors(self, cellId: 'unsigned long', cellSet: 'setUL') -> "unsigned long":
        """
        GetCellNeighbors(itkMeshUC2 self, unsigned long cellId, setUL cellSet) -> unsigned long

        Get the set of
        cells having the given cell as part of their boundary. Returns the
        number of neighbors found. If cellSet is not nullptr, the set of cell
        pointers is filled in with identifiers of the neighboring cells. 
        """
        return _itkMeshBasePython.itkMeshUC2_GetCellNeighbors(self, cellId, cellSet)


    def GetAssignedCellBoundaryIfOneExists(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', arg3: 'itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """
        GetAssignedCellBoundaryIfOneExists(itkMeshUC2 self, int dimension, unsigned long arg1, unsigned long arg2, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2_AutoPointer arg3) -> bool

        Check if there is an explicitly assigned boundary feature for the
        given dimension and cell- and cell-feature-identifiers. If there is, a
        pointer to it is given back through boundary (if boundary != nullptr)
        and true is returned. Otherwise, false is returned. 
        """
        return _itkMeshBasePython.itkMeshUC2_GetAssignedCellBoundaryIfOneExists(self, dimension, arg1, arg2, arg3)


    def BuildCellLinks(self) -> "void":
        """
        BuildCellLinks(itkMeshUC2 self)

        Dynamically build
        the links from points back to their using cells. This information is
        stored in the cell links container, not in the points. 
        """
        return _itkMeshBasePython.itkMeshUC2_BuildCellLinks(self)


    def Accept(self, mv: 'itkCellInterfaceUCCTI2FFULULULPF2VCULPF2::MultiVisitor *') -> "void":
        """
        Accept(itkMeshUC2 self, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2::MultiVisitor * mv)

        This method iterates over
        all the cells in the mesh and has each cell Accept the MultiVisitor.
        See MultiVisitor for more information. (Note, this follows the Visitor
        Design Pattern.) 
        """
        return _itkMeshBasePython.itkMeshUC2_Accept(self, mv)


    def SetCellsAllocationMethod(self, _arg: 'itkMeshEnums::MeshClassCellsAllocationMethod const') -> "void":
        """
        SetCellsAllocationMethod(itkMeshUC2 self, itkMeshEnums::MeshClassCellsAllocationMethod const _arg)

        Set/Get
        the identification of the method used to allocate cells WARNING:
        Failure to call this method correctly will lead to memory leaks and/or
        segmentation faults because the cell memory will not be erased or will
        be erased with an improper method. 
        """
        return _itkMeshBasePython.itkMeshUC2_SetCellsAllocationMethod(self, _arg)


    def GetCellsAllocationMethod(self) -> "itkMeshEnums::MeshClassCellsAllocationMethod const &":
        """GetCellsAllocationMethod(itkMeshUC2 self) -> itkMeshEnums::MeshClassCellsAllocationMethod const &"""
        return _itkMeshBasePython.itkMeshUC2_GetCellsAllocationMethod(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkMeshUC2

    def cast(obj: 'itkLightObject') -> "itkMeshUC2 *":
        """cast(itkLightObject obj) -> itkMeshUC2"""
        return _itkMeshBasePython.itkMeshUC2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkMeshUC2

        Create a new object of the class itkMeshUC2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMeshUC2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkMeshUC2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkMeshUC2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkMeshUC2.Clone = new_instancemethod(_itkMeshBasePython.itkMeshUC2_Clone, None, itkMeshUC2)
itkMeshUC2.GetNumberOfCells = new_instancemethod(_itkMeshBasePython.itkMeshUC2_GetNumberOfCells, None, itkMeshUC2)
itkMeshUC2.PassStructure = new_instancemethod(_itkMeshBasePython.itkMeshUC2_PassStructure, None, itkMeshUC2)
itkMeshUC2.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkMeshUC2_GetBoundingBox, None, itkMeshUC2)
itkMeshUC2.SetCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshUC2_SetCellLinks, None, itkMeshUC2)
itkMeshUC2.GetCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshUC2_GetCellLinks, None, itkMeshUC2)
itkMeshUC2.SetCells = new_instancemethod(_itkMeshBasePython.itkMeshUC2_SetCells, None, itkMeshUC2)
itkMeshUC2.GetCells = new_instancemethod(_itkMeshBasePython.itkMeshUC2_GetCells, None, itkMeshUC2)
itkMeshUC2.DeleteUnusedCellData = new_instancemethod(_itkMeshBasePython.itkMeshUC2_DeleteUnusedCellData, None, itkMeshUC2)
itkMeshUC2.SetCell = new_instancemethod(_itkMeshBasePython.itkMeshUC2_SetCell, None, itkMeshUC2)
itkMeshUC2.GetCell = new_instancemethod(_itkMeshBasePython.itkMeshUC2_GetCell, None, itkMeshUC2)
itkMeshUC2.SetCellData = new_instancemethod(_itkMeshBasePython.itkMeshUC2_SetCellData, None, itkMeshUC2)
itkMeshUC2.GetCellData = new_instancemethod(_itkMeshBasePython.itkMeshUC2_GetCellData, None, itkMeshUC2)
itkMeshUC2.SetBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshUC2_SetBoundaryAssignment, None, itkMeshUC2)
itkMeshUC2.GetBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshUC2_GetBoundaryAssignment, None, itkMeshUC2)
itkMeshUC2.RemoveBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshUC2_RemoveBoundaryAssignment, None, itkMeshUC2)
itkMeshUC2.GetNumberOfCellBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkMeshUC2_GetNumberOfCellBoundaryFeatures, None, itkMeshUC2)
itkMeshUC2.GetCellBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkMeshUC2_GetCellBoundaryFeature, None, itkMeshUC2)
itkMeshUC2.GetCellBoundaryFeatureNeighbors = new_instancemethod(_itkMeshBasePython.itkMeshUC2_GetCellBoundaryFeatureNeighbors, None, itkMeshUC2)
itkMeshUC2.GetCellNeighbors = new_instancemethod(_itkMeshBasePython.itkMeshUC2_GetCellNeighbors, None, itkMeshUC2)
itkMeshUC2.GetAssignedCellBoundaryIfOneExists = new_instancemethod(_itkMeshBasePython.itkMeshUC2_GetAssignedCellBoundaryIfOneExists, None, itkMeshUC2)
itkMeshUC2.BuildCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshUC2_BuildCellLinks, None, itkMeshUC2)
itkMeshUC2.Accept = new_instancemethod(_itkMeshBasePython.itkMeshUC2_Accept, None, itkMeshUC2)
itkMeshUC2.SetCellsAllocationMethod = new_instancemethod(_itkMeshBasePython.itkMeshUC2_SetCellsAllocationMethod, None, itkMeshUC2)
itkMeshUC2.GetCellsAllocationMethod = new_instancemethod(_itkMeshBasePython.itkMeshUC2_GetCellsAllocationMethod, None, itkMeshUC2)
itkMeshUC2_swigregister = _itkMeshBasePython.itkMeshUC2_swigregister
itkMeshUC2_swigregister(itkMeshUC2)

def itkMeshUC2___New_orig__() -> "itkMeshUC2_Pointer":
    """itkMeshUC2___New_orig__() -> itkMeshUC2_Pointer"""
    return _itkMeshBasePython.itkMeshUC2___New_orig__()

def itkMeshUC2_cast(obj: 'itkLightObject') -> "itkMeshUC2 *":
    """itkMeshUC2_cast(itkLightObject obj) -> itkMeshUC2"""
    return _itkMeshBasePython.itkMeshUC2_cast(obj)

class itkMeshUC3(itkPointSetPython.itkPointSetUC3):
    """


    Implements the N-dimensional mesh structure.

    Overview  Mesh implements the N-dimensional mesh structure for ITK. It
    provides an API to perform operations on points, cells, boundaries,
    etc., but does not tie down the underlying implementation and storage.
    A "MeshTraits" structure is used to define the container and
    identifier types that will be used to access the mesh. See
    DefaultStaticMeshTraits for the set of type definitions needed. All
    types that are defined in the "MeshTraits" structure will have
    duplicate type alias in the resulting mesh itself.  Mesh is an
    adaptive, evolving structure. Typically points and cells are created,
    with the cells referring to their defining points. If additional
    topological information is required, then BuildCellLinks() is called
    and links from the points back to the cells that use them are created.
    This allows implicit topological information about the faces to a cell
    can be determined by intersection the sets of cells that use the
    points defining the face. This is an inherent assumption on the
    manifold relationship of the cells in the mesh.) In some cases, either
    because the mesh is non-manifold, because we wish to explicitly store
    information with the faces and edges of the mesh, or because
    performance requirements demand that boundaries are explicitly
    represented (the set intersection does not need to be performed); then
    Mesh can be further extended by adding explicit boundary assignments.

    Usage  Mesh has three template parameters. The first is the pixel
    type, or the type of data stored (optionally) with points, cells,
    and/or boundaries. The second is the geometric dimension of the points
    defining the mesh. This also limits the maximum topological dimension
    of the cells that can be inserted. The third template parameter is the
    "MeshTraits" structure controlling type information for the mesh.
    Most users will be happy with the defaults, and will not have to worry
    about this third argument.  One of the most important parts of using
    this mesh is how to create cells to insert into it. The cells for the
    mesh take two template parameters. The first is the pixel type, and
    should correspond exactly to that type given to the mesh. The second
    is a "CellTraits" which holds a sub-set of the "MeshTraits"
    structure definitions, and is also a member of them. Any cell which is
    to be inserted to a mesh should have MeshTraits::CellTraits as its
    second template parameter.

    Template parameters for Mesh:

    TPixelType = The type stored as data for an entity (cell, point, or
    boundary).

    TMeshTraits = Type information structure for the mesh.

    References No reference information is available.

    C++ includes: itkMesh.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkMeshUC3_Pointer":
        """__New_orig__() -> itkMeshUC3_Pointer"""
        return _itkMeshBasePython.itkMeshUC3___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkMeshUC3_Pointer":
        """Clone(itkMeshUC3 self) -> itkMeshUC3_Pointer"""
        return _itkMeshBasePython.itkMeshUC3_Clone(self)


    def GetNumberOfCells(self) -> "unsigned long":
        """
        GetNumberOfCells(itkMeshUC3 self) -> unsigned long

        Mesh-level
        operation interface. 
        """
        return _itkMeshBasePython.itkMeshUC3_GetNumberOfCells(self)


    def PassStructure(self, inputMesh: 'itkMeshUC3') -> "void":
        """
        PassStructure(itkMeshUC3 self, itkMeshUC3 inputMesh)

        PointSet-level
        operation interface. 
        """
        return _itkMeshBasePython.itkMeshUC3_PassStructure(self, inputMesh)


    def GetBoundingBox(self) -> "itkBoundingBoxUL3FVCULPF3 const *":
        """
        GetBoundingBox(itkMeshUC3 self) -> itkBoundingBoxUL3FVCULPF3

        Get the bounding box
        of the mesh. The methods return a pointer to the user-supplied
        bounding box as a convenience. 
        """
        return _itkMeshBasePython.itkMeshUC3_GetBoundingBox(self)


    def SetCellLinks(self, arg0: 'itkVectorContainerULSUL') -> "void":
        """
        SetCellLinks(itkMeshUC3 self, itkVectorContainerULSUL arg0)

        Access
        m_CellsLinksContainer, which contains parent cell links for each
        point. Since a point can be used by multiple cells, each point
        identifier accesses another container which holds the cell identifiers

        """
        return _itkMeshBasePython.itkMeshUC3_SetCellLinks(self, arg0)


    def GetCellLinks(self, *args) -> "itkVectorContainerULSUL const *":
        """
        GetCellLinks(itkMeshUC3 self) -> itkVectorContainerULSUL
        GetCellLinks(itkMeshUC3 self) -> itkVectorContainerULSUL
        """
        return _itkMeshBasePython.itkMeshUC3_GetCellLinks(self, *args)


    def SetCells(self, arg0: 'itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3') -> "void":
        """
        SetCells(itkMeshUC3 self, itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3 arg0)

        Access m_CellsContainer,
        which holds cells used by the mesh. Individual cells are accessed
        through cell identifiers. 
        """
        return _itkMeshBasePython.itkMeshUC3_SetCells(self, arg0)


    def GetCells(self, *args) -> "itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3 const *":
        """
        GetCells(itkMeshUC3 self) -> itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3
        GetCells(itkMeshUC3 self) -> itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3
        """
        return _itkMeshBasePython.itkMeshUC3_GetCells(self, *args)


    def DeleteUnusedCellData(self) -> "void":
        """
        DeleteUnusedCellData(itkMeshUC3 self)

        Delete entries
        in m_CellDataContainer which do not have a corresponding entry in
        m_CellsContainer. 
        """
        return _itkMeshBasePython.itkMeshUC3_DeleteUnusedCellData(self)


    def SetCell(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer') -> "void":
        """
        SetCell(itkMeshUC3 self, unsigned long arg0, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer arg1)

        Access routines to fill the
        Cells container (m_CellsContainer), and get information from it. If
        SetCell is used to overwrite a cell currently in the mesh, it is the
        caller's responsibility to release the memory for the cell currently
        at the CellIdentifier position prior to calling SetCell. 
        """
        return _itkMeshBasePython.itkMeshUC3_SetCell(self, arg0, arg1)


    def GetCell(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """GetCell(itkMeshUC3 self, unsigned long arg0, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer arg1) -> bool"""
        return _itkMeshBasePython.itkMeshUC3_GetCell(self, arg0, arg1)


    def SetCellData(self, *args) -> "void":
        """
        SetCellData(itkMeshUC3 self, itkVectorContainerULUC arg0)
        SetCellData(itkMeshUC3 self, unsigned long arg0, unsigned char arg1)

        Access routines to fill
        the CellData container, and get information from it. 
        """
        return _itkMeshBasePython.itkMeshUC3_SetCellData(self, *args)


    def GetCellData(self, *args) -> "bool":
        """
        GetCellData(itkMeshUC3 self) -> itkVectorContainerULUC
        GetCellData(itkMeshUC3 self) -> itkVectorContainerULUC
        GetCellData(itkMeshUC3 self, unsigned long arg0, unsigned char * arg1) -> bool
        """
        return _itkMeshBasePython.itkMeshUC3_GetCellData(self, *args)


    def SetBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long', boundaryId: 'unsigned long') -> "void":
        """
        SetBoundaryAssignment(itkMeshUC3 self, int dimension, unsigned long cellId, unsigned long featureId, unsigned long boundaryId)

        Explicitly
        assign boundaryId as a part of the boundary of cellId. The identifiers
        boundaryId and cellId must identify cell objects already in the mesh.
        The dimension of boundaryId must be specified by dimension, and a
        unique CellFeatureIdentifier featureId must be assigned for each
        distinct boundary feature of a given dimension. CellFeatureIdentifier
        is equivalent to IdentifierType by default, and this type alias will
        not typically need to be changed. The UsingCells list of boundaryId is
        automatically updated to include cellId. 
        """
        return _itkMeshBasePython.itkMeshUC3_SetBoundaryAssignment(self, dimension, cellId, featureId, boundaryId)


    def GetBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long', boundaryId: 'unsigned long *') -> "bool":
        """
        GetBoundaryAssignment(itkMeshUC3 self, int dimension, unsigned long cellId, unsigned long featureId, unsigned long * boundaryId) -> bool

        For the given
        cellId, get the identifier of a particular boundary feature of the
        given dimension. The featureId determines which boundary feature of
        the specified dimension is returned. For instance, if dimension is 1
        and featureId is 0, then GetBoundaryAssignment finds the 0th edge of
        the given cell. The return value indicates whether a feature of the
        appropriate dimension and featureId exists. If it does not, the
        BoundaryIdentifier pointer is left unchanged. 
        """
        return _itkMeshBasePython.itkMeshUC3_GetBoundaryAssignment(self, dimension, cellId, featureId, boundaryId)


    def RemoveBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long') -> "bool":
        """RemoveBoundaryAssignment(itkMeshUC3 self, int dimension, unsigned long cellId, unsigned long featureId) -> bool"""
        return _itkMeshBasePython.itkMeshUC3_RemoveBoundaryAssignment(self, dimension, cellId, featureId)


    def GetNumberOfCellBoundaryFeatures(self, dimension: 'int', arg1: 'unsigned long') -> "unsigned long":
        """
        GetNumberOfCellBoundaryFeatures(itkMeshUC3 self, int dimension, unsigned long arg1) -> unsigned long

        Interface to cells. 
        """
        return _itkMeshBasePython.itkMeshUC3_GetNumberOfCellBoundaryFeatures(self, dimension, arg1)


    def GetCellBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', arg3: 'itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """
        GetCellBoundaryFeature(itkMeshUC3 self, int dimension, unsigned long arg1, unsigned long arg2, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer arg3) -> bool

        Get the
        boundary feature of the given dimension of the given cell
        corresponding to the given feature identifier. 
        """
        return _itkMeshBasePython.itkMeshUC3_GetCellBoundaryFeature(self, dimension, arg1, arg2, arg3)


    def GetCellBoundaryFeatureNeighbors(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', cellSet: 'setUL') -> "unsigned long":
        """
        GetCellBoundaryFeatureNeighbors(itkMeshUC3 self, int dimension, unsigned long arg1, unsigned long arg2, setUL cellSet) -> unsigned long

        Get
        the set of cells neighboring the given cell across the given boundary
        feature. Returns the number of neighbors found. If cellSet is not
        nullptr, the set of cell pointers is filled in with identifiers of the
        neighboring cells. 
        """
        return _itkMeshBasePython.itkMeshUC3_GetCellBoundaryFeatureNeighbors(self, dimension, arg1, arg2, cellSet)


    def GetCellNeighbors(self, cellId: 'unsigned long', cellSet: 'setUL') -> "unsigned long":
        """
        GetCellNeighbors(itkMeshUC3 self, unsigned long cellId, setUL cellSet) -> unsigned long

        Get the set of
        cells having the given cell as part of their boundary. Returns the
        number of neighbors found. If cellSet is not nullptr, the set of cell
        pointers is filled in with identifiers of the neighboring cells. 
        """
        return _itkMeshBasePython.itkMeshUC3_GetCellNeighbors(self, cellId, cellSet)


    def GetAssignedCellBoundaryIfOneExists(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', arg3: 'itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """
        GetAssignedCellBoundaryIfOneExists(itkMeshUC3 self, int dimension, unsigned long arg1, unsigned long arg2, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3_AutoPointer arg3) -> bool

        Check if there is an explicitly assigned boundary feature for the
        given dimension and cell- and cell-feature-identifiers. If there is, a
        pointer to it is given back through boundary (if boundary != nullptr)
        and true is returned. Otherwise, false is returned. 
        """
        return _itkMeshBasePython.itkMeshUC3_GetAssignedCellBoundaryIfOneExists(self, dimension, arg1, arg2, arg3)


    def BuildCellLinks(self) -> "void":
        """
        BuildCellLinks(itkMeshUC3 self)

        Dynamically build
        the links from points back to their using cells. This information is
        stored in the cell links container, not in the points. 
        """
        return _itkMeshBasePython.itkMeshUC3_BuildCellLinks(self)


    def Accept(self, mv: 'itkCellInterfaceUCCTI3FFULULULPF3VCULPF3::MultiVisitor *') -> "void":
        """
        Accept(itkMeshUC3 self, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3::MultiVisitor * mv)

        This method iterates over
        all the cells in the mesh and has each cell Accept the MultiVisitor.
        See MultiVisitor for more information. (Note, this follows the Visitor
        Design Pattern.) 
        """
        return _itkMeshBasePython.itkMeshUC3_Accept(self, mv)


    def SetCellsAllocationMethod(self, _arg: 'itkMeshEnums::MeshClassCellsAllocationMethod const') -> "void":
        """
        SetCellsAllocationMethod(itkMeshUC3 self, itkMeshEnums::MeshClassCellsAllocationMethod const _arg)

        Set/Get
        the identification of the method used to allocate cells WARNING:
        Failure to call this method correctly will lead to memory leaks and/or
        segmentation faults because the cell memory will not be erased or will
        be erased with an improper method. 
        """
        return _itkMeshBasePython.itkMeshUC3_SetCellsAllocationMethod(self, _arg)


    def GetCellsAllocationMethod(self) -> "itkMeshEnums::MeshClassCellsAllocationMethod const &":
        """GetCellsAllocationMethod(itkMeshUC3 self) -> itkMeshEnums::MeshClassCellsAllocationMethod const &"""
        return _itkMeshBasePython.itkMeshUC3_GetCellsAllocationMethod(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkMeshUC3

    def cast(obj: 'itkLightObject') -> "itkMeshUC3 *":
        """cast(itkLightObject obj) -> itkMeshUC3"""
        return _itkMeshBasePython.itkMeshUC3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkMeshUC3

        Create a new object of the class itkMeshUC3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMeshUC3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkMeshUC3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkMeshUC3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkMeshUC3.Clone = new_instancemethod(_itkMeshBasePython.itkMeshUC3_Clone, None, itkMeshUC3)
itkMeshUC3.GetNumberOfCells = new_instancemethod(_itkMeshBasePython.itkMeshUC3_GetNumberOfCells, None, itkMeshUC3)
itkMeshUC3.PassStructure = new_instancemethod(_itkMeshBasePython.itkMeshUC3_PassStructure, None, itkMeshUC3)
itkMeshUC3.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkMeshUC3_GetBoundingBox, None, itkMeshUC3)
itkMeshUC3.SetCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshUC3_SetCellLinks, None, itkMeshUC3)
itkMeshUC3.GetCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshUC3_GetCellLinks, None, itkMeshUC3)
itkMeshUC3.SetCells = new_instancemethod(_itkMeshBasePython.itkMeshUC3_SetCells, None, itkMeshUC3)
itkMeshUC3.GetCells = new_instancemethod(_itkMeshBasePython.itkMeshUC3_GetCells, None, itkMeshUC3)
itkMeshUC3.DeleteUnusedCellData = new_instancemethod(_itkMeshBasePython.itkMeshUC3_DeleteUnusedCellData, None, itkMeshUC3)
itkMeshUC3.SetCell = new_instancemethod(_itkMeshBasePython.itkMeshUC3_SetCell, None, itkMeshUC3)
itkMeshUC3.GetCell = new_instancemethod(_itkMeshBasePython.itkMeshUC3_GetCell, None, itkMeshUC3)
itkMeshUC3.SetCellData = new_instancemethod(_itkMeshBasePython.itkMeshUC3_SetCellData, None, itkMeshUC3)
itkMeshUC3.GetCellData = new_instancemethod(_itkMeshBasePython.itkMeshUC3_GetCellData, None, itkMeshUC3)
itkMeshUC3.SetBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshUC3_SetBoundaryAssignment, None, itkMeshUC3)
itkMeshUC3.GetBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshUC3_GetBoundaryAssignment, None, itkMeshUC3)
itkMeshUC3.RemoveBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshUC3_RemoveBoundaryAssignment, None, itkMeshUC3)
itkMeshUC3.GetNumberOfCellBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkMeshUC3_GetNumberOfCellBoundaryFeatures, None, itkMeshUC3)
itkMeshUC3.GetCellBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkMeshUC3_GetCellBoundaryFeature, None, itkMeshUC3)
itkMeshUC3.GetCellBoundaryFeatureNeighbors = new_instancemethod(_itkMeshBasePython.itkMeshUC3_GetCellBoundaryFeatureNeighbors, None, itkMeshUC3)
itkMeshUC3.GetCellNeighbors = new_instancemethod(_itkMeshBasePython.itkMeshUC3_GetCellNeighbors, None, itkMeshUC3)
itkMeshUC3.GetAssignedCellBoundaryIfOneExists = new_instancemethod(_itkMeshBasePython.itkMeshUC3_GetAssignedCellBoundaryIfOneExists, None, itkMeshUC3)
itkMeshUC3.BuildCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshUC3_BuildCellLinks, None, itkMeshUC3)
itkMeshUC3.Accept = new_instancemethod(_itkMeshBasePython.itkMeshUC3_Accept, None, itkMeshUC3)
itkMeshUC3.SetCellsAllocationMethod = new_instancemethod(_itkMeshBasePython.itkMeshUC3_SetCellsAllocationMethod, None, itkMeshUC3)
itkMeshUC3.GetCellsAllocationMethod = new_instancemethod(_itkMeshBasePython.itkMeshUC3_GetCellsAllocationMethod, None, itkMeshUC3)
itkMeshUC3_swigregister = _itkMeshBasePython.itkMeshUC3_swigregister
itkMeshUC3_swigregister(itkMeshUC3)

def itkMeshUC3___New_orig__() -> "itkMeshUC3_Pointer":
    """itkMeshUC3___New_orig__() -> itkMeshUC3_Pointer"""
    return _itkMeshBasePython.itkMeshUC3___New_orig__()

def itkMeshUC3_cast(obj: 'itkLightObject') -> "itkMeshUC3 *":
    """itkMeshUC3_cast(itkLightObject obj) -> itkMeshUC3"""
    return _itkMeshBasePython.itkMeshUC3_cast(obj)

class itkMeshUS2(itkPointSetPython.itkPointSetUS2):
    """


    Implements the N-dimensional mesh structure.

    Overview  Mesh implements the N-dimensional mesh structure for ITK. It
    provides an API to perform operations on points, cells, boundaries,
    etc., but does not tie down the underlying implementation and storage.
    A "MeshTraits" structure is used to define the container and
    identifier types that will be used to access the mesh. See
    DefaultStaticMeshTraits for the set of type definitions needed. All
    types that are defined in the "MeshTraits" structure will have
    duplicate type alias in the resulting mesh itself.  Mesh is an
    adaptive, evolving structure. Typically points and cells are created,
    with the cells referring to their defining points. If additional
    topological information is required, then BuildCellLinks() is called
    and links from the points back to the cells that use them are created.
    This allows implicit topological information about the faces to a cell
    can be determined by intersection the sets of cells that use the
    points defining the face. This is an inherent assumption on the
    manifold relationship of the cells in the mesh.) In some cases, either
    because the mesh is non-manifold, because we wish to explicitly store
    information with the faces and edges of the mesh, or because
    performance requirements demand that boundaries are explicitly
    represented (the set intersection does not need to be performed); then
    Mesh can be further extended by adding explicit boundary assignments.

    Usage  Mesh has three template parameters. The first is the pixel
    type, or the type of data stored (optionally) with points, cells,
    and/or boundaries. The second is the geometric dimension of the points
    defining the mesh. This also limits the maximum topological dimension
    of the cells that can be inserted. The third template parameter is the
    "MeshTraits" structure controlling type information for the mesh.
    Most users will be happy with the defaults, and will not have to worry
    about this third argument.  One of the most important parts of using
    this mesh is how to create cells to insert into it. The cells for the
    mesh take two template parameters. The first is the pixel type, and
    should correspond exactly to that type given to the mesh. The second
    is a "CellTraits" which holds a sub-set of the "MeshTraits"
    structure definitions, and is also a member of them. Any cell which is
    to be inserted to a mesh should have MeshTraits::CellTraits as its
    second template parameter.

    Template parameters for Mesh:

    TPixelType = The type stored as data for an entity (cell, point, or
    boundary).

    TMeshTraits = Type information structure for the mesh.

    References No reference information is available.

    C++ includes: itkMesh.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkMeshUS2_Pointer":
        """__New_orig__() -> itkMeshUS2_Pointer"""
        return _itkMeshBasePython.itkMeshUS2___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkMeshUS2_Pointer":
        """Clone(itkMeshUS2 self) -> itkMeshUS2_Pointer"""
        return _itkMeshBasePython.itkMeshUS2_Clone(self)


    def GetNumberOfCells(self) -> "unsigned long":
        """
        GetNumberOfCells(itkMeshUS2 self) -> unsigned long

        Mesh-level
        operation interface. 
        """
        return _itkMeshBasePython.itkMeshUS2_GetNumberOfCells(self)


    def PassStructure(self, inputMesh: 'itkMeshUS2') -> "void":
        """
        PassStructure(itkMeshUS2 self, itkMeshUS2 inputMesh)

        PointSet-level
        operation interface. 
        """
        return _itkMeshBasePython.itkMeshUS2_PassStructure(self, inputMesh)


    def GetBoundingBox(self) -> "itkBoundingBoxUL2FVCULPF2 const *":
        """
        GetBoundingBox(itkMeshUS2 self) -> itkBoundingBoxUL2FVCULPF2

        Get the bounding box
        of the mesh. The methods return a pointer to the user-supplied
        bounding box as a convenience. 
        """
        return _itkMeshBasePython.itkMeshUS2_GetBoundingBox(self)


    def SetCellLinks(self, arg0: 'itkVectorContainerULSUL') -> "void":
        """
        SetCellLinks(itkMeshUS2 self, itkVectorContainerULSUL arg0)

        Access
        m_CellsLinksContainer, which contains parent cell links for each
        point. Since a point can be used by multiple cells, each point
        identifier accesses another container which holds the cell identifiers

        """
        return _itkMeshBasePython.itkMeshUS2_SetCellLinks(self, arg0)


    def GetCellLinks(self, *args) -> "itkVectorContainerULSUL const *":
        """
        GetCellLinks(itkMeshUS2 self) -> itkVectorContainerULSUL
        GetCellLinks(itkMeshUS2 self) -> itkVectorContainerULSUL
        """
        return _itkMeshBasePython.itkMeshUS2_GetCellLinks(self, *args)


    def SetCells(self, arg0: 'itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2') -> "void":
        """
        SetCells(itkMeshUS2 self, itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2 arg0)

        Access m_CellsContainer,
        which holds cells used by the mesh. Individual cells are accessed
        through cell identifiers. 
        """
        return _itkMeshBasePython.itkMeshUS2_SetCells(self, arg0)


    def GetCells(self, *args) -> "itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2 const *":
        """
        GetCells(itkMeshUS2 self) -> itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2
        GetCells(itkMeshUS2 self) -> itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2
        """
        return _itkMeshBasePython.itkMeshUS2_GetCells(self, *args)


    def DeleteUnusedCellData(self) -> "void":
        """
        DeleteUnusedCellData(itkMeshUS2 self)

        Delete entries
        in m_CellDataContainer which do not have a corresponding entry in
        m_CellsContainer. 
        """
        return _itkMeshBasePython.itkMeshUS2_DeleteUnusedCellData(self)


    def SetCell(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer') -> "void":
        """
        SetCell(itkMeshUS2 self, unsigned long arg0, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer arg1)

        Access routines to fill the
        Cells container (m_CellsContainer), and get information from it. If
        SetCell is used to overwrite a cell currently in the mesh, it is the
        caller's responsibility to release the memory for the cell currently
        at the CellIdentifier position prior to calling SetCell. 
        """
        return _itkMeshBasePython.itkMeshUS2_SetCell(self, arg0, arg1)


    def GetCell(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """GetCell(itkMeshUS2 self, unsigned long arg0, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer arg1) -> bool"""
        return _itkMeshBasePython.itkMeshUS2_GetCell(self, arg0, arg1)


    def SetCellData(self, *args) -> "void":
        """
        SetCellData(itkMeshUS2 self, itkVectorContainerULUS arg0)
        SetCellData(itkMeshUS2 self, unsigned long arg0, unsigned short arg1)

        Access routines to fill
        the CellData container, and get information from it. 
        """
        return _itkMeshBasePython.itkMeshUS2_SetCellData(self, *args)


    def GetCellData(self, *args) -> "bool":
        """
        GetCellData(itkMeshUS2 self) -> itkVectorContainerULUS
        GetCellData(itkMeshUS2 self) -> itkVectorContainerULUS
        GetCellData(itkMeshUS2 self, unsigned long arg0, unsigned short * arg1) -> bool
        """
        return _itkMeshBasePython.itkMeshUS2_GetCellData(self, *args)


    def SetBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long', boundaryId: 'unsigned long') -> "void":
        """
        SetBoundaryAssignment(itkMeshUS2 self, int dimension, unsigned long cellId, unsigned long featureId, unsigned long boundaryId)

        Explicitly
        assign boundaryId as a part of the boundary of cellId. The identifiers
        boundaryId and cellId must identify cell objects already in the mesh.
        The dimension of boundaryId must be specified by dimension, and a
        unique CellFeatureIdentifier featureId must be assigned for each
        distinct boundary feature of a given dimension. CellFeatureIdentifier
        is equivalent to IdentifierType by default, and this type alias will
        not typically need to be changed. The UsingCells list of boundaryId is
        automatically updated to include cellId. 
        """
        return _itkMeshBasePython.itkMeshUS2_SetBoundaryAssignment(self, dimension, cellId, featureId, boundaryId)


    def GetBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long', boundaryId: 'unsigned long *') -> "bool":
        """
        GetBoundaryAssignment(itkMeshUS2 self, int dimension, unsigned long cellId, unsigned long featureId, unsigned long * boundaryId) -> bool

        For the given
        cellId, get the identifier of a particular boundary feature of the
        given dimension. The featureId determines which boundary feature of
        the specified dimension is returned. For instance, if dimension is 1
        and featureId is 0, then GetBoundaryAssignment finds the 0th edge of
        the given cell. The return value indicates whether a feature of the
        appropriate dimension and featureId exists. If it does not, the
        BoundaryIdentifier pointer is left unchanged. 
        """
        return _itkMeshBasePython.itkMeshUS2_GetBoundaryAssignment(self, dimension, cellId, featureId, boundaryId)


    def RemoveBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long') -> "bool":
        """RemoveBoundaryAssignment(itkMeshUS2 self, int dimension, unsigned long cellId, unsigned long featureId) -> bool"""
        return _itkMeshBasePython.itkMeshUS2_RemoveBoundaryAssignment(self, dimension, cellId, featureId)


    def GetNumberOfCellBoundaryFeatures(self, dimension: 'int', arg1: 'unsigned long') -> "unsigned long":
        """
        GetNumberOfCellBoundaryFeatures(itkMeshUS2 self, int dimension, unsigned long arg1) -> unsigned long

        Interface to cells. 
        """
        return _itkMeshBasePython.itkMeshUS2_GetNumberOfCellBoundaryFeatures(self, dimension, arg1)


    def GetCellBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', arg3: 'itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """
        GetCellBoundaryFeature(itkMeshUS2 self, int dimension, unsigned long arg1, unsigned long arg2, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer arg3) -> bool

        Get the
        boundary feature of the given dimension of the given cell
        corresponding to the given feature identifier. 
        """
        return _itkMeshBasePython.itkMeshUS2_GetCellBoundaryFeature(self, dimension, arg1, arg2, arg3)


    def GetCellBoundaryFeatureNeighbors(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', cellSet: 'setUL') -> "unsigned long":
        """
        GetCellBoundaryFeatureNeighbors(itkMeshUS2 self, int dimension, unsigned long arg1, unsigned long arg2, setUL cellSet) -> unsigned long

        Get
        the set of cells neighboring the given cell across the given boundary
        feature. Returns the number of neighbors found. If cellSet is not
        nullptr, the set of cell pointers is filled in with identifiers of the
        neighboring cells. 
        """
        return _itkMeshBasePython.itkMeshUS2_GetCellBoundaryFeatureNeighbors(self, dimension, arg1, arg2, cellSet)


    def GetCellNeighbors(self, cellId: 'unsigned long', cellSet: 'setUL') -> "unsigned long":
        """
        GetCellNeighbors(itkMeshUS2 self, unsigned long cellId, setUL cellSet) -> unsigned long

        Get the set of
        cells having the given cell as part of their boundary. Returns the
        number of neighbors found. If cellSet is not nullptr, the set of cell
        pointers is filled in with identifiers of the neighboring cells. 
        """
        return _itkMeshBasePython.itkMeshUS2_GetCellNeighbors(self, cellId, cellSet)


    def GetAssignedCellBoundaryIfOneExists(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', arg3: 'itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """
        GetAssignedCellBoundaryIfOneExists(itkMeshUS2 self, int dimension, unsigned long arg1, unsigned long arg2, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2_AutoPointer arg3) -> bool

        Check if there is an explicitly assigned boundary feature for the
        given dimension and cell- and cell-feature-identifiers. If there is, a
        pointer to it is given back through boundary (if boundary != nullptr)
        and true is returned. Otherwise, false is returned. 
        """
        return _itkMeshBasePython.itkMeshUS2_GetAssignedCellBoundaryIfOneExists(self, dimension, arg1, arg2, arg3)


    def BuildCellLinks(self) -> "void":
        """
        BuildCellLinks(itkMeshUS2 self)

        Dynamically build
        the links from points back to their using cells. This information is
        stored in the cell links container, not in the points. 
        """
        return _itkMeshBasePython.itkMeshUS2_BuildCellLinks(self)


    def Accept(self, mv: 'itkCellInterfaceUSCTI2FFULULULPF2VCULPF2::MultiVisitor *') -> "void":
        """
        Accept(itkMeshUS2 self, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2::MultiVisitor * mv)

        This method iterates over
        all the cells in the mesh and has each cell Accept the MultiVisitor.
        See MultiVisitor for more information. (Note, this follows the Visitor
        Design Pattern.) 
        """
        return _itkMeshBasePython.itkMeshUS2_Accept(self, mv)


    def SetCellsAllocationMethod(self, _arg: 'itkMeshEnums::MeshClassCellsAllocationMethod const') -> "void":
        """
        SetCellsAllocationMethod(itkMeshUS2 self, itkMeshEnums::MeshClassCellsAllocationMethod const _arg)

        Set/Get
        the identification of the method used to allocate cells WARNING:
        Failure to call this method correctly will lead to memory leaks and/or
        segmentation faults because the cell memory will not be erased or will
        be erased with an improper method. 
        """
        return _itkMeshBasePython.itkMeshUS2_SetCellsAllocationMethod(self, _arg)


    def GetCellsAllocationMethod(self) -> "itkMeshEnums::MeshClassCellsAllocationMethod const &":
        """GetCellsAllocationMethod(itkMeshUS2 self) -> itkMeshEnums::MeshClassCellsAllocationMethod const &"""
        return _itkMeshBasePython.itkMeshUS2_GetCellsAllocationMethod(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkMeshUS2

    def cast(obj: 'itkLightObject') -> "itkMeshUS2 *":
        """cast(itkLightObject obj) -> itkMeshUS2"""
        return _itkMeshBasePython.itkMeshUS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkMeshUS2

        Create a new object of the class itkMeshUS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMeshUS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkMeshUS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkMeshUS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkMeshUS2.Clone = new_instancemethod(_itkMeshBasePython.itkMeshUS2_Clone, None, itkMeshUS2)
itkMeshUS2.GetNumberOfCells = new_instancemethod(_itkMeshBasePython.itkMeshUS2_GetNumberOfCells, None, itkMeshUS2)
itkMeshUS2.PassStructure = new_instancemethod(_itkMeshBasePython.itkMeshUS2_PassStructure, None, itkMeshUS2)
itkMeshUS2.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkMeshUS2_GetBoundingBox, None, itkMeshUS2)
itkMeshUS2.SetCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshUS2_SetCellLinks, None, itkMeshUS2)
itkMeshUS2.GetCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshUS2_GetCellLinks, None, itkMeshUS2)
itkMeshUS2.SetCells = new_instancemethod(_itkMeshBasePython.itkMeshUS2_SetCells, None, itkMeshUS2)
itkMeshUS2.GetCells = new_instancemethod(_itkMeshBasePython.itkMeshUS2_GetCells, None, itkMeshUS2)
itkMeshUS2.DeleteUnusedCellData = new_instancemethod(_itkMeshBasePython.itkMeshUS2_DeleteUnusedCellData, None, itkMeshUS2)
itkMeshUS2.SetCell = new_instancemethod(_itkMeshBasePython.itkMeshUS2_SetCell, None, itkMeshUS2)
itkMeshUS2.GetCell = new_instancemethod(_itkMeshBasePython.itkMeshUS2_GetCell, None, itkMeshUS2)
itkMeshUS2.SetCellData = new_instancemethod(_itkMeshBasePython.itkMeshUS2_SetCellData, None, itkMeshUS2)
itkMeshUS2.GetCellData = new_instancemethod(_itkMeshBasePython.itkMeshUS2_GetCellData, None, itkMeshUS2)
itkMeshUS2.SetBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshUS2_SetBoundaryAssignment, None, itkMeshUS2)
itkMeshUS2.GetBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshUS2_GetBoundaryAssignment, None, itkMeshUS2)
itkMeshUS2.RemoveBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshUS2_RemoveBoundaryAssignment, None, itkMeshUS2)
itkMeshUS2.GetNumberOfCellBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkMeshUS2_GetNumberOfCellBoundaryFeatures, None, itkMeshUS2)
itkMeshUS2.GetCellBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkMeshUS2_GetCellBoundaryFeature, None, itkMeshUS2)
itkMeshUS2.GetCellBoundaryFeatureNeighbors = new_instancemethod(_itkMeshBasePython.itkMeshUS2_GetCellBoundaryFeatureNeighbors, None, itkMeshUS2)
itkMeshUS2.GetCellNeighbors = new_instancemethod(_itkMeshBasePython.itkMeshUS2_GetCellNeighbors, None, itkMeshUS2)
itkMeshUS2.GetAssignedCellBoundaryIfOneExists = new_instancemethod(_itkMeshBasePython.itkMeshUS2_GetAssignedCellBoundaryIfOneExists, None, itkMeshUS2)
itkMeshUS2.BuildCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshUS2_BuildCellLinks, None, itkMeshUS2)
itkMeshUS2.Accept = new_instancemethod(_itkMeshBasePython.itkMeshUS2_Accept, None, itkMeshUS2)
itkMeshUS2.SetCellsAllocationMethod = new_instancemethod(_itkMeshBasePython.itkMeshUS2_SetCellsAllocationMethod, None, itkMeshUS2)
itkMeshUS2.GetCellsAllocationMethod = new_instancemethod(_itkMeshBasePython.itkMeshUS2_GetCellsAllocationMethod, None, itkMeshUS2)
itkMeshUS2_swigregister = _itkMeshBasePython.itkMeshUS2_swigregister
itkMeshUS2_swigregister(itkMeshUS2)

def itkMeshUS2___New_orig__() -> "itkMeshUS2_Pointer":
    """itkMeshUS2___New_orig__() -> itkMeshUS2_Pointer"""
    return _itkMeshBasePython.itkMeshUS2___New_orig__()

def itkMeshUS2_cast(obj: 'itkLightObject') -> "itkMeshUS2 *":
    """itkMeshUS2_cast(itkLightObject obj) -> itkMeshUS2"""
    return _itkMeshBasePython.itkMeshUS2_cast(obj)

class itkMeshUS3(itkPointSetPython.itkPointSetUS3):
    """


    Implements the N-dimensional mesh structure.

    Overview  Mesh implements the N-dimensional mesh structure for ITK. It
    provides an API to perform operations on points, cells, boundaries,
    etc., but does not tie down the underlying implementation and storage.
    A "MeshTraits" structure is used to define the container and
    identifier types that will be used to access the mesh. See
    DefaultStaticMeshTraits for the set of type definitions needed. All
    types that are defined in the "MeshTraits" structure will have
    duplicate type alias in the resulting mesh itself.  Mesh is an
    adaptive, evolving structure. Typically points and cells are created,
    with the cells referring to their defining points. If additional
    topological information is required, then BuildCellLinks() is called
    and links from the points back to the cells that use them are created.
    This allows implicit topological information about the faces to a cell
    can be determined by intersection the sets of cells that use the
    points defining the face. This is an inherent assumption on the
    manifold relationship of the cells in the mesh.) In some cases, either
    because the mesh is non-manifold, because we wish to explicitly store
    information with the faces and edges of the mesh, or because
    performance requirements demand that boundaries are explicitly
    represented (the set intersection does not need to be performed); then
    Mesh can be further extended by adding explicit boundary assignments.

    Usage  Mesh has three template parameters. The first is the pixel
    type, or the type of data stored (optionally) with points, cells,
    and/or boundaries. The second is the geometric dimension of the points
    defining the mesh. This also limits the maximum topological dimension
    of the cells that can be inserted. The third template parameter is the
    "MeshTraits" structure controlling type information for the mesh.
    Most users will be happy with the defaults, and will not have to worry
    about this third argument.  One of the most important parts of using
    this mesh is how to create cells to insert into it. The cells for the
    mesh take two template parameters. The first is the pixel type, and
    should correspond exactly to that type given to the mesh. The second
    is a "CellTraits" which holds a sub-set of the "MeshTraits"
    structure definitions, and is also a member of them. Any cell which is
    to be inserted to a mesh should have MeshTraits::CellTraits as its
    second template parameter.

    Template parameters for Mesh:

    TPixelType = The type stored as data for an entity (cell, point, or
    boundary).

    TMeshTraits = Type information structure for the mesh.

    References No reference information is available.

    C++ includes: itkMesh.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkMeshUS3_Pointer":
        """__New_orig__() -> itkMeshUS3_Pointer"""
        return _itkMeshBasePython.itkMeshUS3___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkMeshUS3_Pointer":
        """Clone(itkMeshUS3 self) -> itkMeshUS3_Pointer"""
        return _itkMeshBasePython.itkMeshUS3_Clone(self)


    def GetNumberOfCells(self) -> "unsigned long":
        """
        GetNumberOfCells(itkMeshUS3 self) -> unsigned long

        Mesh-level
        operation interface. 
        """
        return _itkMeshBasePython.itkMeshUS3_GetNumberOfCells(self)


    def PassStructure(self, inputMesh: 'itkMeshUS3') -> "void":
        """
        PassStructure(itkMeshUS3 self, itkMeshUS3 inputMesh)

        PointSet-level
        operation interface. 
        """
        return _itkMeshBasePython.itkMeshUS3_PassStructure(self, inputMesh)


    def GetBoundingBox(self) -> "itkBoundingBoxUL3FVCULPF3 const *":
        """
        GetBoundingBox(itkMeshUS3 self) -> itkBoundingBoxUL3FVCULPF3

        Get the bounding box
        of the mesh. The methods return a pointer to the user-supplied
        bounding box as a convenience. 
        """
        return _itkMeshBasePython.itkMeshUS3_GetBoundingBox(self)


    def SetCellLinks(self, arg0: 'itkVectorContainerULSUL') -> "void":
        """
        SetCellLinks(itkMeshUS3 self, itkVectorContainerULSUL arg0)

        Access
        m_CellsLinksContainer, which contains parent cell links for each
        point. Since a point can be used by multiple cells, each point
        identifier accesses another container which holds the cell identifiers

        """
        return _itkMeshBasePython.itkMeshUS3_SetCellLinks(self, arg0)


    def GetCellLinks(self, *args) -> "itkVectorContainerULSUL const *":
        """
        GetCellLinks(itkMeshUS3 self) -> itkVectorContainerULSUL
        GetCellLinks(itkMeshUS3 self) -> itkVectorContainerULSUL
        """
        return _itkMeshBasePython.itkMeshUS3_GetCellLinks(self, *args)


    def SetCells(self, arg0: 'itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3') -> "void":
        """
        SetCells(itkMeshUS3 self, itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3 arg0)

        Access m_CellsContainer,
        which holds cells used by the mesh. Individual cells are accessed
        through cell identifiers. 
        """
        return _itkMeshBasePython.itkMeshUS3_SetCells(self, arg0)


    def GetCells(self, *args) -> "itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3 const *":
        """
        GetCells(itkMeshUS3 self) -> itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3
        GetCells(itkMeshUS3 self) -> itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3
        """
        return _itkMeshBasePython.itkMeshUS3_GetCells(self, *args)


    def DeleteUnusedCellData(self) -> "void":
        """
        DeleteUnusedCellData(itkMeshUS3 self)

        Delete entries
        in m_CellDataContainer which do not have a corresponding entry in
        m_CellsContainer. 
        """
        return _itkMeshBasePython.itkMeshUS3_DeleteUnusedCellData(self)


    def SetCell(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer') -> "void":
        """
        SetCell(itkMeshUS3 self, unsigned long arg0, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer arg1)

        Access routines to fill the
        Cells container (m_CellsContainer), and get information from it. If
        SetCell is used to overwrite a cell currently in the mesh, it is the
        caller's responsibility to release the memory for the cell currently
        at the CellIdentifier position prior to calling SetCell. 
        """
        return _itkMeshBasePython.itkMeshUS3_SetCell(self, arg0, arg1)


    def GetCell(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """GetCell(itkMeshUS3 self, unsigned long arg0, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer arg1) -> bool"""
        return _itkMeshBasePython.itkMeshUS3_GetCell(self, arg0, arg1)


    def SetCellData(self, *args) -> "void":
        """
        SetCellData(itkMeshUS3 self, itkVectorContainerULUS arg0)
        SetCellData(itkMeshUS3 self, unsigned long arg0, unsigned short arg1)

        Access routines to fill
        the CellData container, and get information from it. 
        """
        return _itkMeshBasePython.itkMeshUS3_SetCellData(self, *args)


    def GetCellData(self, *args) -> "bool":
        """
        GetCellData(itkMeshUS3 self) -> itkVectorContainerULUS
        GetCellData(itkMeshUS3 self) -> itkVectorContainerULUS
        GetCellData(itkMeshUS3 self, unsigned long arg0, unsigned short * arg1) -> bool
        """
        return _itkMeshBasePython.itkMeshUS3_GetCellData(self, *args)


    def SetBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long', boundaryId: 'unsigned long') -> "void":
        """
        SetBoundaryAssignment(itkMeshUS3 self, int dimension, unsigned long cellId, unsigned long featureId, unsigned long boundaryId)

        Explicitly
        assign boundaryId as a part of the boundary of cellId. The identifiers
        boundaryId and cellId must identify cell objects already in the mesh.
        The dimension of boundaryId must be specified by dimension, and a
        unique CellFeatureIdentifier featureId must be assigned for each
        distinct boundary feature of a given dimension. CellFeatureIdentifier
        is equivalent to IdentifierType by default, and this type alias will
        not typically need to be changed. The UsingCells list of boundaryId is
        automatically updated to include cellId. 
        """
        return _itkMeshBasePython.itkMeshUS3_SetBoundaryAssignment(self, dimension, cellId, featureId, boundaryId)


    def GetBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long', boundaryId: 'unsigned long *') -> "bool":
        """
        GetBoundaryAssignment(itkMeshUS3 self, int dimension, unsigned long cellId, unsigned long featureId, unsigned long * boundaryId) -> bool

        For the given
        cellId, get the identifier of a particular boundary feature of the
        given dimension. The featureId determines which boundary feature of
        the specified dimension is returned. For instance, if dimension is 1
        and featureId is 0, then GetBoundaryAssignment finds the 0th edge of
        the given cell. The return value indicates whether a feature of the
        appropriate dimension and featureId exists. If it does not, the
        BoundaryIdentifier pointer is left unchanged. 
        """
        return _itkMeshBasePython.itkMeshUS3_GetBoundaryAssignment(self, dimension, cellId, featureId, boundaryId)


    def RemoveBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long') -> "bool":
        """RemoveBoundaryAssignment(itkMeshUS3 self, int dimension, unsigned long cellId, unsigned long featureId) -> bool"""
        return _itkMeshBasePython.itkMeshUS3_RemoveBoundaryAssignment(self, dimension, cellId, featureId)


    def GetNumberOfCellBoundaryFeatures(self, dimension: 'int', arg1: 'unsigned long') -> "unsigned long":
        """
        GetNumberOfCellBoundaryFeatures(itkMeshUS3 self, int dimension, unsigned long arg1) -> unsigned long

        Interface to cells. 
        """
        return _itkMeshBasePython.itkMeshUS3_GetNumberOfCellBoundaryFeatures(self, dimension, arg1)


    def GetCellBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', arg3: 'itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """
        GetCellBoundaryFeature(itkMeshUS3 self, int dimension, unsigned long arg1, unsigned long arg2, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer arg3) -> bool

        Get the
        boundary feature of the given dimension of the given cell
        corresponding to the given feature identifier. 
        """
        return _itkMeshBasePython.itkMeshUS3_GetCellBoundaryFeature(self, dimension, arg1, arg2, arg3)


    def GetCellBoundaryFeatureNeighbors(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', cellSet: 'setUL') -> "unsigned long":
        """
        GetCellBoundaryFeatureNeighbors(itkMeshUS3 self, int dimension, unsigned long arg1, unsigned long arg2, setUL cellSet) -> unsigned long

        Get
        the set of cells neighboring the given cell across the given boundary
        feature. Returns the number of neighbors found. If cellSet is not
        nullptr, the set of cell pointers is filled in with identifiers of the
        neighboring cells. 
        """
        return _itkMeshBasePython.itkMeshUS3_GetCellBoundaryFeatureNeighbors(self, dimension, arg1, arg2, cellSet)


    def GetCellNeighbors(self, cellId: 'unsigned long', cellSet: 'setUL') -> "unsigned long":
        """
        GetCellNeighbors(itkMeshUS3 self, unsigned long cellId, setUL cellSet) -> unsigned long

        Get the set of
        cells having the given cell as part of their boundary. Returns the
        number of neighbors found. If cellSet is not nullptr, the set of cell
        pointers is filled in with identifiers of the neighboring cells. 
        """
        return _itkMeshBasePython.itkMeshUS3_GetCellNeighbors(self, cellId, cellSet)


    def GetAssignedCellBoundaryIfOneExists(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', arg3: 'itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """
        GetAssignedCellBoundaryIfOneExists(itkMeshUS3 self, int dimension, unsigned long arg1, unsigned long arg2, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3_AutoPointer arg3) -> bool

        Check if there is an explicitly assigned boundary feature for the
        given dimension and cell- and cell-feature-identifiers. If there is, a
        pointer to it is given back through boundary (if boundary != nullptr)
        and true is returned. Otherwise, false is returned. 
        """
        return _itkMeshBasePython.itkMeshUS3_GetAssignedCellBoundaryIfOneExists(self, dimension, arg1, arg2, arg3)


    def BuildCellLinks(self) -> "void":
        """
        BuildCellLinks(itkMeshUS3 self)

        Dynamically build
        the links from points back to their using cells. This information is
        stored in the cell links container, not in the points. 
        """
        return _itkMeshBasePython.itkMeshUS3_BuildCellLinks(self)


    def Accept(self, mv: 'itkCellInterfaceUSCTI3FFULULULPF3VCULPF3::MultiVisitor *') -> "void":
        """
        Accept(itkMeshUS3 self, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3::MultiVisitor * mv)

        This method iterates over
        all the cells in the mesh and has each cell Accept the MultiVisitor.
        See MultiVisitor for more information. (Note, this follows the Visitor
        Design Pattern.) 
        """
        return _itkMeshBasePython.itkMeshUS3_Accept(self, mv)


    def SetCellsAllocationMethod(self, _arg: 'itkMeshEnums::MeshClassCellsAllocationMethod const') -> "void":
        """
        SetCellsAllocationMethod(itkMeshUS3 self, itkMeshEnums::MeshClassCellsAllocationMethod const _arg)

        Set/Get
        the identification of the method used to allocate cells WARNING:
        Failure to call this method correctly will lead to memory leaks and/or
        segmentation faults because the cell memory will not be erased or will
        be erased with an improper method. 
        """
        return _itkMeshBasePython.itkMeshUS3_SetCellsAllocationMethod(self, _arg)


    def GetCellsAllocationMethod(self) -> "itkMeshEnums::MeshClassCellsAllocationMethod const &":
        """GetCellsAllocationMethod(itkMeshUS3 self) -> itkMeshEnums::MeshClassCellsAllocationMethod const &"""
        return _itkMeshBasePython.itkMeshUS3_GetCellsAllocationMethod(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkMeshUS3

    def cast(obj: 'itkLightObject') -> "itkMeshUS3 *":
        """cast(itkLightObject obj) -> itkMeshUS3"""
        return _itkMeshBasePython.itkMeshUS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkMeshUS3

        Create a new object of the class itkMeshUS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMeshUS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkMeshUS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkMeshUS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkMeshUS3.Clone = new_instancemethod(_itkMeshBasePython.itkMeshUS3_Clone, None, itkMeshUS3)
itkMeshUS3.GetNumberOfCells = new_instancemethod(_itkMeshBasePython.itkMeshUS3_GetNumberOfCells, None, itkMeshUS3)
itkMeshUS3.PassStructure = new_instancemethod(_itkMeshBasePython.itkMeshUS3_PassStructure, None, itkMeshUS3)
itkMeshUS3.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkMeshUS3_GetBoundingBox, None, itkMeshUS3)
itkMeshUS3.SetCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshUS3_SetCellLinks, None, itkMeshUS3)
itkMeshUS3.GetCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshUS3_GetCellLinks, None, itkMeshUS3)
itkMeshUS3.SetCells = new_instancemethod(_itkMeshBasePython.itkMeshUS3_SetCells, None, itkMeshUS3)
itkMeshUS3.GetCells = new_instancemethod(_itkMeshBasePython.itkMeshUS3_GetCells, None, itkMeshUS3)
itkMeshUS3.DeleteUnusedCellData = new_instancemethod(_itkMeshBasePython.itkMeshUS3_DeleteUnusedCellData, None, itkMeshUS3)
itkMeshUS3.SetCell = new_instancemethod(_itkMeshBasePython.itkMeshUS3_SetCell, None, itkMeshUS3)
itkMeshUS3.GetCell = new_instancemethod(_itkMeshBasePython.itkMeshUS3_GetCell, None, itkMeshUS3)
itkMeshUS3.SetCellData = new_instancemethod(_itkMeshBasePython.itkMeshUS3_SetCellData, None, itkMeshUS3)
itkMeshUS3.GetCellData = new_instancemethod(_itkMeshBasePython.itkMeshUS3_GetCellData, None, itkMeshUS3)
itkMeshUS3.SetBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshUS3_SetBoundaryAssignment, None, itkMeshUS3)
itkMeshUS3.GetBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshUS3_GetBoundaryAssignment, None, itkMeshUS3)
itkMeshUS3.RemoveBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshUS3_RemoveBoundaryAssignment, None, itkMeshUS3)
itkMeshUS3.GetNumberOfCellBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkMeshUS3_GetNumberOfCellBoundaryFeatures, None, itkMeshUS3)
itkMeshUS3.GetCellBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkMeshUS3_GetCellBoundaryFeature, None, itkMeshUS3)
itkMeshUS3.GetCellBoundaryFeatureNeighbors = new_instancemethod(_itkMeshBasePython.itkMeshUS3_GetCellBoundaryFeatureNeighbors, None, itkMeshUS3)
itkMeshUS3.GetCellNeighbors = new_instancemethod(_itkMeshBasePython.itkMeshUS3_GetCellNeighbors, None, itkMeshUS3)
itkMeshUS3.GetAssignedCellBoundaryIfOneExists = new_instancemethod(_itkMeshBasePython.itkMeshUS3_GetAssignedCellBoundaryIfOneExists, None, itkMeshUS3)
itkMeshUS3.BuildCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshUS3_BuildCellLinks, None, itkMeshUS3)
itkMeshUS3.Accept = new_instancemethod(_itkMeshBasePython.itkMeshUS3_Accept, None, itkMeshUS3)
itkMeshUS3.SetCellsAllocationMethod = new_instancemethod(_itkMeshBasePython.itkMeshUS3_SetCellsAllocationMethod, None, itkMeshUS3)
itkMeshUS3.GetCellsAllocationMethod = new_instancemethod(_itkMeshBasePython.itkMeshUS3_GetCellsAllocationMethod, None, itkMeshUS3)
itkMeshUS3_swigregister = _itkMeshBasePython.itkMeshUS3_swigregister
itkMeshUS3_swigregister(itkMeshUS3)

def itkMeshUS3___New_orig__() -> "itkMeshUS3_Pointer":
    """itkMeshUS3___New_orig__() -> itkMeshUS3_Pointer"""
    return _itkMeshBasePython.itkMeshUS3___New_orig__()

def itkMeshUS3_cast(obj: 'itkLightObject') -> "itkMeshUS3 *":
    """itkMeshUS3_cast(itkLightObject obj) -> itkMeshUS3"""
    return _itkMeshBasePython.itkMeshUS3_cast(obj)

class itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2(ITKCommonBasePython.itkObject):
    """


    Define a front-end to the STL "vector" container that conforms to
    the IndexedContainerInterface.

    This is a full-fleged Object, so there is modification time, debug,
    and reference count information.

    Parameters:
    -----------

    TElementIdentifier:  An INTEGRAL type for use in indexing the vector.

    TElement:  The element type stored in the container.

    C++ includes: itkVectorContainer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2_Pointer":
        """__New_orig__() -> itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2_Pointer"""
        return _itkMeshBasePython.itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2_Pointer":
        """Clone(itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2 self) -> itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2_Pointer"""
        return _itkMeshBasePython.itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2_Clone(self)


    def CastToSTLContainer(self) -> "std::vector< itkCellInterfaceDCTI2FFULULULPF2VCULPF2 *,std::allocator< itkCellInterfaceDCTI2FFULULULPF2VCULPF2 * > > &":
        """
        CastToSTLContainer(itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2 self) -> std::vector< itkCellInterfaceDCTI2FFULULULPF2VCULPF2 *,std::allocator< itkCellInterfaceDCTI2FFULULULPF2VCULPF2 * > > &

        Cast the
        container to a STL container type 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2_CastToSTLContainer(self)


    def CastToSTLConstContainer(self) -> "std::vector< itkCellInterfaceDCTI2FFULULULPF2VCULPF2 *,std::allocator< itkCellInterfaceDCTI2FFULULULPF2VCULPF2 * > > const &":
        """
        CastToSTLConstContainer(itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2 self) -> std::vector< itkCellInterfaceDCTI2FFULULULPF2VCULPF2 *,std::allocator< itkCellInterfaceDCTI2FFULULULPF2VCULPF2 * > > const &

        Cast the
        container to a const STL container type 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2_CastToSTLConstContainer(self)


    def ElementAt(self, *args) -> "itkCellInterfaceDCTI2FFULULULPF2VCULPF2 *const &":
        """
        ElementAt(itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2 self, unsigned long arg0) -> itkCellInterfaceDCTI2FFULULULPF2VCULPF2
        ElementAt(itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2 self, unsigned long arg0) -> itkCellInterfaceDCTI2FFULULULPF2VCULPF2

        Get a reference to the
        element at the given index. It is assumed that the index exists, and
        it will not automatically be created. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2_ElementAt(self, *args)


    def CreateElementAt(self, arg0: 'unsigned long') -> "itkCellInterfaceDCTI2FFULULULPF2VCULPF2 *&":
        """
        CreateElementAt(itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2 self, unsigned long arg0) -> itkCellInterfaceDCTI2FFULULULPF2VCULPF2 *&

        Get a reference to
        the element at the given index. If the element location does not
        exist, it will be created with a default element value.

        It is assumed that the value of the element is modified through the
        reference. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2_CreateElementAt(self, arg0)


    def GetElement(self, arg0: 'unsigned long') -> "itkCellInterfaceDCTI2FFULULULPF2VCULPF2 *":
        """
        GetElement(itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2 self, unsigned long arg0) -> itkCellInterfaceDCTI2FFULULULPF2VCULPF2

        Read the element from
        the given index. It is assumed that the index exists. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2_GetElement(self, arg0)


    def SetElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI2FFULULULPF2VCULPF2') -> "void":
        """
        SetElement(itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2 self, unsigned long arg0, itkCellInterfaceDCTI2FFULULULPF2VCULPF2 arg1)

        Set the element value at
        the given index. It is assumed that the index exists. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2_SetElement(self, arg0, arg1)


    def InsertElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI2FFULULULPF2VCULPF2') -> "void":
        """
        InsertElement(itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2 self, unsigned long arg0, itkCellInterfaceDCTI2FFULULULPF2VCULPF2 arg1)

        Set the element value
        at the given index. If the element location does not exist, it will be
        created with a default element value. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2_InsertElement(self, arg0, arg1)


    def IndexExists(self, arg0: 'unsigned long') -> "bool":
        """
        IndexExists(itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2 self, unsigned long arg0) -> bool

        Check if the index
        range of the vector is large enough to allow the given index without
        expansion. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2_IndexExists(self, arg0)


    def GetElementIfIndexExists(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI2FFULULULPF2VCULPF2 **') -> "bool":
        """
        GetElementIfIndexExists(itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2 self, unsigned long arg0, itkCellInterfaceDCTI2FFULULULPF2VCULPF2 ** arg1) -> bool

        Check if
        the given index is in range of the vector. If it is not, return false.
        Otherwise, set the element through the pointer (if it isn't nullptr),
        and return true. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2_GetElementIfIndexExists(self, arg0, arg1)


    def CreateIndex(self, arg0: 'unsigned long') -> "void":
        """
        CreateIndex(itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2 self, unsigned long arg0)

        Make sure that the
        index range of the vector is large enough to allow the given index,
        expanding it if necessary. The index will contain the default element
        regardless of whether expansion occurred. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2_CreateIndex(self, arg0)


    def DeleteIndex(self, arg0: 'unsigned long') -> "void":
        """
        DeleteIndex(itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2 self, unsigned long arg0)

        Delete the element
        defined by the index identifier. In practice, it doesn't make sense to
        delete a vector index. Instead, this method just overwrite the index
        with the default element. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2_DeleteIndex(self, arg0)


    def Size(self) -> "unsigned long":
        """
        Size(itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2 self) -> unsigned long

        Get the number of elements
        currently stored in the vector. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2_Size(self)


    def Reserve(self, arg0: 'unsigned long') -> "void":
        """
        Reserve(itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2 self, unsigned long arg0)

        Tell the container to
        allocate enough memory to allow at least as many elements as the size
        given to be stored. In the generic case of ITK containers this is NOT
        guaranteed to actually allocate any memory, but it is useful if the
        implementation of the container allocates contiguous storage. In the
        particular implementation of this VectorContainer the call to this
        method actually allocates memory for the number of elements defined by
        ElementIdentifier. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2_Reserve(self, arg0)


    def Squeeze(self) -> "void":
        """
        Squeeze(itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2 self)

        Tell the container to try
        to minimize its memory usage for storage of the current number of
        elements. This is NOT guaranteed to decrease memory usage. This method
        is included here mainly for providing a unified API with other
        containers in the toolkit. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2_Squeeze(self)


    def Initialize(self) -> "void":
        """
        Initialize(itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2 self)

        Clear the elements. The
        final size will be zero. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2_Initialize(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2

    def cast(obj: 'itkLightObject') -> "itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2 *":
        """cast(itkLightObject obj) -> itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2"""
        return _itkMeshBasePython.itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2

        Create a new object of the class itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2.Clone = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2_Clone, None, itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2.CastToSTLContainer = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2_CastToSTLContainer, None, itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2.CastToSTLConstContainer = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2_CastToSTLConstContainer, None, itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2.ElementAt = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2_ElementAt, None, itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2.CreateElementAt = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2_CreateElementAt, None, itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2.GetElement = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2_GetElement, None, itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2.SetElement = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2_SetElement, None, itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2.InsertElement = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2_InsertElement, None, itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2.IndexExists = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2_IndexExists, None, itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2.GetElementIfIndexExists = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2_GetElementIfIndexExists, None, itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2.CreateIndex = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2_CreateIndex, None, itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2.DeleteIndex = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2_DeleteIndex, None, itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2.Size = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2_Size, None, itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2.Reserve = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2_Reserve, None, itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2.Squeeze = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2_Squeeze, None, itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2.Initialize = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2_Initialize, None, itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2_swigregister = _itkMeshBasePython.itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2_swigregister
itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2_swigregister(itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2)

def itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2___New_orig__() -> "itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2_Pointer":
    """itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2___New_orig__() -> itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2_Pointer"""
    return _itkMeshBasePython.itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2___New_orig__()

def itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2_cast(obj: 'itkLightObject') -> "itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2 *":
    """itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2_cast(itkLightObject obj) -> itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2"""
    return _itkMeshBasePython.itkVectorContainerULCIDCTI2FFULULULPF2VCULPF2_cast(obj)

class itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3(ITKCommonBasePython.itkObject):
    """


    Define a front-end to the STL "vector" container that conforms to
    the IndexedContainerInterface.

    This is a full-fleged Object, so there is modification time, debug,
    and reference count information.

    Parameters:
    -----------

    TElementIdentifier:  An INTEGRAL type for use in indexing the vector.

    TElement:  The element type stored in the container.

    C++ includes: itkVectorContainer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3_Pointer":
        """__New_orig__() -> itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3_Pointer"""
        return _itkMeshBasePython.itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3_Pointer":
        """Clone(itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3 self) -> itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3_Pointer"""
        return _itkMeshBasePython.itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3_Clone(self)


    def CastToSTLContainer(self) -> "std::vector< itkCellInterfaceDCTI3FFULULULPF3VCULPF3 *,std::allocator< itkCellInterfaceDCTI3FFULULULPF3VCULPF3 * > > &":
        """
        CastToSTLContainer(itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3 self) -> std::vector< itkCellInterfaceDCTI3FFULULULPF3VCULPF3 *,std::allocator< itkCellInterfaceDCTI3FFULULULPF3VCULPF3 * > > &

        Cast the
        container to a STL container type 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3_CastToSTLContainer(self)


    def CastToSTLConstContainer(self) -> "std::vector< itkCellInterfaceDCTI3FFULULULPF3VCULPF3 *,std::allocator< itkCellInterfaceDCTI3FFULULULPF3VCULPF3 * > > const &":
        """
        CastToSTLConstContainer(itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3 self) -> std::vector< itkCellInterfaceDCTI3FFULULULPF3VCULPF3 *,std::allocator< itkCellInterfaceDCTI3FFULULULPF3VCULPF3 * > > const &

        Cast the
        container to a const STL container type 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3_CastToSTLConstContainer(self)


    def ElementAt(self, *args) -> "itkCellInterfaceDCTI3FFULULULPF3VCULPF3 *const &":
        """
        ElementAt(itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3 self, unsigned long arg0) -> itkCellInterfaceDCTI3FFULULULPF3VCULPF3
        ElementAt(itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3 self, unsigned long arg0) -> itkCellInterfaceDCTI3FFULULULPF3VCULPF3

        Get a reference to the
        element at the given index. It is assumed that the index exists, and
        it will not automatically be created. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3_ElementAt(self, *args)


    def CreateElementAt(self, arg0: 'unsigned long') -> "itkCellInterfaceDCTI3FFULULULPF3VCULPF3 *&":
        """
        CreateElementAt(itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3 self, unsigned long arg0) -> itkCellInterfaceDCTI3FFULULULPF3VCULPF3 *&

        Get a reference to
        the element at the given index. If the element location does not
        exist, it will be created with a default element value.

        It is assumed that the value of the element is modified through the
        reference. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3_CreateElementAt(self, arg0)


    def GetElement(self, arg0: 'unsigned long') -> "itkCellInterfaceDCTI3FFULULULPF3VCULPF3 *":
        """
        GetElement(itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3 self, unsigned long arg0) -> itkCellInterfaceDCTI3FFULULULPF3VCULPF3

        Read the element from
        the given index. It is assumed that the index exists. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3_GetElement(self, arg0)


    def SetElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI3FFULULULPF3VCULPF3') -> "void":
        """
        SetElement(itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3 self, unsigned long arg0, itkCellInterfaceDCTI3FFULULULPF3VCULPF3 arg1)

        Set the element value at
        the given index. It is assumed that the index exists. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3_SetElement(self, arg0, arg1)


    def InsertElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI3FFULULULPF3VCULPF3') -> "void":
        """
        InsertElement(itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3 self, unsigned long arg0, itkCellInterfaceDCTI3FFULULULPF3VCULPF3 arg1)

        Set the element value
        at the given index. If the element location does not exist, it will be
        created with a default element value. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3_InsertElement(self, arg0, arg1)


    def IndexExists(self, arg0: 'unsigned long') -> "bool":
        """
        IndexExists(itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3 self, unsigned long arg0) -> bool

        Check if the index
        range of the vector is large enough to allow the given index without
        expansion. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3_IndexExists(self, arg0)


    def GetElementIfIndexExists(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI3FFULULULPF3VCULPF3 **') -> "bool":
        """
        GetElementIfIndexExists(itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3 self, unsigned long arg0, itkCellInterfaceDCTI3FFULULULPF3VCULPF3 ** arg1) -> bool

        Check if
        the given index is in range of the vector. If it is not, return false.
        Otherwise, set the element through the pointer (if it isn't nullptr),
        and return true. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3_GetElementIfIndexExists(self, arg0, arg1)


    def CreateIndex(self, arg0: 'unsigned long') -> "void":
        """
        CreateIndex(itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3 self, unsigned long arg0)

        Make sure that the
        index range of the vector is large enough to allow the given index,
        expanding it if necessary. The index will contain the default element
        regardless of whether expansion occurred. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3_CreateIndex(self, arg0)


    def DeleteIndex(self, arg0: 'unsigned long') -> "void":
        """
        DeleteIndex(itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3 self, unsigned long arg0)

        Delete the element
        defined by the index identifier. In practice, it doesn't make sense to
        delete a vector index. Instead, this method just overwrite the index
        with the default element. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3_DeleteIndex(self, arg0)


    def Size(self) -> "unsigned long":
        """
        Size(itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3 self) -> unsigned long

        Get the number of elements
        currently stored in the vector. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3_Size(self)


    def Reserve(self, arg0: 'unsigned long') -> "void":
        """
        Reserve(itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3 self, unsigned long arg0)

        Tell the container to
        allocate enough memory to allow at least as many elements as the size
        given to be stored. In the generic case of ITK containers this is NOT
        guaranteed to actually allocate any memory, but it is useful if the
        implementation of the container allocates contiguous storage. In the
        particular implementation of this VectorContainer the call to this
        method actually allocates memory for the number of elements defined by
        ElementIdentifier. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3_Reserve(self, arg0)


    def Squeeze(self) -> "void":
        """
        Squeeze(itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3 self)

        Tell the container to try
        to minimize its memory usage for storage of the current number of
        elements. This is NOT guaranteed to decrease memory usage. This method
        is included here mainly for providing a unified API with other
        containers in the toolkit. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3_Squeeze(self)


    def Initialize(self) -> "void":
        """
        Initialize(itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3 self)

        Clear the elements. The
        final size will be zero. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3_Initialize(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3

    def cast(obj: 'itkLightObject') -> "itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3 *":
        """cast(itkLightObject obj) -> itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3"""
        return _itkMeshBasePython.itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3

        Create a new object of the class itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3.Clone = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3_Clone, None, itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3.CastToSTLContainer = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3_CastToSTLContainer, None, itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3.CastToSTLConstContainer = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3_CastToSTLConstContainer, None, itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3.ElementAt = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3_ElementAt, None, itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3.CreateElementAt = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3_CreateElementAt, None, itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3.GetElement = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3_GetElement, None, itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3.SetElement = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3_SetElement, None, itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3.InsertElement = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3_InsertElement, None, itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3.IndexExists = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3_IndexExists, None, itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3.GetElementIfIndexExists = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3_GetElementIfIndexExists, None, itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3.CreateIndex = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3_CreateIndex, None, itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3.DeleteIndex = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3_DeleteIndex, None, itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3.Size = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3_Size, None, itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3.Reserve = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3_Reserve, None, itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3.Squeeze = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3_Squeeze, None, itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3.Initialize = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3_Initialize, None, itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3_swigregister = _itkMeshBasePython.itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3_swigregister
itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3_swigregister(itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3)

def itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3___New_orig__() -> "itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3_Pointer":
    """itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3___New_orig__() -> itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3_Pointer"""
    return _itkMeshBasePython.itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3___New_orig__()

def itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3_cast(obj: 'itkLightObject') -> "itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3 *":
    """itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3_cast(itkLightObject obj) -> itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3"""
    return _itkMeshBasePython.itkVectorContainerULCIDCTI3FFULULULPF3VCULPF3_cast(obj)

class itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2(ITKCommonBasePython.itkObject):
    """


    Define a front-end to the STL "vector" container that conforms to
    the IndexedContainerInterface.

    This is a full-fleged Object, so there is modification time, debug,
    and reference count information.

    Parameters:
    -----------

    TElementIdentifier:  An INTEGRAL type for use in indexing the vector.

    TElement:  The element type stored in the container.

    C++ includes: itkVectorContainer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_Pointer":
        """__New_orig__() -> itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_Pointer"""
        return _itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_Pointer":
        """Clone(itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2 self) -> itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_Pointer"""
        return _itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_Clone(self)


    def CastToSTLContainer(self) -> "std::vector< itkCellInterfaceFCTI2FFULULULPF2VCULPF2 *,std::allocator< itkCellInterfaceFCTI2FFULULULPF2VCULPF2 * > > &":
        """
        CastToSTLContainer(itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2 self) -> std::vector< itkCellInterfaceFCTI2FFULULULPF2VCULPF2 *,std::allocator< itkCellInterfaceFCTI2FFULULULPF2VCULPF2 * > > &

        Cast the
        container to a STL container type 
        """
        return _itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_CastToSTLContainer(self)


    def CastToSTLConstContainer(self) -> "std::vector< itkCellInterfaceFCTI2FFULULULPF2VCULPF2 *,std::allocator< itkCellInterfaceFCTI2FFULULULPF2VCULPF2 * > > const &":
        """
        CastToSTLConstContainer(itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2 self) -> std::vector< itkCellInterfaceFCTI2FFULULULPF2VCULPF2 *,std::allocator< itkCellInterfaceFCTI2FFULULULPF2VCULPF2 * > > const &

        Cast the
        container to a const STL container type 
        """
        return _itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_CastToSTLConstContainer(self)


    def ElementAt(self, *args) -> "itkCellInterfaceFCTI2FFULULULPF2VCULPF2 *const &":
        """
        ElementAt(itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2 self, unsigned long arg0) -> itkCellInterfaceFCTI2FFULULULPF2VCULPF2
        ElementAt(itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2 self, unsigned long arg0) -> itkCellInterfaceFCTI2FFULULULPF2VCULPF2

        Get a reference to the
        element at the given index. It is assumed that the index exists, and
        it will not automatically be created. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_ElementAt(self, *args)


    def CreateElementAt(self, arg0: 'unsigned long') -> "itkCellInterfaceFCTI2FFULULULPF2VCULPF2 *&":
        """
        CreateElementAt(itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2 self, unsigned long arg0) -> itkCellInterfaceFCTI2FFULULULPF2VCULPF2 *&

        Get a reference to
        the element at the given index. If the element location does not
        exist, it will be created with a default element value.

        It is assumed that the value of the element is modified through the
        reference. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_CreateElementAt(self, arg0)


    def GetElement(self, arg0: 'unsigned long') -> "itkCellInterfaceFCTI2FFULULULPF2VCULPF2 *":
        """
        GetElement(itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2 self, unsigned long arg0) -> itkCellInterfaceFCTI2FFULULULPF2VCULPF2

        Read the element from
        the given index. It is assumed that the index exists. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_GetElement(self, arg0)


    def SetElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceFCTI2FFULULULPF2VCULPF2') -> "void":
        """
        SetElement(itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2 self, unsigned long arg0, itkCellInterfaceFCTI2FFULULULPF2VCULPF2 arg1)

        Set the element value at
        the given index. It is assumed that the index exists. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_SetElement(self, arg0, arg1)


    def InsertElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceFCTI2FFULULULPF2VCULPF2') -> "void":
        """
        InsertElement(itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2 self, unsigned long arg0, itkCellInterfaceFCTI2FFULULULPF2VCULPF2 arg1)

        Set the element value
        at the given index. If the element location does not exist, it will be
        created with a default element value. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_InsertElement(self, arg0, arg1)


    def IndexExists(self, arg0: 'unsigned long') -> "bool":
        """
        IndexExists(itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2 self, unsigned long arg0) -> bool

        Check if the index
        range of the vector is large enough to allow the given index without
        expansion. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_IndexExists(self, arg0)


    def GetElementIfIndexExists(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceFCTI2FFULULULPF2VCULPF2 **') -> "bool":
        """
        GetElementIfIndexExists(itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2 self, unsigned long arg0, itkCellInterfaceFCTI2FFULULULPF2VCULPF2 ** arg1) -> bool

        Check if
        the given index is in range of the vector. If it is not, return false.
        Otherwise, set the element through the pointer (if it isn't nullptr),
        and return true. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_GetElementIfIndexExists(self, arg0, arg1)


    def CreateIndex(self, arg0: 'unsigned long') -> "void":
        """
        CreateIndex(itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2 self, unsigned long arg0)

        Make sure that the
        index range of the vector is large enough to allow the given index,
        expanding it if necessary. The index will contain the default element
        regardless of whether expansion occurred. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_CreateIndex(self, arg0)


    def DeleteIndex(self, arg0: 'unsigned long') -> "void":
        """
        DeleteIndex(itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2 self, unsigned long arg0)

        Delete the element
        defined by the index identifier. In practice, it doesn't make sense to
        delete a vector index. Instead, this method just overwrite the index
        with the default element. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_DeleteIndex(self, arg0)


    def Size(self) -> "unsigned long":
        """
        Size(itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2 self) -> unsigned long

        Get the number of elements
        currently stored in the vector. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_Size(self)


    def Reserve(self, arg0: 'unsigned long') -> "void":
        """
        Reserve(itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2 self, unsigned long arg0)

        Tell the container to
        allocate enough memory to allow at least as many elements as the size
        given to be stored. In the generic case of ITK containers this is NOT
        guaranteed to actually allocate any memory, but it is useful if the
        implementation of the container allocates contiguous storage. In the
        particular implementation of this VectorContainer the call to this
        method actually allocates memory for the number of elements defined by
        ElementIdentifier. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_Reserve(self, arg0)


    def Squeeze(self) -> "void":
        """
        Squeeze(itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2 self)

        Tell the container to try
        to minimize its memory usage for storage of the current number of
        elements. This is NOT guaranteed to decrease memory usage. This method
        is included here mainly for providing a unified API with other
        containers in the toolkit. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_Squeeze(self)


    def Initialize(self) -> "void":
        """
        Initialize(itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2 self)

        Clear the elements. The
        final size will be zero. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_Initialize(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2

    def cast(obj: 'itkLightObject') -> "itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2 *":
        """cast(itkLightObject obj) -> itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2"""
        return _itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2

        Create a new object of the class itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2.Clone = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_Clone, None, itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2.CastToSTLContainer = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_CastToSTLContainer, None, itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2.CastToSTLConstContainer = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_CastToSTLConstContainer, None, itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2.ElementAt = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_ElementAt, None, itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2.CreateElementAt = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_CreateElementAt, None, itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2.GetElement = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_GetElement, None, itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2.SetElement = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_SetElement, None, itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2.InsertElement = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_InsertElement, None, itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2.IndexExists = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_IndexExists, None, itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2.GetElementIfIndexExists = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_GetElementIfIndexExists, None, itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2.CreateIndex = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_CreateIndex, None, itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2.DeleteIndex = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_DeleteIndex, None, itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2.Size = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_Size, None, itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2.Reserve = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_Reserve, None, itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2.Squeeze = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_Squeeze, None, itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2.Initialize = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_Initialize, None, itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_swigregister = _itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_swigregister
itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_swigregister(itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2)

def itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2___New_orig__() -> "itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_Pointer":
    """itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2___New_orig__() -> itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_Pointer"""
    return _itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2___New_orig__()

def itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_cast(obj: 'itkLightObject') -> "itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2 *":
    """itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_cast(itkLightObject obj) -> itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2"""
    return _itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_cast(obj)

class itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3(ITKCommonBasePython.itkObject):
    """


    Define a front-end to the STL "vector" container that conforms to
    the IndexedContainerInterface.

    This is a full-fleged Object, so there is modification time, debug,
    and reference count information.

    Parameters:
    -----------

    TElementIdentifier:  An INTEGRAL type for use in indexing the vector.

    TElement:  The element type stored in the container.

    C++ includes: itkVectorContainer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_Pointer":
        """__New_orig__() -> itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_Pointer"""
        return _itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_Pointer":
        """Clone(itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3 self) -> itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_Pointer"""
        return _itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_Clone(self)


    def CastToSTLContainer(self) -> "std::vector< itkCellInterfaceFCTI3FFULULULPF3VCULPF3 *,std::allocator< itkCellInterfaceFCTI3FFULULULPF3VCULPF3 * > > &":
        """
        CastToSTLContainer(itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3 self) -> std::vector< itkCellInterfaceFCTI3FFULULULPF3VCULPF3 *,std::allocator< itkCellInterfaceFCTI3FFULULULPF3VCULPF3 * > > &

        Cast the
        container to a STL container type 
        """
        return _itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_CastToSTLContainer(self)


    def CastToSTLConstContainer(self) -> "std::vector< itkCellInterfaceFCTI3FFULULULPF3VCULPF3 *,std::allocator< itkCellInterfaceFCTI3FFULULULPF3VCULPF3 * > > const &":
        """
        CastToSTLConstContainer(itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3 self) -> std::vector< itkCellInterfaceFCTI3FFULULULPF3VCULPF3 *,std::allocator< itkCellInterfaceFCTI3FFULULULPF3VCULPF3 * > > const &

        Cast the
        container to a const STL container type 
        """
        return _itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_CastToSTLConstContainer(self)


    def ElementAt(self, *args) -> "itkCellInterfaceFCTI3FFULULULPF3VCULPF3 *const &":
        """
        ElementAt(itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3 self, unsigned long arg0) -> itkCellInterfaceFCTI3FFULULULPF3VCULPF3
        ElementAt(itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3 self, unsigned long arg0) -> itkCellInterfaceFCTI3FFULULULPF3VCULPF3

        Get a reference to the
        element at the given index. It is assumed that the index exists, and
        it will not automatically be created. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_ElementAt(self, *args)


    def CreateElementAt(self, arg0: 'unsigned long') -> "itkCellInterfaceFCTI3FFULULULPF3VCULPF3 *&":
        """
        CreateElementAt(itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3 self, unsigned long arg0) -> itkCellInterfaceFCTI3FFULULULPF3VCULPF3 *&

        Get a reference to
        the element at the given index. If the element location does not
        exist, it will be created with a default element value.

        It is assumed that the value of the element is modified through the
        reference. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_CreateElementAt(self, arg0)


    def GetElement(self, arg0: 'unsigned long') -> "itkCellInterfaceFCTI3FFULULULPF3VCULPF3 *":
        """
        GetElement(itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3 self, unsigned long arg0) -> itkCellInterfaceFCTI3FFULULULPF3VCULPF3

        Read the element from
        the given index. It is assumed that the index exists. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_GetElement(self, arg0)


    def SetElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceFCTI3FFULULULPF3VCULPF3') -> "void":
        """
        SetElement(itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3 self, unsigned long arg0, itkCellInterfaceFCTI3FFULULULPF3VCULPF3 arg1)

        Set the element value at
        the given index. It is assumed that the index exists. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_SetElement(self, arg0, arg1)


    def InsertElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceFCTI3FFULULULPF3VCULPF3') -> "void":
        """
        InsertElement(itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3 self, unsigned long arg0, itkCellInterfaceFCTI3FFULULULPF3VCULPF3 arg1)

        Set the element value
        at the given index. If the element location does not exist, it will be
        created with a default element value. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_InsertElement(self, arg0, arg1)


    def IndexExists(self, arg0: 'unsigned long') -> "bool":
        """
        IndexExists(itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3 self, unsigned long arg0) -> bool

        Check if the index
        range of the vector is large enough to allow the given index without
        expansion. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_IndexExists(self, arg0)


    def GetElementIfIndexExists(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceFCTI3FFULULULPF3VCULPF3 **') -> "bool":
        """
        GetElementIfIndexExists(itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3 self, unsigned long arg0, itkCellInterfaceFCTI3FFULULULPF3VCULPF3 ** arg1) -> bool

        Check if
        the given index is in range of the vector. If it is not, return false.
        Otherwise, set the element through the pointer (if it isn't nullptr),
        and return true. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_GetElementIfIndexExists(self, arg0, arg1)


    def CreateIndex(self, arg0: 'unsigned long') -> "void":
        """
        CreateIndex(itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3 self, unsigned long arg0)

        Make sure that the
        index range of the vector is large enough to allow the given index,
        expanding it if necessary. The index will contain the default element
        regardless of whether expansion occurred. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_CreateIndex(self, arg0)


    def DeleteIndex(self, arg0: 'unsigned long') -> "void":
        """
        DeleteIndex(itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3 self, unsigned long arg0)

        Delete the element
        defined by the index identifier. In practice, it doesn't make sense to
        delete a vector index. Instead, this method just overwrite the index
        with the default element. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_DeleteIndex(self, arg0)


    def Size(self) -> "unsigned long":
        """
        Size(itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3 self) -> unsigned long

        Get the number of elements
        currently stored in the vector. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_Size(self)


    def Reserve(self, arg0: 'unsigned long') -> "void":
        """
        Reserve(itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3 self, unsigned long arg0)

        Tell the container to
        allocate enough memory to allow at least as many elements as the size
        given to be stored. In the generic case of ITK containers this is NOT
        guaranteed to actually allocate any memory, but it is useful if the
        implementation of the container allocates contiguous storage. In the
        particular implementation of this VectorContainer the call to this
        method actually allocates memory for the number of elements defined by
        ElementIdentifier. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_Reserve(self, arg0)


    def Squeeze(self) -> "void":
        """
        Squeeze(itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3 self)

        Tell the container to try
        to minimize its memory usage for storage of the current number of
        elements. This is NOT guaranteed to decrease memory usage. This method
        is included here mainly for providing a unified API with other
        containers in the toolkit. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_Squeeze(self)


    def Initialize(self) -> "void":
        """
        Initialize(itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3 self)

        Clear the elements. The
        final size will be zero. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_Initialize(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3

    def cast(obj: 'itkLightObject') -> "itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3 *":
        """cast(itkLightObject obj) -> itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3"""
        return _itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3

        Create a new object of the class itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3.Clone = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_Clone, None, itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3.CastToSTLContainer = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_CastToSTLContainer, None, itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3.CastToSTLConstContainer = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_CastToSTLConstContainer, None, itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3.ElementAt = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_ElementAt, None, itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3.CreateElementAt = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_CreateElementAt, None, itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3.GetElement = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_GetElement, None, itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3.SetElement = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_SetElement, None, itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3.InsertElement = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_InsertElement, None, itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3.IndexExists = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_IndexExists, None, itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3.GetElementIfIndexExists = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_GetElementIfIndexExists, None, itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3.CreateIndex = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_CreateIndex, None, itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3.DeleteIndex = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_DeleteIndex, None, itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3.Size = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_Size, None, itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3.Reserve = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_Reserve, None, itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3.Squeeze = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_Squeeze, None, itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3.Initialize = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_Initialize, None, itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_swigregister = _itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_swigregister
itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_swigregister(itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3)

def itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3___New_orig__() -> "itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_Pointer":
    """itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3___New_orig__() -> itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_Pointer"""
    return _itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3___New_orig__()

def itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_cast(obj: 'itkLightObject') -> "itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3 *":
    """itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_cast(itkLightObject obj) -> itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3"""
    return _itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_cast(obj)

class itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2(ITKCommonBasePython.itkObject):
    """


    Define a front-end to the STL "vector" container that conforms to
    the IndexedContainerInterface.

    This is a full-fleged Object, so there is modification time, debug,
    and reference count information.

    Parameters:
    -----------

    TElementIdentifier:  An INTEGRAL type for use in indexing the vector.

    TElement:  The element type stored in the container.

    C++ includes: itkVectorContainer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2_Pointer":
        """__New_orig__() -> itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2_Pointer"""
        return _itkMeshBasePython.itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2_Pointer":
        """Clone(itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2 self) -> itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2_Pointer"""
        return _itkMeshBasePython.itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2_Clone(self)


    def CastToSTLContainer(self) -> "std::vector< itkCellInterfaceSSCTI2FFULULULPF2VCULPF2 *,std::allocator< itkCellInterfaceSSCTI2FFULULULPF2VCULPF2 * > > &":
        """
        CastToSTLContainer(itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2 self) -> std::vector< itkCellInterfaceSSCTI2FFULULULPF2VCULPF2 *,std::allocator< itkCellInterfaceSSCTI2FFULULULPF2VCULPF2 * > > &

        Cast the
        container to a STL container type 
        """
        return _itkMeshBasePython.itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2_CastToSTLContainer(self)


    def CastToSTLConstContainer(self) -> "std::vector< itkCellInterfaceSSCTI2FFULULULPF2VCULPF2 *,std::allocator< itkCellInterfaceSSCTI2FFULULULPF2VCULPF2 * > > const &":
        """
        CastToSTLConstContainer(itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2 self) -> std::vector< itkCellInterfaceSSCTI2FFULULULPF2VCULPF2 *,std::allocator< itkCellInterfaceSSCTI2FFULULULPF2VCULPF2 * > > const &

        Cast the
        container to a const STL container type 
        """
        return _itkMeshBasePython.itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2_CastToSTLConstContainer(self)


    def ElementAt(self, *args) -> "itkCellInterfaceSSCTI2FFULULULPF2VCULPF2 *const &":
        """
        ElementAt(itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2 self, unsigned long arg0) -> itkCellInterfaceSSCTI2FFULULULPF2VCULPF2
        ElementAt(itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2 self, unsigned long arg0) -> itkCellInterfaceSSCTI2FFULULULPF2VCULPF2

        Get a reference to the
        element at the given index. It is assumed that the index exists, and
        it will not automatically be created. 
        """
        return _itkMeshBasePython.itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2_ElementAt(self, *args)


    def CreateElementAt(self, arg0: 'unsigned long') -> "itkCellInterfaceSSCTI2FFULULULPF2VCULPF2 *&":
        """
        CreateElementAt(itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2 self, unsigned long arg0) -> itkCellInterfaceSSCTI2FFULULULPF2VCULPF2 *&

        Get a reference to
        the element at the given index. If the element location does not
        exist, it will be created with a default element value.

        It is assumed that the value of the element is modified through the
        reference. 
        """
        return _itkMeshBasePython.itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2_CreateElementAt(self, arg0)


    def GetElement(self, arg0: 'unsigned long') -> "itkCellInterfaceSSCTI2FFULULULPF2VCULPF2 *":
        """
        GetElement(itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2 self, unsigned long arg0) -> itkCellInterfaceSSCTI2FFULULULPF2VCULPF2

        Read the element from
        the given index. It is assumed that the index exists. 
        """
        return _itkMeshBasePython.itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2_GetElement(self, arg0)


    def SetElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceSSCTI2FFULULULPF2VCULPF2') -> "void":
        """
        SetElement(itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2 self, unsigned long arg0, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2 arg1)

        Set the element value at
        the given index. It is assumed that the index exists. 
        """
        return _itkMeshBasePython.itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2_SetElement(self, arg0, arg1)


    def InsertElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceSSCTI2FFULULULPF2VCULPF2') -> "void":
        """
        InsertElement(itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2 self, unsigned long arg0, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2 arg1)

        Set the element value
        at the given index. If the element location does not exist, it will be
        created with a default element value. 
        """
        return _itkMeshBasePython.itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2_InsertElement(self, arg0, arg1)


    def IndexExists(self, arg0: 'unsigned long') -> "bool":
        """
        IndexExists(itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2 self, unsigned long arg0) -> bool

        Check if the index
        range of the vector is large enough to allow the given index without
        expansion. 
        """
        return _itkMeshBasePython.itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2_IndexExists(self, arg0)


    def GetElementIfIndexExists(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceSSCTI2FFULULULPF2VCULPF2 **') -> "bool":
        """
        GetElementIfIndexExists(itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2 self, unsigned long arg0, itkCellInterfaceSSCTI2FFULULULPF2VCULPF2 ** arg1) -> bool

        Check if
        the given index is in range of the vector. If it is not, return false.
        Otherwise, set the element through the pointer (if it isn't nullptr),
        and return true. 
        """
        return _itkMeshBasePython.itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2_GetElementIfIndexExists(self, arg0, arg1)


    def CreateIndex(self, arg0: 'unsigned long') -> "void":
        """
        CreateIndex(itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2 self, unsigned long arg0)

        Make sure that the
        index range of the vector is large enough to allow the given index,
        expanding it if necessary. The index will contain the default element
        regardless of whether expansion occurred. 
        """
        return _itkMeshBasePython.itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2_CreateIndex(self, arg0)


    def DeleteIndex(self, arg0: 'unsigned long') -> "void":
        """
        DeleteIndex(itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2 self, unsigned long arg0)

        Delete the element
        defined by the index identifier. In practice, it doesn't make sense to
        delete a vector index. Instead, this method just overwrite the index
        with the default element. 
        """
        return _itkMeshBasePython.itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2_DeleteIndex(self, arg0)


    def Size(self) -> "unsigned long":
        """
        Size(itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2 self) -> unsigned long

        Get the number of elements
        currently stored in the vector. 
        """
        return _itkMeshBasePython.itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2_Size(self)


    def Reserve(self, arg0: 'unsigned long') -> "void":
        """
        Reserve(itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2 self, unsigned long arg0)

        Tell the container to
        allocate enough memory to allow at least as many elements as the size
        given to be stored. In the generic case of ITK containers this is NOT
        guaranteed to actually allocate any memory, but it is useful if the
        implementation of the container allocates contiguous storage. In the
        particular implementation of this VectorContainer the call to this
        method actually allocates memory for the number of elements defined by
        ElementIdentifier. 
        """
        return _itkMeshBasePython.itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2_Reserve(self, arg0)


    def Squeeze(self) -> "void":
        """
        Squeeze(itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2 self)

        Tell the container to try
        to minimize its memory usage for storage of the current number of
        elements. This is NOT guaranteed to decrease memory usage. This method
        is included here mainly for providing a unified API with other
        containers in the toolkit. 
        """
        return _itkMeshBasePython.itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2_Squeeze(self)


    def Initialize(self) -> "void":
        """
        Initialize(itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2 self)

        Clear the elements. The
        final size will be zero. 
        """
        return _itkMeshBasePython.itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2_Initialize(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2

    def cast(obj: 'itkLightObject') -> "itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2 *":
        """cast(itkLightObject obj) -> itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2"""
        return _itkMeshBasePython.itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2

        Create a new object of the class itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2.Clone = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2_Clone, None, itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2.CastToSTLContainer = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2_CastToSTLContainer, None, itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2.CastToSTLConstContainer = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2_CastToSTLConstContainer, None, itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2.ElementAt = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2_ElementAt, None, itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2.CreateElementAt = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2_CreateElementAt, None, itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2.GetElement = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2_GetElement, None, itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2.SetElement = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2_SetElement, None, itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2.InsertElement = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2_InsertElement, None, itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2.IndexExists = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2_IndexExists, None, itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2.GetElementIfIndexExists = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2_GetElementIfIndexExists, None, itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2.CreateIndex = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2_CreateIndex, None, itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2.DeleteIndex = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2_DeleteIndex, None, itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2.Size = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2_Size, None, itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2.Reserve = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2_Reserve, None, itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2.Squeeze = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2_Squeeze, None, itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2.Initialize = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2_Initialize, None, itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2_swigregister = _itkMeshBasePython.itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2_swigregister
itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2_swigregister(itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2)

def itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2___New_orig__() -> "itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2_Pointer":
    """itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2___New_orig__() -> itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2_Pointer"""
    return _itkMeshBasePython.itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2___New_orig__()

def itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2_cast(obj: 'itkLightObject') -> "itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2 *":
    """itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2_cast(itkLightObject obj) -> itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2"""
    return _itkMeshBasePython.itkVectorContainerULCISSCTI2FFULULULPF2VCULPF2_cast(obj)

class itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3(ITKCommonBasePython.itkObject):
    """


    Define a front-end to the STL "vector" container that conforms to
    the IndexedContainerInterface.

    This is a full-fleged Object, so there is modification time, debug,
    and reference count information.

    Parameters:
    -----------

    TElementIdentifier:  An INTEGRAL type for use in indexing the vector.

    TElement:  The element type stored in the container.

    C++ includes: itkVectorContainer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3_Pointer":
        """__New_orig__() -> itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3_Pointer"""
        return _itkMeshBasePython.itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3_Pointer":
        """Clone(itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3 self) -> itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3_Pointer"""
        return _itkMeshBasePython.itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3_Clone(self)


    def CastToSTLContainer(self) -> "std::vector< itkCellInterfaceSSCTI3FFULULULPF3VCULPF3 *,std::allocator< itkCellInterfaceSSCTI3FFULULULPF3VCULPF3 * > > &":
        """
        CastToSTLContainer(itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3 self) -> std::vector< itkCellInterfaceSSCTI3FFULULULPF3VCULPF3 *,std::allocator< itkCellInterfaceSSCTI3FFULULULPF3VCULPF3 * > > &

        Cast the
        container to a STL container type 
        """
        return _itkMeshBasePython.itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3_CastToSTLContainer(self)


    def CastToSTLConstContainer(self) -> "std::vector< itkCellInterfaceSSCTI3FFULULULPF3VCULPF3 *,std::allocator< itkCellInterfaceSSCTI3FFULULULPF3VCULPF3 * > > const &":
        """
        CastToSTLConstContainer(itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3 self) -> std::vector< itkCellInterfaceSSCTI3FFULULULPF3VCULPF3 *,std::allocator< itkCellInterfaceSSCTI3FFULULULPF3VCULPF3 * > > const &

        Cast the
        container to a const STL container type 
        """
        return _itkMeshBasePython.itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3_CastToSTLConstContainer(self)


    def ElementAt(self, *args) -> "itkCellInterfaceSSCTI3FFULULULPF3VCULPF3 *const &":
        """
        ElementAt(itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3 self, unsigned long arg0) -> itkCellInterfaceSSCTI3FFULULULPF3VCULPF3
        ElementAt(itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3 self, unsigned long arg0) -> itkCellInterfaceSSCTI3FFULULULPF3VCULPF3

        Get a reference to the
        element at the given index. It is assumed that the index exists, and
        it will not automatically be created. 
        """
        return _itkMeshBasePython.itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3_ElementAt(self, *args)


    def CreateElementAt(self, arg0: 'unsigned long') -> "itkCellInterfaceSSCTI3FFULULULPF3VCULPF3 *&":
        """
        CreateElementAt(itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3 self, unsigned long arg0) -> itkCellInterfaceSSCTI3FFULULULPF3VCULPF3 *&

        Get a reference to
        the element at the given index. If the element location does not
        exist, it will be created with a default element value.

        It is assumed that the value of the element is modified through the
        reference. 
        """
        return _itkMeshBasePython.itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3_CreateElementAt(self, arg0)


    def GetElement(self, arg0: 'unsigned long') -> "itkCellInterfaceSSCTI3FFULULULPF3VCULPF3 *":
        """
        GetElement(itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3 self, unsigned long arg0) -> itkCellInterfaceSSCTI3FFULULULPF3VCULPF3

        Read the element from
        the given index. It is assumed that the index exists. 
        """
        return _itkMeshBasePython.itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3_GetElement(self, arg0)


    def SetElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceSSCTI3FFULULULPF3VCULPF3') -> "void":
        """
        SetElement(itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3 self, unsigned long arg0, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3 arg1)

        Set the element value at
        the given index. It is assumed that the index exists. 
        """
        return _itkMeshBasePython.itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3_SetElement(self, arg0, arg1)


    def InsertElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceSSCTI3FFULULULPF3VCULPF3') -> "void":
        """
        InsertElement(itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3 self, unsigned long arg0, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3 arg1)

        Set the element value
        at the given index. If the element location does not exist, it will be
        created with a default element value. 
        """
        return _itkMeshBasePython.itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3_InsertElement(self, arg0, arg1)


    def IndexExists(self, arg0: 'unsigned long') -> "bool":
        """
        IndexExists(itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3 self, unsigned long arg0) -> bool

        Check if the index
        range of the vector is large enough to allow the given index without
        expansion. 
        """
        return _itkMeshBasePython.itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3_IndexExists(self, arg0)


    def GetElementIfIndexExists(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceSSCTI3FFULULULPF3VCULPF3 **') -> "bool":
        """
        GetElementIfIndexExists(itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3 self, unsigned long arg0, itkCellInterfaceSSCTI3FFULULULPF3VCULPF3 ** arg1) -> bool

        Check if
        the given index is in range of the vector. If it is not, return false.
        Otherwise, set the element through the pointer (if it isn't nullptr),
        and return true. 
        """
        return _itkMeshBasePython.itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3_GetElementIfIndexExists(self, arg0, arg1)


    def CreateIndex(self, arg0: 'unsigned long') -> "void":
        """
        CreateIndex(itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3 self, unsigned long arg0)

        Make sure that the
        index range of the vector is large enough to allow the given index,
        expanding it if necessary. The index will contain the default element
        regardless of whether expansion occurred. 
        """
        return _itkMeshBasePython.itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3_CreateIndex(self, arg0)


    def DeleteIndex(self, arg0: 'unsigned long') -> "void":
        """
        DeleteIndex(itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3 self, unsigned long arg0)

        Delete the element
        defined by the index identifier. In practice, it doesn't make sense to
        delete a vector index. Instead, this method just overwrite the index
        with the default element. 
        """
        return _itkMeshBasePython.itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3_DeleteIndex(self, arg0)


    def Size(self) -> "unsigned long":
        """
        Size(itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3 self) -> unsigned long

        Get the number of elements
        currently stored in the vector. 
        """
        return _itkMeshBasePython.itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3_Size(self)


    def Reserve(self, arg0: 'unsigned long') -> "void":
        """
        Reserve(itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3 self, unsigned long arg0)

        Tell the container to
        allocate enough memory to allow at least as many elements as the size
        given to be stored. In the generic case of ITK containers this is NOT
        guaranteed to actually allocate any memory, but it is useful if the
        implementation of the container allocates contiguous storage. In the
        particular implementation of this VectorContainer the call to this
        method actually allocates memory for the number of elements defined by
        ElementIdentifier. 
        """
        return _itkMeshBasePython.itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3_Reserve(self, arg0)


    def Squeeze(self) -> "void":
        """
        Squeeze(itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3 self)

        Tell the container to try
        to minimize its memory usage for storage of the current number of
        elements. This is NOT guaranteed to decrease memory usage. This method
        is included here mainly for providing a unified API with other
        containers in the toolkit. 
        """
        return _itkMeshBasePython.itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3_Squeeze(self)


    def Initialize(self) -> "void":
        """
        Initialize(itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3 self)

        Clear the elements. The
        final size will be zero. 
        """
        return _itkMeshBasePython.itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3_Initialize(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3

    def cast(obj: 'itkLightObject') -> "itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3 *":
        """cast(itkLightObject obj) -> itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3"""
        return _itkMeshBasePython.itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3

        Create a new object of the class itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3.Clone = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3_Clone, None, itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3.CastToSTLContainer = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3_CastToSTLContainer, None, itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3.CastToSTLConstContainer = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3_CastToSTLConstContainer, None, itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3.ElementAt = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3_ElementAt, None, itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3.CreateElementAt = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3_CreateElementAt, None, itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3.GetElement = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3_GetElement, None, itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3.SetElement = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3_SetElement, None, itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3.InsertElement = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3_InsertElement, None, itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3.IndexExists = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3_IndexExists, None, itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3.GetElementIfIndexExists = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3_GetElementIfIndexExists, None, itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3.CreateIndex = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3_CreateIndex, None, itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3.DeleteIndex = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3_DeleteIndex, None, itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3.Size = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3_Size, None, itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3.Reserve = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3_Reserve, None, itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3.Squeeze = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3_Squeeze, None, itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3.Initialize = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3_Initialize, None, itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3_swigregister = _itkMeshBasePython.itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3_swigregister
itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3_swigregister(itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3)

def itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3___New_orig__() -> "itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3_Pointer":
    """itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3___New_orig__() -> itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3_Pointer"""
    return _itkMeshBasePython.itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3___New_orig__()

def itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3_cast(obj: 'itkLightObject') -> "itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3 *":
    """itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3_cast(itkLightObject obj) -> itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3"""
    return _itkMeshBasePython.itkVectorContainerULCISSCTI3FFULULULPF3VCULPF3_cast(obj)

class itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2(ITKCommonBasePython.itkObject):
    """


    Define a front-end to the STL "vector" container that conforms to
    the IndexedContainerInterface.

    This is a full-fleged Object, so there is modification time, debug,
    and reference count information.

    Parameters:
    -----------

    TElementIdentifier:  An INTEGRAL type for use in indexing the vector.

    TElement:  The element type stored in the container.

    C++ includes: itkVectorContainer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2_Pointer":
        """__New_orig__() -> itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2_Pointer"""
        return _itkMeshBasePython.itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2_Pointer":
        """Clone(itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2 self) -> itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2_Pointer"""
        return _itkMeshBasePython.itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2_Clone(self)


    def CastToSTLContainer(self) -> "std::vector< itkCellInterfaceUCCTI2FFULULULPF2VCULPF2 *,std::allocator< itkCellInterfaceUCCTI2FFULULULPF2VCULPF2 * > > &":
        """
        CastToSTLContainer(itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2 self) -> std::vector< itkCellInterfaceUCCTI2FFULULULPF2VCULPF2 *,std::allocator< itkCellInterfaceUCCTI2FFULULULPF2VCULPF2 * > > &

        Cast the
        container to a STL container type 
        """
        return _itkMeshBasePython.itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2_CastToSTLContainer(self)


    def CastToSTLConstContainer(self) -> "std::vector< itkCellInterfaceUCCTI2FFULULULPF2VCULPF2 *,std::allocator< itkCellInterfaceUCCTI2FFULULULPF2VCULPF2 * > > const &":
        """
        CastToSTLConstContainer(itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2 self) -> std::vector< itkCellInterfaceUCCTI2FFULULULPF2VCULPF2 *,std::allocator< itkCellInterfaceUCCTI2FFULULULPF2VCULPF2 * > > const &

        Cast the
        container to a const STL container type 
        """
        return _itkMeshBasePython.itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2_CastToSTLConstContainer(self)


    def ElementAt(self, *args) -> "itkCellInterfaceUCCTI2FFULULULPF2VCULPF2 *const &":
        """
        ElementAt(itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2 self, unsigned long arg0) -> itkCellInterfaceUCCTI2FFULULULPF2VCULPF2
        ElementAt(itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2 self, unsigned long arg0) -> itkCellInterfaceUCCTI2FFULULULPF2VCULPF2

        Get a reference to the
        element at the given index. It is assumed that the index exists, and
        it will not automatically be created. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2_ElementAt(self, *args)


    def CreateElementAt(self, arg0: 'unsigned long') -> "itkCellInterfaceUCCTI2FFULULULPF2VCULPF2 *&":
        """
        CreateElementAt(itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2 self, unsigned long arg0) -> itkCellInterfaceUCCTI2FFULULULPF2VCULPF2 *&

        Get a reference to
        the element at the given index. If the element location does not
        exist, it will be created with a default element value.

        It is assumed that the value of the element is modified through the
        reference. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2_CreateElementAt(self, arg0)


    def GetElement(self, arg0: 'unsigned long') -> "itkCellInterfaceUCCTI2FFULULULPF2VCULPF2 *":
        """
        GetElement(itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2 self, unsigned long arg0) -> itkCellInterfaceUCCTI2FFULULULPF2VCULPF2

        Read the element from
        the given index. It is assumed that the index exists. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2_GetElement(self, arg0)


    def SetElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceUCCTI2FFULULULPF2VCULPF2') -> "void":
        """
        SetElement(itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2 self, unsigned long arg0, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2 arg1)

        Set the element value at
        the given index. It is assumed that the index exists. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2_SetElement(self, arg0, arg1)


    def InsertElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceUCCTI2FFULULULPF2VCULPF2') -> "void":
        """
        InsertElement(itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2 self, unsigned long arg0, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2 arg1)

        Set the element value
        at the given index. If the element location does not exist, it will be
        created with a default element value. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2_InsertElement(self, arg0, arg1)


    def IndexExists(self, arg0: 'unsigned long') -> "bool":
        """
        IndexExists(itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2 self, unsigned long arg0) -> bool

        Check if the index
        range of the vector is large enough to allow the given index without
        expansion. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2_IndexExists(self, arg0)


    def GetElementIfIndexExists(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceUCCTI2FFULULULPF2VCULPF2 **') -> "bool":
        """
        GetElementIfIndexExists(itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2 self, unsigned long arg0, itkCellInterfaceUCCTI2FFULULULPF2VCULPF2 ** arg1) -> bool

        Check if
        the given index is in range of the vector. If it is not, return false.
        Otherwise, set the element through the pointer (if it isn't nullptr),
        and return true. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2_GetElementIfIndexExists(self, arg0, arg1)


    def CreateIndex(self, arg0: 'unsigned long') -> "void":
        """
        CreateIndex(itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2 self, unsigned long arg0)

        Make sure that the
        index range of the vector is large enough to allow the given index,
        expanding it if necessary. The index will contain the default element
        regardless of whether expansion occurred. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2_CreateIndex(self, arg0)


    def DeleteIndex(self, arg0: 'unsigned long') -> "void":
        """
        DeleteIndex(itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2 self, unsigned long arg0)

        Delete the element
        defined by the index identifier. In practice, it doesn't make sense to
        delete a vector index. Instead, this method just overwrite the index
        with the default element. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2_DeleteIndex(self, arg0)


    def Size(self) -> "unsigned long":
        """
        Size(itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2 self) -> unsigned long

        Get the number of elements
        currently stored in the vector. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2_Size(self)


    def Reserve(self, arg0: 'unsigned long') -> "void":
        """
        Reserve(itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2 self, unsigned long arg0)

        Tell the container to
        allocate enough memory to allow at least as many elements as the size
        given to be stored. In the generic case of ITK containers this is NOT
        guaranteed to actually allocate any memory, but it is useful if the
        implementation of the container allocates contiguous storage. In the
        particular implementation of this VectorContainer the call to this
        method actually allocates memory for the number of elements defined by
        ElementIdentifier. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2_Reserve(self, arg0)


    def Squeeze(self) -> "void":
        """
        Squeeze(itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2 self)

        Tell the container to try
        to minimize its memory usage for storage of the current number of
        elements. This is NOT guaranteed to decrease memory usage. This method
        is included here mainly for providing a unified API with other
        containers in the toolkit. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2_Squeeze(self)


    def Initialize(self) -> "void":
        """
        Initialize(itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2 self)

        Clear the elements. The
        final size will be zero. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2_Initialize(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2

    def cast(obj: 'itkLightObject') -> "itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2 *":
        """cast(itkLightObject obj) -> itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2"""
        return _itkMeshBasePython.itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2

        Create a new object of the class itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2.Clone = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2_Clone, None, itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2.CastToSTLContainer = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2_CastToSTLContainer, None, itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2.CastToSTLConstContainer = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2_CastToSTLConstContainer, None, itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2.ElementAt = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2_ElementAt, None, itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2.CreateElementAt = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2_CreateElementAt, None, itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2.GetElement = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2_GetElement, None, itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2.SetElement = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2_SetElement, None, itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2.InsertElement = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2_InsertElement, None, itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2.IndexExists = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2_IndexExists, None, itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2.GetElementIfIndexExists = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2_GetElementIfIndexExists, None, itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2.CreateIndex = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2_CreateIndex, None, itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2.DeleteIndex = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2_DeleteIndex, None, itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2.Size = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2_Size, None, itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2.Reserve = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2_Reserve, None, itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2.Squeeze = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2_Squeeze, None, itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2.Initialize = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2_Initialize, None, itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2_swigregister = _itkMeshBasePython.itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2_swigregister
itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2_swigregister(itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2)

def itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2___New_orig__() -> "itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2_Pointer":
    """itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2___New_orig__() -> itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2_Pointer"""
    return _itkMeshBasePython.itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2___New_orig__()

def itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2_cast(obj: 'itkLightObject') -> "itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2 *":
    """itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2_cast(itkLightObject obj) -> itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2"""
    return _itkMeshBasePython.itkVectorContainerULCIUCCTI2FFULULULPF2VCULPF2_cast(obj)

class itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3(ITKCommonBasePython.itkObject):
    """


    Define a front-end to the STL "vector" container that conforms to
    the IndexedContainerInterface.

    This is a full-fleged Object, so there is modification time, debug,
    and reference count information.

    Parameters:
    -----------

    TElementIdentifier:  An INTEGRAL type for use in indexing the vector.

    TElement:  The element type stored in the container.

    C++ includes: itkVectorContainer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3_Pointer":
        """__New_orig__() -> itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3_Pointer"""
        return _itkMeshBasePython.itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3_Pointer":
        """Clone(itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3 self) -> itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3_Pointer"""
        return _itkMeshBasePython.itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3_Clone(self)


    def CastToSTLContainer(self) -> "std::vector< itkCellInterfaceUCCTI3FFULULULPF3VCULPF3 *,std::allocator< itkCellInterfaceUCCTI3FFULULULPF3VCULPF3 * > > &":
        """
        CastToSTLContainer(itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3 self) -> std::vector< itkCellInterfaceUCCTI3FFULULULPF3VCULPF3 *,std::allocator< itkCellInterfaceUCCTI3FFULULULPF3VCULPF3 * > > &

        Cast the
        container to a STL container type 
        """
        return _itkMeshBasePython.itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3_CastToSTLContainer(self)


    def CastToSTLConstContainer(self) -> "std::vector< itkCellInterfaceUCCTI3FFULULULPF3VCULPF3 *,std::allocator< itkCellInterfaceUCCTI3FFULULULPF3VCULPF3 * > > const &":
        """
        CastToSTLConstContainer(itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3 self) -> std::vector< itkCellInterfaceUCCTI3FFULULULPF3VCULPF3 *,std::allocator< itkCellInterfaceUCCTI3FFULULULPF3VCULPF3 * > > const &

        Cast the
        container to a const STL container type 
        """
        return _itkMeshBasePython.itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3_CastToSTLConstContainer(self)


    def ElementAt(self, *args) -> "itkCellInterfaceUCCTI3FFULULULPF3VCULPF3 *const &":
        """
        ElementAt(itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3 self, unsigned long arg0) -> itkCellInterfaceUCCTI3FFULULULPF3VCULPF3
        ElementAt(itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3 self, unsigned long arg0) -> itkCellInterfaceUCCTI3FFULULULPF3VCULPF3

        Get a reference to the
        element at the given index. It is assumed that the index exists, and
        it will not automatically be created. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3_ElementAt(self, *args)


    def CreateElementAt(self, arg0: 'unsigned long') -> "itkCellInterfaceUCCTI3FFULULULPF3VCULPF3 *&":
        """
        CreateElementAt(itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3 self, unsigned long arg0) -> itkCellInterfaceUCCTI3FFULULULPF3VCULPF3 *&

        Get a reference to
        the element at the given index. If the element location does not
        exist, it will be created with a default element value.

        It is assumed that the value of the element is modified through the
        reference. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3_CreateElementAt(self, arg0)


    def GetElement(self, arg0: 'unsigned long') -> "itkCellInterfaceUCCTI3FFULULULPF3VCULPF3 *":
        """
        GetElement(itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3 self, unsigned long arg0) -> itkCellInterfaceUCCTI3FFULULULPF3VCULPF3

        Read the element from
        the given index. It is assumed that the index exists. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3_GetElement(self, arg0)


    def SetElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceUCCTI3FFULULULPF3VCULPF3') -> "void":
        """
        SetElement(itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3 self, unsigned long arg0, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3 arg1)

        Set the element value at
        the given index. It is assumed that the index exists. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3_SetElement(self, arg0, arg1)


    def InsertElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceUCCTI3FFULULULPF3VCULPF3') -> "void":
        """
        InsertElement(itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3 self, unsigned long arg0, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3 arg1)

        Set the element value
        at the given index. If the element location does not exist, it will be
        created with a default element value. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3_InsertElement(self, arg0, arg1)


    def IndexExists(self, arg0: 'unsigned long') -> "bool":
        """
        IndexExists(itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3 self, unsigned long arg0) -> bool

        Check if the index
        range of the vector is large enough to allow the given index without
        expansion. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3_IndexExists(self, arg0)


    def GetElementIfIndexExists(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceUCCTI3FFULULULPF3VCULPF3 **') -> "bool":
        """
        GetElementIfIndexExists(itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3 self, unsigned long arg0, itkCellInterfaceUCCTI3FFULULULPF3VCULPF3 ** arg1) -> bool

        Check if
        the given index is in range of the vector. If it is not, return false.
        Otherwise, set the element through the pointer (if it isn't nullptr),
        and return true. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3_GetElementIfIndexExists(self, arg0, arg1)


    def CreateIndex(self, arg0: 'unsigned long') -> "void":
        """
        CreateIndex(itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3 self, unsigned long arg0)

        Make sure that the
        index range of the vector is large enough to allow the given index,
        expanding it if necessary. The index will contain the default element
        regardless of whether expansion occurred. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3_CreateIndex(self, arg0)


    def DeleteIndex(self, arg0: 'unsigned long') -> "void":
        """
        DeleteIndex(itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3 self, unsigned long arg0)

        Delete the element
        defined by the index identifier. In practice, it doesn't make sense to
        delete a vector index. Instead, this method just overwrite the index
        with the default element. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3_DeleteIndex(self, arg0)


    def Size(self) -> "unsigned long":
        """
        Size(itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3 self) -> unsigned long

        Get the number of elements
        currently stored in the vector. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3_Size(self)


    def Reserve(self, arg0: 'unsigned long') -> "void":
        """
        Reserve(itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3 self, unsigned long arg0)

        Tell the container to
        allocate enough memory to allow at least as many elements as the size
        given to be stored. In the generic case of ITK containers this is NOT
        guaranteed to actually allocate any memory, but it is useful if the
        implementation of the container allocates contiguous storage. In the
        particular implementation of this VectorContainer the call to this
        method actually allocates memory for the number of elements defined by
        ElementIdentifier. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3_Reserve(self, arg0)


    def Squeeze(self) -> "void":
        """
        Squeeze(itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3 self)

        Tell the container to try
        to minimize its memory usage for storage of the current number of
        elements. This is NOT guaranteed to decrease memory usage. This method
        is included here mainly for providing a unified API with other
        containers in the toolkit. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3_Squeeze(self)


    def Initialize(self) -> "void":
        """
        Initialize(itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3 self)

        Clear the elements. The
        final size will be zero. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3_Initialize(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3

    def cast(obj: 'itkLightObject') -> "itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3 *":
        """cast(itkLightObject obj) -> itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3"""
        return _itkMeshBasePython.itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3

        Create a new object of the class itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3.Clone = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3_Clone, None, itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3.CastToSTLContainer = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3_CastToSTLContainer, None, itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3.CastToSTLConstContainer = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3_CastToSTLConstContainer, None, itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3.ElementAt = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3_ElementAt, None, itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3.CreateElementAt = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3_CreateElementAt, None, itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3.GetElement = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3_GetElement, None, itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3.SetElement = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3_SetElement, None, itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3.InsertElement = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3_InsertElement, None, itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3.IndexExists = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3_IndexExists, None, itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3.GetElementIfIndexExists = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3_GetElementIfIndexExists, None, itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3.CreateIndex = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3_CreateIndex, None, itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3.DeleteIndex = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3_DeleteIndex, None, itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3.Size = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3_Size, None, itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3.Reserve = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3_Reserve, None, itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3.Squeeze = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3_Squeeze, None, itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3.Initialize = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3_Initialize, None, itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3_swigregister = _itkMeshBasePython.itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3_swigregister
itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3_swigregister(itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3)

def itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3___New_orig__() -> "itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3_Pointer":
    """itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3___New_orig__() -> itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3_Pointer"""
    return _itkMeshBasePython.itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3___New_orig__()

def itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3_cast(obj: 'itkLightObject') -> "itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3 *":
    """itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3_cast(itkLightObject obj) -> itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3"""
    return _itkMeshBasePython.itkVectorContainerULCIUCCTI3FFULULULPF3VCULPF3_cast(obj)

class itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2(ITKCommonBasePython.itkObject):
    """


    Define a front-end to the STL "vector" container that conforms to
    the IndexedContainerInterface.

    This is a full-fleged Object, so there is modification time, debug,
    and reference count information.

    Parameters:
    -----------

    TElementIdentifier:  An INTEGRAL type for use in indexing the vector.

    TElement:  The element type stored in the container.

    C++ includes: itkVectorContainer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2_Pointer":
        """__New_orig__() -> itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2_Pointer"""
        return _itkMeshBasePython.itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2_Pointer":
        """Clone(itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2 self) -> itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2_Pointer"""
        return _itkMeshBasePython.itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2_Clone(self)


    def CastToSTLContainer(self) -> "std::vector< itkCellInterfaceUSCTI2FFULULULPF2VCULPF2 *,std::allocator< itkCellInterfaceUSCTI2FFULULULPF2VCULPF2 * > > &":
        """
        CastToSTLContainer(itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2 self) -> std::vector< itkCellInterfaceUSCTI2FFULULULPF2VCULPF2 *,std::allocator< itkCellInterfaceUSCTI2FFULULULPF2VCULPF2 * > > &

        Cast the
        container to a STL container type 
        """
        return _itkMeshBasePython.itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2_CastToSTLContainer(self)


    def CastToSTLConstContainer(self) -> "std::vector< itkCellInterfaceUSCTI2FFULULULPF2VCULPF2 *,std::allocator< itkCellInterfaceUSCTI2FFULULULPF2VCULPF2 * > > const &":
        """
        CastToSTLConstContainer(itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2 self) -> std::vector< itkCellInterfaceUSCTI2FFULULULPF2VCULPF2 *,std::allocator< itkCellInterfaceUSCTI2FFULULULPF2VCULPF2 * > > const &

        Cast the
        container to a const STL container type 
        """
        return _itkMeshBasePython.itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2_CastToSTLConstContainer(self)


    def ElementAt(self, *args) -> "itkCellInterfaceUSCTI2FFULULULPF2VCULPF2 *const &":
        """
        ElementAt(itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2 self, unsigned long arg0) -> itkCellInterfaceUSCTI2FFULULULPF2VCULPF2
        ElementAt(itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2 self, unsigned long arg0) -> itkCellInterfaceUSCTI2FFULULULPF2VCULPF2

        Get a reference to the
        element at the given index. It is assumed that the index exists, and
        it will not automatically be created. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2_ElementAt(self, *args)


    def CreateElementAt(self, arg0: 'unsigned long') -> "itkCellInterfaceUSCTI2FFULULULPF2VCULPF2 *&":
        """
        CreateElementAt(itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2 self, unsigned long arg0) -> itkCellInterfaceUSCTI2FFULULULPF2VCULPF2 *&

        Get a reference to
        the element at the given index. If the element location does not
        exist, it will be created with a default element value.

        It is assumed that the value of the element is modified through the
        reference. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2_CreateElementAt(self, arg0)


    def GetElement(self, arg0: 'unsigned long') -> "itkCellInterfaceUSCTI2FFULULULPF2VCULPF2 *":
        """
        GetElement(itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2 self, unsigned long arg0) -> itkCellInterfaceUSCTI2FFULULULPF2VCULPF2

        Read the element from
        the given index. It is assumed that the index exists. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2_GetElement(self, arg0)


    def SetElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceUSCTI2FFULULULPF2VCULPF2') -> "void":
        """
        SetElement(itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2 self, unsigned long arg0, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2 arg1)

        Set the element value at
        the given index. It is assumed that the index exists. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2_SetElement(self, arg0, arg1)


    def InsertElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceUSCTI2FFULULULPF2VCULPF2') -> "void":
        """
        InsertElement(itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2 self, unsigned long arg0, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2 arg1)

        Set the element value
        at the given index. If the element location does not exist, it will be
        created with a default element value. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2_InsertElement(self, arg0, arg1)


    def IndexExists(self, arg0: 'unsigned long') -> "bool":
        """
        IndexExists(itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2 self, unsigned long arg0) -> bool

        Check if the index
        range of the vector is large enough to allow the given index without
        expansion. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2_IndexExists(self, arg0)


    def GetElementIfIndexExists(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceUSCTI2FFULULULPF2VCULPF2 **') -> "bool":
        """
        GetElementIfIndexExists(itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2 self, unsigned long arg0, itkCellInterfaceUSCTI2FFULULULPF2VCULPF2 ** arg1) -> bool

        Check if
        the given index is in range of the vector. If it is not, return false.
        Otherwise, set the element through the pointer (if it isn't nullptr),
        and return true. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2_GetElementIfIndexExists(self, arg0, arg1)


    def CreateIndex(self, arg0: 'unsigned long') -> "void":
        """
        CreateIndex(itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2 self, unsigned long arg0)

        Make sure that the
        index range of the vector is large enough to allow the given index,
        expanding it if necessary. The index will contain the default element
        regardless of whether expansion occurred. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2_CreateIndex(self, arg0)


    def DeleteIndex(self, arg0: 'unsigned long') -> "void":
        """
        DeleteIndex(itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2 self, unsigned long arg0)

        Delete the element
        defined by the index identifier. In practice, it doesn't make sense to
        delete a vector index. Instead, this method just overwrite the index
        with the default element. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2_DeleteIndex(self, arg0)


    def Size(self) -> "unsigned long":
        """
        Size(itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2 self) -> unsigned long

        Get the number of elements
        currently stored in the vector. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2_Size(self)


    def Reserve(self, arg0: 'unsigned long') -> "void":
        """
        Reserve(itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2 self, unsigned long arg0)

        Tell the container to
        allocate enough memory to allow at least as many elements as the size
        given to be stored. In the generic case of ITK containers this is NOT
        guaranteed to actually allocate any memory, but it is useful if the
        implementation of the container allocates contiguous storage. In the
        particular implementation of this VectorContainer the call to this
        method actually allocates memory for the number of elements defined by
        ElementIdentifier. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2_Reserve(self, arg0)


    def Squeeze(self) -> "void":
        """
        Squeeze(itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2 self)

        Tell the container to try
        to minimize its memory usage for storage of the current number of
        elements. This is NOT guaranteed to decrease memory usage. This method
        is included here mainly for providing a unified API with other
        containers in the toolkit. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2_Squeeze(self)


    def Initialize(self) -> "void":
        """
        Initialize(itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2 self)

        Clear the elements. The
        final size will be zero. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2_Initialize(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2

    def cast(obj: 'itkLightObject') -> "itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2 *":
        """cast(itkLightObject obj) -> itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2"""
        return _itkMeshBasePython.itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2

        Create a new object of the class itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2.Clone = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2_Clone, None, itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2.CastToSTLContainer = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2_CastToSTLContainer, None, itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2.CastToSTLConstContainer = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2_CastToSTLConstContainer, None, itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2.ElementAt = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2_ElementAt, None, itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2.CreateElementAt = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2_CreateElementAt, None, itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2.GetElement = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2_GetElement, None, itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2.SetElement = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2_SetElement, None, itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2.InsertElement = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2_InsertElement, None, itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2.IndexExists = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2_IndexExists, None, itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2.GetElementIfIndexExists = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2_GetElementIfIndexExists, None, itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2.CreateIndex = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2_CreateIndex, None, itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2.DeleteIndex = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2_DeleteIndex, None, itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2.Size = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2_Size, None, itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2.Reserve = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2_Reserve, None, itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2.Squeeze = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2_Squeeze, None, itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2.Initialize = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2_Initialize, None, itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2_swigregister = _itkMeshBasePython.itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2_swigregister
itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2_swigregister(itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2)

def itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2___New_orig__() -> "itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2_Pointer":
    """itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2___New_orig__() -> itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2_Pointer"""
    return _itkMeshBasePython.itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2___New_orig__()

def itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2_cast(obj: 'itkLightObject') -> "itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2 *":
    """itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2_cast(itkLightObject obj) -> itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2"""
    return _itkMeshBasePython.itkVectorContainerULCIUSCTI2FFULULULPF2VCULPF2_cast(obj)

class itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3(ITKCommonBasePython.itkObject):
    """


    Define a front-end to the STL "vector" container that conforms to
    the IndexedContainerInterface.

    This is a full-fleged Object, so there is modification time, debug,
    and reference count information.

    Parameters:
    -----------

    TElementIdentifier:  An INTEGRAL type for use in indexing the vector.

    TElement:  The element type stored in the container.

    C++ includes: itkVectorContainer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3_Pointer":
        """__New_orig__() -> itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3_Pointer"""
        return _itkMeshBasePython.itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3_Pointer":
        """Clone(itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3 self) -> itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3_Pointer"""
        return _itkMeshBasePython.itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3_Clone(self)


    def CastToSTLContainer(self) -> "std::vector< itkCellInterfaceUSCTI3FFULULULPF3VCULPF3 *,std::allocator< itkCellInterfaceUSCTI3FFULULULPF3VCULPF3 * > > &":
        """
        CastToSTLContainer(itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3 self) -> std::vector< itkCellInterfaceUSCTI3FFULULULPF3VCULPF3 *,std::allocator< itkCellInterfaceUSCTI3FFULULULPF3VCULPF3 * > > &

        Cast the
        container to a STL container type 
        """
        return _itkMeshBasePython.itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3_CastToSTLContainer(self)


    def CastToSTLConstContainer(self) -> "std::vector< itkCellInterfaceUSCTI3FFULULULPF3VCULPF3 *,std::allocator< itkCellInterfaceUSCTI3FFULULULPF3VCULPF3 * > > const &":
        """
        CastToSTLConstContainer(itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3 self) -> std::vector< itkCellInterfaceUSCTI3FFULULULPF3VCULPF3 *,std::allocator< itkCellInterfaceUSCTI3FFULULULPF3VCULPF3 * > > const &

        Cast the
        container to a const STL container type 
        """
        return _itkMeshBasePython.itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3_CastToSTLConstContainer(self)


    def ElementAt(self, *args) -> "itkCellInterfaceUSCTI3FFULULULPF3VCULPF3 *const &":
        """
        ElementAt(itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3 self, unsigned long arg0) -> itkCellInterfaceUSCTI3FFULULULPF3VCULPF3
        ElementAt(itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3 self, unsigned long arg0) -> itkCellInterfaceUSCTI3FFULULULPF3VCULPF3

        Get a reference to the
        element at the given index. It is assumed that the index exists, and
        it will not automatically be created. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3_ElementAt(self, *args)


    def CreateElementAt(self, arg0: 'unsigned long') -> "itkCellInterfaceUSCTI3FFULULULPF3VCULPF3 *&":
        """
        CreateElementAt(itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3 self, unsigned long arg0) -> itkCellInterfaceUSCTI3FFULULULPF3VCULPF3 *&

        Get a reference to
        the element at the given index. If the element location does not
        exist, it will be created with a default element value.

        It is assumed that the value of the element is modified through the
        reference. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3_CreateElementAt(self, arg0)


    def GetElement(self, arg0: 'unsigned long') -> "itkCellInterfaceUSCTI3FFULULULPF3VCULPF3 *":
        """
        GetElement(itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3 self, unsigned long arg0) -> itkCellInterfaceUSCTI3FFULULULPF3VCULPF3

        Read the element from
        the given index. It is assumed that the index exists. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3_GetElement(self, arg0)


    def SetElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceUSCTI3FFULULULPF3VCULPF3') -> "void":
        """
        SetElement(itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3 self, unsigned long arg0, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3 arg1)

        Set the element value at
        the given index. It is assumed that the index exists. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3_SetElement(self, arg0, arg1)


    def InsertElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceUSCTI3FFULULULPF3VCULPF3') -> "void":
        """
        InsertElement(itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3 self, unsigned long arg0, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3 arg1)

        Set the element value
        at the given index. If the element location does not exist, it will be
        created with a default element value. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3_InsertElement(self, arg0, arg1)


    def IndexExists(self, arg0: 'unsigned long') -> "bool":
        """
        IndexExists(itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3 self, unsigned long arg0) -> bool

        Check if the index
        range of the vector is large enough to allow the given index without
        expansion. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3_IndexExists(self, arg0)


    def GetElementIfIndexExists(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceUSCTI3FFULULULPF3VCULPF3 **') -> "bool":
        """
        GetElementIfIndexExists(itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3 self, unsigned long arg0, itkCellInterfaceUSCTI3FFULULULPF3VCULPF3 ** arg1) -> bool

        Check if
        the given index is in range of the vector. If it is not, return false.
        Otherwise, set the element through the pointer (if it isn't nullptr),
        and return true. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3_GetElementIfIndexExists(self, arg0, arg1)


    def CreateIndex(self, arg0: 'unsigned long') -> "void":
        """
        CreateIndex(itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3 self, unsigned long arg0)

        Make sure that the
        index range of the vector is large enough to allow the given index,
        expanding it if necessary. The index will contain the default element
        regardless of whether expansion occurred. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3_CreateIndex(self, arg0)


    def DeleteIndex(self, arg0: 'unsigned long') -> "void":
        """
        DeleteIndex(itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3 self, unsigned long arg0)

        Delete the element
        defined by the index identifier. In practice, it doesn't make sense to
        delete a vector index. Instead, this method just overwrite the index
        with the default element. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3_DeleteIndex(self, arg0)


    def Size(self) -> "unsigned long":
        """
        Size(itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3 self) -> unsigned long

        Get the number of elements
        currently stored in the vector. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3_Size(self)


    def Reserve(self, arg0: 'unsigned long') -> "void":
        """
        Reserve(itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3 self, unsigned long arg0)

        Tell the container to
        allocate enough memory to allow at least as many elements as the size
        given to be stored. In the generic case of ITK containers this is NOT
        guaranteed to actually allocate any memory, but it is useful if the
        implementation of the container allocates contiguous storage. In the
        particular implementation of this VectorContainer the call to this
        method actually allocates memory for the number of elements defined by
        ElementIdentifier. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3_Reserve(self, arg0)


    def Squeeze(self) -> "void":
        """
        Squeeze(itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3 self)

        Tell the container to try
        to minimize its memory usage for storage of the current number of
        elements. This is NOT guaranteed to decrease memory usage. This method
        is included here mainly for providing a unified API with other
        containers in the toolkit. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3_Squeeze(self)


    def Initialize(self) -> "void":
        """
        Initialize(itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3 self)

        Clear the elements. The
        final size will be zero. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3_Initialize(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3

    def cast(obj: 'itkLightObject') -> "itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3 *":
        """cast(itkLightObject obj) -> itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3"""
        return _itkMeshBasePython.itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3

        Create a new object of the class itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3.Clone = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3_Clone, None, itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3.CastToSTLContainer = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3_CastToSTLContainer, None, itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3.CastToSTLConstContainer = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3_CastToSTLConstContainer, None, itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3.ElementAt = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3_ElementAt, None, itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3.CreateElementAt = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3_CreateElementAt, None, itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3.GetElement = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3_GetElement, None, itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3.SetElement = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3_SetElement, None, itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3.InsertElement = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3_InsertElement, None, itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3.IndexExists = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3_IndexExists, None, itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3.GetElementIfIndexExists = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3_GetElementIfIndexExists, None, itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3.CreateIndex = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3_CreateIndex, None, itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3.DeleteIndex = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3_DeleteIndex, None, itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3.Size = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3_Size, None, itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3.Reserve = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3_Reserve, None, itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3.Squeeze = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3_Squeeze, None, itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3.Initialize = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3_Initialize, None, itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3_swigregister = _itkMeshBasePython.itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3_swigregister
itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3_swigregister(itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3)

def itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3___New_orig__() -> "itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3_Pointer":
    """itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3___New_orig__() -> itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3_Pointer"""
    return _itkMeshBasePython.itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3___New_orig__()

def itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3_cast(obj: 'itkLightObject') -> "itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3 *":
    """itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3_cast(itkLightObject obj) -> itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3"""
    return _itkMeshBasePython.itkVectorContainerULCIUSCTI3FFULULULPF3VCULPF3_cast(obj)



