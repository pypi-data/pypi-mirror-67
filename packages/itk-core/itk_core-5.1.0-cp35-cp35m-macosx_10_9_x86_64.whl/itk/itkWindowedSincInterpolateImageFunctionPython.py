# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.8
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _itkWindowedSincInterpolateImageFunctionPython.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_itkWindowedSincInterpolateImageFunctionPython', [dirname(__file__)])
        except ImportError:
            import _itkWindowedSincInterpolateImageFunctionPython
            return _itkWindowedSincInterpolateImageFunctionPython
        if fp is not None:
            try:
                _mod = imp.load_module('_itkWindowedSincInterpolateImageFunctionPython', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _itkWindowedSincInterpolateImageFunctionPython = swig_import_helper()
    del swig_import_helper
else:
    import _itkWindowedSincInterpolateImageFunctionPython
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0



def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


import itkImagePython
import itkImageRegionPython
import itkSizePython
import pyBasePython
import ITKCommonBasePython
import itkIndexPython
import itkOffsetPython
import itkRGBAPixelPython
import itkFixedArrayPython
import stdcomplexPython
import itkRGBPixelPython
import itkMatrixPython
import vnl_matrix_fixedPython
import vnl_matrixPython
import vnl_vectorPython
import itkVectorPython
import vnl_vector_refPython
import itkCovariantVectorPython
import itkPointPython
import itkSymmetricSecondRankTensorPython
import itkInterpolateImageFunctionPython
import itkImageFunctionBasePython
import itkContinuousIndexPython
import itkFunctionBasePython
import itkArrayPython

def itkWindowedSincInterpolateImageFunctionID33Lanczos_New():
  return itkWindowedSincInterpolateImageFunctionID33Lanczos.New()


def itkWindowedSincInterpolateImageFunctionID33Welch_New():
  return itkWindowedSincInterpolateImageFunctionID33Welch.New()


def itkWindowedSincInterpolateImageFunctionID33Cosine_New():
  return itkWindowedSincInterpolateImageFunctionID33Cosine.New()


def itkWindowedSincInterpolateImageFunctionID33Hamming_New():
  return itkWindowedSincInterpolateImageFunctionID33Hamming.New()


def itkWindowedSincInterpolateImageFunctionID32Lanczos_New():
  return itkWindowedSincInterpolateImageFunctionID32Lanczos.New()


def itkWindowedSincInterpolateImageFunctionID32Welch_New():
  return itkWindowedSincInterpolateImageFunctionID32Welch.New()


def itkWindowedSincInterpolateImageFunctionID32Cosine_New():
  return itkWindowedSincInterpolateImageFunctionID32Cosine.New()


def itkWindowedSincInterpolateImageFunctionID32Hamming_New():
  return itkWindowedSincInterpolateImageFunctionID32Hamming.New()


def itkWindowedSincInterpolateImageFunctionIF33Lanczos_New():
  return itkWindowedSincInterpolateImageFunctionIF33Lanczos.New()


def itkWindowedSincInterpolateImageFunctionIF33Welch_New():
  return itkWindowedSincInterpolateImageFunctionIF33Welch.New()


def itkWindowedSincInterpolateImageFunctionIF33Cosine_New():
  return itkWindowedSincInterpolateImageFunctionIF33Cosine.New()


def itkWindowedSincInterpolateImageFunctionIF33Hamming_New():
  return itkWindowedSincInterpolateImageFunctionIF33Hamming.New()


def itkWindowedSincInterpolateImageFunctionIF32Lanczos_New():
  return itkWindowedSincInterpolateImageFunctionIF32Lanczos.New()


def itkWindowedSincInterpolateImageFunctionIF32Welch_New():
  return itkWindowedSincInterpolateImageFunctionIF32Welch.New()


def itkWindowedSincInterpolateImageFunctionIF32Cosine_New():
  return itkWindowedSincInterpolateImageFunctionIF32Cosine.New()


def itkWindowedSincInterpolateImageFunctionIF32Hamming_New():
  return itkWindowedSincInterpolateImageFunctionIF32Hamming.New()


def itkWindowedSincInterpolateImageFunctionIUS33Lanczos_New():
  return itkWindowedSincInterpolateImageFunctionIUS33Lanczos.New()


def itkWindowedSincInterpolateImageFunctionIUS33Welch_New():
  return itkWindowedSincInterpolateImageFunctionIUS33Welch.New()


def itkWindowedSincInterpolateImageFunctionIUS33Cosine_New():
  return itkWindowedSincInterpolateImageFunctionIUS33Cosine.New()


def itkWindowedSincInterpolateImageFunctionIUS33Hamming_New():
  return itkWindowedSincInterpolateImageFunctionIUS33Hamming.New()


def itkWindowedSincInterpolateImageFunctionIUS32Lanczos_New():
  return itkWindowedSincInterpolateImageFunctionIUS32Lanczos.New()


def itkWindowedSincInterpolateImageFunctionIUS32Welch_New():
  return itkWindowedSincInterpolateImageFunctionIUS32Welch.New()


def itkWindowedSincInterpolateImageFunctionIUS32Cosine_New():
  return itkWindowedSincInterpolateImageFunctionIUS32Cosine.New()


def itkWindowedSincInterpolateImageFunctionIUS32Hamming_New():
  return itkWindowedSincInterpolateImageFunctionIUS32Hamming.New()


def itkWindowedSincInterpolateImageFunctionIUC33Lanczos_New():
  return itkWindowedSincInterpolateImageFunctionIUC33Lanczos.New()


def itkWindowedSincInterpolateImageFunctionIUC33Welch_New():
  return itkWindowedSincInterpolateImageFunctionIUC33Welch.New()


def itkWindowedSincInterpolateImageFunctionIUC33Cosine_New():
  return itkWindowedSincInterpolateImageFunctionIUC33Cosine.New()


def itkWindowedSincInterpolateImageFunctionIUC33Hamming_New():
  return itkWindowedSincInterpolateImageFunctionIUC33Hamming.New()


def itkWindowedSincInterpolateImageFunctionIUC32Lanczos_New():
  return itkWindowedSincInterpolateImageFunctionIUC32Lanczos.New()


def itkWindowedSincInterpolateImageFunctionIUC32Welch_New():
  return itkWindowedSincInterpolateImageFunctionIUC32Welch.New()


def itkWindowedSincInterpolateImageFunctionIUC32Cosine_New():
  return itkWindowedSincInterpolateImageFunctionIUC32Cosine.New()


def itkWindowedSincInterpolateImageFunctionIUC32Hamming_New():
  return itkWindowedSincInterpolateImageFunctionIUC32Hamming.New()


def itkWindowedSincInterpolateImageFunctionISS33Lanczos_New():
  return itkWindowedSincInterpolateImageFunctionISS33Lanczos.New()


def itkWindowedSincInterpolateImageFunctionISS33Welch_New():
  return itkWindowedSincInterpolateImageFunctionISS33Welch.New()


def itkWindowedSincInterpolateImageFunctionISS33Cosine_New():
  return itkWindowedSincInterpolateImageFunctionISS33Cosine.New()


def itkWindowedSincInterpolateImageFunctionISS33Hamming_New():
  return itkWindowedSincInterpolateImageFunctionISS33Hamming.New()


def itkWindowedSincInterpolateImageFunctionISS32Lanczos_New():
  return itkWindowedSincInterpolateImageFunctionISS32Lanczos.New()


def itkWindowedSincInterpolateImageFunctionISS32Welch_New():
  return itkWindowedSincInterpolateImageFunctionISS32Welch.New()


def itkWindowedSincInterpolateImageFunctionISS32Cosine_New():
  return itkWindowedSincInterpolateImageFunctionISS32Cosine.New()


def itkWindowedSincInterpolateImageFunctionISS32Hamming_New():
  return itkWindowedSincInterpolateImageFunctionISS32Hamming.New()


def itkWindowedSincInterpolateImageFunctionID23Lanczos_New():
  return itkWindowedSincInterpolateImageFunctionID23Lanczos.New()


def itkWindowedSincInterpolateImageFunctionID23Welch_New():
  return itkWindowedSincInterpolateImageFunctionID23Welch.New()


def itkWindowedSincInterpolateImageFunctionID23Cosine_New():
  return itkWindowedSincInterpolateImageFunctionID23Cosine.New()


def itkWindowedSincInterpolateImageFunctionID23Hamming_New():
  return itkWindowedSincInterpolateImageFunctionID23Hamming.New()


def itkWindowedSincInterpolateImageFunctionID22Lanczos_New():
  return itkWindowedSincInterpolateImageFunctionID22Lanczos.New()


def itkWindowedSincInterpolateImageFunctionID22Welch_New():
  return itkWindowedSincInterpolateImageFunctionID22Welch.New()


def itkWindowedSincInterpolateImageFunctionID22Cosine_New():
  return itkWindowedSincInterpolateImageFunctionID22Cosine.New()


def itkWindowedSincInterpolateImageFunctionID22Hamming_New():
  return itkWindowedSincInterpolateImageFunctionID22Hamming.New()


def itkWindowedSincInterpolateImageFunctionIF23Lanczos_New():
  return itkWindowedSincInterpolateImageFunctionIF23Lanczos.New()


def itkWindowedSincInterpolateImageFunctionIF23Welch_New():
  return itkWindowedSincInterpolateImageFunctionIF23Welch.New()


def itkWindowedSincInterpolateImageFunctionIF23Cosine_New():
  return itkWindowedSincInterpolateImageFunctionIF23Cosine.New()


def itkWindowedSincInterpolateImageFunctionIF23Hamming_New():
  return itkWindowedSincInterpolateImageFunctionIF23Hamming.New()


def itkWindowedSincInterpolateImageFunctionIF22Lanczos_New():
  return itkWindowedSincInterpolateImageFunctionIF22Lanczos.New()


def itkWindowedSincInterpolateImageFunctionIF22Welch_New():
  return itkWindowedSincInterpolateImageFunctionIF22Welch.New()


def itkWindowedSincInterpolateImageFunctionIF22Cosine_New():
  return itkWindowedSincInterpolateImageFunctionIF22Cosine.New()


def itkWindowedSincInterpolateImageFunctionIF22Hamming_New():
  return itkWindowedSincInterpolateImageFunctionIF22Hamming.New()


def itkWindowedSincInterpolateImageFunctionIUS23Lanczos_New():
  return itkWindowedSincInterpolateImageFunctionIUS23Lanczos.New()


def itkWindowedSincInterpolateImageFunctionIUS23Welch_New():
  return itkWindowedSincInterpolateImageFunctionIUS23Welch.New()


def itkWindowedSincInterpolateImageFunctionIUS23Cosine_New():
  return itkWindowedSincInterpolateImageFunctionIUS23Cosine.New()


def itkWindowedSincInterpolateImageFunctionIUS23Hamming_New():
  return itkWindowedSincInterpolateImageFunctionIUS23Hamming.New()


def itkWindowedSincInterpolateImageFunctionIUS22Lanczos_New():
  return itkWindowedSincInterpolateImageFunctionIUS22Lanczos.New()


def itkWindowedSincInterpolateImageFunctionIUS22Welch_New():
  return itkWindowedSincInterpolateImageFunctionIUS22Welch.New()


def itkWindowedSincInterpolateImageFunctionIUS22Cosine_New():
  return itkWindowedSincInterpolateImageFunctionIUS22Cosine.New()


def itkWindowedSincInterpolateImageFunctionIUS22Hamming_New():
  return itkWindowedSincInterpolateImageFunctionIUS22Hamming.New()


def itkWindowedSincInterpolateImageFunctionIUC23Lanczos_New():
  return itkWindowedSincInterpolateImageFunctionIUC23Lanczos.New()


def itkWindowedSincInterpolateImageFunctionIUC23Welch_New():
  return itkWindowedSincInterpolateImageFunctionIUC23Welch.New()


def itkWindowedSincInterpolateImageFunctionIUC23Cosine_New():
  return itkWindowedSincInterpolateImageFunctionIUC23Cosine.New()


def itkWindowedSincInterpolateImageFunctionIUC23Hamming_New():
  return itkWindowedSincInterpolateImageFunctionIUC23Hamming.New()


def itkWindowedSincInterpolateImageFunctionIUC22Lanczos_New():
  return itkWindowedSincInterpolateImageFunctionIUC22Lanczos.New()


def itkWindowedSincInterpolateImageFunctionIUC22Welch_New():
  return itkWindowedSincInterpolateImageFunctionIUC22Welch.New()


def itkWindowedSincInterpolateImageFunctionIUC22Cosine_New():
  return itkWindowedSincInterpolateImageFunctionIUC22Cosine.New()


def itkWindowedSincInterpolateImageFunctionIUC22Hamming_New():
  return itkWindowedSincInterpolateImageFunctionIUC22Hamming.New()


def itkWindowedSincInterpolateImageFunctionISS23Lanczos_New():
  return itkWindowedSincInterpolateImageFunctionISS23Lanczos.New()


def itkWindowedSincInterpolateImageFunctionISS23Welch_New():
  return itkWindowedSincInterpolateImageFunctionISS23Welch.New()


def itkWindowedSincInterpolateImageFunctionISS23Cosine_New():
  return itkWindowedSincInterpolateImageFunctionISS23Cosine.New()


def itkWindowedSincInterpolateImageFunctionISS23Hamming_New():
  return itkWindowedSincInterpolateImageFunctionISS23Hamming.New()


def itkWindowedSincInterpolateImageFunctionISS22Lanczos_New():
  return itkWindowedSincInterpolateImageFunctionISS22Lanczos.New()


def itkWindowedSincInterpolateImageFunctionISS22Welch_New():
  return itkWindowedSincInterpolateImageFunctionISS22Welch.New()


def itkWindowedSincInterpolateImageFunctionISS22Cosine_New():
  return itkWindowedSincInterpolateImageFunctionISS22Cosine.New()


def itkWindowedSincInterpolateImageFunctionISS22Hamming_New():
  return itkWindowedSincInterpolateImageFunctionISS22Hamming.New()

class itkCosineWindowFunction2(object):
    """Proxy of C++ itkCosineWindowFunction2 class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __call__(self, A: 'double const &') -> "double":
        """__call__(itkCosineWindowFunction2 self, double const & A) -> double"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkCosineWindowFunction2___call__(self, A)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkCosineWindowFunction2

    def __init__(self, *args):
        """
        __init__(itkCosineWindowFunction2 self) -> itkCosineWindowFunction2
        __init__(itkCosineWindowFunction2 self, itkCosineWindowFunction2 arg0) -> itkCosineWindowFunction2
        """
        _itkWindowedSincInterpolateImageFunctionPython.itkCosineWindowFunction2_swiginit(self, _itkWindowedSincInterpolateImageFunctionPython.new_itkCosineWindowFunction2(*args))
itkCosineWindowFunction2.__call__ = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkCosineWindowFunction2___call__, None, itkCosineWindowFunction2)
itkCosineWindowFunction2_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkCosineWindowFunction2_swigregister
itkCosineWindowFunction2_swigregister(itkCosineWindowFunction2)

class itkCosineWindowFunction3(object):
    """Proxy of C++ itkCosineWindowFunction3 class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __call__(self, A: 'double const &') -> "double":
        """__call__(itkCosineWindowFunction3 self, double const & A) -> double"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkCosineWindowFunction3___call__(self, A)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkCosineWindowFunction3

    def __init__(self, *args):
        """
        __init__(itkCosineWindowFunction3 self) -> itkCosineWindowFunction3
        __init__(itkCosineWindowFunction3 self, itkCosineWindowFunction3 arg0) -> itkCosineWindowFunction3
        """
        _itkWindowedSincInterpolateImageFunctionPython.itkCosineWindowFunction3_swiginit(self, _itkWindowedSincInterpolateImageFunctionPython.new_itkCosineWindowFunction3(*args))
itkCosineWindowFunction3.__call__ = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkCosineWindowFunction3___call__, None, itkCosineWindowFunction3)
itkCosineWindowFunction3_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkCosineWindowFunction3_swigregister
itkCosineWindowFunction3_swigregister(itkCosineWindowFunction3)

class itkHammingWindowFunction2(object):
    """Proxy of C++ itkHammingWindowFunction2 class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __call__(self, A: 'double const &') -> "double":
        """__call__(itkHammingWindowFunction2 self, double const & A) -> double"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkHammingWindowFunction2___call__(self, A)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkHammingWindowFunction2

    def __init__(self, *args):
        """
        __init__(itkHammingWindowFunction2 self) -> itkHammingWindowFunction2
        __init__(itkHammingWindowFunction2 self, itkHammingWindowFunction2 arg0) -> itkHammingWindowFunction2
        """
        _itkWindowedSincInterpolateImageFunctionPython.itkHammingWindowFunction2_swiginit(self, _itkWindowedSincInterpolateImageFunctionPython.new_itkHammingWindowFunction2(*args))
itkHammingWindowFunction2.__call__ = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkHammingWindowFunction2___call__, None, itkHammingWindowFunction2)
itkHammingWindowFunction2_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkHammingWindowFunction2_swigregister
itkHammingWindowFunction2_swigregister(itkHammingWindowFunction2)

class itkHammingWindowFunction3(object):
    """Proxy of C++ itkHammingWindowFunction3 class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __call__(self, A: 'double const &') -> "double":
        """__call__(itkHammingWindowFunction3 self, double const & A) -> double"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkHammingWindowFunction3___call__(self, A)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkHammingWindowFunction3

    def __init__(self, *args):
        """
        __init__(itkHammingWindowFunction3 self) -> itkHammingWindowFunction3
        __init__(itkHammingWindowFunction3 self, itkHammingWindowFunction3 arg0) -> itkHammingWindowFunction3
        """
        _itkWindowedSincInterpolateImageFunctionPython.itkHammingWindowFunction3_swiginit(self, _itkWindowedSincInterpolateImageFunctionPython.new_itkHammingWindowFunction3(*args))
itkHammingWindowFunction3.__call__ = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkHammingWindowFunction3___call__, None, itkHammingWindowFunction3)
itkHammingWindowFunction3_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkHammingWindowFunction3_swigregister
itkHammingWindowFunction3_swigregister(itkHammingWindowFunction3)

class itkLanczosWindowFunction2(object):
    """Proxy of C++ itkLanczosWindowFunction2 class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __call__(self, A: 'double const &') -> "double":
        """__call__(itkLanczosWindowFunction2 self, double const & A) -> double"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkLanczosWindowFunction2___call__(self, A)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkLanczosWindowFunction2

    def __init__(self, *args):
        """
        __init__(itkLanczosWindowFunction2 self) -> itkLanczosWindowFunction2
        __init__(itkLanczosWindowFunction2 self, itkLanczosWindowFunction2 arg0) -> itkLanczosWindowFunction2
        """
        _itkWindowedSincInterpolateImageFunctionPython.itkLanczosWindowFunction2_swiginit(self, _itkWindowedSincInterpolateImageFunctionPython.new_itkLanczosWindowFunction2(*args))
itkLanczosWindowFunction2.__call__ = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkLanczosWindowFunction2___call__, None, itkLanczosWindowFunction2)
itkLanczosWindowFunction2_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkLanczosWindowFunction2_swigregister
itkLanczosWindowFunction2_swigregister(itkLanczosWindowFunction2)

class itkLanczosWindowFunction3(object):
    """Proxy of C++ itkLanczosWindowFunction3 class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __call__(self, A: 'double const &') -> "double":
        """__call__(itkLanczosWindowFunction3 self, double const & A) -> double"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkLanczosWindowFunction3___call__(self, A)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkLanczosWindowFunction3

    def __init__(self, *args):
        """
        __init__(itkLanczosWindowFunction3 self) -> itkLanczosWindowFunction3
        __init__(itkLanczosWindowFunction3 self, itkLanczosWindowFunction3 arg0) -> itkLanczosWindowFunction3
        """
        _itkWindowedSincInterpolateImageFunctionPython.itkLanczosWindowFunction3_swiginit(self, _itkWindowedSincInterpolateImageFunctionPython.new_itkLanczosWindowFunction3(*args))
itkLanczosWindowFunction3.__call__ = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkLanczosWindowFunction3___call__, None, itkLanczosWindowFunction3)
itkLanczosWindowFunction3_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkLanczosWindowFunction3_swigregister
itkLanczosWindowFunction3_swigregister(itkLanczosWindowFunction3)

class itkWelchWindowFunction2(object):
    """Proxy of C++ itkWelchWindowFunction2 class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __call__(self, A: 'double const &') -> "double":
        """__call__(itkWelchWindowFunction2 self, double const & A) -> double"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWelchWindowFunction2___call__(self, A)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWelchWindowFunction2

    def __init__(self, *args):
        """
        __init__(itkWelchWindowFunction2 self) -> itkWelchWindowFunction2
        __init__(itkWelchWindowFunction2 self, itkWelchWindowFunction2 arg0) -> itkWelchWindowFunction2
        """
        _itkWindowedSincInterpolateImageFunctionPython.itkWelchWindowFunction2_swiginit(self, _itkWindowedSincInterpolateImageFunctionPython.new_itkWelchWindowFunction2(*args))
itkWelchWindowFunction2.__call__ = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWelchWindowFunction2___call__, None, itkWelchWindowFunction2)
itkWelchWindowFunction2_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWelchWindowFunction2_swigregister
itkWelchWindowFunction2_swigregister(itkWelchWindowFunction2)

class itkWelchWindowFunction3(object):
    """Proxy of C++ itkWelchWindowFunction3 class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __call__(self, A: 'double const &') -> "double":
        """__call__(itkWelchWindowFunction3 self, double const & A) -> double"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWelchWindowFunction3___call__(self, A)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWelchWindowFunction3

    def __init__(self, *args):
        """
        __init__(itkWelchWindowFunction3 self) -> itkWelchWindowFunction3
        __init__(itkWelchWindowFunction3 self, itkWelchWindowFunction3 arg0) -> itkWelchWindowFunction3
        """
        _itkWindowedSincInterpolateImageFunctionPython.itkWelchWindowFunction3_swiginit(self, _itkWindowedSincInterpolateImageFunctionPython.new_itkWelchWindowFunction3(*args))
itkWelchWindowFunction3.__call__ = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWelchWindowFunction3___call__, None, itkWelchWindowFunction3)
itkWelchWindowFunction3_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWelchWindowFunction3_swigregister
itkWelchWindowFunction3_swigregister(itkWelchWindowFunction3)

class itkWindowedSincInterpolateImageFunctionID22Cosine(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionID2D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionID22Cosine_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionID22Cosine_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID22Cosine___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionID22Cosine_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionID22Cosine self) -> itkWindowedSincInterpolateImageFunctionID22Cosine_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID22Cosine_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionID22Cosine

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionID22Cosine *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionID22Cosine"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID22Cosine_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionID22Cosine

        Create a new object of the class itkWindowedSincInterpolateImageFunctionID22Cosine and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionID22Cosine.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionID22Cosine.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionID22Cosine.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionID22Cosine.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID22Cosine_Clone, None, itkWindowedSincInterpolateImageFunctionID22Cosine)
itkWindowedSincInterpolateImageFunctionID22Cosine_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID22Cosine_swigregister
itkWindowedSincInterpolateImageFunctionID22Cosine_swigregister(itkWindowedSincInterpolateImageFunctionID22Cosine)

def itkWindowedSincInterpolateImageFunctionID22Cosine___New_orig__() -> "itkWindowedSincInterpolateImageFunctionID22Cosine_Pointer":
    """itkWindowedSincInterpolateImageFunctionID22Cosine___New_orig__() -> itkWindowedSincInterpolateImageFunctionID22Cosine_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID22Cosine___New_orig__()

def itkWindowedSincInterpolateImageFunctionID22Cosine_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionID22Cosine *":
    """itkWindowedSincInterpolateImageFunctionID22Cosine_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionID22Cosine"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID22Cosine_cast(obj)

class itkWindowedSincInterpolateImageFunctionID22Hamming(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionID2D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionID22Hamming_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionID22Hamming_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID22Hamming___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionID22Hamming_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionID22Hamming self) -> itkWindowedSincInterpolateImageFunctionID22Hamming_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID22Hamming_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionID22Hamming

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionID22Hamming *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionID22Hamming"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID22Hamming_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionID22Hamming

        Create a new object of the class itkWindowedSincInterpolateImageFunctionID22Hamming and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionID22Hamming.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionID22Hamming.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionID22Hamming.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionID22Hamming.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID22Hamming_Clone, None, itkWindowedSincInterpolateImageFunctionID22Hamming)
itkWindowedSincInterpolateImageFunctionID22Hamming_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID22Hamming_swigregister
itkWindowedSincInterpolateImageFunctionID22Hamming_swigregister(itkWindowedSincInterpolateImageFunctionID22Hamming)

def itkWindowedSincInterpolateImageFunctionID22Hamming___New_orig__() -> "itkWindowedSincInterpolateImageFunctionID22Hamming_Pointer":
    """itkWindowedSincInterpolateImageFunctionID22Hamming___New_orig__() -> itkWindowedSincInterpolateImageFunctionID22Hamming_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID22Hamming___New_orig__()

def itkWindowedSincInterpolateImageFunctionID22Hamming_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionID22Hamming *":
    """itkWindowedSincInterpolateImageFunctionID22Hamming_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionID22Hamming"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID22Hamming_cast(obj)

class itkWindowedSincInterpolateImageFunctionID22Lanczos(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionID2D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionID22Lanczos_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionID22Lanczos_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID22Lanczos___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionID22Lanczos_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionID22Lanczos self) -> itkWindowedSincInterpolateImageFunctionID22Lanczos_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID22Lanczos_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionID22Lanczos

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionID22Lanczos *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionID22Lanczos"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID22Lanczos_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionID22Lanczos

        Create a new object of the class itkWindowedSincInterpolateImageFunctionID22Lanczos and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionID22Lanczos.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionID22Lanczos.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionID22Lanczos.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionID22Lanczos.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID22Lanczos_Clone, None, itkWindowedSincInterpolateImageFunctionID22Lanczos)
itkWindowedSincInterpolateImageFunctionID22Lanczos_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID22Lanczos_swigregister
itkWindowedSincInterpolateImageFunctionID22Lanczos_swigregister(itkWindowedSincInterpolateImageFunctionID22Lanczos)

def itkWindowedSincInterpolateImageFunctionID22Lanczos___New_orig__() -> "itkWindowedSincInterpolateImageFunctionID22Lanczos_Pointer":
    """itkWindowedSincInterpolateImageFunctionID22Lanczos___New_orig__() -> itkWindowedSincInterpolateImageFunctionID22Lanczos_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID22Lanczos___New_orig__()

def itkWindowedSincInterpolateImageFunctionID22Lanczos_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionID22Lanczos *":
    """itkWindowedSincInterpolateImageFunctionID22Lanczos_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionID22Lanczos"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID22Lanczos_cast(obj)

class itkWindowedSincInterpolateImageFunctionID22Welch(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionID2D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionID22Welch_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionID22Welch_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID22Welch___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionID22Welch_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionID22Welch self) -> itkWindowedSincInterpolateImageFunctionID22Welch_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID22Welch_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionID22Welch

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionID22Welch *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionID22Welch"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID22Welch_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionID22Welch

        Create a new object of the class itkWindowedSincInterpolateImageFunctionID22Welch and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionID22Welch.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionID22Welch.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionID22Welch.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionID22Welch.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID22Welch_Clone, None, itkWindowedSincInterpolateImageFunctionID22Welch)
itkWindowedSincInterpolateImageFunctionID22Welch_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID22Welch_swigregister
itkWindowedSincInterpolateImageFunctionID22Welch_swigregister(itkWindowedSincInterpolateImageFunctionID22Welch)

def itkWindowedSincInterpolateImageFunctionID22Welch___New_orig__() -> "itkWindowedSincInterpolateImageFunctionID22Welch_Pointer":
    """itkWindowedSincInterpolateImageFunctionID22Welch___New_orig__() -> itkWindowedSincInterpolateImageFunctionID22Welch_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID22Welch___New_orig__()

def itkWindowedSincInterpolateImageFunctionID22Welch_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionID22Welch *":
    """itkWindowedSincInterpolateImageFunctionID22Welch_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionID22Welch"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID22Welch_cast(obj)

class itkWindowedSincInterpolateImageFunctionID23Cosine(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionID2D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionID23Cosine_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionID23Cosine_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID23Cosine___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionID23Cosine_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionID23Cosine self) -> itkWindowedSincInterpolateImageFunctionID23Cosine_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID23Cosine_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionID23Cosine

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionID23Cosine *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionID23Cosine"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID23Cosine_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionID23Cosine

        Create a new object of the class itkWindowedSincInterpolateImageFunctionID23Cosine and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionID23Cosine.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionID23Cosine.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionID23Cosine.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionID23Cosine.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID23Cosine_Clone, None, itkWindowedSincInterpolateImageFunctionID23Cosine)
itkWindowedSincInterpolateImageFunctionID23Cosine_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID23Cosine_swigregister
itkWindowedSincInterpolateImageFunctionID23Cosine_swigregister(itkWindowedSincInterpolateImageFunctionID23Cosine)

def itkWindowedSincInterpolateImageFunctionID23Cosine___New_orig__() -> "itkWindowedSincInterpolateImageFunctionID23Cosine_Pointer":
    """itkWindowedSincInterpolateImageFunctionID23Cosine___New_orig__() -> itkWindowedSincInterpolateImageFunctionID23Cosine_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID23Cosine___New_orig__()

def itkWindowedSincInterpolateImageFunctionID23Cosine_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionID23Cosine *":
    """itkWindowedSincInterpolateImageFunctionID23Cosine_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionID23Cosine"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID23Cosine_cast(obj)

class itkWindowedSincInterpolateImageFunctionID23Hamming(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionID2D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionID23Hamming_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionID23Hamming_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID23Hamming___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionID23Hamming_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionID23Hamming self) -> itkWindowedSincInterpolateImageFunctionID23Hamming_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID23Hamming_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionID23Hamming

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionID23Hamming *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionID23Hamming"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID23Hamming_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionID23Hamming

        Create a new object of the class itkWindowedSincInterpolateImageFunctionID23Hamming and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionID23Hamming.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionID23Hamming.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionID23Hamming.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionID23Hamming.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID23Hamming_Clone, None, itkWindowedSincInterpolateImageFunctionID23Hamming)
itkWindowedSincInterpolateImageFunctionID23Hamming_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID23Hamming_swigregister
itkWindowedSincInterpolateImageFunctionID23Hamming_swigregister(itkWindowedSincInterpolateImageFunctionID23Hamming)

def itkWindowedSincInterpolateImageFunctionID23Hamming___New_orig__() -> "itkWindowedSincInterpolateImageFunctionID23Hamming_Pointer":
    """itkWindowedSincInterpolateImageFunctionID23Hamming___New_orig__() -> itkWindowedSincInterpolateImageFunctionID23Hamming_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID23Hamming___New_orig__()

def itkWindowedSincInterpolateImageFunctionID23Hamming_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionID23Hamming *":
    """itkWindowedSincInterpolateImageFunctionID23Hamming_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionID23Hamming"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID23Hamming_cast(obj)

class itkWindowedSincInterpolateImageFunctionID23Lanczos(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionID2D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionID23Lanczos_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionID23Lanczos_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID23Lanczos___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionID23Lanczos_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionID23Lanczos self) -> itkWindowedSincInterpolateImageFunctionID23Lanczos_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID23Lanczos_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionID23Lanczos

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionID23Lanczos *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionID23Lanczos"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID23Lanczos_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionID23Lanczos

        Create a new object of the class itkWindowedSincInterpolateImageFunctionID23Lanczos and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionID23Lanczos.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionID23Lanczos.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionID23Lanczos.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionID23Lanczos.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID23Lanczos_Clone, None, itkWindowedSincInterpolateImageFunctionID23Lanczos)
itkWindowedSincInterpolateImageFunctionID23Lanczos_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID23Lanczos_swigregister
itkWindowedSincInterpolateImageFunctionID23Lanczos_swigregister(itkWindowedSincInterpolateImageFunctionID23Lanczos)

def itkWindowedSincInterpolateImageFunctionID23Lanczos___New_orig__() -> "itkWindowedSincInterpolateImageFunctionID23Lanczos_Pointer":
    """itkWindowedSincInterpolateImageFunctionID23Lanczos___New_orig__() -> itkWindowedSincInterpolateImageFunctionID23Lanczos_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID23Lanczos___New_orig__()

def itkWindowedSincInterpolateImageFunctionID23Lanczos_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionID23Lanczos *":
    """itkWindowedSincInterpolateImageFunctionID23Lanczos_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionID23Lanczos"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID23Lanczos_cast(obj)

class itkWindowedSincInterpolateImageFunctionID23Welch(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionID2D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionID23Welch_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionID23Welch_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID23Welch___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionID23Welch_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionID23Welch self) -> itkWindowedSincInterpolateImageFunctionID23Welch_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID23Welch_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionID23Welch

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionID23Welch *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionID23Welch"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID23Welch_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionID23Welch

        Create a new object of the class itkWindowedSincInterpolateImageFunctionID23Welch and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionID23Welch.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionID23Welch.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionID23Welch.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionID23Welch.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID23Welch_Clone, None, itkWindowedSincInterpolateImageFunctionID23Welch)
itkWindowedSincInterpolateImageFunctionID23Welch_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID23Welch_swigregister
itkWindowedSincInterpolateImageFunctionID23Welch_swigregister(itkWindowedSincInterpolateImageFunctionID23Welch)

def itkWindowedSincInterpolateImageFunctionID23Welch___New_orig__() -> "itkWindowedSincInterpolateImageFunctionID23Welch_Pointer":
    """itkWindowedSincInterpolateImageFunctionID23Welch___New_orig__() -> itkWindowedSincInterpolateImageFunctionID23Welch_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID23Welch___New_orig__()

def itkWindowedSincInterpolateImageFunctionID23Welch_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionID23Welch *":
    """itkWindowedSincInterpolateImageFunctionID23Welch_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionID23Welch"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID23Welch_cast(obj)

class itkWindowedSincInterpolateImageFunctionID32Cosine(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionID3D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionID32Cosine_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionID32Cosine_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID32Cosine___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionID32Cosine_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionID32Cosine self) -> itkWindowedSincInterpolateImageFunctionID32Cosine_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID32Cosine_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionID32Cosine

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionID32Cosine *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionID32Cosine"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID32Cosine_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionID32Cosine

        Create a new object of the class itkWindowedSincInterpolateImageFunctionID32Cosine and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionID32Cosine.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionID32Cosine.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionID32Cosine.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionID32Cosine.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID32Cosine_Clone, None, itkWindowedSincInterpolateImageFunctionID32Cosine)
itkWindowedSincInterpolateImageFunctionID32Cosine_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID32Cosine_swigregister
itkWindowedSincInterpolateImageFunctionID32Cosine_swigregister(itkWindowedSincInterpolateImageFunctionID32Cosine)

def itkWindowedSincInterpolateImageFunctionID32Cosine___New_orig__() -> "itkWindowedSincInterpolateImageFunctionID32Cosine_Pointer":
    """itkWindowedSincInterpolateImageFunctionID32Cosine___New_orig__() -> itkWindowedSincInterpolateImageFunctionID32Cosine_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID32Cosine___New_orig__()

def itkWindowedSincInterpolateImageFunctionID32Cosine_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionID32Cosine *":
    """itkWindowedSincInterpolateImageFunctionID32Cosine_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionID32Cosine"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID32Cosine_cast(obj)

class itkWindowedSincInterpolateImageFunctionID32Hamming(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionID3D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionID32Hamming_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionID32Hamming_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID32Hamming___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionID32Hamming_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionID32Hamming self) -> itkWindowedSincInterpolateImageFunctionID32Hamming_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID32Hamming_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionID32Hamming

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionID32Hamming *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionID32Hamming"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID32Hamming_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionID32Hamming

        Create a new object of the class itkWindowedSincInterpolateImageFunctionID32Hamming and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionID32Hamming.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionID32Hamming.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionID32Hamming.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionID32Hamming.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID32Hamming_Clone, None, itkWindowedSincInterpolateImageFunctionID32Hamming)
itkWindowedSincInterpolateImageFunctionID32Hamming_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID32Hamming_swigregister
itkWindowedSincInterpolateImageFunctionID32Hamming_swigregister(itkWindowedSincInterpolateImageFunctionID32Hamming)

def itkWindowedSincInterpolateImageFunctionID32Hamming___New_orig__() -> "itkWindowedSincInterpolateImageFunctionID32Hamming_Pointer":
    """itkWindowedSincInterpolateImageFunctionID32Hamming___New_orig__() -> itkWindowedSincInterpolateImageFunctionID32Hamming_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID32Hamming___New_orig__()

def itkWindowedSincInterpolateImageFunctionID32Hamming_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionID32Hamming *":
    """itkWindowedSincInterpolateImageFunctionID32Hamming_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionID32Hamming"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID32Hamming_cast(obj)

class itkWindowedSincInterpolateImageFunctionID32Lanczos(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionID3D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionID32Lanczos_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionID32Lanczos_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID32Lanczos___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionID32Lanczos_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionID32Lanczos self) -> itkWindowedSincInterpolateImageFunctionID32Lanczos_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID32Lanczos_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionID32Lanczos

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionID32Lanczos *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionID32Lanczos"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID32Lanczos_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionID32Lanczos

        Create a new object of the class itkWindowedSincInterpolateImageFunctionID32Lanczos and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionID32Lanczos.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionID32Lanczos.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionID32Lanczos.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionID32Lanczos.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID32Lanczos_Clone, None, itkWindowedSincInterpolateImageFunctionID32Lanczos)
itkWindowedSincInterpolateImageFunctionID32Lanczos_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID32Lanczos_swigregister
itkWindowedSincInterpolateImageFunctionID32Lanczos_swigregister(itkWindowedSincInterpolateImageFunctionID32Lanczos)

def itkWindowedSincInterpolateImageFunctionID32Lanczos___New_orig__() -> "itkWindowedSincInterpolateImageFunctionID32Lanczos_Pointer":
    """itkWindowedSincInterpolateImageFunctionID32Lanczos___New_orig__() -> itkWindowedSincInterpolateImageFunctionID32Lanczos_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID32Lanczos___New_orig__()

def itkWindowedSincInterpolateImageFunctionID32Lanczos_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionID32Lanczos *":
    """itkWindowedSincInterpolateImageFunctionID32Lanczos_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionID32Lanczos"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID32Lanczos_cast(obj)

class itkWindowedSincInterpolateImageFunctionID32Welch(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionID3D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionID32Welch_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionID32Welch_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID32Welch___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionID32Welch_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionID32Welch self) -> itkWindowedSincInterpolateImageFunctionID32Welch_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID32Welch_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionID32Welch

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionID32Welch *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionID32Welch"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID32Welch_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionID32Welch

        Create a new object of the class itkWindowedSincInterpolateImageFunctionID32Welch and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionID32Welch.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionID32Welch.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionID32Welch.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionID32Welch.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID32Welch_Clone, None, itkWindowedSincInterpolateImageFunctionID32Welch)
itkWindowedSincInterpolateImageFunctionID32Welch_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID32Welch_swigregister
itkWindowedSincInterpolateImageFunctionID32Welch_swigregister(itkWindowedSincInterpolateImageFunctionID32Welch)

def itkWindowedSincInterpolateImageFunctionID32Welch___New_orig__() -> "itkWindowedSincInterpolateImageFunctionID32Welch_Pointer":
    """itkWindowedSincInterpolateImageFunctionID32Welch___New_orig__() -> itkWindowedSincInterpolateImageFunctionID32Welch_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID32Welch___New_orig__()

def itkWindowedSincInterpolateImageFunctionID32Welch_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionID32Welch *":
    """itkWindowedSincInterpolateImageFunctionID32Welch_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionID32Welch"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID32Welch_cast(obj)

class itkWindowedSincInterpolateImageFunctionID33Cosine(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionID3D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionID33Cosine_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionID33Cosine_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID33Cosine___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionID33Cosine_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionID33Cosine self) -> itkWindowedSincInterpolateImageFunctionID33Cosine_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID33Cosine_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionID33Cosine

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionID33Cosine *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionID33Cosine"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID33Cosine_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionID33Cosine

        Create a new object of the class itkWindowedSincInterpolateImageFunctionID33Cosine and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionID33Cosine.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionID33Cosine.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionID33Cosine.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionID33Cosine.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID33Cosine_Clone, None, itkWindowedSincInterpolateImageFunctionID33Cosine)
itkWindowedSincInterpolateImageFunctionID33Cosine_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID33Cosine_swigregister
itkWindowedSincInterpolateImageFunctionID33Cosine_swigregister(itkWindowedSincInterpolateImageFunctionID33Cosine)

def itkWindowedSincInterpolateImageFunctionID33Cosine___New_orig__() -> "itkWindowedSincInterpolateImageFunctionID33Cosine_Pointer":
    """itkWindowedSincInterpolateImageFunctionID33Cosine___New_orig__() -> itkWindowedSincInterpolateImageFunctionID33Cosine_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID33Cosine___New_orig__()

def itkWindowedSincInterpolateImageFunctionID33Cosine_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionID33Cosine *":
    """itkWindowedSincInterpolateImageFunctionID33Cosine_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionID33Cosine"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID33Cosine_cast(obj)

class itkWindowedSincInterpolateImageFunctionID33Hamming(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionID3D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionID33Hamming_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionID33Hamming_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID33Hamming___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionID33Hamming_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionID33Hamming self) -> itkWindowedSincInterpolateImageFunctionID33Hamming_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID33Hamming_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionID33Hamming

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionID33Hamming *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionID33Hamming"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID33Hamming_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionID33Hamming

        Create a new object of the class itkWindowedSincInterpolateImageFunctionID33Hamming and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionID33Hamming.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionID33Hamming.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionID33Hamming.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionID33Hamming.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID33Hamming_Clone, None, itkWindowedSincInterpolateImageFunctionID33Hamming)
itkWindowedSincInterpolateImageFunctionID33Hamming_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID33Hamming_swigregister
itkWindowedSincInterpolateImageFunctionID33Hamming_swigregister(itkWindowedSincInterpolateImageFunctionID33Hamming)

def itkWindowedSincInterpolateImageFunctionID33Hamming___New_orig__() -> "itkWindowedSincInterpolateImageFunctionID33Hamming_Pointer":
    """itkWindowedSincInterpolateImageFunctionID33Hamming___New_orig__() -> itkWindowedSincInterpolateImageFunctionID33Hamming_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID33Hamming___New_orig__()

def itkWindowedSincInterpolateImageFunctionID33Hamming_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionID33Hamming *":
    """itkWindowedSincInterpolateImageFunctionID33Hamming_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionID33Hamming"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID33Hamming_cast(obj)

class itkWindowedSincInterpolateImageFunctionID33Lanczos(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionID3D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionID33Lanczos_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionID33Lanczos_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID33Lanczos___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionID33Lanczos_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionID33Lanczos self) -> itkWindowedSincInterpolateImageFunctionID33Lanczos_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID33Lanczos_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionID33Lanczos

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionID33Lanczos *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionID33Lanczos"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID33Lanczos_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionID33Lanczos

        Create a new object of the class itkWindowedSincInterpolateImageFunctionID33Lanczos and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionID33Lanczos.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionID33Lanczos.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionID33Lanczos.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionID33Lanczos.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID33Lanczos_Clone, None, itkWindowedSincInterpolateImageFunctionID33Lanczos)
itkWindowedSincInterpolateImageFunctionID33Lanczos_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID33Lanczos_swigregister
itkWindowedSincInterpolateImageFunctionID33Lanczos_swigregister(itkWindowedSincInterpolateImageFunctionID33Lanczos)

def itkWindowedSincInterpolateImageFunctionID33Lanczos___New_orig__() -> "itkWindowedSincInterpolateImageFunctionID33Lanczos_Pointer":
    """itkWindowedSincInterpolateImageFunctionID33Lanczos___New_orig__() -> itkWindowedSincInterpolateImageFunctionID33Lanczos_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID33Lanczos___New_orig__()

def itkWindowedSincInterpolateImageFunctionID33Lanczos_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionID33Lanczos *":
    """itkWindowedSincInterpolateImageFunctionID33Lanczos_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionID33Lanczos"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID33Lanczos_cast(obj)

class itkWindowedSincInterpolateImageFunctionID33Welch(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionID3D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionID33Welch_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionID33Welch_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID33Welch___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionID33Welch_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionID33Welch self) -> itkWindowedSincInterpolateImageFunctionID33Welch_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID33Welch_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionID33Welch

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionID33Welch *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionID33Welch"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID33Welch_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionID33Welch

        Create a new object of the class itkWindowedSincInterpolateImageFunctionID33Welch and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionID33Welch.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionID33Welch.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionID33Welch.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionID33Welch.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID33Welch_Clone, None, itkWindowedSincInterpolateImageFunctionID33Welch)
itkWindowedSincInterpolateImageFunctionID33Welch_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID33Welch_swigregister
itkWindowedSincInterpolateImageFunctionID33Welch_swigregister(itkWindowedSincInterpolateImageFunctionID33Welch)

def itkWindowedSincInterpolateImageFunctionID33Welch___New_orig__() -> "itkWindowedSincInterpolateImageFunctionID33Welch_Pointer":
    """itkWindowedSincInterpolateImageFunctionID33Welch___New_orig__() -> itkWindowedSincInterpolateImageFunctionID33Welch_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID33Welch___New_orig__()

def itkWindowedSincInterpolateImageFunctionID33Welch_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionID33Welch *":
    """itkWindowedSincInterpolateImageFunctionID33Welch_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionID33Welch"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID33Welch_cast(obj)

class itkWindowedSincInterpolateImageFunctionIF22Cosine(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIF2D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionIF22Cosine_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionIF22Cosine_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF22Cosine___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionIF22Cosine_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionIF22Cosine self) -> itkWindowedSincInterpolateImageFunctionIF22Cosine_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF22Cosine_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIF22Cosine

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIF22Cosine *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIF22Cosine"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF22Cosine_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIF22Cosine

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIF22Cosine and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIF22Cosine.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIF22Cosine.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionIF22Cosine.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionIF22Cosine.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF22Cosine_Clone, None, itkWindowedSincInterpolateImageFunctionIF22Cosine)
itkWindowedSincInterpolateImageFunctionIF22Cosine_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF22Cosine_swigregister
itkWindowedSincInterpolateImageFunctionIF22Cosine_swigregister(itkWindowedSincInterpolateImageFunctionIF22Cosine)

def itkWindowedSincInterpolateImageFunctionIF22Cosine___New_orig__() -> "itkWindowedSincInterpolateImageFunctionIF22Cosine_Pointer":
    """itkWindowedSincInterpolateImageFunctionIF22Cosine___New_orig__() -> itkWindowedSincInterpolateImageFunctionIF22Cosine_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF22Cosine___New_orig__()

def itkWindowedSincInterpolateImageFunctionIF22Cosine_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIF22Cosine *":
    """itkWindowedSincInterpolateImageFunctionIF22Cosine_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIF22Cosine"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF22Cosine_cast(obj)

class itkWindowedSincInterpolateImageFunctionIF22Hamming(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIF2D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionIF22Hamming_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionIF22Hamming_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF22Hamming___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionIF22Hamming_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionIF22Hamming self) -> itkWindowedSincInterpolateImageFunctionIF22Hamming_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF22Hamming_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIF22Hamming

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIF22Hamming *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIF22Hamming"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF22Hamming_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIF22Hamming

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIF22Hamming and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIF22Hamming.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIF22Hamming.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionIF22Hamming.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionIF22Hamming.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF22Hamming_Clone, None, itkWindowedSincInterpolateImageFunctionIF22Hamming)
itkWindowedSincInterpolateImageFunctionIF22Hamming_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF22Hamming_swigregister
itkWindowedSincInterpolateImageFunctionIF22Hamming_swigregister(itkWindowedSincInterpolateImageFunctionIF22Hamming)

def itkWindowedSincInterpolateImageFunctionIF22Hamming___New_orig__() -> "itkWindowedSincInterpolateImageFunctionIF22Hamming_Pointer":
    """itkWindowedSincInterpolateImageFunctionIF22Hamming___New_orig__() -> itkWindowedSincInterpolateImageFunctionIF22Hamming_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF22Hamming___New_orig__()

def itkWindowedSincInterpolateImageFunctionIF22Hamming_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIF22Hamming *":
    """itkWindowedSincInterpolateImageFunctionIF22Hamming_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIF22Hamming"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF22Hamming_cast(obj)

class itkWindowedSincInterpolateImageFunctionIF22Lanczos(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIF2D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionIF22Lanczos_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionIF22Lanczos_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF22Lanczos___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionIF22Lanczos_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionIF22Lanczos self) -> itkWindowedSincInterpolateImageFunctionIF22Lanczos_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF22Lanczos_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIF22Lanczos

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIF22Lanczos *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIF22Lanczos"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF22Lanczos_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIF22Lanczos

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIF22Lanczos and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIF22Lanczos.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIF22Lanczos.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionIF22Lanczos.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionIF22Lanczos.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF22Lanczos_Clone, None, itkWindowedSincInterpolateImageFunctionIF22Lanczos)
itkWindowedSincInterpolateImageFunctionIF22Lanczos_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF22Lanczos_swigregister
itkWindowedSincInterpolateImageFunctionIF22Lanczos_swigregister(itkWindowedSincInterpolateImageFunctionIF22Lanczos)

def itkWindowedSincInterpolateImageFunctionIF22Lanczos___New_orig__() -> "itkWindowedSincInterpolateImageFunctionIF22Lanczos_Pointer":
    """itkWindowedSincInterpolateImageFunctionIF22Lanczos___New_orig__() -> itkWindowedSincInterpolateImageFunctionIF22Lanczos_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF22Lanczos___New_orig__()

def itkWindowedSincInterpolateImageFunctionIF22Lanczos_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIF22Lanczos *":
    """itkWindowedSincInterpolateImageFunctionIF22Lanczos_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIF22Lanczos"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF22Lanczos_cast(obj)

class itkWindowedSincInterpolateImageFunctionIF22Welch(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIF2D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionIF22Welch_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionIF22Welch_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF22Welch___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionIF22Welch_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionIF22Welch self) -> itkWindowedSincInterpolateImageFunctionIF22Welch_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF22Welch_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIF22Welch

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIF22Welch *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIF22Welch"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF22Welch_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIF22Welch

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIF22Welch and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIF22Welch.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIF22Welch.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionIF22Welch.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionIF22Welch.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF22Welch_Clone, None, itkWindowedSincInterpolateImageFunctionIF22Welch)
itkWindowedSincInterpolateImageFunctionIF22Welch_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF22Welch_swigregister
itkWindowedSincInterpolateImageFunctionIF22Welch_swigregister(itkWindowedSincInterpolateImageFunctionIF22Welch)

def itkWindowedSincInterpolateImageFunctionIF22Welch___New_orig__() -> "itkWindowedSincInterpolateImageFunctionIF22Welch_Pointer":
    """itkWindowedSincInterpolateImageFunctionIF22Welch___New_orig__() -> itkWindowedSincInterpolateImageFunctionIF22Welch_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF22Welch___New_orig__()

def itkWindowedSincInterpolateImageFunctionIF22Welch_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIF22Welch *":
    """itkWindowedSincInterpolateImageFunctionIF22Welch_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIF22Welch"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF22Welch_cast(obj)

class itkWindowedSincInterpolateImageFunctionIF23Cosine(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIF2D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionIF23Cosine_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionIF23Cosine_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF23Cosine___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionIF23Cosine_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionIF23Cosine self) -> itkWindowedSincInterpolateImageFunctionIF23Cosine_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF23Cosine_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIF23Cosine

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIF23Cosine *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIF23Cosine"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF23Cosine_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIF23Cosine

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIF23Cosine and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIF23Cosine.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIF23Cosine.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionIF23Cosine.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionIF23Cosine.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF23Cosine_Clone, None, itkWindowedSincInterpolateImageFunctionIF23Cosine)
itkWindowedSincInterpolateImageFunctionIF23Cosine_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF23Cosine_swigregister
itkWindowedSincInterpolateImageFunctionIF23Cosine_swigregister(itkWindowedSincInterpolateImageFunctionIF23Cosine)

def itkWindowedSincInterpolateImageFunctionIF23Cosine___New_orig__() -> "itkWindowedSincInterpolateImageFunctionIF23Cosine_Pointer":
    """itkWindowedSincInterpolateImageFunctionIF23Cosine___New_orig__() -> itkWindowedSincInterpolateImageFunctionIF23Cosine_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF23Cosine___New_orig__()

def itkWindowedSincInterpolateImageFunctionIF23Cosine_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIF23Cosine *":
    """itkWindowedSincInterpolateImageFunctionIF23Cosine_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIF23Cosine"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF23Cosine_cast(obj)

class itkWindowedSincInterpolateImageFunctionIF23Hamming(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIF2D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionIF23Hamming_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionIF23Hamming_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF23Hamming___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionIF23Hamming_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionIF23Hamming self) -> itkWindowedSincInterpolateImageFunctionIF23Hamming_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF23Hamming_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIF23Hamming

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIF23Hamming *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIF23Hamming"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF23Hamming_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIF23Hamming

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIF23Hamming and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIF23Hamming.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIF23Hamming.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionIF23Hamming.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionIF23Hamming.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF23Hamming_Clone, None, itkWindowedSincInterpolateImageFunctionIF23Hamming)
itkWindowedSincInterpolateImageFunctionIF23Hamming_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF23Hamming_swigregister
itkWindowedSincInterpolateImageFunctionIF23Hamming_swigregister(itkWindowedSincInterpolateImageFunctionIF23Hamming)

def itkWindowedSincInterpolateImageFunctionIF23Hamming___New_orig__() -> "itkWindowedSincInterpolateImageFunctionIF23Hamming_Pointer":
    """itkWindowedSincInterpolateImageFunctionIF23Hamming___New_orig__() -> itkWindowedSincInterpolateImageFunctionIF23Hamming_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF23Hamming___New_orig__()

def itkWindowedSincInterpolateImageFunctionIF23Hamming_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIF23Hamming *":
    """itkWindowedSincInterpolateImageFunctionIF23Hamming_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIF23Hamming"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF23Hamming_cast(obj)

class itkWindowedSincInterpolateImageFunctionIF23Lanczos(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIF2D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionIF23Lanczos_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionIF23Lanczos_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF23Lanczos___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionIF23Lanczos_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionIF23Lanczos self) -> itkWindowedSincInterpolateImageFunctionIF23Lanczos_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF23Lanczos_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIF23Lanczos

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIF23Lanczos *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIF23Lanczos"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF23Lanczos_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIF23Lanczos

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIF23Lanczos and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIF23Lanczos.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIF23Lanczos.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionIF23Lanczos.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionIF23Lanczos.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF23Lanczos_Clone, None, itkWindowedSincInterpolateImageFunctionIF23Lanczos)
itkWindowedSincInterpolateImageFunctionIF23Lanczos_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF23Lanczos_swigregister
itkWindowedSincInterpolateImageFunctionIF23Lanczos_swigregister(itkWindowedSincInterpolateImageFunctionIF23Lanczos)

def itkWindowedSincInterpolateImageFunctionIF23Lanczos___New_orig__() -> "itkWindowedSincInterpolateImageFunctionIF23Lanczos_Pointer":
    """itkWindowedSincInterpolateImageFunctionIF23Lanczos___New_orig__() -> itkWindowedSincInterpolateImageFunctionIF23Lanczos_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF23Lanczos___New_orig__()

def itkWindowedSincInterpolateImageFunctionIF23Lanczos_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIF23Lanczos *":
    """itkWindowedSincInterpolateImageFunctionIF23Lanczos_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIF23Lanczos"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF23Lanczos_cast(obj)

class itkWindowedSincInterpolateImageFunctionIF23Welch(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIF2D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionIF23Welch_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionIF23Welch_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF23Welch___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionIF23Welch_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionIF23Welch self) -> itkWindowedSincInterpolateImageFunctionIF23Welch_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF23Welch_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIF23Welch

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIF23Welch *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIF23Welch"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF23Welch_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIF23Welch

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIF23Welch and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIF23Welch.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIF23Welch.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionIF23Welch.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionIF23Welch.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF23Welch_Clone, None, itkWindowedSincInterpolateImageFunctionIF23Welch)
itkWindowedSincInterpolateImageFunctionIF23Welch_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF23Welch_swigregister
itkWindowedSincInterpolateImageFunctionIF23Welch_swigregister(itkWindowedSincInterpolateImageFunctionIF23Welch)

def itkWindowedSincInterpolateImageFunctionIF23Welch___New_orig__() -> "itkWindowedSincInterpolateImageFunctionIF23Welch_Pointer":
    """itkWindowedSincInterpolateImageFunctionIF23Welch___New_orig__() -> itkWindowedSincInterpolateImageFunctionIF23Welch_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF23Welch___New_orig__()

def itkWindowedSincInterpolateImageFunctionIF23Welch_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIF23Welch *":
    """itkWindowedSincInterpolateImageFunctionIF23Welch_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIF23Welch"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF23Welch_cast(obj)

class itkWindowedSincInterpolateImageFunctionIF32Cosine(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIF3D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionIF32Cosine_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionIF32Cosine_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF32Cosine___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionIF32Cosine_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionIF32Cosine self) -> itkWindowedSincInterpolateImageFunctionIF32Cosine_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF32Cosine_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIF32Cosine

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIF32Cosine *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIF32Cosine"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF32Cosine_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIF32Cosine

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIF32Cosine and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIF32Cosine.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIF32Cosine.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionIF32Cosine.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionIF32Cosine.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF32Cosine_Clone, None, itkWindowedSincInterpolateImageFunctionIF32Cosine)
itkWindowedSincInterpolateImageFunctionIF32Cosine_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF32Cosine_swigregister
itkWindowedSincInterpolateImageFunctionIF32Cosine_swigregister(itkWindowedSincInterpolateImageFunctionIF32Cosine)

def itkWindowedSincInterpolateImageFunctionIF32Cosine___New_orig__() -> "itkWindowedSincInterpolateImageFunctionIF32Cosine_Pointer":
    """itkWindowedSincInterpolateImageFunctionIF32Cosine___New_orig__() -> itkWindowedSincInterpolateImageFunctionIF32Cosine_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF32Cosine___New_orig__()

def itkWindowedSincInterpolateImageFunctionIF32Cosine_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIF32Cosine *":
    """itkWindowedSincInterpolateImageFunctionIF32Cosine_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIF32Cosine"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF32Cosine_cast(obj)

class itkWindowedSincInterpolateImageFunctionIF32Hamming(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIF3D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionIF32Hamming_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionIF32Hamming_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF32Hamming___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionIF32Hamming_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionIF32Hamming self) -> itkWindowedSincInterpolateImageFunctionIF32Hamming_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF32Hamming_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIF32Hamming

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIF32Hamming *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIF32Hamming"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF32Hamming_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIF32Hamming

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIF32Hamming and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIF32Hamming.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIF32Hamming.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionIF32Hamming.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionIF32Hamming.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF32Hamming_Clone, None, itkWindowedSincInterpolateImageFunctionIF32Hamming)
itkWindowedSincInterpolateImageFunctionIF32Hamming_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF32Hamming_swigregister
itkWindowedSincInterpolateImageFunctionIF32Hamming_swigregister(itkWindowedSincInterpolateImageFunctionIF32Hamming)

def itkWindowedSincInterpolateImageFunctionIF32Hamming___New_orig__() -> "itkWindowedSincInterpolateImageFunctionIF32Hamming_Pointer":
    """itkWindowedSincInterpolateImageFunctionIF32Hamming___New_orig__() -> itkWindowedSincInterpolateImageFunctionIF32Hamming_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF32Hamming___New_orig__()

def itkWindowedSincInterpolateImageFunctionIF32Hamming_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIF32Hamming *":
    """itkWindowedSincInterpolateImageFunctionIF32Hamming_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIF32Hamming"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF32Hamming_cast(obj)

class itkWindowedSincInterpolateImageFunctionIF32Lanczos(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIF3D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionIF32Lanczos_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionIF32Lanczos_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF32Lanczos___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionIF32Lanczos_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionIF32Lanczos self) -> itkWindowedSincInterpolateImageFunctionIF32Lanczos_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF32Lanczos_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIF32Lanczos

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIF32Lanczos *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIF32Lanczos"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF32Lanczos_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIF32Lanczos

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIF32Lanczos and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIF32Lanczos.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIF32Lanczos.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionIF32Lanczos.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionIF32Lanczos.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF32Lanczos_Clone, None, itkWindowedSincInterpolateImageFunctionIF32Lanczos)
itkWindowedSincInterpolateImageFunctionIF32Lanczos_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF32Lanczos_swigregister
itkWindowedSincInterpolateImageFunctionIF32Lanczos_swigregister(itkWindowedSincInterpolateImageFunctionIF32Lanczos)

def itkWindowedSincInterpolateImageFunctionIF32Lanczos___New_orig__() -> "itkWindowedSincInterpolateImageFunctionIF32Lanczos_Pointer":
    """itkWindowedSincInterpolateImageFunctionIF32Lanczos___New_orig__() -> itkWindowedSincInterpolateImageFunctionIF32Lanczos_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF32Lanczos___New_orig__()

def itkWindowedSincInterpolateImageFunctionIF32Lanczos_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIF32Lanczos *":
    """itkWindowedSincInterpolateImageFunctionIF32Lanczos_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIF32Lanczos"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF32Lanczos_cast(obj)

class itkWindowedSincInterpolateImageFunctionIF32Welch(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIF3D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionIF32Welch_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionIF32Welch_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF32Welch___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionIF32Welch_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionIF32Welch self) -> itkWindowedSincInterpolateImageFunctionIF32Welch_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF32Welch_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIF32Welch

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIF32Welch *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIF32Welch"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF32Welch_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIF32Welch

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIF32Welch and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIF32Welch.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIF32Welch.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionIF32Welch.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionIF32Welch.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF32Welch_Clone, None, itkWindowedSincInterpolateImageFunctionIF32Welch)
itkWindowedSincInterpolateImageFunctionIF32Welch_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF32Welch_swigregister
itkWindowedSincInterpolateImageFunctionIF32Welch_swigregister(itkWindowedSincInterpolateImageFunctionIF32Welch)

def itkWindowedSincInterpolateImageFunctionIF32Welch___New_orig__() -> "itkWindowedSincInterpolateImageFunctionIF32Welch_Pointer":
    """itkWindowedSincInterpolateImageFunctionIF32Welch___New_orig__() -> itkWindowedSincInterpolateImageFunctionIF32Welch_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF32Welch___New_orig__()

def itkWindowedSincInterpolateImageFunctionIF32Welch_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIF32Welch *":
    """itkWindowedSincInterpolateImageFunctionIF32Welch_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIF32Welch"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF32Welch_cast(obj)

class itkWindowedSincInterpolateImageFunctionIF33Cosine(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIF3D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionIF33Cosine_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionIF33Cosine_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF33Cosine___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionIF33Cosine_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionIF33Cosine self) -> itkWindowedSincInterpolateImageFunctionIF33Cosine_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF33Cosine_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIF33Cosine

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIF33Cosine *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIF33Cosine"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF33Cosine_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIF33Cosine

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIF33Cosine and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIF33Cosine.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIF33Cosine.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionIF33Cosine.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionIF33Cosine.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF33Cosine_Clone, None, itkWindowedSincInterpolateImageFunctionIF33Cosine)
itkWindowedSincInterpolateImageFunctionIF33Cosine_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF33Cosine_swigregister
itkWindowedSincInterpolateImageFunctionIF33Cosine_swigregister(itkWindowedSincInterpolateImageFunctionIF33Cosine)

def itkWindowedSincInterpolateImageFunctionIF33Cosine___New_orig__() -> "itkWindowedSincInterpolateImageFunctionIF33Cosine_Pointer":
    """itkWindowedSincInterpolateImageFunctionIF33Cosine___New_orig__() -> itkWindowedSincInterpolateImageFunctionIF33Cosine_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF33Cosine___New_orig__()

def itkWindowedSincInterpolateImageFunctionIF33Cosine_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIF33Cosine *":
    """itkWindowedSincInterpolateImageFunctionIF33Cosine_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIF33Cosine"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF33Cosine_cast(obj)

class itkWindowedSincInterpolateImageFunctionIF33Hamming(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIF3D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionIF33Hamming_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionIF33Hamming_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF33Hamming___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionIF33Hamming_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionIF33Hamming self) -> itkWindowedSincInterpolateImageFunctionIF33Hamming_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF33Hamming_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIF33Hamming

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIF33Hamming *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIF33Hamming"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF33Hamming_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIF33Hamming

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIF33Hamming and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIF33Hamming.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIF33Hamming.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionIF33Hamming.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionIF33Hamming.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF33Hamming_Clone, None, itkWindowedSincInterpolateImageFunctionIF33Hamming)
itkWindowedSincInterpolateImageFunctionIF33Hamming_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF33Hamming_swigregister
itkWindowedSincInterpolateImageFunctionIF33Hamming_swigregister(itkWindowedSincInterpolateImageFunctionIF33Hamming)

def itkWindowedSincInterpolateImageFunctionIF33Hamming___New_orig__() -> "itkWindowedSincInterpolateImageFunctionIF33Hamming_Pointer":
    """itkWindowedSincInterpolateImageFunctionIF33Hamming___New_orig__() -> itkWindowedSincInterpolateImageFunctionIF33Hamming_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF33Hamming___New_orig__()

def itkWindowedSincInterpolateImageFunctionIF33Hamming_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIF33Hamming *":
    """itkWindowedSincInterpolateImageFunctionIF33Hamming_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIF33Hamming"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF33Hamming_cast(obj)

class itkWindowedSincInterpolateImageFunctionIF33Lanczos(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIF3D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionIF33Lanczos_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionIF33Lanczos_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF33Lanczos___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionIF33Lanczos_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionIF33Lanczos self) -> itkWindowedSincInterpolateImageFunctionIF33Lanczos_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF33Lanczos_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIF33Lanczos

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIF33Lanczos *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIF33Lanczos"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF33Lanczos_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIF33Lanczos

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIF33Lanczos and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIF33Lanczos.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIF33Lanczos.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionIF33Lanczos.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionIF33Lanczos.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF33Lanczos_Clone, None, itkWindowedSincInterpolateImageFunctionIF33Lanczos)
itkWindowedSincInterpolateImageFunctionIF33Lanczos_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF33Lanczos_swigregister
itkWindowedSincInterpolateImageFunctionIF33Lanczos_swigregister(itkWindowedSincInterpolateImageFunctionIF33Lanczos)

def itkWindowedSincInterpolateImageFunctionIF33Lanczos___New_orig__() -> "itkWindowedSincInterpolateImageFunctionIF33Lanczos_Pointer":
    """itkWindowedSincInterpolateImageFunctionIF33Lanczos___New_orig__() -> itkWindowedSincInterpolateImageFunctionIF33Lanczos_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF33Lanczos___New_orig__()

def itkWindowedSincInterpolateImageFunctionIF33Lanczos_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIF33Lanczos *":
    """itkWindowedSincInterpolateImageFunctionIF33Lanczos_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIF33Lanczos"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF33Lanczos_cast(obj)

class itkWindowedSincInterpolateImageFunctionIF33Welch(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIF3D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionIF33Welch_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionIF33Welch_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF33Welch___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionIF33Welch_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionIF33Welch self) -> itkWindowedSincInterpolateImageFunctionIF33Welch_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF33Welch_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIF33Welch

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIF33Welch *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIF33Welch"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF33Welch_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIF33Welch

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIF33Welch and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIF33Welch.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIF33Welch.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionIF33Welch.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionIF33Welch.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF33Welch_Clone, None, itkWindowedSincInterpolateImageFunctionIF33Welch)
itkWindowedSincInterpolateImageFunctionIF33Welch_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF33Welch_swigregister
itkWindowedSincInterpolateImageFunctionIF33Welch_swigregister(itkWindowedSincInterpolateImageFunctionIF33Welch)

def itkWindowedSincInterpolateImageFunctionIF33Welch___New_orig__() -> "itkWindowedSincInterpolateImageFunctionIF33Welch_Pointer":
    """itkWindowedSincInterpolateImageFunctionIF33Welch___New_orig__() -> itkWindowedSincInterpolateImageFunctionIF33Welch_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF33Welch___New_orig__()

def itkWindowedSincInterpolateImageFunctionIF33Welch_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIF33Welch *":
    """itkWindowedSincInterpolateImageFunctionIF33Welch_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIF33Welch"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF33Welch_cast(obj)

class itkWindowedSincInterpolateImageFunctionISS22Cosine(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionISS2D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionISS22Cosine_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionISS22Cosine_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS22Cosine___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionISS22Cosine_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionISS22Cosine self) -> itkWindowedSincInterpolateImageFunctionISS22Cosine_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS22Cosine_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionISS22Cosine

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionISS22Cosine *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionISS22Cosine"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS22Cosine_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionISS22Cosine

        Create a new object of the class itkWindowedSincInterpolateImageFunctionISS22Cosine and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionISS22Cosine.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionISS22Cosine.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionISS22Cosine.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionISS22Cosine.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS22Cosine_Clone, None, itkWindowedSincInterpolateImageFunctionISS22Cosine)
itkWindowedSincInterpolateImageFunctionISS22Cosine_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS22Cosine_swigregister
itkWindowedSincInterpolateImageFunctionISS22Cosine_swigregister(itkWindowedSincInterpolateImageFunctionISS22Cosine)

def itkWindowedSincInterpolateImageFunctionISS22Cosine___New_orig__() -> "itkWindowedSincInterpolateImageFunctionISS22Cosine_Pointer":
    """itkWindowedSincInterpolateImageFunctionISS22Cosine___New_orig__() -> itkWindowedSincInterpolateImageFunctionISS22Cosine_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS22Cosine___New_orig__()

def itkWindowedSincInterpolateImageFunctionISS22Cosine_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionISS22Cosine *":
    """itkWindowedSincInterpolateImageFunctionISS22Cosine_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionISS22Cosine"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS22Cosine_cast(obj)

class itkWindowedSincInterpolateImageFunctionISS22Hamming(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionISS2D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionISS22Hamming_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionISS22Hamming_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS22Hamming___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionISS22Hamming_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionISS22Hamming self) -> itkWindowedSincInterpolateImageFunctionISS22Hamming_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS22Hamming_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionISS22Hamming

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionISS22Hamming *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionISS22Hamming"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS22Hamming_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionISS22Hamming

        Create a new object of the class itkWindowedSincInterpolateImageFunctionISS22Hamming and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionISS22Hamming.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionISS22Hamming.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionISS22Hamming.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionISS22Hamming.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS22Hamming_Clone, None, itkWindowedSincInterpolateImageFunctionISS22Hamming)
itkWindowedSincInterpolateImageFunctionISS22Hamming_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS22Hamming_swigregister
itkWindowedSincInterpolateImageFunctionISS22Hamming_swigregister(itkWindowedSincInterpolateImageFunctionISS22Hamming)

def itkWindowedSincInterpolateImageFunctionISS22Hamming___New_orig__() -> "itkWindowedSincInterpolateImageFunctionISS22Hamming_Pointer":
    """itkWindowedSincInterpolateImageFunctionISS22Hamming___New_orig__() -> itkWindowedSincInterpolateImageFunctionISS22Hamming_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS22Hamming___New_orig__()

def itkWindowedSincInterpolateImageFunctionISS22Hamming_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionISS22Hamming *":
    """itkWindowedSincInterpolateImageFunctionISS22Hamming_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionISS22Hamming"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS22Hamming_cast(obj)

class itkWindowedSincInterpolateImageFunctionISS22Lanczos(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionISS2D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionISS22Lanczos_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionISS22Lanczos_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS22Lanczos___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionISS22Lanczos_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionISS22Lanczos self) -> itkWindowedSincInterpolateImageFunctionISS22Lanczos_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS22Lanczos_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionISS22Lanczos

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionISS22Lanczos *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionISS22Lanczos"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS22Lanczos_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionISS22Lanczos

        Create a new object of the class itkWindowedSincInterpolateImageFunctionISS22Lanczos and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionISS22Lanczos.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionISS22Lanczos.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionISS22Lanczos.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionISS22Lanczos.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS22Lanczos_Clone, None, itkWindowedSincInterpolateImageFunctionISS22Lanczos)
itkWindowedSincInterpolateImageFunctionISS22Lanczos_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS22Lanczos_swigregister
itkWindowedSincInterpolateImageFunctionISS22Lanczos_swigregister(itkWindowedSincInterpolateImageFunctionISS22Lanczos)

def itkWindowedSincInterpolateImageFunctionISS22Lanczos___New_orig__() -> "itkWindowedSincInterpolateImageFunctionISS22Lanczos_Pointer":
    """itkWindowedSincInterpolateImageFunctionISS22Lanczos___New_orig__() -> itkWindowedSincInterpolateImageFunctionISS22Lanczos_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS22Lanczos___New_orig__()

def itkWindowedSincInterpolateImageFunctionISS22Lanczos_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionISS22Lanczos *":
    """itkWindowedSincInterpolateImageFunctionISS22Lanczos_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionISS22Lanczos"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS22Lanczos_cast(obj)

class itkWindowedSincInterpolateImageFunctionISS22Welch(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionISS2D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionISS22Welch_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionISS22Welch_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS22Welch___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionISS22Welch_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionISS22Welch self) -> itkWindowedSincInterpolateImageFunctionISS22Welch_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS22Welch_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionISS22Welch

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionISS22Welch *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionISS22Welch"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS22Welch_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionISS22Welch

        Create a new object of the class itkWindowedSincInterpolateImageFunctionISS22Welch and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionISS22Welch.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionISS22Welch.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionISS22Welch.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionISS22Welch.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS22Welch_Clone, None, itkWindowedSincInterpolateImageFunctionISS22Welch)
itkWindowedSincInterpolateImageFunctionISS22Welch_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS22Welch_swigregister
itkWindowedSincInterpolateImageFunctionISS22Welch_swigregister(itkWindowedSincInterpolateImageFunctionISS22Welch)

def itkWindowedSincInterpolateImageFunctionISS22Welch___New_orig__() -> "itkWindowedSincInterpolateImageFunctionISS22Welch_Pointer":
    """itkWindowedSincInterpolateImageFunctionISS22Welch___New_orig__() -> itkWindowedSincInterpolateImageFunctionISS22Welch_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS22Welch___New_orig__()

def itkWindowedSincInterpolateImageFunctionISS22Welch_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionISS22Welch *":
    """itkWindowedSincInterpolateImageFunctionISS22Welch_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionISS22Welch"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS22Welch_cast(obj)

class itkWindowedSincInterpolateImageFunctionISS23Cosine(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionISS2D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionISS23Cosine_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionISS23Cosine_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS23Cosine___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionISS23Cosine_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionISS23Cosine self) -> itkWindowedSincInterpolateImageFunctionISS23Cosine_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS23Cosine_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionISS23Cosine

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionISS23Cosine *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionISS23Cosine"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS23Cosine_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionISS23Cosine

        Create a new object of the class itkWindowedSincInterpolateImageFunctionISS23Cosine and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionISS23Cosine.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionISS23Cosine.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionISS23Cosine.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionISS23Cosine.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS23Cosine_Clone, None, itkWindowedSincInterpolateImageFunctionISS23Cosine)
itkWindowedSincInterpolateImageFunctionISS23Cosine_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS23Cosine_swigregister
itkWindowedSincInterpolateImageFunctionISS23Cosine_swigregister(itkWindowedSincInterpolateImageFunctionISS23Cosine)

def itkWindowedSincInterpolateImageFunctionISS23Cosine___New_orig__() -> "itkWindowedSincInterpolateImageFunctionISS23Cosine_Pointer":
    """itkWindowedSincInterpolateImageFunctionISS23Cosine___New_orig__() -> itkWindowedSincInterpolateImageFunctionISS23Cosine_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS23Cosine___New_orig__()

def itkWindowedSincInterpolateImageFunctionISS23Cosine_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionISS23Cosine *":
    """itkWindowedSincInterpolateImageFunctionISS23Cosine_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionISS23Cosine"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS23Cosine_cast(obj)

class itkWindowedSincInterpolateImageFunctionISS23Hamming(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionISS2D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionISS23Hamming_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionISS23Hamming_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS23Hamming___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionISS23Hamming_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionISS23Hamming self) -> itkWindowedSincInterpolateImageFunctionISS23Hamming_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS23Hamming_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionISS23Hamming

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionISS23Hamming *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionISS23Hamming"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS23Hamming_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionISS23Hamming

        Create a new object of the class itkWindowedSincInterpolateImageFunctionISS23Hamming and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionISS23Hamming.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionISS23Hamming.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionISS23Hamming.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionISS23Hamming.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS23Hamming_Clone, None, itkWindowedSincInterpolateImageFunctionISS23Hamming)
itkWindowedSincInterpolateImageFunctionISS23Hamming_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS23Hamming_swigregister
itkWindowedSincInterpolateImageFunctionISS23Hamming_swigregister(itkWindowedSincInterpolateImageFunctionISS23Hamming)

def itkWindowedSincInterpolateImageFunctionISS23Hamming___New_orig__() -> "itkWindowedSincInterpolateImageFunctionISS23Hamming_Pointer":
    """itkWindowedSincInterpolateImageFunctionISS23Hamming___New_orig__() -> itkWindowedSincInterpolateImageFunctionISS23Hamming_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS23Hamming___New_orig__()

def itkWindowedSincInterpolateImageFunctionISS23Hamming_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionISS23Hamming *":
    """itkWindowedSincInterpolateImageFunctionISS23Hamming_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionISS23Hamming"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS23Hamming_cast(obj)

class itkWindowedSincInterpolateImageFunctionISS23Lanczos(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionISS2D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionISS23Lanczos_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionISS23Lanczos_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS23Lanczos___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionISS23Lanczos_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionISS23Lanczos self) -> itkWindowedSincInterpolateImageFunctionISS23Lanczos_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS23Lanczos_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionISS23Lanczos

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionISS23Lanczos *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionISS23Lanczos"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS23Lanczos_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionISS23Lanczos

        Create a new object of the class itkWindowedSincInterpolateImageFunctionISS23Lanczos and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionISS23Lanczos.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionISS23Lanczos.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionISS23Lanczos.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionISS23Lanczos.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS23Lanczos_Clone, None, itkWindowedSincInterpolateImageFunctionISS23Lanczos)
itkWindowedSincInterpolateImageFunctionISS23Lanczos_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS23Lanczos_swigregister
itkWindowedSincInterpolateImageFunctionISS23Lanczos_swigregister(itkWindowedSincInterpolateImageFunctionISS23Lanczos)

def itkWindowedSincInterpolateImageFunctionISS23Lanczos___New_orig__() -> "itkWindowedSincInterpolateImageFunctionISS23Lanczos_Pointer":
    """itkWindowedSincInterpolateImageFunctionISS23Lanczos___New_orig__() -> itkWindowedSincInterpolateImageFunctionISS23Lanczos_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS23Lanczos___New_orig__()

def itkWindowedSincInterpolateImageFunctionISS23Lanczos_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionISS23Lanczos *":
    """itkWindowedSincInterpolateImageFunctionISS23Lanczos_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionISS23Lanczos"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS23Lanczos_cast(obj)

class itkWindowedSincInterpolateImageFunctionISS23Welch(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionISS2D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionISS23Welch_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionISS23Welch_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS23Welch___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionISS23Welch_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionISS23Welch self) -> itkWindowedSincInterpolateImageFunctionISS23Welch_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS23Welch_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionISS23Welch

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionISS23Welch *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionISS23Welch"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS23Welch_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionISS23Welch

        Create a new object of the class itkWindowedSincInterpolateImageFunctionISS23Welch and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionISS23Welch.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionISS23Welch.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionISS23Welch.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionISS23Welch.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS23Welch_Clone, None, itkWindowedSincInterpolateImageFunctionISS23Welch)
itkWindowedSincInterpolateImageFunctionISS23Welch_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS23Welch_swigregister
itkWindowedSincInterpolateImageFunctionISS23Welch_swigregister(itkWindowedSincInterpolateImageFunctionISS23Welch)

def itkWindowedSincInterpolateImageFunctionISS23Welch___New_orig__() -> "itkWindowedSincInterpolateImageFunctionISS23Welch_Pointer":
    """itkWindowedSincInterpolateImageFunctionISS23Welch___New_orig__() -> itkWindowedSincInterpolateImageFunctionISS23Welch_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS23Welch___New_orig__()

def itkWindowedSincInterpolateImageFunctionISS23Welch_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionISS23Welch *":
    """itkWindowedSincInterpolateImageFunctionISS23Welch_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionISS23Welch"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS23Welch_cast(obj)

class itkWindowedSincInterpolateImageFunctionISS32Cosine(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionISS3D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionISS32Cosine_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionISS32Cosine_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS32Cosine___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionISS32Cosine_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionISS32Cosine self) -> itkWindowedSincInterpolateImageFunctionISS32Cosine_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS32Cosine_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionISS32Cosine

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionISS32Cosine *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionISS32Cosine"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS32Cosine_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionISS32Cosine

        Create a new object of the class itkWindowedSincInterpolateImageFunctionISS32Cosine and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionISS32Cosine.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionISS32Cosine.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionISS32Cosine.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionISS32Cosine.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS32Cosine_Clone, None, itkWindowedSincInterpolateImageFunctionISS32Cosine)
itkWindowedSincInterpolateImageFunctionISS32Cosine_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS32Cosine_swigregister
itkWindowedSincInterpolateImageFunctionISS32Cosine_swigregister(itkWindowedSincInterpolateImageFunctionISS32Cosine)

def itkWindowedSincInterpolateImageFunctionISS32Cosine___New_orig__() -> "itkWindowedSincInterpolateImageFunctionISS32Cosine_Pointer":
    """itkWindowedSincInterpolateImageFunctionISS32Cosine___New_orig__() -> itkWindowedSincInterpolateImageFunctionISS32Cosine_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS32Cosine___New_orig__()

def itkWindowedSincInterpolateImageFunctionISS32Cosine_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionISS32Cosine *":
    """itkWindowedSincInterpolateImageFunctionISS32Cosine_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionISS32Cosine"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS32Cosine_cast(obj)

class itkWindowedSincInterpolateImageFunctionISS32Hamming(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionISS3D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionISS32Hamming_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionISS32Hamming_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS32Hamming___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionISS32Hamming_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionISS32Hamming self) -> itkWindowedSincInterpolateImageFunctionISS32Hamming_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS32Hamming_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionISS32Hamming

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionISS32Hamming *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionISS32Hamming"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS32Hamming_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionISS32Hamming

        Create a new object of the class itkWindowedSincInterpolateImageFunctionISS32Hamming and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionISS32Hamming.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionISS32Hamming.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionISS32Hamming.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionISS32Hamming.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS32Hamming_Clone, None, itkWindowedSincInterpolateImageFunctionISS32Hamming)
itkWindowedSincInterpolateImageFunctionISS32Hamming_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS32Hamming_swigregister
itkWindowedSincInterpolateImageFunctionISS32Hamming_swigregister(itkWindowedSincInterpolateImageFunctionISS32Hamming)

def itkWindowedSincInterpolateImageFunctionISS32Hamming___New_orig__() -> "itkWindowedSincInterpolateImageFunctionISS32Hamming_Pointer":
    """itkWindowedSincInterpolateImageFunctionISS32Hamming___New_orig__() -> itkWindowedSincInterpolateImageFunctionISS32Hamming_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS32Hamming___New_orig__()

def itkWindowedSincInterpolateImageFunctionISS32Hamming_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionISS32Hamming *":
    """itkWindowedSincInterpolateImageFunctionISS32Hamming_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionISS32Hamming"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS32Hamming_cast(obj)

class itkWindowedSincInterpolateImageFunctionISS32Lanczos(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionISS3D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionISS32Lanczos_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionISS32Lanczos_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS32Lanczos___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionISS32Lanczos_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionISS32Lanczos self) -> itkWindowedSincInterpolateImageFunctionISS32Lanczos_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS32Lanczos_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionISS32Lanczos

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionISS32Lanczos *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionISS32Lanczos"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS32Lanczos_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionISS32Lanczos

        Create a new object of the class itkWindowedSincInterpolateImageFunctionISS32Lanczos and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionISS32Lanczos.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionISS32Lanczos.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionISS32Lanczos.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionISS32Lanczos.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS32Lanczos_Clone, None, itkWindowedSincInterpolateImageFunctionISS32Lanczos)
itkWindowedSincInterpolateImageFunctionISS32Lanczos_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS32Lanczos_swigregister
itkWindowedSincInterpolateImageFunctionISS32Lanczos_swigregister(itkWindowedSincInterpolateImageFunctionISS32Lanczos)

def itkWindowedSincInterpolateImageFunctionISS32Lanczos___New_orig__() -> "itkWindowedSincInterpolateImageFunctionISS32Lanczos_Pointer":
    """itkWindowedSincInterpolateImageFunctionISS32Lanczos___New_orig__() -> itkWindowedSincInterpolateImageFunctionISS32Lanczos_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS32Lanczos___New_orig__()

def itkWindowedSincInterpolateImageFunctionISS32Lanczos_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionISS32Lanczos *":
    """itkWindowedSincInterpolateImageFunctionISS32Lanczos_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionISS32Lanczos"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS32Lanczos_cast(obj)

class itkWindowedSincInterpolateImageFunctionISS32Welch(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionISS3D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionISS32Welch_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionISS32Welch_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS32Welch___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionISS32Welch_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionISS32Welch self) -> itkWindowedSincInterpolateImageFunctionISS32Welch_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS32Welch_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionISS32Welch

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionISS32Welch *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionISS32Welch"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS32Welch_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionISS32Welch

        Create a new object of the class itkWindowedSincInterpolateImageFunctionISS32Welch and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionISS32Welch.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionISS32Welch.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionISS32Welch.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionISS32Welch.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS32Welch_Clone, None, itkWindowedSincInterpolateImageFunctionISS32Welch)
itkWindowedSincInterpolateImageFunctionISS32Welch_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS32Welch_swigregister
itkWindowedSincInterpolateImageFunctionISS32Welch_swigregister(itkWindowedSincInterpolateImageFunctionISS32Welch)

def itkWindowedSincInterpolateImageFunctionISS32Welch___New_orig__() -> "itkWindowedSincInterpolateImageFunctionISS32Welch_Pointer":
    """itkWindowedSincInterpolateImageFunctionISS32Welch___New_orig__() -> itkWindowedSincInterpolateImageFunctionISS32Welch_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS32Welch___New_orig__()

def itkWindowedSincInterpolateImageFunctionISS32Welch_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionISS32Welch *":
    """itkWindowedSincInterpolateImageFunctionISS32Welch_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionISS32Welch"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS32Welch_cast(obj)

class itkWindowedSincInterpolateImageFunctionISS33Cosine(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionISS3D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionISS33Cosine_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionISS33Cosine_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS33Cosine___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionISS33Cosine_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionISS33Cosine self) -> itkWindowedSincInterpolateImageFunctionISS33Cosine_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS33Cosine_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionISS33Cosine

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionISS33Cosine *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionISS33Cosine"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS33Cosine_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionISS33Cosine

        Create a new object of the class itkWindowedSincInterpolateImageFunctionISS33Cosine and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionISS33Cosine.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionISS33Cosine.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionISS33Cosine.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionISS33Cosine.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS33Cosine_Clone, None, itkWindowedSincInterpolateImageFunctionISS33Cosine)
itkWindowedSincInterpolateImageFunctionISS33Cosine_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS33Cosine_swigregister
itkWindowedSincInterpolateImageFunctionISS33Cosine_swigregister(itkWindowedSincInterpolateImageFunctionISS33Cosine)

def itkWindowedSincInterpolateImageFunctionISS33Cosine___New_orig__() -> "itkWindowedSincInterpolateImageFunctionISS33Cosine_Pointer":
    """itkWindowedSincInterpolateImageFunctionISS33Cosine___New_orig__() -> itkWindowedSincInterpolateImageFunctionISS33Cosine_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS33Cosine___New_orig__()

def itkWindowedSincInterpolateImageFunctionISS33Cosine_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionISS33Cosine *":
    """itkWindowedSincInterpolateImageFunctionISS33Cosine_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionISS33Cosine"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS33Cosine_cast(obj)

class itkWindowedSincInterpolateImageFunctionISS33Hamming(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionISS3D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionISS33Hamming_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionISS33Hamming_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS33Hamming___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionISS33Hamming_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionISS33Hamming self) -> itkWindowedSincInterpolateImageFunctionISS33Hamming_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS33Hamming_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionISS33Hamming

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionISS33Hamming *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionISS33Hamming"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS33Hamming_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionISS33Hamming

        Create a new object of the class itkWindowedSincInterpolateImageFunctionISS33Hamming and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionISS33Hamming.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionISS33Hamming.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionISS33Hamming.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionISS33Hamming.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS33Hamming_Clone, None, itkWindowedSincInterpolateImageFunctionISS33Hamming)
itkWindowedSincInterpolateImageFunctionISS33Hamming_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS33Hamming_swigregister
itkWindowedSincInterpolateImageFunctionISS33Hamming_swigregister(itkWindowedSincInterpolateImageFunctionISS33Hamming)

def itkWindowedSincInterpolateImageFunctionISS33Hamming___New_orig__() -> "itkWindowedSincInterpolateImageFunctionISS33Hamming_Pointer":
    """itkWindowedSincInterpolateImageFunctionISS33Hamming___New_orig__() -> itkWindowedSincInterpolateImageFunctionISS33Hamming_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS33Hamming___New_orig__()

def itkWindowedSincInterpolateImageFunctionISS33Hamming_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionISS33Hamming *":
    """itkWindowedSincInterpolateImageFunctionISS33Hamming_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionISS33Hamming"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS33Hamming_cast(obj)

class itkWindowedSincInterpolateImageFunctionISS33Lanczos(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionISS3D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionISS33Lanczos_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionISS33Lanczos_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS33Lanczos___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionISS33Lanczos_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionISS33Lanczos self) -> itkWindowedSincInterpolateImageFunctionISS33Lanczos_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS33Lanczos_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionISS33Lanczos

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionISS33Lanczos *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionISS33Lanczos"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS33Lanczos_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionISS33Lanczos

        Create a new object of the class itkWindowedSincInterpolateImageFunctionISS33Lanczos and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionISS33Lanczos.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionISS33Lanczos.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionISS33Lanczos.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionISS33Lanczos.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS33Lanczos_Clone, None, itkWindowedSincInterpolateImageFunctionISS33Lanczos)
itkWindowedSincInterpolateImageFunctionISS33Lanczos_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS33Lanczos_swigregister
itkWindowedSincInterpolateImageFunctionISS33Lanczos_swigregister(itkWindowedSincInterpolateImageFunctionISS33Lanczos)

def itkWindowedSincInterpolateImageFunctionISS33Lanczos___New_orig__() -> "itkWindowedSincInterpolateImageFunctionISS33Lanczos_Pointer":
    """itkWindowedSincInterpolateImageFunctionISS33Lanczos___New_orig__() -> itkWindowedSincInterpolateImageFunctionISS33Lanczos_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS33Lanczos___New_orig__()

def itkWindowedSincInterpolateImageFunctionISS33Lanczos_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionISS33Lanczos *":
    """itkWindowedSincInterpolateImageFunctionISS33Lanczos_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionISS33Lanczos"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS33Lanczos_cast(obj)

class itkWindowedSincInterpolateImageFunctionISS33Welch(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionISS3D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionISS33Welch_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionISS33Welch_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS33Welch___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionISS33Welch_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionISS33Welch self) -> itkWindowedSincInterpolateImageFunctionISS33Welch_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS33Welch_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionISS33Welch

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionISS33Welch *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionISS33Welch"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS33Welch_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionISS33Welch

        Create a new object of the class itkWindowedSincInterpolateImageFunctionISS33Welch and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionISS33Welch.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionISS33Welch.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionISS33Welch.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionISS33Welch.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS33Welch_Clone, None, itkWindowedSincInterpolateImageFunctionISS33Welch)
itkWindowedSincInterpolateImageFunctionISS33Welch_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS33Welch_swigregister
itkWindowedSincInterpolateImageFunctionISS33Welch_swigregister(itkWindowedSincInterpolateImageFunctionISS33Welch)

def itkWindowedSincInterpolateImageFunctionISS33Welch___New_orig__() -> "itkWindowedSincInterpolateImageFunctionISS33Welch_Pointer":
    """itkWindowedSincInterpolateImageFunctionISS33Welch___New_orig__() -> itkWindowedSincInterpolateImageFunctionISS33Welch_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS33Welch___New_orig__()

def itkWindowedSincInterpolateImageFunctionISS33Welch_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionISS33Welch *":
    """itkWindowedSincInterpolateImageFunctionISS33Welch_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionISS33Welch"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS33Welch_cast(obj)

class itkWindowedSincInterpolateImageFunctionIUC22Cosine(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUC2D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUC22Cosine_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionIUC22Cosine_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC22Cosine___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionIUC22Cosine_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionIUC22Cosine self) -> itkWindowedSincInterpolateImageFunctionIUC22Cosine_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC22Cosine_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUC22Cosine

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUC22Cosine *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUC22Cosine"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC22Cosine_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUC22Cosine

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUC22Cosine and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUC22Cosine.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUC22Cosine.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionIUC22Cosine.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionIUC22Cosine.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC22Cosine_Clone, None, itkWindowedSincInterpolateImageFunctionIUC22Cosine)
itkWindowedSincInterpolateImageFunctionIUC22Cosine_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC22Cosine_swigregister
itkWindowedSincInterpolateImageFunctionIUC22Cosine_swigregister(itkWindowedSincInterpolateImageFunctionIUC22Cosine)

def itkWindowedSincInterpolateImageFunctionIUC22Cosine___New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUC22Cosine_Pointer":
    """itkWindowedSincInterpolateImageFunctionIUC22Cosine___New_orig__() -> itkWindowedSincInterpolateImageFunctionIUC22Cosine_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC22Cosine___New_orig__()

def itkWindowedSincInterpolateImageFunctionIUC22Cosine_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUC22Cosine *":
    """itkWindowedSincInterpolateImageFunctionIUC22Cosine_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUC22Cosine"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC22Cosine_cast(obj)

class itkWindowedSincInterpolateImageFunctionIUC22Hamming(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUC2D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUC22Hamming_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionIUC22Hamming_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC22Hamming___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionIUC22Hamming_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionIUC22Hamming self) -> itkWindowedSincInterpolateImageFunctionIUC22Hamming_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC22Hamming_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUC22Hamming

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUC22Hamming *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUC22Hamming"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC22Hamming_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUC22Hamming

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUC22Hamming and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUC22Hamming.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUC22Hamming.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionIUC22Hamming.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionIUC22Hamming.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC22Hamming_Clone, None, itkWindowedSincInterpolateImageFunctionIUC22Hamming)
itkWindowedSincInterpolateImageFunctionIUC22Hamming_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC22Hamming_swigregister
itkWindowedSincInterpolateImageFunctionIUC22Hamming_swigregister(itkWindowedSincInterpolateImageFunctionIUC22Hamming)

def itkWindowedSincInterpolateImageFunctionIUC22Hamming___New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUC22Hamming_Pointer":
    """itkWindowedSincInterpolateImageFunctionIUC22Hamming___New_orig__() -> itkWindowedSincInterpolateImageFunctionIUC22Hamming_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC22Hamming___New_orig__()

def itkWindowedSincInterpolateImageFunctionIUC22Hamming_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUC22Hamming *":
    """itkWindowedSincInterpolateImageFunctionIUC22Hamming_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUC22Hamming"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC22Hamming_cast(obj)

class itkWindowedSincInterpolateImageFunctionIUC22Lanczos(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUC2D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUC22Lanczos_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionIUC22Lanczos_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC22Lanczos___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionIUC22Lanczos_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionIUC22Lanczos self) -> itkWindowedSincInterpolateImageFunctionIUC22Lanczos_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC22Lanczos_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUC22Lanczos

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUC22Lanczos *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUC22Lanczos"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC22Lanczos_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUC22Lanczos

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUC22Lanczos and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUC22Lanczos.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUC22Lanczos.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionIUC22Lanczos.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionIUC22Lanczos.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC22Lanczos_Clone, None, itkWindowedSincInterpolateImageFunctionIUC22Lanczos)
itkWindowedSincInterpolateImageFunctionIUC22Lanczos_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC22Lanczos_swigregister
itkWindowedSincInterpolateImageFunctionIUC22Lanczos_swigregister(itkWindowedSincInterpolateImageFunctionIUC22Lanczos)

def itkWindowedSincInterpolateImageFunctionIUC22Lanczos___New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUC22Lanczos_Pointer":
    """itkWindowedSincInterpolateImageFunctionIUC22Lanczos___New_orig__() -> itkWindowedSincInterpolateImageFunctionIUC22Lanczos_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC22Lanczos___New_orig__()

def itkWindowedSincInterpolateImageFunctionIUC22Lanczos_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUC22Lanczos *":
    """itkWindowedSincInterpolateImageFunctionIUC22Lanczos_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUC22Lanczos"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC22Lanczos_cast(obj)

class itkWindowedSincInterpolateImageFunctionIUC22Welch(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUC2D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUC22Welch_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionIUC22Welch_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC22Welch___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionIUC22Welch_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionIUC22Welch self) -> itkWindowedSincInterpolateImageFunctionIUC22Welch_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC22Welch_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUC22Welch

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUC22Welch *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUC22Welch"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC22Welch_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUC22Welch

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUC22Welch and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUC22Welch.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUC22Welch.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionIUC22Welch.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionIUC22Welch.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC22Welch_Clone, None, itkWindowedSincInterpolateImageFunctionIUC22Welch)
itkWindowedSincInterpolateImageFunctionIUC22Welch_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC22Welch_swigregister
itkWindowedSincInterpolateImageFunctionIUC22Welch_swigregister(itkWindowedSincInterpolateImageFunctionIUC22Welch)

def itkWindowedSincInterpolateImageFunctionIUC22Welch___New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUC22Welch_Pointer":
    """itkWindowedSincInterpolateImageFunctionIUC22Welch___New_orig__() -> itkWindowedSincInterpolateImageFunctionIUC22Welch_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC22Welch___New_orig__()

def itkWindowedSincInterpolateImageFunctionIUC22Welch_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUC22Welch *":
    """itkWindowedSincInterpolateImageFunctionIUC22Welch_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUC22Welch"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC22Welch_cast(obj)

class itkWindowedSincInterpolateImageFunctionIUC23Cosine(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUC2D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUC23Cosine_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionIUC23Cosine_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC23Cosine___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionIUC23Cosine_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionIUC23Cosine self) -> itkWindowedSincInterpolateImageFunctionIUC23Cosine_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC23Cosine_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUC23Cosine

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUC23Cosine *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUC23Cosine"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC23Cosine_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUC23Cosine

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUC23Cosine and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUC23Cosine.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUC23Cosine.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionIUC23Cosine.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionIUC23Cosine.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC23Cosine_Clone, None, itkWindowedSincInterpolateImageFunctionIUC23Cosine)
itkWindowedSincInterpolateImageFunctionIUC23Cosine_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC23Cosine_swigregister
itkWindowedSincInterpolateImageFunctionIUC23Cosine_swigregister(itkWindowedSincInterpolateImageFunctionIUC23Cosine)

def itkWindowedSincInterpolateImageFunctionIUC23Cosine___New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUC23Cosine_Pointer":
    """itkWindowedSincInterpolateImageFunctionIUC23Cosine___New_orig__() -> itkWindowedSincInterpolateImageFunctionIUC23Cosine_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC23Cosine___New_orig__()

def itkWindowedSincInterpolateImageFunctionIUC23Cosine_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUC23Cosine *":
    """itkWindowedSincInterpolateImageFunctionIUC23Cosine_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUC23Cosine"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC23Cosine_cast(obj)

class itkWindowedSincInterpolateImageFunctionIUC23Hamming(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUC2D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUC23Hamming_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionIUC23Hamming_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC23Hamming___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionIUC23Hamming_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionIUC23Hamming self) -> itkWindowedSincInterpolateImageFunctionIUC23Hamming_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC23Hamming_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUC23Hamming

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUC23Hamming *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUC23Hamming"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC23Hamming_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUC23Hamming

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUC23Hamming and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUC23Hamming.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUC23Hamming.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionIUC23Hamming.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionIUC23Hamming.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC23Hamming_Clone, None, itkWindowedSincInterpolateImageFunctionIUC23Hamming)
itkWindowedSincInterpolateImageFunctionIUC23Hamming_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC23Hamming_swigregister
itkWindowedSincInterpolateImageFunctionIUC23Hamming_swigregister(itkWindowedSincInterpolateImageFunctionIUC23Hamming)

def itkWindowedSincInterpolateImageFunctionIUC23Hamming___New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUC23Hamming_Pointer":
    """itkWindowedSincInterpolateImageFunctionIUC23Hamming___New_orig__() -> itkWindowedSincInterpolateImageFunctionIUC23Hamming_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC23Hamming___New_orig__()

def itkWindowedSincInterpolateImageFunctionIUC23Hamming_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUC23Hamming *":
    """itkWindowedSincInterpolateImageFunctionIUC23Hamming_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUC23Hamming"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC23Hamming_cast(obj)

class itkWindowedSincInterpolateImageFunctionIUC23Lanczos(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUC2D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUC23Lanczos_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionIUC23Lanczos_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC23Lanczos___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionIUC23Lanczos_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionIUC23Lanczos self) -> itkWindowedSincInterpolateImageFunctionIUC23Lanczos_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC23Lanczos_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUC23Lanczos

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUC23Lanczos *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUC23Lanczos"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC23Lanczos_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUC23Lanczos

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUC23Lanczos and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUC23Lanczos.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUC23Lanczos.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionIUC23Lanczos.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionIUC23Lanczos.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC23Lanczos_Clone, None, itkWindowedSincInterpolateImageFunctionIUC23Lanczos)
itkWindowedSincInterpolateImageFunctionIUC23Lanczos_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC23Lanczos_swigregister
itkWindowedSincInterpolateImageFunctionIUC23Lanczos_swigregister(itkWindowedSincInterpolateImageFunctionIUC23Lanczos)

def itkWindowedSincInterpolateImageFunctionIUC23Lanczos___New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUC23Lanczos_Pointer":
    """itkWindowedSincInterpolateImageFunctionIUC23Lanczos___New_orig__() -> itkWindowedSincInterpolateImageFunctionIUC23Lanczos_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC23Lanczos___New_orig__()

def itkWindowedSincInterpolateImageFunctionIUC23Lanczos_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUC23Lanczos *":
    """itkWindowedSincInterpolateImageFunctionIUC23Lanczos_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUC23Lanczos"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC23Lanczos_cast(obj)

class itkWindowedSincInterpolateImageFunctionIUC23Welch(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUC2D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUC23Welch_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionIUC23Welch_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC23Welch___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionIUC23Welch_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionIUC23Welch self) -> itkWindowedSincInterpolateImageFunctionIUC23Welch_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC23Welch_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUC23Welch

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUC23Welch *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUC23Welch"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC23Welch_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUC23Welch

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUC23Welch and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUC23Welch.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUC23Welch.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionIUC23Welch.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionIUC23Welch.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC23Welch_Clone, None, itkWindowedSincInterpolateImageFunctionIUC23Welch)
itkWindowedSincInterpolateImageFunctionIUC23Welch_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC23Welch_swigregister
itkWindowedSincInterpolateImageFunctionIUC23Welch_swigregister(itkWindowedSincInterpolateImageFunctionIUC23Welch)

def itkWindowedSincInterpolateImageFunctionIUC23Welch___New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUC23Welch_Pointer":
    """itkWindowedSincInterpolateImageFunctionIUC23Welch___New_orig__() -> itkWindowedSincInterpolateImageFunctionIUC23Welch_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC23Welch___New_orig__()

def itkWindowedSincInterpolateImageFunctionIUC23Welch_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUC23Welch *":
    """itkWindowedSincInterpolateImageFunctionIUC23Welch_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUC23Welch"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC23Welch_cast(obj)

class itkWindowedSincInterpolateImageFunctionIUC32Cosine(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUC3D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUC32Cosine_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionIUC32Cosine_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC32Cosine___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionIUC32Cosine_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionIUC32Cosine self) -> itkWindowedSincInterpolateImageFunctionIUC32Cosine_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC32Cosine_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUC32Cosine

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUC32Cosine *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUC32Cosine"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC32Cosine_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUC32Cosine

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUC32Cosine and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUC32Cosine.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUC32Cosine.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionIUC32Cosine.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionIUC32Cosine.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC32Cosine_Clone, None, itkWindowedSincInterpolateImageFunctionIUC32Cosine)
itkWindowedSincInterpolateImageFunctionIUC32Cosine_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC32Cosine_swigregister
itkWindowedSincInterpolateImageFunctionIUC32Cosine_swigregister(itkWindowedSincInterpolateImageFunctionIUC32Cosine)

def itkWindowedSincInterpolateImageFunctionIUC32Cosine___New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUC32Cosine_Pointer":
    """itkWindowedSincInterpolateImageFunctionIUC32Cosine___New_orig__() -> itkWindowedSincInterpolateImageFunctionIUC32Cosine_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC32Cosine___New_orig__()

def itkWindowedSincInterpolateImageFunctionIUC32Cosine_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUC32Cosine *":
    """itkWindowedSincInterpolateImageFunctionIUC32Cosine_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUC32Cosine"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC32Cosine_cast(obj)

class itkWindowedSincInterpolateImageFunctionIUC32Hamming(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUC3D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUC32Hamming_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionIUC32Hamming_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC32Hamming___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionIUC32Hamming_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionIUC32Hamming self) -> itkWindowedSincInterpolateImageFunctionIUC32Hamming_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC32Hamming_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUC32Hamming

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUC32Hamming *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUC32Hamming"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC32Hamming_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUC32Hamming

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUC32Hamming and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUC32Hamming.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUC32Hamming.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionIUC32Hamming.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionIUC32Hamming.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC32Hamming_Clone, None, itkWindowedSincInterpolateImageFunctionIUC32Hamming)
itkWindowedSincInterpolateImageFunctionIUC32Hamming_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC32Hamming_swigregister
itkWindowedSincInterpolateImageFunctionIUC32Hamming_swigregister(itkWindowedSincInterpolateImageFunctionIUC32Hamming)

def itkWindowedSincInterpolateImageFunctionIUC32Hamming___New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUC32Hamming_Pointer":
    """itkWindowedSincInterpolateImageFunctionIUC32Hamming___New_orig__() -> itkWindowedSincInterpolateImageFunctionIUC32Hamming_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC32Hamming___New_orig__()

def itkWindowedSincInterpolateImageFunctionIUC32Hamming_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUC32Hamming *":
    """itkWindowedSincInterpolateImageFunctionIUC32Hamming_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUC32Hamming"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC32Hamming_cast(obj)

class itkWindowedSincInterpolateImageFunctionIUC32Lanczos(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUC3D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUC32Lanczos_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionIUC32Lanczos_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC32Lanczos___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionIUC32Lanczos_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionIUC32Lanczos self) -> itkWindowedSincInterpolateImageFunctionIUC32Lanczos_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC32Lanczos_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUC32Lanczos

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUC32Lanczos *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUC32Lanczos"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC32Lanczos_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUC32Lanczos

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUC32Lanczos and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUC32Lanczos.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUC32Lanczos.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionIUC32Lanczos.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionIUC32Lanczos.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC32Lanczos_Clone, None, itkWindowedSincInterpolateImageFunctionIUC32Lanczos)
itkWindowedSincInterpolateImageFunctionIUC32Lanczos_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC32Lanczos_swigregister
itkWindowedSincInterpolateImageFunctionIUC32Lanczos_swigregister(itkWindowedSincInterpolateImageFunctionIUC32Lanczos)

def itkWindowedSincInterpolateImageFunctionIUC32Lanczos___New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUC32Lanczos_Pointer":
    """itkWindowedSincInterpolateImageFunctionIUC32Lanczos___New_orig__() -> itkWindowedSincInterpolateImageFunctionIUC32Lanczos_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC32Lanczos___New_orig__()

def itkWindowedSincInterpolateImageFunctionIUC32Lanczos_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUC32Lanczos *":
    """itkWindowedSincInterpolateImageFunctionIUC32Lanczos_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUC32Lanczos"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC32Lanczos_cast(obj)

class itkWindowedSincInterpolateImageFunctionIUC32Welch(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUC3D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUC32Welch_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionIUC32Welch_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC32Welch___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionIUC32Welch_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionIUC32Welch self) -> itkWindowedSincInterpolateImageFunctionIUC32Welch_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC32Welch_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUC32Welch

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUC32Welch *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUC32Welch"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC32Welch_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUC32Welch

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUC32Welch and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUC32Welch.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUC32Welch.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionIUC32Welch.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionIUC32Welch.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC32Welch_Clone, None, itkWindowedSincInterpolateImageFunctionIUC32Welch)
itkWindowedSincInterpolateImageFunctionIUC32Welch_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC32Welch_swigregister
itkWindowedSincInterpolateImageFunctionIUC32Welch_swigregister(itkWindowedSincInterpolateImageFunctionIUC32Welch)

def itkWindowedSincInterpolateImageFunctionIUC32Welch___New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUC32Welch_Pointer":
    """itkWindowedSincInterpolateImageFunctionIUC32Welch___New_orig__() -> itkWindowedSincInterpolateImageFunctionIUC32Welch_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC32Welch___New_orig__()

def itkWindowedSincInterpolateImageFunctionIUC32Welch_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUC32Welch *":
    """itkWindowedSincInterpolateImageFunctionIUC32Welch_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUC32Welch"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC32Welch_cast(obj)

class itkWindowedSincInterpolateImageFunctionIUC33Cosine(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUC3D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUC33Cosine_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionIUC33Cosine_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC33Cosine___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionIUC33Cosine_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionIUC33Cosine self) -> itkWindowedSincInterpolateImageFunctionIUC33Cosine_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC33Cosine_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUC33Cosine

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUC33Cosine *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUC33Cosine"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC33Cosine_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUC33Cosine

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUC33Cosine and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUC33Cosine.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUC33Cosine.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionIUC33Cosine.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionIUC33Cosine.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC33Cosine_Clone, None, itkWindowedSincInterpolateImageFunctionIUC33Cosine)
itkWindowedSincInterpolateImageFunctionIUC33Cosine_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC33Cosine_swigregister
itkWindowedSincInterpolateImageFunctionIUC33Cosine_swigregister(itkWindowedSincInterpolateImageFunctionIUC33Cosine)

def itkWindowedSincInterpolateImageFunctionIUC33Cosine___New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUC33Cosine_Pointer":
    """itkWindowedSincInterpolateImageFunctionIUC33Cosine___New_orig__() -> itkWindowedSincInterpolateImageFunctionIUC33Cosine_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC33Cosine___New_orig__()

def itkWindowedSincInterpolateImageFunctionIUC33Cosine_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUC33Cosine *":
    """itkWindowedSincInterpolateImageFunctionIUC33Cosine_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUC33Cosine"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC33Cosine_cast(obj)

class itkWindowedSincInterpolateImageFunctionIUC33Hamming(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUC3D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUC33Hamming_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionIUC33Hamming_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC33Hamming___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionIUC33Hamming_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionIUC33Hamming self) -> itkWindowedSincInterpolateImageFunctionIUC33Hamming_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC33Hamming_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUC33Hamming

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUC33Hamming *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUC33Hamming"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC33Hamming_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUC33Hamming

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUC33Hamming and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUC33Hamming.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUC33Hamming.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionIUC33Hamming.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionIUC33Hamming.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC33Hamming_Clone, None, itkWindowedSincInterpolateImageFunctionIUC33Hamming)
itkWindowedSincInterpolateImageFunctionIUC33Hamming_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC33Hamming_swigregister
itkWindowedSincInterpolateImageFunctionIUC33Hamming_swigregister(itkWindowedSincInterpolateImageFunctionIUC33Hamming)

def itkWindowedSincInterpolateImageFunctionIUC33Hamming___New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUC33Hamming_Pointer":
    """itkWindowedSincInterpolateImageFunctionIUC33Hamming___New_orig__() -> itkWindowedSincInterpolateImageFunctionIUC33Hamming_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC33Hamming___New_orig__()

def itkWindowedSincInterpolateImageFunctionIUC33Hamming_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUC33Hamming *":
    """itkWindowedSincInterpolateImageFunctionIUC33Hamming_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUC33Hamming"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC33Hamming_cast(obj)

class itkWindowedSincInterpolateImageFunctionIUC33Lanczos(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUC3D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUC33Lanczos_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionIUC33Lanczos_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC33Lanczos___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionIUC33Lanczos_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionIUC33Lanczos self) -> itkWindowedSincInterpolateImageFunctionIUC33Lanczos_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC33Lanczos_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUC33Lanczos

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUC33Lanczos *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUC33Lanczos"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC33Lanczos_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUC33Lanczos

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUC33Lanczos and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUC33Lanczos.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUC33Lanczos.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionIUC33Lanczos.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionIUC33Lanczos.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC33Lanczos_Clone, None, itkWindowedSincInterpolateImageFunctionIUC33Lanczos)
itkWindowedSincInterpolateImageFunctionIUC33Lanczos_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC33Lanczos_swigregister
itkWindowedSincInterpolateImageFunctionIUC33Lanczos_swigregister(itkWindowedSincInterpolateImageFunctionIUC33Lanczos)

def itkWindowedSincInterpolateImageFunctionIUC33Lanczos___New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUC33Lanczos_Pointer":
    """itkWindowedSincInterpolateImageFunctionIUC33Lanczos___New_orig__() -> itkWindowedSincInterpolateImageFunctionIUC33Lanczos_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC33Lanczos___New_orig__()

def itkWindowedSincInterpolateImageFunctionIUC33Lanczos_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUC33Lanczos *":
    """itkWindowedSincInterpolateImageFunctionIUC33Lanczos_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUC33Lanczos"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC33Lanczos_cast(obj)

class itkWindowedSincInterpolateImageFunctionIUC33Welch(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUC3D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUC33Welch_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionIUC33Welch_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC33Welch___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionIUC33Welch_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionIUC33Welch self) -> itkWindowedSincInterpolateImageFunctionIUC33Welch_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC33Welch_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUC33Welch

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUC33Welch *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUC33Welch"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC33Welch_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUC33Welch

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUC33Welch and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUC33Welch.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUC33Welch.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionIUC33Welch.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionIUC33Welch.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC33Welch_Clone, None, itkWindowedSincInterpolateImageFunctionIUC33Welch)
itkWindowedSincInterpolateImageFunctionIUC33Welch_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC33Welch_swigregister
itkWindowedSincInterpolateImageFunctionIUC33Welch_swigregister(itkWindowedSincInterpolateImageFunctionIUC33Welch)

def itkWindowedSincInterpolateImageFunctionIUC33Welch___New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUC33Welch_Pointer":
    """itkWindowedSincInterpolateImageFunctionIUC33Welch___New_orig__() -> itkWindowedSincInterpolateImageFunctionIUC33Welch_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC33Welch___New_orig__()

def itkWindowedSincInterpolateImageFunctionIUC33Welch_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUC33Welch *":
    """itkWindowedSincInterpolateImageFunctionIUC33Welch_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUC33Welch"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC33Welch_cast(obj)

class itkWindowedSincInterpolateImageFunctionIUS22Cosine(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUS2D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUS22Cosine_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionIUS22Cosine_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS22Cosine___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionIUS22Cosine_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionIUS22Cosine self) -> itkWindowedSincInterpolateImageFunctionIUS22Cosine_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS22Cosine_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUS22Cosine

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUS22Cosine *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUS22Cosine"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS22Cosine_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUS22Cosine

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUS22Cosine and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUS22Cosine.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUS22Cosine.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionIUS22Cosine.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionIUS22Cosine.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS22Cosine_Clone, None, itkWindowedSincInterpolateImageFunctionIUS22Cosine)
itkWindowedSincInterpolateImageFunctionIUS22Cosine_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS22Cosine_swigregister
itkWindowedSincInterpolateImageFunctionIUS22Cosine_swigregister(itkWindowedSincInterpolateImageFunctionIUS22Cosine)

def itkWindowedSincInterpolateImageFunctionIUS22Cosine___New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUS22Cosine_Pointer":
    """itkWindowedSincInterpolateImageFunctionIUS22Cosine___New_orig__() -> itkWindowedSincInterpolateImageFunctionIUS22Cosine_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS22Cosine___New_orig__()

def itkWindowedSincInterpolateImageFunctionIUS22Cosine_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUS22Cosine *":
    """itkWindowedSincInterpolateImageFunctionIUS22Cosine_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUS22Cosine"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS22Cosine_cast(obj)

class itkWindowedSincInterpolateImageFunctionIUS22Hamming(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUS2D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUS22Hamming_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionIUS22Hamming_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS22Hamming___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionIUS22Hamming_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionIUS22Hamming self) -> itkWindowedSincInterpolateImageFunctionIUS22Hamming_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS22Hamming_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUS22Hamming

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUS22Hamming *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUS22Hamming"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS22Hamming_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUS22Hamming

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUS22Hamming and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUS22Hamming.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUS22Hamming.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionIUS22Hamming.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionIUS22Hamming.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS22Hamming_Clone, None, itkWindowedSincInterpolateImageFunctionIUS22Hamming)
itkWindowedSincInterpolateImageFunctionIUS22Hamming_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS22Hamming_swigregister
itkWindowedSincInterpolateImageFunctionIUS22Hamming_swigregister(itkWindowedSincInterpolateImageFunctionIUS22Hamming)

def itkWindowedSincInterpolateImageFunctionIUS22Hamming___New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUS22Hamming_Pointer":
    """itkWindowedSincInterpolateImageFunctionIUS22Hamming___New_orig__() -> itkWindowedSincInterpolateImageFunctionIUS22Hamming_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS22Hamming___New_orig__()

def itkWindowedSincInterpolateImageFunctionIUS22Hamming_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUS22Hamming *":
    """itkWindowedSincInterpolateImageFunctionIUS22Hamming_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUS22Hamming"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS22Hamming_cast(obj)

class itkWindowedSincInterpolateImageFunctionIUS22Lanczos(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUS2D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUS22Lanczos_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionIUS22Lanczos_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS22Lanczos___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionIUS22Lanczos_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionIUS22Lanczos self) -> itkWindowedSincInterpolateImageFunctionIUS22Lanczos_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS22Lanczos_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUS22Lanczos

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUS22Lanczos *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUS22Lanczos"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS22Lanczos_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUS22Lanczos

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUS22Lanczos and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUS22Lanczos.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUS22Lanczos.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionIUS22Lanczos.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionIUS22Lanczos.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS22Lanczos_Clone, None, itkWindowedSincInterpolateImageFunctionIUS22Lanczos)
itkWindowedSincInterpolateImageFunctionIUS22Lanczos_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS22Lanczos_swigregister
itkWindowedSincInterpolateImageFunctionIUS22Lanczos_swigregister(itkWindowedSincInterpolateImageFunctionIUS22Lanczos)

def itkWindowedSincInterpolateImageFunctionIUS22Lanczos___New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUS22Lanczos_Pointer":
    """itkWindowedSincInterpolateImageFunctionIUS22Lanczos___New_orig__() -> itkWindowedSincInterpolateImageFunctionIUS22Lanczos_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS22Lanczos___New_orig__()

def itkWindowedSincInterpolateImageFunctionIUS22Lanczos_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUS22Lanczos *":
    """itkWindowedSincInterpolateImageFunctionIUS22Lanczos_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUS22Lanczos"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS22Lanczos_cast(obj)

class itkWindowedSincInterpolateImageFunctionIUS22Welch(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUS2D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUS22Welch_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionIUS22Welch_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS22Welch___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionIUS22Welch_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionIUS22Welch self) -> itkWindowedSincInterpolateImageFunctionIUS22Welch_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS22Welch_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUS22Welch

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUS22Welch *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUS22Welch"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS22Welch_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUS22Welch

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUS22Welch and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUS22Welch.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUS22Welch.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionIUS22Welch.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionIUS22Welch.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS22Welch_Clone, None, itkWindowedSincInterpolateImageFunctionIUS22Welch)
itkWindowedSincInterpolateImageFunctionIUS22Welch_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS22Welch_swigregister
itkWindowedSincInterpolateImageFunctionIUS22Welch_swigregister(itkWindowedSincInterpolateImageFunctionIUS22Welch)

def itkWindowedSincInterpolateImageFunctionIUS22Welch___New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUS22Welch_Pointer":
    """itkWindowedSincInterpolateImageFunctionIUS22Welch___New_orig__() -> itkWindowedSincInterpolateImageFunctionIUS22Welch_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS22Welch___New_orig__()

def itkWindowedSincInterpolateImageFunctionIUS22Welch_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUS22Welch *":
    """itkWindowedSincInterpolateImageFunctionIUS22Welch_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUS22Welch"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS22Welch_cast(obj)

class itkWindowedSincInterpolateImageFunctionIUS23Cosine(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUS2D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUS23Cosine_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionIUS23Cosine_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS23Cosine___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionIUS23Cosine_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionIUS23Cosine self) -> itkWindowedSincInterpolateImageFunctionIUS23Cosine_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS23Cosine_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUS23Cosine

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUS23Cosine *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUS23Cosine"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS23Cosine_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUS23Cosine

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUS23Cosine and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUS23Cosine.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUS23Cosine.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionIUS23Cosine.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionIUS23Cosine.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS23Cosine_Clone, None, itkWindowedSincInterpolateImageFunctionIUS23Cosine)
itkWindowedSincInterpolateImageFunctionIUS23Cosine_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS23Cosine_swigregister
itkWindowedSincInterpolateImageFunctionIUS23Cosine_swigregister(itkWindowedSincInterpolateImageFunctionIUS23Cosine)

def itkWindowedSincInterpolateImageFunctionIUS23Cosine___New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUS23Cosine_Pointer":
    """itkWindowedSincInterpolateImageFunctionIUS23Cosine___New_orig__() -> itkWindowedSincInterpolateImageFunctionIUS23Cosine_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS23Cosine___New_orig__()

def itkWindowedSincInterpolateImageFunctionIUS23Cosine_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUS23Cosine *":
    """itkWindowedSincInterpolateImageFunctionIUS23Cosine_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUS23Cosine"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS23Cosine_cast(obj)

class itkWindowedSincInterpolateImageFunctionIUS23Hamming(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUS2D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUS23Hamming_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionIUS23Hamming_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS23Hamming___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionIUS23Hamming_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionIUS23Hamming self) -> itkWindowedSincInterpolateImageFunctionIUS23Hamming_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS23Hamming_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUS23Hamming

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUS23Hamming *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUS23Hamming"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS23Hamming_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUS23Hamming

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUS23Hamming and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUS23Hamming.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUS23Hamming.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionIUS23Hamming.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionIUS23Hamming.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS23Hamming_Clone, None, itkWindowedSincInterpolateImageFunctionIUS23Hamming)
itkWindowedSincInterpolateImageFunctionIUS23Hamming_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS23Hamming_swigregister
itkWindowedSincInterpolateImageFunctionIUS23Hamming_swigregister(itkWindowedSincInterpolateImageFunctionIUS23Hamming)

def itkWindowedSincInterpolateImageFunctionIUS23Hamming___New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUS23Hamming_Pointer":
    """itkWindowedSincInterpolateImageFunctionIUS23Hamming___New_orig__() -> itkWindowedSincInterpolateImageFunctionIUS23Hamming_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS23Hamming___New_orig__()

def itkWindowedSincInterpolateImageFunctionIUS23Hamming_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUS23Hamming *":
    """itkWindowedSincInterpolateImageFunctionIUS23Hamming_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUS23Hamming"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS23Hamming_cast(obj)

class itkWindowedSincInterpolateImageFunctionIUS23Lanczos(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUS2D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUS23Lanczos_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionIUS23Lanczos_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS23Lanczos___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionIUS23Lanczos_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionIUS23Lanczos self) -> itkWindowedSincInterpolateImageFunctionIUS23Lanczos_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS23Lanczos_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUS23Lanczos

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUS23Lanczos *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUS23Lanczos"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS23Lanczos_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUS23Lanczos

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUS23Lanczos and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUS23Lanczos.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUS23Lanczos.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionIUS23Lanczos.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionIUS23Lanczos.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS23Lanczos_Clone, None, itkWindowedSincInterpolateImageFunctionIUS23Lanczos)
itkWindowedSincInterpolateImageFunctionIUS23Lanczos_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS23Lanczos_swigregister
itkWindowedSincInterpolateImageFunctionIUS23Lanczos_swigregister(itkWindowedSincInterpolateImageFunctionIUS23Lanczos)

def itkWindowedSincInterpolateImageFunctionIUS23Lanczos___New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUS23Lanczos_Pointer":
    """itkWindowedSincInterpolateImageFunctionIUS23Lanczos___New_orig__() -> itkWindowedSincInterpolateImageFunctionIUS23Lanczos_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS23Lanczos___New_orig__()

def itkWindowedSincInterpolateImageFunctionIUS23Lanczos_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUS23Lanczos *":
    """itkWindowedSincInterpolateImageFunctionIUS23Lanczos_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUS23Lanczos"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS23Lanczos_cast(obj)

class itkWindowedSincInterpolateImageFunctionIUS23Welch(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUS2D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUS23Welch_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionIUS23Welch_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS23Welch___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionIUS23Welch_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionIUS23Welch self) -> itkWindowedSincInterpolateImageFunctionIUS23Welch_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS23Welch_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUS23Welch

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUS23Welch *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUS23Welch"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS23Welch_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUS23Welch

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUS23Welch and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUS23Welch.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUS23Welch.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionIUS23Welch.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionIUS23Welch.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS23Welch_Clone, None, itkWindowedSincInterpolateImageFunctionIUS23Welch)
itkWindowedSincInterpolateImageFunctionIUS23Welch_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS23Welch_swigregister
itkWindowedSincInterpolateImageFunctionIUS23Welch_swigregister(itkWindowedSincInterpolateImageFunctionIUS23Welch)

def itkWindowedSincInterpolateImageFunctionIUS23Welch___New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUS23Welch_Pointer":
    """itkWindowedSincInterpolateImageFunctionIUS23Welch___New_orig__() -> itkWindowedSincInterpolateImageFunctionIUS23Welch_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS23Welch___New_orig__()

def itkWindowedSincInterpolateImageFunctionIUS23Welch_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUS23Welch *":
    """itkWindowedSincInterpolateImageFunctionIUS23Welch_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUS23Welch"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS23Welch_cast(obj)

class itkWindowedSincInterpolateImageFunctionIUS32Cosine(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUS3D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUS32Cosine_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionIUS32Cosine_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS32Cosine___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionIUS32Cosine_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionIUS32Cosine self) -> itkWindowedSincInterpolateImageFunctionIUS32Cosine_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS32Cosine_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUS32Cosine

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUS32Cosine *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUS32Cosine"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS32Cosine_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUS32Cosine

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUS32Cosine and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUS32Cosine.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUS32Cosine.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionIUS32Cosine.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionIUS32Cosine.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS32Cosine_Clone, None, itkWindowedSincInterpolateImageFunctionIUS32Cosine)
itkWindowedSincInterpolateImageFunctionIUS32Cosine_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS32Cosine_swigregister
itkWindowedSincInterpolateImageFunctionIUS32Cosine_swigregister(itkWindowedSincInterpolateImageFunctionIUS32Cosine)

def itkWindowedSincInterpolateImageFunctionIUS32Cosine___New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUS32Cosine_Pointer":
    """itkWindowedSincInterpolateImageFunctionIUS32Cosine___New_orig__() -> itkWindowedSincInterpolateImageFunctionIUS32Cosine_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS32Cosine___New_orig__()

def itkWindowedSincInterpolateImageFunctionIUS32Cosine_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUS32Cosine *":
    """itkWindowedSincInterpolateImageFunctionIUS32Cosine_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUS32Cosine"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS32Cosine_cast(obj)

class itkWindowedSincInterpolateImageFunctionIUS32Hamming(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUS3D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUS32Hamming_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionIUS32Hamming_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS32Hamming___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionIUS32Hamming_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionIUS32Hamming self) -> itkWindowedSincInterpolateImageFunctionIUS32Hamming_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS32Hamming_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUS32Hamming

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUS32Hamming *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUS32Hamming"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS32Hamming_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUS32Hamming

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUS32Hamming and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUS32Hamming.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUS32Hamming.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionIUS32Hamming.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionIUS32Hamming.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS32Hamming_Clone, None, itkWindowedSincInterpolateImageFunctionIUS32Hamming)
itkWindowedSincInterpolateImageFunctionIUS32Hamming_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS32Hamming_swigregister
itkWindowedSincInterpolateImageFunctionIUS32Hamming_swigregister(itkWindowedSincInterpolateImageFunctionIUS32Hamming)

def itkWindowedSincInterpolateImageFunctionIUS32Hamming___New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUS32Hamming_Pointer":
    """itkWindowedSincInterpolateImageFunctionIUS32Hamming___New_orig__() -> itkWindowedSincInterpolateImageFunctionIUS32Hamming_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS32Hamming___New_orig__()

def itkWindowedSincInterpolateImageFunctionIUS32Hamming_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUS32Hamming *":
    """itkWindowedSincInterpolateImageFunctionIUS32Hamming_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUS32Hamming"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS32Hamming_cast(obj)

class itkWindowedSincInterpolateImageFunctionIUS32Lanczos(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUS3D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUS32Lanczos_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionIUS32Lanczos_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS32Lanczos___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionIUS32Lanczos_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionIUS32Lanczos self) -> itkWindowedSincInterpolateImageFunctionIUS32Lanczos_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS32Lanczos_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUS32Lanczos

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUS32Lanczos *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUS32Lanczos"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS32Lanczos_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUS32Lanczos

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUS32Lanczos and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUS32Lanczos.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUS32Lanczos.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionIUS32Lanczos.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionIUS32Lanczos.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS32Lanczos_Clone, None, itkWindowedSincInterpolateImageFunctionIUS32Lanczos)
itkWindowedSincInterpolateImageFunctionIUS32Lanczos_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS32Lanczos_swigregister
itkWindowedSincInterpolateImageFunctionIUS32Lanczos_swigregister(itkWindowedSincInterpolateImageFunctionIUS32Lanczos)

def itkWindowedSincInterpolateImageFunctionIUS32Lanczos___New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUS32Lanczos_Pointer":
    """itkWindowedSincInterpolateImageFunctionIUS32Lanczos___New_orig__() -> itkWindowedSincInterpolateImageFunctionIUS32Lanczos_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS32Lanczos___New_orig__()

def itkWindowedSincInterpolateImageFunctionIUS32Lanczos_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUS32Lanczos *":
    """itkWindowedSincInterpolateImageFunctionIUS32Lanczos_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUS32Lanczos"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS32Lanczos_cast(obj)

class itkWindowedSincInterpolateImageFunctionIUS32Welch(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUS3D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUS32Welch_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionIUS32Welch_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS32Welch___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionIUS32Welch_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionIUS32Welch self) -> itkWindowedSincInterpolateImageFunctionIUS32Welch_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS32Welch_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUS32Welch

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUS32Welch *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUS32Welch"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS32Welch_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUS32Welch

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUS32Welch and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUS32Welch.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUS32Welch.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionIUS32Welch.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionIUS32Welch.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS32Welch_Clone, None, itkWindowedSincInterpolateImageFunctionIUS32Welch)
itkWindowedSincInterpolateImageFunctionIUS32Welch_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS32Welch_swigregister
itkWindowedSincInterpolateImageFunctionIUS32Welch_swigregister(itkWindowedSincInterpolateImageFunctionIUS32Welch)

def itkWindowedSincInterpolateImageFunctionIUS32Welch___New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUS32Welch_Pointer":
    """itkWindowedSincInterpolateImageFunctionIUS32Welch___New_orig__() -> itkWindowedSincInterpolateImageFunctionIUS32Welch_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS32Welch___New_orig__()

def itkWindowedSincInterpolateImageFunctionIUS32Welch_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUS32Welch *":
    """itkWindowedSincInterpolateImageFunctionIUS32Welch_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUS32Welch"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS32Welch_cast(obj)

class itkWindowedSincInterpolateImageFunctionIUS33Cosine(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUS3D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUS33Cosine_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionIUS33Cosine_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS33Cosine___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionIUS33Cosine_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionIUS33Cosine self) -> itkWindowedSincInterpolateImageFunctionIUS33Cosine_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS33Cosine_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUS33Cosine

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUS33Cosine *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUS33Cosine"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS33Cosine_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUS33Cosine

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUS33Cosine and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUS33Cosine.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUS33Cosine.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionIUS33Cosine.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionIUS33Cosine.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS33Cosine_Clone, None, itkWindowedSincInterpolateImageFunctionIUS33Cosine)
itkWindowedSincInterpolateImageFunctionIUS33Cosine_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS33Cosine_swigregister
itkWindowedSincInterpolateImageFunctionIUS33Cosine_swigregister(itkWindowedSincInterpolateImageFunctionIUS33Cosine)

def itkWindowedSincInterpolateImageFunctionIUS33Cosine___New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUS33Cosine_Pointer":
    """itkWindowedSincInterpolateImageFunctionIUS33Cosine___New_orig__() -> itkWindowedSincInterpolateImageFunctionIUS33Cosine_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS33Cosine___New_orig__()

def itkWindowedSincInterpolateImageFunctionIUS33Cosine_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUS33Cosine *":
    """itkWindowedSincInterpolateImageFunctionIUS33Cosine_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUS33Cosine"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS33Cosine_cast(obj)

class itkWindowedSincInterpolateImageFunctionIUS33Hamming(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUS3D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUS33Hamming_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionIUS33Hamming_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS33Hamming___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionIUS33Hamming_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionIUS33Hamming self) -> itkWindowedSincInterpolateImageFunctionIUS33Hamming_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS33Hamming_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUS33Hamming

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUS33Hamming *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUS33Hamming"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS33Hamming_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUS33Hamming

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUS33Hamming and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUS33Hamming.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUS33Hamming.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionIUS33Hamming.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionIUS33Hamming.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS33Hamming_Clone, None, itkWindowedSincInterpolateImageFunctionIUS33Hamming)
itkWindowedSincInterpolateImageFunctionIUS33Hamming_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS33Hamming_swigregister
itkWindowedSincInterpolateImageFunctionIUS33Hamming_swigregister(itkWindowedSincInterpolateImageFunctionIUS33Hamming)

def itkWindowedSincInterpolateImageFunctionIUS33Hamming___New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUS33Hamming_Pointer":
    """itkWindowedSincInterpolateImageFunctionIUS33Hamming___New_orig__() -> itkWindowedSincInterpolateImageFunctionIUS33Hamming_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS33Hamming___New_orig__()

def itkWindowedSincInterpolateImageFunctionIUS33Hamming_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUS33Hamming *":
    """itkWindowedSincInterpolateImageFunctionIUS33Hamming_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUS33Hamming"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS33Hamming_cast(obj)

class itkWindowedSincInterpolateImageFunctionIUS33Lanczos(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUS3D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUS33Lanczos_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionIUS33Lanczos_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS33Lanczos___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionIUS33Lanczos_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionIUS33Lanczos self) -> itkWindowedSincInterpolateImageFunctionIUS33Lanczos_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS33Lanczos_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUS33Lanczos

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUS33Lanczos *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUS33Lanczos"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS33Lanczos_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUS33Lanczos

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUS33Lanczos and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUS33Lanczos.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUS33Lanczos.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionIUS33Lanczos.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionIUS33Lanczos.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS33Lanczos_Clone, None, itkWindowedSincInterpolateImageFunctionIUS33Lanczos)
itkWindowedSincInterpolateImageFunctionIUS33Lanczos_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS33Lanczos_swigregister
itkWindowedSincInterpolateImageFunctionIUS33Lanczos_swigregister(itkWindowedSincInterpolateImageFunctionIUS33Lanczos)

def itkWindowedSincInterpolateImageFunctionIUS33Lanczos___New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUS33Lanczos_Pointer":
    """itkWindowedSincInterpolateImageFunctionIUS33Lanczos___New_orig__() -> itkWindowedSincInterpolateImageFunctionIUS33Lanczos_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS33Lanczos___New_orig__()

def itkWindowedSincInterpolateImageFunctionIUS33Lanczos_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUS33Lanczos *":
    """itkWindowedSincInterpolateImageFunctionIUS33Lanczos_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUS33Lanczos"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS33Lanczos_cast(obj)

class itkWindowedSincInterpolateImageFunctionIUS33Welch(itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUS3D):
    """


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction

    C++ includes: itkWindowedSincInterpolateImageFunction.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUS33Welch_Pointer":
        """__New_orig__() -> itkWindowedSincInterpolateImageFunctionIUS33Welch_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS33Welch___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkWindowedSincInterpolateImageFunctionIUS33Welch_Pointer":
        """Clone(itkWindowedSincInterpolateImageFunctionIUS33Welch self) -> itkWindowedSincInterpolateImageFunctionIUS33Welch_Pointer"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS33Welch_Clone(self)

    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUS33Welch

    def cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUS33Welch *":
        """cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUS33Welch"""
        return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS33Welch_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUS33Welch

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUS33Welch and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUS33Welch.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUS33Welch.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkWindowedSincInterpolateImageFunctionIUS33Welch.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkWindowedSincInterpolateImageFunctionIUS33Welch.Clone = new_instancemethod(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS33Welch_Clone, None, itkWindowedSincInterpolateImageFunctionIUS33Welch)
itkWindowedSincInterpolateImageFunctionIUS33Welch_swigregister = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS33Welch_swigregister
itkWindowedSincInterpolateImageFunctionIUS33Welch_swigregister(itkWindowedSincInterpolateImageFunctionIUS33Welch)

def itkWindowedSincInterpolateImageFunctionIUS33Welch___New_orig__() -> "itkWindowedSincInterpolateImageFunctionIUS33Welch_Pointer":
    """itkWindowedSincInterpolateImageFunctionIUS33Welch___New_orig__() -> itkWindowedSincInterpolateImageFunctionIUS33Welch_Pointer"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS33Welch___New_orig__()

def itkWindowedSincInterpolateImageFunctionIUS33Welch_cast(obj: 'itkLightObject') -> "itkWindowedSincInterpolateImageFunctionIUS33Welch *":
    """itkWindowedSincInterpolateImageFunctionIUS33Welch_cast(itkLightObject obj) -> itkWindowedSincInterpolateImageFunctionIUS33Welch"""
    return _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS33Welch_cast(obj)



