# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.8
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _itkAffineTransformPython.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_itkAffineTransformPython', [dirname(__file__)])
        except ImportError:
            import _itkAffineTransformPython
            return _itkAffineTransformPython
        if fp is not None:
            try:
                _mod = imp.load_module('_itkAffineTransformPython', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _itkAffineTransformPython = swig_import_helper()
    del swig_import_helper
else:
    import _itkAffineTransformPython
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0



def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


import itkTransformBasePython
import itkDiffusionTensor3DPython
import itkSymmetricSecondRankTensorPython
import itkFixedArrayPython
import pyBasePython
import itkMatrixPython
import vnl_matrix_fixedPython
import vnl_matrixPython
import vnl_vectorPython
import stdcomplexPython
import itkVectorPython
import vnl_vector_refPython
import itkCovariantVectorPython
import itkPointPython
import itkArray2DPython
import itkVariableLengthVectorPython
import itkOptimizerParametersPython
import itkArrayPython
import ITKCommonBasePython
import itkMatrixOffsetTransformBasePython

def itkAffineTransformD3_New():
  return itkAffineTransformD3.New()


def itkAffineTransformD2_New():
  return itkAffineTransformD2.New()

class itkAffineTransformD2(itkMatrixOffsetTransformBasePython.itkMatrixOffsetTransformBaseD22):
    """


    Affine transformation of a vector space (e.g. space coordinates)

    This class allows the definition and manipulation of affine
    transformations of an n-dimensional affine space (and its associated
    vector space) onto itself. One common use is to define and manipulate
    Euclidean coordinate transformations in two and three dimensions, but
    other uses are possible as well.

    An affine transformation is defined mathematically as a linear
    transformation plus a constant offset. If A is a constant n x n matrix
    and b is a constant n-vector, then y = Ax+b defines an affine
    transformation from the n-vector x to the n-vector y.

    The difference between two points is a vector and transforms linearly,
    using the matrix only. That is, (y1-y2) = A*(x1-x2).

    The AffineTransform class determines whether to transform an object as
    a point or a vector by examining its type. An object of type Point
    transforms as a point; an object of type Vector transforms as a
    vector.

    One common use of affine transformations is to define coordinate
    conversions in two- and three-dimensional space. In this application,
    x is a two- or three-dimensional vector containing the "source"
    coordinates of a point, y is a vector containing the "target"
    coordinates, the matrix A defines the scaling and rotation of the
    coordinate systems from the source to the target, and b defines the
    translation of the origin from the source to the target. More
    generally, A can also define anisotropic scaling and shearing
    transformations. Any good textbook on computer graphics will discuss
    coordinate transformations in more detail. Several of the methods in
    this class are designed for this purpose and use the language
    appropriate to coordinate conversions.

    Any two affine transformations may be composed and the result is
    another affine transformation. However, the order is important. Given
    two affine transformations T1 and T2, we will say that "precomposing
    T1 with T2" yields the transformation which applies T1 to the source,
    and then applies T2 to that result to obtain the target. Conversely,
    we will say that "postcomposing T1 with T2" yields the
    transformation which applies T2 to the source, and then applies T1 to
    that result to obtain the target. (Whether T1 or T2 comes first
    lexicographically depends on whether you choose to write mappings from
    right-to-left or vice versa; we avoid the whole problem by referring
    to the order of application rather than the textual order.)

    There are two template parameters for this class:

    TParametersValueType The type to be used for scalar numeric values.
    Either float or double.

    NDimensions The number of dimensions of the vector space.

    This class provides several methods for setting the matrix and vector
    defining the transform. To support the registration framework, the
    transform parameters can also be set as an Array<double> of size
    (NDimension + 1) * NDimension using method SetParameters(). The first
    (NDimension x NDimension) parameters defines the matrix in row-major
    order (where the column index varies the fastest). The last NDimension
    parameters defines the translation in each dimensions.

    This class also supports the specification of a center of rotation
    (center) and a translation that is applied with respect to that
    centered rotation. By default the center of rotation is set to the
    origin.

    C++ includes: itkAffineTransform.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkAffineTransformD2_Pointer":
        """__New_orig__() -> itkAffineTransformD2_Pointer"""
        return _itkAffineTransformPython.itkAffineTransformD2___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkAffineTransformD2_Pointer":
        """Clone(itkAffineTransformD2 self) -> itkAffineTransformD2_Pointer"""
        return _itkAffineTransformPython.itkAffineTransformD2_Clone(self)


    def Translate(self, offset: 'itkVectorD2', pre: 'bool'=False) -> "void":
        """
        Translate(itkAffineTransformD2 self, itkVectorD2 offset, bool pre=False)
        Translate(itkAffineTransformD2 self, itkVectorD2 offset)

        Compose affine
        transformation with a translation

        This method modifies self to include a translation of the origin. The
        translation is precomposed with self if pre is true, and postcomposed
        otherwise. This updates Translation based on current center. 
        """
        return _itkAffineTransformPython.itkAffineTransformD2_Translate(self, offset, pre)


    def Scale(self, *args) -> "void":
        """
        Scale(itkAffineTransformD2 self, itkVectorD2 factor, bool pre=False)
        Scale(itkAffineTransformD2 self, itkVectorD2 factor)
        Scale(itkAffineTransformD2 self, double const & factor, bool pre=False)
        Scale(itkAffineTransformD2 self, double const & factor)

        Compose affine transformation
        with a scaling

        This method modifies self to magnify the source by a given factor
        along each axis. If all factors are the same, or only a single factor
        is given, then the scaling is isotropic; otherwise it is anisotropic.
        If an odd number of factors are negative, then the parity of the image
        changes. If any of the factors is zero, then the transformation
        becomes a projection and is not invertible. The scaling is precomposed
        with self if pre is true, and postcomposed otherwise. Note that the
        scaling is applied centered at the origin. 
        """
        return _itkAffineTransformPython.itkAffineTransformD2_Scale(self, *args)


    def Rotate(self, axis1: 'int', axis2: 'int', angle: 'double', pre: 'bool'=False) -> "void":
        """
        Rotate(itkAffineTransformD2 self, int axis1, int axis2, double angle, bool pre=False)
        Rotate(itkAffineTransformD2 self, int axis1, int axis2, double angle)

        Compose affine
        transformation with an elementary rotation

        This method composes self with a rotation that affects two specified
        axes, replacing the current value of self. The rotation angle is in
        radians. The axis of rotation goes through the origin. The
        transformation is given by

        y[axis1] = std::cos(angle)*x[axis1] + std::sin(angle)*x[axis2]
        y[axis2] = -sin(angle)*x[axis1] + std::cos(angle)*x[axis2].

        All coordinates other than axis1 and axis2 are unchanged; a rotation
        of pi/2 radians will carry +axis1 into +axis2. The rotation is
        precomposed with self if pre is true, and postcomposed otherwise. Note
        that the rotation is applied centered at the origin. 
        """
        return _itkAffineTransformPython.itkAffineTransformD2_Rotate(self, axis1, axis2, angle, pre)


    def Rotate2D(self, angle: 'double', pre: 'bool'=False) -> "void":
        """
        Rotate2D(itkAffineTransformD2 self, double angle, bool pre=False)
        Rotate2D(itkAffineTransformD2 self, double angle)

        Compose 2D affine
        transformation with a rotation

        This method composes self, which must be a 2D affine transformation,
        with a clockwise rotation through a given angle in radians. The center
        of rotation is the origin. The rotation is precomposed with self if
        pre is true, and postcomposed otherwise. Note that the rotation is
        applied centered at the origin.

        WARNING:  Only to be use in two dimensions Todo Find a way to generate
        a compile-time error is this is used with NDimensions != 2. 
        """
        return _itkAffineTransformPython.itkAffineTransformD2_Rotate2D(self, angle, pre)


    def Rotate3D(self, axis: 'itkVectorD2', angle: 'double', pre: 'bool'=False) -> "void":
        """
        Rotate3D(itkAffineTransformD2 self, itkVectorD2 axis, double angle, bool pre=False)
        Rotate3D(itkAffineTransformD2 self, itkVectorD2 axis, double angle)

        Compose 3D affine
        transformation with a rotation

        This method composes self, which must be a 3D affine transformation,
        with a clockwise rotation around a specified axis. The rotation angle
        is in radians; the axis of rotation goes through the origin. The
        rotation is precomposed with self if pre is true, and postcomposed
        otherwise. Note that the rotation is applied centered at the origin.

        WARNING:  Only to be used in dimension 3 Todo Find a way to generate a
        compile-time error is this is used with NDimensions != 3. 
        """
        return _itkAffineTransformPython.itkAffineTransformD2_Rotate3D(self, axis, angle, pre)


    def Shear(self, axis1: 'int', axis2: 'int', coef: 'double', pre: 'bool'=False) -> "void":
        """
        Shear(itkAffineTransformD2 self, int axis1, int axis2, double coef, bool pre=False)
        Shear(itkAffineTransformD2 self, int axis1, int axis2, double coef)

        Compose affine transformation
        with a shear

        This method composes self with a shear transformation, replacing the
        original contents of self. The shear is precomposed with self if pre
        is true, and postcomposed otherwise. The transformation is given by

        y[axis1] = x[axis1] + coef*x[axis2] y[axis2] = x[axis2].

        Note that the shear is applied centered at the origin. 
        """
        return _itkAffineTransformPython.itkAffineTransformD2_Shear(self, axis1, axis2, coef, pre)


    def GetInverse(self, inverse: 'itkAffineTransformD2') -> "bool":
        """
        GetInverse(itkAffineTransformD2 self, itkAffineTransformD2 inverse) -> bool

        Get an inverse of this
        transform. 
        """
        return _itkAffineTransformPython.itkAffineTransformD2_GetInverse(self, inverse)


    def Metric(self, *args) -> "double":
        """
        Metric(itkAffineTransformD2 self, itkAffineTransformD2 other) -> double
        Metric(itkAffineTransformD2 self) -> double

        This method computes the
        distance from self to the identity transformation, using the same
        metric as the one-argument form of the Metric() method. 
        """
        return _itkAffineTransformPython.itkAffineTransformD2_Metric(self, *args)

    __swig_destroy__ = _itkAffineTransformPython.delete_itkAffineTransformD2

    def cast(obj: 'itkLightObject') -> "itkAffineTransformD2 *":
        """cast(itkLightObject obj) -> itkAffineTransformD2"""
        return _itkAffineTransformPython.itkAffineTransformD2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkAffineTransformD2

        Create a new object of the class itkAffineTransformD2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkAffineTransformD2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkAffineTransformD2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkAffineTransformD2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkAffineTransformD2.Clone = new_instancemethod(_itkAffineTransformPython.itkAffineTransformD2_Clone, None, itkAffineTransformD2)
itkAffineTransformD2.Translate = new_instancemethod(_itkAffineTransformPython.itkAffineTransformD2_Translate, None, itkAffineTransformD2)
itkAffineTransformD2.Scale = new_instancemethod(_itkAffineTransformPython.itkAffineTransformD2_Scale, None, itkAffineTransformD2)
itkAffineTransformD2.Rotate = new_instancemethod(_itkAffineTransformPython.itkAffineTransformD2_Rotate, None, itkAffineTransformD2)
itkAffineTransformD2.Rotate2D = new_instancemethod(_itkAffineTransformPython.itkAffineTransformD2_Rotate2D, None, itkAffineTransformD2)
itkAffineTransformD2.Rotate3D = new_instancemethod(_itkAffineTransformPython.itkAffineTransformD2_Rotate3D, None, itkAffineTransformD2)
itkAffineTransformD2.Shear = new_instancemethod(_itkAffineTransformPython.itkAffineTransformD2_Shear, None, itkAffineTransformD2)
itkAffineTransformD2.GetInverse = new_instancemethod(_itkAffineTransformPython.itkAffineTransformD2_GetInverse, None, itkAffineTransformD2)
itkAffineTransformD2.Metric = new_instancemethod(_itkAffineTransformPython.itkAffineTransformD2_Metric, None, itkAffineTransformD2)
itkAffineTransformD2_swigregister = _itkAffineTransformPython.itkAffineTransformD2_swigregister
itkAffineTransformD2_swigregister(itkAffineTransformD2)

def itkAffineTransformD2___New_orig__() -> "itkAffineTransformD2_Pointer":
    """itkAffineTransformD2___New_orig__() -> itkAffineTransformD2_Pointer"""
    return _itkAffineTransformPython.itkAffineTransformD2___New_orig__()

def itkAffineTransformD2_cast(obj: 'itkLightObject') -> "itkAffineTransformD2 *":
    """itkAffineTransformD2_cast(itkLightObject obj) -> itkAffineTransformD2"""
    return _itkAffineTransformPython.itkAffineTransformD2_cast(obj)

class itkAffineTransformD3(itkMatrixOffsetTransformBasePython.itkMatrixOffsetTransformBaseD33):
    """


    Affine transformation of a vector space (e.g. space coordinates)

    This class allows the definition and manipulation of affine
    transformations of an n-dimensional affine space (and its associated
    vector space) onto itself. One common use is to define and manipulate
    Euclidean coordinate transformations in two and three dimensions, but
    other uses are possible as well.

    An affine transformation is defined mathematically as a linear
    transformation plus a constant offset. If A is a constant n x n matrix
    and b is a constant n-vector, then y = Ax+b defines an affine
    transformation from the n-vector x to the n-vector y.

    The difference between two points is a vector and transforms linearly,
    using the matrix only. That is, (y1-y2) = A*(x1-x2).

    The AffineTransform class determines whether to transform an object as
    a point or a vector by examining its type. An object of type Point
    transforms as a point; an object of type Vector transforms as a
    vector.

    One common use of affine transformations is to define coordinate
    conversions in two- and three-dimensional space. In this application,
    x is a two- or three-dimensional vector containing the "source"
    coordinates of a point, y is a vector containing the "target"
    coordinates, the matrix A defines the scaling and rotation of the
    coordinate systems from the source to the target, and b defines the
    translation of the origin from the source to the target. More
    generally, A can also define anisotropic scaling and shearing
    transformations. Any good textbook on computer graphics will discuss
    coordinate transformations in more detail. Several of the methods in
    this class are designed for this purpose and use the language
    appropriate to coordinate conversions.

    Any two affine transformations may be composed and the result is
    another affine transformation. However, the order is important. Given
    two affine transformations T1 and T2, we will say that "precomposing
    T1 with T2" yields the transformation which applies T1 to the source,
    and then applies T2 to that result to obtain the target. Conversely,
    we will say that "postcomposing T1 with T2" yields the
    transformation which applies T2 to the source, and then applies T1 to
    that result to obtain the target. (Whether T1 or T2 comes first
    lexicographically depends on whether you choose to write mappings from
    right-to-left or vice versa; we avoid the whole problem by referring
    to the order of application rather than the textual order.)

    There are two template parameters for this class:

    TParametersValueType The type to be used for scalar numeric values.
    Either float or double.

    NDimensions The number of dimensions of the vector space.

    This class provides several methods for setting the matrix and vector
    defining the transform. To support the registration framework, the
    transform parameters can also be set as an Array<double> of size
    (NDimension + 1) * NDimension using method SetParameters(). The first
    (NDimension x NDimension) parameters defines the matrix in row-major
    order (where the column index varies the fastest). The last NDimension
    parameters defines the translation in each dimensions.

    This class also supports the specification of a center of rotation
    (center) and a translation that is applied with respect to that
    centered rotation. By default the center of rotation is set to the
    origin.

    C++ includes: itkAffineTransform.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkAffineTransformD3_Pointer":
        """__New_orig__() -> itkAffineTransformD3_Pointer"""
        return _itkAffineTransformPython.itkAffineTransformD3___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkAffineTransformD3_Pointer":
        """Clone(itkAffineTransformD3 self) -> itkAffineTransformD3_Pointer"""
        return _itkAffineTransformPython.itkAffineTransformD3_Clone(self)


    def Translate(self, offset: 'itkVectorD3', pre: 'bool'=False) -> "void":
        """
        Translate(itkAffineTransformD3 self, itkVectorD3 offset, bool pre=False)
        Translate(itkAffineTransformD3 self, itkVectorD3 offset)

        Compose affine
        transformation with a translation

        This method modifies self to include a translation of the origin. The
        translation is precomposed with self if pre is true, and postcomposed
        otherwise. This updates Translation based on current center. 
        """
        return _itkAffineTransformPython.itkAffineTransformD3_Translate(self, offset, pre)


    def Scale(self, *args) -> "void":
        """
        Scale(itkAffineTransformD3 self, itkVectorD3 factor, bool pre=False)
        Scale(itkAffineTransformD3 self, itkVectorD3 factor)
        Scale(itkAffineTransformD3 self, double const & factor, bool pre=False)
        Scale(itkAffineTransformD3 self, double const & factor)

        Compose affine transformation
        with a scaling

        This method modifies self to magnify the source by a given factor
        along each axis. If all factors are the same, or only a single factor
        is given, then the scaling is isotropic; otherwise it is anisotropic.
        If an odd number of factors are negative, then the parity of the image
        changes. If any of the factors is zero, then the transformation
        becomes a projection and is not invertible. The scaling is precomposed
        with self if pre is true, and postcomposed otherwise. Note that the
        scaling is applied centered at the origin. 
        """
        return _itkAffineTransformPython.itkAffineTransformD3_Scale(self, *args)


    def Rotate(self, axis1: 'int', axis2: 'int', angle: 'double', pre: 'bool'=False) -> "void":
        """
        Rotate(itkAffineTransformD3 self, int axis1, int axis2, double angle, bool pre=False)
        Rotate(itkAffineTransformD3 self, int axis1, int axis2, double angle)

        Compose affine
        transformation with an elementary rotation

        This method composes self with a rotation that affects two specified
        axes, replacing the current value of self. The rotation angle is in
        radians. The axis of rotation goes through the origin. The
        transformation is given by

        y[axis1] = std::cos(angle)*x[axis1] + std::sin(angle)*x[axis2]
        y[axis2] = -sin(angle)*x[axis1] + std::cos(angle)*x[axis2].

        All coordinates other than axis1 and axis2 are unchanged; a rotation
        of pi/2 radians will carry +axis1 into +axis2. The rotation is
        precomposed with self if pre is true, and postcomposed otherwise. Note
        that the rotation is applied centered at the origin. 
        """
        return _itkAffineTransformPython.itkAffineTransformD3_Rotate(self, axis1, axis2, angle, pre)


    def Rotate2D(self, angle: 'double', pre: 'bool'=False) -> "void":
        """
        Rotate2D(itkAffineTransformD3 self, double angle, bool pre=False)
        Rotate2D(itkAffineTransformD3 self, double angle)

        Compose 2D affine
        transformation with a rotation

        This method composes self, which must be a 2D affine transformation,
        with a clockwise rotation through a given angle in radians. The center
        of rotation is the origin. The rotation is precomposed with self if
        pre is true, and postcomposed otherwise. Note that the rotation is
        applied centered at the origin.

        WARNING:  Only to be use in two dimensions Todo Find a way to generate
        a compile-time error is this is used with NDimensions != 2. 
        """
        return _itkAffineTransformPython.itkAffineTransformD3_Rotate2D(self, angle, pre)


    def Rotate3D(self, axis: 'itkVectorD3', angle: 'double', pre: 'bool'=False) -> "void":
        """
        Rotate3D(itkAffineTransformD3 self, itkVectorD3 axis, double angle, bool pre=False)
        Rotate3D(itkAffineTransformD3 self, itkVectorD3 axis, double angle)

        Compose 3D affine
        transformation with a rotation

        This method composes self, which must be a 3D affine transformation,
        with a clockwise rotation around a specified axis. The rotation angle
        is in radians; the axis of rotation goes through the origin. The
        rotation is precomposed with self if pre is true, and postcomposed
        otherwise. Note that the rotation is applied centered at the origin.

        WARNING:  Only to be used in dimension 3 Todo Find a way to generate a
        compile-time error is this is used with NDimensions != 3. 
        """
        return _itkAffineTransformPython.itkAffineTransformD3_Rotate3D(self, axis, angle, pre)


    def Shear(self, axis1: 'int', axis2: 'int', coef: 'double', pre: 'bool'=False) -> "void":
        """
        Shear(itkAffineTransformD3 self, int axis1, int axis2, double coef, bool pre=False)
        Shear(itkAffineTransformD3 self, int axis1, int axis2, double coef)

        Compose affine transformation
        with a shear

        This method composes self with a shear transformation, replacing the
        original contents of self. The shear is precomposed with self if pre
        is true, and postcomposed otherwise. The transformation is given by

        y[axis1] = x[axis1] + coef*x[axis2] y[axis2] = x[axis2].

        Note that the shear is applied centered at the origin. 
        """
        return _itkAffineTransformPython.itkAffineTransformD3_Shear(self, axis1, axis2, coef, pre)


    def GetInverse(self, inverse: 'itkAffineTransformD3') -> "bool":
        """
        GetInverse(itkAffineTransformD3 self, itkAffineTransformD3 inverse) -> bool

        Get an inverse of this
        transform. 
        """
        return _itkAffineTransformPython.itkAffineTransformD3_GetInverse(self, inverse)


    def Metric(self, *args) -> "double":
        """
        Metric(itkAffineTransformD3 self, itkAffineTransformD3 other) -> double
        Metric(itkAffineTransformD3 self) -> double

        This method computes the
        distance from self to the identity transformation, using the same
        metric as the one-argument form of the Metric() method. 
        """
        return _itkAffineTransformPython.itkAffineTransformD3_Metric(self, *args)

    __swig_destroy__ = _itkAffineTransformPython.delete_itkAffineTransformD3

    def cast(obj: 'itkLightObject') -> "itkAffineTransformD3 *":
        """cast(itkLightObject obj) -> itkAffineTransformD3"""
        return _itkAffineTransformPython.itkAffineTransformD3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkAffineTransformD3

        Create a new object of the class itkAffineTransformD3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkAffineTransformD3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkAffineTransformD3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkAffineTransformD3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkAffineTransformD3.Clone = new_instancemethod(_itkAffineTransformPython.itkAffineTransformD3_Clone, None, itkAffineTransformD3)
itkAffineTransformD3.Translate = new_instancemethod(_itkAffineTransformPython.itkAffineTransformD3_Translate, None, itkAffineTransformD3)
itkAffineTransformD3.Scale = new_instancemethod(_itkAffineTransformPython.itkAffineTransformD3_Scale, None, itkAffineTransformD3)
itkAffineTransformD3.Rotate = new_instancemethod(_itkAffineTransformPython.itkAffineTransformD3_Rotate, None, itkAffineTransformD3)
itkAffineTransformD3.Rotate2D = new_instancemethod(_itkAffineTransformPython.itkAffineTransformD3_Rotate2D, None, itkAffineTransformD3)
itkAffineTransformD3.Rotate3D = new_instancemethod(_itkAffineTransformPython.itkAffineTransformD3_Rotate3D, None, itkAffineTransformD3)
itkAffineTransformD3.Shear = new_instancemethod(_itkAffineTransformPython.itkAffineTransformD3_Shear, None, itkAffineTransformD3)
itkAffineTransformD3.GetInverse = new_instancemethod(_itkAffineTransformPython.itkAffineTransformD3_GetInverse, None, itkAffineTransformD3)
itkAffineTransformD3.Metric = new_instancemethod(_itkAffineTransformPython.itkAffineTransformD3_Metric, None, itkAffineTransformD3)
itkAffineTransformD3_swigregister = _itkAffineTransformPython.itkAffineTransformD3_swigregister
itkAffineTransformD3_swigregister(itkAffineTransformD3)

def itkAffineTransformD3___New_orig__() -> "itkAffineTransformD3_Pointer":
    """itkAffineTransformD3___New_orig__() -> itkAffineTransformD3_Pointer"""
    return _itkAffineTransformPython.itkAffineTransformD3___New_orig__()

def itkAffineTransformD3_cast(obj: 'itkLightObject') -> "itkAffineTransformD3 *":
    """itkAffineTransformD3_cast(itkLightObject obj) -> itkAffineTransformD3"""
    return _itkAffineTransformPython.itkAffineTransformD3_cast(obj)



