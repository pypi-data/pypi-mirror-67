# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.8
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _itkImageToImageFilterAPython.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_itkImageToImageFilterAPython', [dirname(__file__)])
        except ImportError:
            import _itkImageToImageFilterAPython
            return _itkImageToImageFilterAPython
        if fp is not None:
            try:
                _mod = imp.load_module('_itkImageToImageFilterAPython', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _itkImageToImageFilterAPython = swig_import_helper()
    del swig_import_helper
else:
    import _itkImageToImageFilterAPython
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0



def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


import itkImagePython
import itkSymmetricSecondRankTensorPython
import itkFixedArrayPython
import pyBasePython
import itkMatrixPython
import vnl_vectorPython
import vnl_matrixPython
import stdcomplexPython
import itkPointPython
import vnl_vector_refPython
import itkVectorPython
import vnl_matrix_fixedPython
import itkCovariantVectorPython
import itkIndexPython
import itkSizePython
import itkOffsetPython
import itkImageRegionPython
import ITKCommonBasePython
import itkRGBAPixelPython
import itkRGBPixelPython
import itkImageToImageFilterCommonPython
import itkVectorImagePython
import itkVariableLengthVectorPython
import itkImageSourcePython
import itkImageSourceCommonPython

def itkImageToImageFilterIRGBAUC3IRGBAUC3_New():
  return itkImageToImageFilterIRGBAUC3IRGBAUC3.New()


def itkImageToImageFilterIRGBAUC2IRGBAUC2_New():
  return itkImageToImageFilterIRGBAUC2IRGBAUC2.New()


def itkImageToImageFilterIRGBUC3IRGBUC3_New():
  return itkImageToImageFilterIRGBUC3IRGBUC3.New()


def itkImageToImageFilterIRGBUC2IRGBUC2_New():
  return itkImageToImageFilterIRGBUC2IRGBUC2.New()


def itkImageToImageFilterIVF23ICVF43_New():
  return itkImageToImageFilterIVF23ICVF43.New()


def itkImageToImageFilterIVF22ICVF42_New():
  return itkImageToImageFilterIVF22ICVF42.New()


def itkImageToImageFilterICVF43ICVF43_New():
  return itkImageToImageFilterICVF43ICVF43.New()


def itkImageToImageFilterICVF42ICVF42_New():
  return itkImageToImageFilterICVF42ICVF42.New()


def itkImageToImageFilterICVF33ICVF33_New():
  return itkImageToImageFilterICVF33ICVF33.New()


def itkImageToImageFilterICVF32ICVF32_New():
  return itkImageToImageFilterICVF32ICVF32.New()


def itkImageToImageFilterICVF23ICVF23_New():
  return itkImageToImageFilterICVF23ICVF23.New()


def itkImageToImageFilterICVF22ICVF22_New():
  return itkImageToImageFilterICVF22ICVF22.New()


def itkImageToImageFilterICVF43IVF43_New():
  return itkImageToImageFilterICVF43IVF43.New()


def itkImageToImageFilterICVF42IVF42_New():
  return itkImageToImageFilterICVF42IVF42.New()


def itkImageToImageFilterICVF33IVF33_New():
  return itkImageToImageFilterICVF33IVF33.New()


def itkImageToImageFilterICVF32IVF32_New():
  return itkImageToImageFilterICVF32IVF32.New()


def itkImageToImageFilterICVF23IVF23_New():
  return itkImageToImageFilterICVF23IVF23.New()


def itkImageToImageFilterICVF22IVF22_New():
  return itkImageToImageFilterICVF22IVF22.New()


def itkImageToImageFilterIVF43ICVF43_New():
  return itkImageToImageFilterIVF43ICVF43.New()


def itkImageToImageFilterIVF42ICVF42_New():
  return itkImageToImageFilterIVF42ICVF42.New()


def itkImageToImageFilterIVF33ICVF33_New():
  return itkImageToImageFilterIVF33ICVF33.New()


def itkImageToImageFilterIVF32ICVF32_New():
  return itkImageToImageFilterIVF32ICVF32.New()


def itkImageToImageFilterIVF23ICVF23_New():
  return itkImageToImageFilterIVF23ICVF23.New()


def itkImageToImageFilterIVF22ICVF22_New():
  return itkImageToImageFilterIVF22ICVF22.New()


def itkImageToImageFilterIVF43IVF43_New():
  return itkImageToImageFilterIVF43IVF43.New()


def itkImageToImageFilterIVF42IVF42_New():
  return itkImageToImageFilterIVF42IVF42.New()


def itkImageToImageFilterIVF33IVF33_New():
  return itkImageToImageFilterIVF33IVF33.New()


def itkImageToImageFilterIVF32IVF32_New():
  return itkImageToImageFilterIVF32IVF32.New()


def itkImageToImageFilterIVF23IVF23_New():
  return itkImageToImageFilterIVF23IVF23.New()


def itkImageToImageFilterIVF22IVF22_New():
  return itkImageToImageFilterIVF22IVF22.New()


def itkImageToImageFilterVID3VID3_New():
  return itkImageToImageFilterVID3VID3.New()


def itkImageToImageFilterVIF3VIF3_New():
  return itkImageToImageFilterVIF3VIF3.New()


def itkImageToImageFilterVIUS3VIUS3_New():
  return itkImageToImageFilterVIUS3VIUS3.New()


def itkImageToImageFilterVISS3VISS3_New():
  return itkImageToImageFilterVISS3VISS3.New()


def itkImageToImageFilterVIUC3VIUC3_New():
  return itkImageToImageFilterVIUC3VIUC3.New()


def itkImageToImageFilterVID2VID2_New():
  return itkImageToImageFilterVID2VID2.New()


def itkImageToImageFilterVIF2VIF2_New():
  return itkImageToImageFilterVIF2VIF2.New()


def itkImageToImageFilterVIUS2VIUS2_New():
  return itkImageToImageFilterVIUS2VIUS2.New()


def itkImageToImageFilterVISS2VISS2_New():
  return itkImageToImageFilterVISS2VISS2.New()


def itkImageToImageFilterVIUC2VIUC2_New():
  return itkImageToImageFilterVIUC2VIUC2.New()


def itkImageToImageFilterID3ID3_New():
  return itkImageToImageFilterID3ID3.New()


def itkImageToImageFilterID2ID2_New():
  return itkImageToImageFilterID2ID2.New()


def itkImageToImageFilterID3IF3_New():
  return itkImageToImageFilterID3IF3.New()


def itkImageToImageFilterID2IF2_New():
  return itkImageToImageFilterID2IF2.New()


def itkImageToImageFilterID3IUS3_New():
  return itkImageToImageFilterID3IUS3.New()


def itkImageToImageFilterID2IUS2_New():
  return itkImageToImageFilterID2IUS2.New()


def itkImageToImageFilterID3ISS3_New():
  return itkImageToImageFilterID3ISS3.New()


def itkImageToImageFilterID2ISS2_New():
  return itkImageToImageFilterID2ISS2.New()


def itkImageToImageFilterID3IUL3_New():
  return itkImageToImageFilterID3IUL3.New()


def itkImageToImageFilterID2IUL2_New():
  return itkImageToImageFilterID2IUL2.New()


def itkImageToImageFilterID3IUC3_New():
  return itkImageToImageFilterID3IUC3.New()


def itkImageToImageFilterID2IUC2_New():
  return itkImageToImageFilterID2IUC2.New()


def itkImageToImageFilterIF3ID3_New():
  return itkImageToImageFilterIF3ID3.New()


def itkImageToImageFilterIF2ID2_New():
  return itkImageToImageFilterIF2ID2.New()


def itkImageToImageFilterIF3IF3_New():
  return itkImageToImageFilterIF3IF3.New()


def itkImageToImageFilterIF2IF2_New():
  return itkImageToImageFilterIF2IF2.New()


def itkImageToImageFilterIF3IUS3_New():
  return itkImageToImageFilterIF3IUS3.New()


def itkImageToImageFilterIF2IUS2_New():
  return itkImageToImageFilterIF2IUS2.New()


def itkImageToImageFilterIF3ISS3_New():
  return itkImageToImageFilterIF3ISS3.New()


def itkImageToImageFilterIF2ISS2_New():
  return itkImageToImageFilterIF2ISS2.New()


def itkImageToImageFilterIF3IUL3_New():
  return itkImageToImageFilterIF3IUL3.New()


def itkImageToImageFilterIF2IUL2_New():
  return itkImageToImageFilterIF2IUL2.New()


def itkImageToImageFilterIF3IUC3_New():
  return itkImageToImageFilterIF3IUC3.New()


def itkImageToImageFilterIF2IUC2_New():
  return itkImageToImageFilterIF2IUC2.New()


def itkImageToImageFilterIUS3ID3_New():
  return itkImageToImageFilterIUS3ID3.New()


def itkImageToImageFilterIUS2ID2_New():
  return itkImageToImageFilterIUS2ID2.New()


def itkImageToImageFilterIUS3IF3_New():
  return itkImageToImageFilterIUS3IF3.New()


def itkImageToImageFilterIUS2IF2_New():
  return itkImageToImageFilterIUS2IF2.New()


def itkImageToImageFilterIUS3IUS3_New():
  return itkImageToImageFilterIUS3IUS3.New()


def itkImageToImageFilterIUS2IUS2_New():
  return itkImageToImageFilterIUS2IUS2.New()


def itkImageToImageFilterIUS3ISS3_New():
  return itkImageToImageFilterIUS3ISS3.New()


def itkImageToImageFilterIUS2ISS2_New():
  return itkImageToImageFilterIUS2ISS2.New()


def itkImageToImageFilterIUS3IUL3_New():
  return itkImageToImageFilterIUS3IUL3.New()


def itkImageToImageFilterIUS2IUL2_New():
  return itkImageToImageFilterIUS2IUL2.New()


def itkImageToImageFilterIUS3IUC3_New():
  return itkImageToImageFilterIUS3IUC3.New()


def itkImageToImageFilterIUS2IUC2_New():
  return itkImageToImageFilterIUS2IUC2.New()


def itkImageToImageFilterISS3ID3_New():
  return itkImageToImageFilterISS3ID3.New()


def itkImageToImageFilterISS2ID2_New():
  return itkImageToImageFilterISS2ID2.New()


def itkImageToImageFilterISS3IF3_New():
  return itkImageToImageFilterISS3IF3.New()


def itkImageToImageFilterISS2IF2_New():
  return itkImageToImageFilterISS2IF2.New()


def itkImageToImageFilterISS3IUS3_New():
  return itkImageToImageFilterISS3IUS3.New()


def itkImageToImageFilterISS2IUS2_New():
  return itkImageToImageFilterISS2IUS2.New()


def itkImageToImageFilterISS3ISS3_New():
  return itkImageToImageFilterISS3ISS3.New()


def itkImageToImageFilterISS2ISS2_New():
  return itkImageToImageFilterISS2ISS2.New()


def itkImageToImageFilterISS3IUL3_New():
  return itkImageToImageFilterISS3IUL3.New()


def itkImageToImageFilterISS2IUL2_New():
  return itkImageToImageFilterISS2IUL2.New()


def itkImageToImageFilterISS3IUC3_New():
  return itkImageToImageFilterISS3IUC3.New()


def itkImageToImageFilterISS2IUC2_New():
  return itkImageToImageFilterISS2IUC2.New()


def itkImageToImageFilterIULL3ID3_New():
  return itkImageToImageFilterIULL3ID3.New()


def itkImageToImageFilterIULL2ID2_New():
  return itkImageToImageFilterIULL2ID2.New()


def itkImageToImageFilterIULL3IF3_New():
  return itkImageToImageFilterIULL3IF3.New()


def itkImageToImageFilterIULL2IF2_New():
  return itkImageToImageFilterIULL2IF2.New()


def itkImageToImageFilterIULL3IUS3_New():
  return itkImageToImageFilterIULL3IUS3.New()


def itkImageToImageFilterIULL2IUS2_New():
  return itkImageToImageFilterIULL2IUS2.New()


def itkImageToImageFilterIULL3ISS3_New():
  return itkImageToImageFilterIULL3ISS3.New()


def itkImageToImageFilterIULL2ISS2_New():
  return itkImageToImageFilterIULL2ISS2.New()


def itkImageToImageFilterIULL3IUL3_New():
  return itkImageToImageFilterIULL3IUL3.New()


def itkImageToImageFilterIULL2IUL2_New():
  return itkImageToImageFilterIULL2IUL2.New()


def itkImageToImageFilterIULL3IUC3_New():
  return itkImageToImageFilterIULL3IUC3.New()


def itkImageToImageFilterIULL2IUC2_New():
  return itkImageToImageFilterIULL2IUC2.New()


def itkImageToImageFilterIUL3ID3_New():
  return itkImageToImageFilterIUL3ID3.New()


def itkImageToImageFilterIUL2ID2_New():
  return itkImageToImageFilterIUL2ID2.New()


def itkImageToImageFilterIUL3IF3_New():
  return itkImageToImageFilterIUL3IF3.New()


def itkImageToImageFilterIUL2IF2_New():
  return itkImageToImageFilterIUL2IF2.New()


def itkImageToImageFilterIUL3IUS3_New():
  return itkImageToImageFilterIUL3IUS3.New()


def itkImageToImageFilterIUL2IUS2_New():
  return itkImageToImageFilterIUL2IUS2.New()


def itkImageToImageFilterIUL3ISS3_New():
  return itkImageToImageFilterIUL3ISS3.New()


def itkImageToImageFilterIUL2ISS2_New():
  return itkImageToImageFilterIUL2ISS2.New()


def itkImageToImageFilterIUL3IUL3_New():
  return itkImageToImageFilterIUL3IUL3.New()


def itkImageToImageFilterIUL2IUL2_New():
  return itkImageToImageFilterIUL2IUL2.New()


def itkImageToImageFilterIUL3IUC3_New():
  return itkImageToImageFilterIUL3IUC3.New()


def itkImageToImageFilterIUL2IUC2_New():
  return itkImageToImageFilterIUL2IUC2.New()


def itkImageToImageFilterIUC3ID3_New():
  return itkImageToImageFilterIUC3ID3.New()


def itkImageToImageFilterIUC2ID2_New():
  return itkImageToImageFilterIUC2ID2.New()


def itkImageToImageFilterIUC3IF3_New():
  return itkImageToImageFilterIUC3IF3.New()


def itkImageToImageFilterIUC2IF2_New():
  return itkImageToImageFilterIUC2IF2.New()


def itkImageToImageFilterIUC3IUS3_New():
  return itkImageToImageFilterIUC3IUS3.New()


def itkImageToImageFilterIUC2IUS2_New():
  return itkImageToImageFilterIUC2IUS2.New()


def itkImageToImageFilterIUC3ISS3_New():
  return itkImageToImageFilterIUC3ISS3.New()


def itkImageToImageFilterIUC2ISS2_New():
  return itkImageToImageFilterIUC2ISS2.New()


def itkImageToImageFilterIUC3IUL3_New():
  return itkImageToImageFilterIUC3IUL3.New()


def itkImageToImageFilterIUC2IUL2_New():
  return itkImageToImageFilterIUC2IUL2.New()


def itkImageToImageFilterIUC3IUC3_New():
  return itkImageToImageFilterIUC3IUC3.New()


def itkImageToImageFilterIUC2IUC2_New():
  return itkImageToImageFilterIUC2IUC2.New()

class itkImageToImageFilterICVF22ICVF22(itkImageSourcePython.itkImageSourceICVF22):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterICVF22ICVF22 self, itkImageCVF22 image)
        SetInput(itkImageToImageFilterICVF22ICVF22 self, unsigned int arg0, itkImageCVF22 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF22ICVF22_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageCVF22 const *":
        """
        GetInput(itkImageToImageFilterICVF22ICVF22 self) -> itkImageCVF22
        GetInput(itkImageToImageFilterICVF22ICVF22 self, unsigned int idx) -> itkImageCVF22
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF22ICVF22_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageCVF22') -> "void":
        """
        PushBackInput(itkImageToImageFilterICVF22ICVF22 self, itkImageCVF22 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF22ICVF22_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterICVF22ICVF22 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF22ICVF22_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageCVF22') -> "void":
        """PushFrontInput(itkImageToImageFilterICVF22ICVF22 self, itkImageCVF22 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF22ICVF22_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterICVF22ICVF22 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF22ICVF22_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterICVF22ICVF22 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF22ICVF22_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterICVF22ICVF22 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF22ICVF22_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterICVF22ICVF22 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF22ICVF22_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterICVF22ICVF22 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF22ICVF22_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterICVF22ICVF22

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF22ICVF22 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterICVF22ICVF22"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF22ICVF22_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterICVF22ICVF22

        Create a new object of the class itkImageToImageFilterICVF22ICVF22 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterICVF22ICVF22.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterICVF22ICVF22.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterICVF22ICVF22.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterICVF22ICVF22.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF22ICVF22_SetInput, None, itkImageToImageFilterICVF22ICVF22)
itkImageToImageFilterICVF22ICVF22.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF22ICVF22_GetInput, None, itkImageToImageFilterICVF22ICVF22)
itkImageToImageFilterICVF22ICVF22.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF22ICVF22_PushBackInput, None, itkImageToImageFilterICVF22ICVF22)
itkImageToImageFilterICVF22ICVF22.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF22ICVF22_PopBackInput, None, itkImageToImageFilterICVF22ICVF22)
itkImageToImageFilterICVF22ICVF22.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF22ICVF22_PushFrontInput, None, itkImageToImageFilterICVF22ICVF22)
itkImageToImageFilterICVF22ICVF22.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF22ICVF22_PopFrontInput, None, itkImageToImageFilterICVF22ICVF22)
itkImageToImageFilterICVF22ICVF22.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF22ICVF22_SetCoordinateTolerance, None, itkImageToImageFilterICVF22ICVF22)
itkImageToImageFilterICVF22ICVF22.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF22ICVF22_GetCoordinateTolerance, None, itkImageToImageFilterICVF22ICVF22)
itkImageToImageFilterICVF22ICVF22.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF22ICVF22_SetDirectionTolerance, None, itkImageToImageFilterICVF22ICVF22)
itkImageToImageFilterICVF22ICVF22.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF22ICVF22_GetDirectionTolerance, None, itkImageToImageFilterICVF22ICVF22)
itkImageToImageFilterICVF22ICVF22_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterICVF22ICVF22_swigregister
itkImageToImageFilterICVF22ICVF22_swigregister(itkImageToImageFilterICVF22ICVF22)

def itkImageToImageFilterICVF22ICVF22_cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF22ICVF22 *":
    """itkImageToImageFilterICVF22ICVF22_cast(itkLightObject obj) -> itkImageToImageFilterICVF22ICVF22"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterICVF22ICVF22_cast(obj)

class itkImageToImageFilterICVF22IVF22(itkImageSourcePython.itkImageSourceIVF22):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterICVF22IVF22 self, itkImageCVF22 image)
        SetInput(itkImageToImageFilterICVF22IVF22 self, unsigned int arg0, itkImageCVF22 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF22IVF22_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageCVF22 const *":
        """
        GetInput(itkImageToImageFilterICVF22IVF22 self) -> itkImageCVF22
        GetInput(itkImageToImageFilterICVF22IVF22 self, unsigned int idx) -> itkImageCVF22
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF22IVF22_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageCVF22') -> "void":
        """
        PushBackInput(itkImageToImageFilterICVF22IVF22 self, itkImageCVF22 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF22IVF22_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterICVF22IVF22 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF22IVF22_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageCVF22') -> "void":
        """PushFrontInput(itkImageToImageFilterICVF22IVF22 self, itkImageCVF22 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF22IVF22_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterICVF22IVF22 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF22IVF22_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterICVF22IVF22 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF22IVF22_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterICVF22IVF22 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF22IVF22_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterICVF22IVF22 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF22IVF22_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterICVF22IVF22 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF22IVF22_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterICVF22IVF22

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF22IVF22 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterICVF22IVF22"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF22IVF22_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterICVF22IVF22

        Create a new object of the class itkImageToImageFilterICVF22IVF22 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterICVF22IVF22.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterICVF22IVF22.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterICVF22IVF22.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterICVF22IVF22.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF22IVF22_SetInput, None, itkImageToImageFilterICVF22IVF22)
itkImageToImageFilterICVF22IVF22.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF22IVF22_GetInput, None, itkImageToImageFilterICVF22IVF22)
itkImageToImageFilterICVF22IVF22.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF22IVF22_PushBackInput, None, itkImageToImageFilterICVF22IVF22)
itkImageToImageFilterICVF22IVF22.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF22IVF22_PopBackInput, None, itkImageToImageFilterICVF22IVF22)
itkImageToImageFilterICVF22IVF22.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF22IVF22_PushFrontInput, None, itkImageToImageFilterICVF22IVF22)
itkImageToImageFilterICVF22IVF22.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF22IVF22_PopFrontInput, None, itkImageToImageFilterICVF22IVF22)
itkImageToImageFilterICVF22IVF22.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF22IVF22_SetCoordinateTolerance, None, itkImageToImageFilterICVF22IVF22)
itkImageToImageFilterICVF22IVF22.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF22IVF22_GetCoordinateTolerance, None, itkImageToImageFilterICVF22IVF22)
itkImageToImageFilterICVF22IVF22.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF22IVF22_SetDirectionTolerance, None, itkImageToImageFilterICVF22IVF22)
itkImageToImageFilterICVF22IVF22.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF22IVF22_GetDirectionTolerance, None, itkImageToImageFilterICVF22IVF22)
itkImageToImageFilterICVF22IVF22_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterICVF22IVF22_swigregister
itkImageToImageFilterICVF22IVF22_swigregister(itkImageToImageFilterICVF22IVF22)

def itkImageToImageFilterICVF22IVF22_cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF22IVF22 *":
    """itkImageToImageFilterICVF22IVF22_cast(itkLightObject obj) -> itkImageToImageFilterICVF22IVF22"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterICVF22IVF22_cast(obj)

class itkImageToImageFilterICVF23ICVF23(itkImageSourcePython.itkImageSourceICVF23):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterICVF23ICVF23 self, itkImageCVF23 image)
        SetInput(itkImageToImageFilterICVF23ICVF23 self, unsigned int arg0, itkImageCVF23 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF23ICVF23_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageCVF23 const *":
        """
        GetInput(itkImageToImageFilterICVF23ICVF23 self) -> itkImageCVF23
        GetInput(itkImageToImageFilterICVF23ICVF23 self, unsigned int idx) -> itkImageCVF23
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF23ICVF23_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageCVF23') -> "void":
        """
        PushBackInput(itkImageToImageFilterICVF23ICVF23 self, itkImageCVF23 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF23ICVF23_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterICVF23ICVF23 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF23ICVF23_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageCVF23') -> "void":
        """PushFrontInput(itkImageToImageFilterICVF23ICVF23 self, itkImageCVF23 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF23ICVF23_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterICVF23ICVF23 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF23ICVF23_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterICVF23ICVF23 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF23ICVF23_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterICVF23ICVF23 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF23ICVF23_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterICVF23ICVF23 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF23ICVF23_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterICVF23ICVF23 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF23ICVF23_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterICVF23ICVF23

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF23ICVF23 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterICVF23ICVF23"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF23ICVF23_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterICVF23ICVF23

        Create a new object of the class itkImageToImageFilterICVF23ICVF23 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterICVF23ICVF23.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterICVF23ICVF23.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterICVF23ICVF23.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterICVF23ICVF23.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF23ICVF23_SetInput, None, itkImageToImageFilterICVF23ICVF23)
itkImageToImageFilterICVF23ICVF23.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF23ICVF23_GetInput, None, itkImageToImageFilterICVF23ICVF23)
itkImageToImageFilterICVF23ICVF23.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF23ICVF23_PushBackInput, None, itkImageToImageFilterICVF23ICVF23)
itkImageToImageFilterICVF23ICVF23.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF23ICVF23_PopBackInput, None, itkImageToImageFilterICVF23ICVF23)
itkImageToImageFilterICVF23ICVF23.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF23ICVF23_PushFrontInput, None, itkImageToImageFilterICVF23ICVF23)
itkImageToImageFilterICVF23ICVF23.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF23ICVF23_PopFrontInput, None, itkImageToImageFilterICVF23ICVF23)
itkImageToImageFilterICVF23ICVF23.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF23ICVF23_SetCoordinateTolerance, None, itkImageToImageFilterICVF23ICVF23)
itkImageToImageFilterICVF23ICVF23.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF23ICVF23_GetCoordinateTolerance, None, itkImageToImageFilterICVF23ICVF23)
itkImageToImageFilterICVF23ICVF23.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF23ICVF23_SetDirectionTolerance, None, itkImageToImageFilterICVF23ICVF23)
itkImageToImageFilterICVF23ICVF23.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF23ICVF23_GetDirectionTolerance, None, itkImageToImageFilterICVF23ICVF23)
itkImageToImageFilterICVF23ICVF23_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterICVF23ICVF23_swigregister
itkImageToImageFilterICVF23ICVF23_swigregister(itkImageToImageFilterICVF23ICVF23)

def itkImageToImageFilterICVF23ICVF23_cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF23ICVF23 *":
    """itkImageToImageFilterICVF23ICVF23_cast(itkLightObject obj) -> itkImageToImageFilterICVF23ICVF23"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterICVF23ICVF23_cast(obj)

class itkImageToImageFilterICVF23IVF23(itkImageSourcePython.itkImageSourceIVF23):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterICVF23IVF23 self, itkImageCVF23 image)
        SetInput(itkImageToImageFilterICVF23IVF23 self, unsigned int arg0, itkImageCVF23 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF23IVF23_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageCVF23 const *":
        """
        GetInput(itkImageToImageFilterICVF23IVF23 self) -> itkImageCVF23
        GetInput(itkImageToImageFilterICVF23IVF23 self, unsigned int idx) -> itkImageCVF23
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF23IVF23_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageCVF23') -> "void":
        """
        PushBackInput(itkImageToImageFilterICVF23IVF23 self, itkImageCVF23 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF23IVF23_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterICVF23IVF23 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF23IVF23_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageCVF23') -> "void":
        """PushFrontInput(itkImageToImageFilterICVF23IVF23 self, itkImageCVF23 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF23IVF23_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterICVF23IVF23 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF23IVF23_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterICVF23IVF23 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF23IVF23_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterICVF23IVF23 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF23IVF23_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterICVF23IVF23 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF23IVF23_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterICVF23IVF23 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF23IVF23_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterICVF23IVF23

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF23IVF23 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterICVF23IVF23"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF23IVF23_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterICVF23IVF23

        Create a new object of the class itkImageToImageFilterICVF23IVF23 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterICVF23IVF23.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterICVF23IVF23.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterICVF23IVF23.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterICVF23IVF23.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF23IVF23_SetInput, None, itkImageToImageFilterICVF23IVF23)
itkImageToImageFilterICVF23IVF23.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF23IVF23_GetInput, None, itkImageToImageFilterICVF23IVF23)
itkImageToImageFilterICVF23IVF23.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF23IVF23_PushBackInput, None, itkImageToImageFilterICVF23IVF23)
itkImageToImageFilterICVF23IVF23.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF23IVF23_PopBackInput, None, itkImageToImageFilterICVF23IVF23)
itkImageToImageFilterICVF23IVF23.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF23IVF23_PushFrontInput, None, itkImageToImageFilterICVF23IVF23)
itkImageToImageFilterICVF23IVF23.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF23IVF23_PopFrontInput, None, itkImageToImageFilterICVF23IVF23)
itkImageToImageFilterICVF23IVF23.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF23IVF23_SetCoordinateTolerance, None, itkImageToImageFilterICVF23IVF23)
itkImageToImageFilterICVF23IVF23.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF23IVF23_GetCoordinateTolerance, None, itkImageToImageFilterICVF23IVF23)
itkImageToImageFilterICVF23IVF23.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF23IVF23_SetDirectionTolerance, None, itkImageToImageFilterICVF23IVF23)
itkImageToImageFilterICVF23IVF23.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF23IVF23_GetDirectionTolerance, None, itkImageToImageFilterICVF23IVF23)
itkImageToImageFilterICVF23IVF23_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterICVF23IVF23_swigregister
itkImageToImageFilterICVF23IVF23_swigregister(itkImageToImageFilterICVF23IVF23)

def itkImageToImageFilterICVF23IVF23_cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF23IVF23 *":
    """itkImageToImageFilterICVF23IVF23_cast(itkLightObject obj) -> itkImageToImageFilterICVF23IVF23"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterICVF23IVF23_cast(obj)

class itkImageToImageFilterICVF32ICVF32(itkImageSourcePython.itkImageSourceICVF32):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterICVF32ICVF32 self, itkImageCVF32 image)
        SetInput(itkImageToImageFilterICVF32ICVF32 self, unsigned int arg0, itkImageCVF32 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF32ICVF32_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageCVF32 const *":
        """
        GetInput(itkImageToImageFilterICVF32ICVF32 self) -> itkImageCVF32
        GetInput(itkImageToImageFilterICVF32ICVF32 self, unsigned int idx) -> itkImageCVF32
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF32ICVF32_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageCVF32') -> "void":
        """
        PushBackInput(itkImageToImageFilterICVF32ICVF32 self, itkImageCVF32 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF32ICVF32_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterICVF32ICVF32 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF32ICVF32_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageCVF32') -> "void":
        """PushFrontInput(itkImageToImageFilterICVF32ICVF32 self, itkImageCVF32 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF32ICVF32_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterICVF32ICVF32 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF32ICVF32_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterICVF32ICVF32 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF32ICVF32_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterICVF32ICVF32 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF32ICVF32_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterICVF32ICVF32 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF32ICVF32_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterICVF32ICVF32 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF32ICVF32_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterICVF32ICVF32

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF32ICVF32 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterICVF32ICVF32"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF32ICVF32_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterICVF32ICVF32

        Create a new object of the class itkImageToImageFilterICVF32ICVF32 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterICVF32ICVF32.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterICVF32ICVF32.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterICVF32ICVF32.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterICVF32ICVF32.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF32ICVF32_SetInput, None, itkImageToImageFilterICVF32ICVF32)
itkImageToImageFilterICVF32ICVF32.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF32ICVF32_GetInput, None, itkImageToImageFilterICVF32ICVF32)
itkImageToImageFilterICVF32ICVF32.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF32ICVF32_PushBackInput, None, itkImageToImageFilterICVF32ICVF32)
itkImageToImageFilterICVF32ICVF32.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF32ICVF32_PopBackInput, None, itkImageToImageFilterICVF32ICVF32)
itkImageToImageFilterICVF32ICVF32.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF32ICVF32_PushFrontInput, None, itkImageToImageFilterICVF32ICVF32)
itkImageToImageFilterICVF32ICVF32.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF32ICVF32_PopFrontInput, None, itkImageToImageFilterICVF32ICVF32)
itkImageToImageFilterICVF32ICVF32.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF32ICVF32_SetCoordinateTolerance, None, itkImageToImageFilterICVF32ICVF32)
itkImageToImageFilterICVF32ICVF32.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF32ICVF32_GetCoordinateTolerance, None, itkImageToImageFilterICVF32ICVF32)
itkImageToImageFilterICVF32ICVF32.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF32ICVF32_SetDirectionTolerance, None, itkImageToImageFilterICVF32ICVF32)
itkImageToImageFilterICVF32ICVF32.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF32ICVF32_GetDirectionTolerance, None, itkImageToImageFilterICVF32ICVF32)
itkImageToImageFilterICVF32ICVF32_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterICVF32ICVF32_swigregister
itkImageToImageFilterICVF32ICVF32_swigregister(itkImageToImageFilterICVF32ICVF32)

def itkImageToImageFilterICVF32ICVF32_cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF32ICVF32 *":
    """itkImageToImageFilterICVF32ICVF32_cast(itkLightObject obj) -> itkImageToImageFilterICVF32ICVF32"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterICVF32ICVF32_cast(obj)

class itkImageToImageFilterICVF32IVF32(itkImageSourcePython.itkImageSourceIVF32):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterICVF32IVF32 self, itkImageCVF32 image)
        SetInput(itkImageToImageFilterICVF32IVF32 self, unsigned int arg0, itkImageCVF32 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF32IVF32_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageCVF32 const *":
        """
        GetInput(itkImageToImageFilterICVF32IVF32 self) -> itkImageCVF32
        GetInput(itkImageToImageFilterICVF32IVF32 self, unsigned int idx) -> itkImageCVF32
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF32IVF32_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageCVF32') -> "void":
        """
        PushBackInput(itkImageToImageFilterICVF32IVF32 self, itkImageCVF32 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF32IVF32_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterICVF32IVF32 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF32IVF32_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageCVF32') -> "void":
        """PushFrontInput(itkImageToImageFilterICVF32IVF32 self, itkImageCVF32 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF32IVF32_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterICVF32IVF32 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF32IVF32_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterICVF32IVF32 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF32IVF32_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterICVF32IVF32 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF32IVF32_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterICVF32IVF32 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF32IVF32_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterICVF32IVF32 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF32IVF32_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterICVF32IVF32

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF32IVF32 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterICVF32IVF32"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF32IVF32_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterICVF32IVF32

        Create a new object of the class itkImageToImageFilterICVF32IVF32 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterICVF32IVF32.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterICVF32IVF32.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterICVF32IVF32.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterICVF32IVF32.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF32IVF32_SetInput, None, itkImageToImageFilterICVF32IVF32)
itkImageToImageFilterICVF32IVF32.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF32IVF32_GetInput, None, itkImageToImageFilterICVF32IVF32)
itkImageToImageFilterICVF32IVF32.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF32IVF32_PushBackInput, None, itkImageToImageFilterICVF32IVF32)
itkImageToImageFilterICVF32IVF32.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF32IVF32_PopBackInput, None, itkImageToImageFilterICVF32IVF32)
itkImageToImageFilterICVF32IVF32.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF32IVF32_PushFrontInput, None, itkImageToImageFilterICVF32IVF32)
itkImageToImageFilterICVF32IVF32.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF32IVF32_PopFrontInput, None, itkImageToImageFilterICVF32IVF32)
itkImageToImageFilterICVF32IVF32.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF32IVF32_SetCoordinateTolerance, None, itkImageToImageFilterICVF32IVF32)
itkImageToImageFilterICVF32IVF32.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF32IVF32_GetCoordinateTolerance, None, itkImageToImageFilterICVF32IVF32)
itkImageToImageFilterICVF32IVF32.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF32IVF32_SetDirectionTolerance, None, itkImageToImageFilterICVF32IVF32)
itkImageToImageFilterICVF32IVF32.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF32IVF32_GetDirectionTolerance, None, itkImageToImageFilterICVF32IVF32)
itkImageToImageFilterICVF32IVF32_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterICVF32IVF32_swigregister
itkImageToImageFilterICVF32IVF32_swigregister(itkImageToImageFilterICVF32IVF32)

def itkImageToImageFilterICVF32IVF32_cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF32IVF32 *":
    """itkImageToImageFilterICVF32IVF32_cast(itkLightObject obj) -> itkImageToImageFilterICVF32IVF32"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterICVF32IVF32_cast(obj)

class itkImageToImageFilterICVF33ICVF33(itkImageSourcePython.itkImageSourceICVF33):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterICVF33ICVF33 self, itkImageCVF33 image)
        SetInput(itkImageToImageFilterICVF33ICVF33 self, unsigned int arg0, itkImageCVF33 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF33ICVF33_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageCVF33 const *":
        """
        GetInput(itkImageToImageFilterICVF33ICVF33 self) -> itkImageCVF33
        GetInput(itkImageToImageFilterICVF33ICVF33 self, unsigned int idx) -> itkImageCVF33
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF33ICVF33_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageCVF33') -> "void":
        """
        PushBackInput(itkImageToImageFilterICVF33ICVF33 self, itkImageCVF33 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF33ICVF33_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterICVF33ICVF33 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF33ICVF33_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageCVF33') -> "void":
        """PushFrontInput(itkImageToImageFilterICVF33ICVF33 self, itkImageCVF33 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF33ICVF33_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterICVF33ICVF33 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF33ICVF33_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterICVF33ICVF33 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF33ICVF33_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterICVF33ICVF33 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF33ICVF33_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterICVF33ICVF33 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF33ICVF33_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterICVF33ICVF33 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF33ICVF33_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterICVF33ICVF33

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF33ICVF33 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterICVF33ICVF33"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF33ICVF33_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterICVF33ICVF33

        Create a new object of the class itkImageToImageFilterICVF33ICVF33 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterICVF33ICVF33.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterICVF33ICVF33.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterICVF33ICVF33.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterICVF33ICVF33.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF33ICVF33_SetInput, None, itkImageToImageFilterICVF33ICVF33)
itkImageToImageFilterICVF33ICVF33.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF33ICVF33_GetInput, None, itkImageToImageFilterICVF33ICVF33)
itkImageToImageFilterICVF33ICVF33.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF33ICVF33_PushBackInput, None, itkImageToImageFilterICVF33ICVF33)
itkImageToImageFilterICVF33ICVF33.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF33ICVF33_PopBackInput, None, itkImageToImageFilterICVF33ICVF33)
itkImageToImageFilterICVF33ICVF33.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF33ICVF33_PushFrontInput, None, itkImageToImageFilterICVF33ICVF33)
itkImageToImageFilterICVF33ICVF33.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF33ICVF33_PopFrontInput, None, itkImageToImageFilterICVF33ICVF33)
itkImageToImageFilterICVF33ICVF33.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF33ICVF33_SetCoordinateTolerance, None, itkImageToImageFilterICVF33ICVF33)
itkImageToImageFilterICVF33ICVF33.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF33ICVF33_GetCoordinateTolerance, None, itkImageToImageFilterICVF33ICVF33)
itkImageToImageFilterICVF33ICVF33.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF33ICVF33_SetDirectionTolerance, None, itkImageToImageFilterICVF33ICVF33)
itkImageToImageFilterICVF33ICVF33.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF33ICVF33_GetDirectionTolerance, None, itkImageToImageFilterICVF33ICVF33)
itkImageToImageFilterICVF33ICVF33_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterICVF33ICVF33_swigregister
itkImageToImageFilterICVF33ICVF33_swigregister(itkImageToImageFilterICVF33ICVF33)

def itkImageToImageFilterICVF33ICVF33_cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF33ICVF33 *":
    """itkImageToImageFilterICVF33ICVF33_cast(itkLightObject obj) -> itkImageToImageFilterICVF33ICVF33"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterICVF33ICVF33_cast(obj)

class itkImageToImageFilterICVF33IVF33(itkImageSourcePython.itkImageSourceIVF33):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterICVF33IVF33 self, itkImageCVF33 image)
        SetInput(itkImageToImageFilterICVF33IVF33 self, unsigned int arg0, itkImageCVF33 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF33IVF33_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageCVF33 const *":
        """
        GetInput(itkImageToImageFilterICVF33IVF33 self) -> itkImageCVF33
        GetInput(itkImageToImageFilterICVF33IVF33 self, unsigned int idx) -> itkImageCVF33
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF33IVF33_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageCVF33') -> "void":
        """
        PushBackInput(itkImageToImageFilterICVF33IVF33 self, itkImageCVF33 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF33IVF33_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterICVF33IVF33 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF33IVF33_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageCVF33') -> "void":
        """PushFrontInput(itkImageToImageFilterICVF33IVF33 self, itkImageCVF33 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF33IVF33_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterICVF33IVF33 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF33IVF33_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterICVF33IVF33 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF33IVF33_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterICVF33IVF33 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF33IVF33_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterICVF33IVF33 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF33IVF33_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterICVF33IVF33 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF33IVF33_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterICVF33IVF33

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF33IVF33 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterICVF33IVF33"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF33IVF33_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterICVF33IVF33

        Create a new object of the class itkImageToImageFilterICVF33IVF33 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterICVF33IVF33.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterICVF33IVF33.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterICVF33IVF33.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterICVF33IVF33.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF33IVF33_SetInput, None, itkImageToImageFilterICVF33IVF33)
itkImageToImageFilterICVF33IVF33.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF33IVF33_GetInput, None, itkImageToImageFilterICVF33IVF33)
itkImageToImageFilterICVF33IVF33.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF33IVF33_PushBackInput, None, itkImageToImageFilterICVF33IVF33)
itkImageToImageFilterICVF33IVF33.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF33IVF33_PopBackInput, None, itkImageToImageFilterICVF33IVF33)
itkImageToImageFilterICVF33IVF33.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF33IVF33_PushFrontInput, None, itkImageToImageFilterICVF33IVF33)
itkImageToImageFilterICVF33IVF33.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF33IVF33_PopFrontInput, None, itkImageToImageFilterICVF33IVF33)
itkImageToImageFilterICVF33IVF33.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF33IVF33_SetCoordinateTolerance, None, itkImageToImageFilterICVF33IVF33)
itkImageToImageFilterICVF33IVF33.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF33IVF33_GetCoordinateTolerance, None, itkImageToImageFilterICVF33IVF33)
itkImageToImageFilterICVF33IVF33.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF33IVF33_SetDirectionTolerance, None, itkImageToImageFilterICVF33IVF33)
itkImageToImageFilterICVF33IVF33.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF33IVF33_GetDirectionTolerance, None, itkImageToImageFilterICVF33IVF33)
itkImageToImageFilterICVF33IVF33_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterICVF33IVF33_swigregister
itkImageToImageFilterICVF33IVF33_swigregister(itkImageToImageFilterICVF33IVF33)

def itkImageToImageFilterICVF33IVF33_cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF33IVF33 *":
    """itkImageToImageFilterICVF33IVF33_cast(itkLightObject obj) -> itkImageToImageFilterICVF33IVF33"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterICVF33IVF33_cast(obj)

class itkImageToImageFilterICVF42ICVF42(itkImageSourcePython.itkImageSourceICVF42):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterICVF42ICVF42 self, itkImageCVF42 image)
        SetInput(itkImageToImageFilterICVF42ICVF42 self, unsigned int arg0, itkImageCVF42 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF42ICVF42_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageCVF42 const *":
        """
        GetInput(itkImageToImageFilterICVF42ICVF42 self) -> itkImageCVF42
        GetInput(itkImageToImageFilterICVF42ICVF42 self, unsigned int idx) -> itkImageCVF42
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF42ICVF42_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageCVF42') -> "void":
        """
        PushBackInput(itkImageToImageFilterICVF42ICVF42 self, itkImageCVF42 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF42ICVF42_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterICVF42ICVF42 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF42ICVF42_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageCVF42') -> "void":
        """PushFrontInput(itkImageToImageFilterICVF42ICVF42 self, itkImageCVF42 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF42ICVF42_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterICVF42ICVF42 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF42ICVF42_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterICVF42ICVF42 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF42ICVF42_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterICVF42ICVF42 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF42ICVF42_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterICVF42ICVF42 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF42ICVF42_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterICVF42ICVF42 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF42ICVF42_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterICVF42ICVF42

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF42ICVF42 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterICVF42ICVF42"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF42ICVF42_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterICVF42ICVF42

        Create a new object of the class itkImageToImageFilterICVF42ICVF42 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterICVF42ICVF42.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterICVF42ICVF42.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterICVF42ICVF42.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterICVF42ICVF42.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF42ICVF42_SetInput, None, itkImageToImageFilterICVF42ICVF42)
itkImageToImageFilterICVF42ICVF42.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF42ICVF42_GetInput, None, itkImageToImageFilterICVF42ICVF42)
itkImageToImageFilterICVF42ICVF42.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF42ICVF42_PushBackInput, None, itkImageToImageFilterICVF42ICVF42)
itkImageToImageFilterICVF42ICVF42.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF42ICVF42_PopBackInput, None, itkImageToImageFilterICVF42ICVF42)
itkImageToImageFilterICVF42ICVF42.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF42ICVF42_PushFrontInput, None, itkImageToImageFilterICVF42ICVF42)
itkImageToImageFilterICVF42ICVF42.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF42ICVF42_PopFrontInput, None, itkImageToImageFilterICVF42ICVF42)
itkImageToImageFilterICVF42ICVF42.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF42ICVF42_SetCoordinateTolerance, None, itkImageToImageFilterICVF42ICVF42)
itkImageToImageFilterICVF42ICVF42.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF42ICVF42_GetCoordinateTolerance, None, itkImageToImageFilterICVF42ICVF42)
itkImageToImageFilterICVF42ICVF42.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF42ICVF42_SetDirectionTolerance, None, itkImageToImageFilterICVF42ICVF42)
itkImageToImageFilterICVF42ICVF42.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF42ICVF42_GetDirectionTolerance, None, itkImageToImageFilterICVF42ICVF42)
itkImageToImageFilterICVF42ICVF42_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterICVF42ICVF42_swigregister
itkImageToImageFilterICVF42ICVF42_swigregister(itkImageToImageFilterICVF42ICVF42)

def itkImageToImageFilterICVF42ICVF42_cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF42ICVF42 *":
    """itkImageToImageFilterICVF42ICVF42_cast(itkLightObject obj) -> itkImageToImageFilterICVF42ICVF42"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterICVF42ICVF42_cast(obj)

class itkImageToImageFilterICVF42IVF42(itkImageSourcePython.itkImageSourceIVF42):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterICVF42IVF42 self, itkImageCVF42 image)
        SetInput(itkImageToImageFilterICVF42IVF42 self, unsigned int arg0, itkImageCVF42 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF42IVF42_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageCVF42 const *":
        """
        GetInput(itkImageToImageFilterICVF42IVF42 self) -> itkImageCVF42
        GetInput(itkImageToImageFilterICVF42IVF42 self, unsigned int idx) -> itkImageCVF42
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF42IVF42_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageCVF42') -> "void":
        """
        PushBackInput(itkImageToImageFilterICVF42IVF42 self, itkImageCVF42 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF42IVF42_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterICVF42IVF42 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF42IVF42_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageCVF42') -> "void":
        """PushFrontInput(itkImageToImageFilterICVF42IVF42 self, itkImageCVF42 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF42IVF42_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterICVF42IVF42 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF42IVF42_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterICVF42IVF42 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF42IVF42_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterICVF42IVF42 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF42IVF42_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterICVF42IVF42 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF42IVF42_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterICVF42IVF42 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF42IVF42_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterICVF42IVF42

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF42IVF42 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterICVF42IVF42"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF42IVF42_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterICVF42IVF42

        Create a new object of the class itkImageToImageFilterICVF42IVF42 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterICVF42IVF42.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterICVF42IVF42.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterICVF42IVF42.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterICVF42IVF42.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF42IVF42_SetInput, None, itkImageToImageFilterICVF42IVF42)
itkImageToImageFilterICVF42IVF42.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF42IVF42_GetInput, None, itkImageToImageFilterICVF42IVF42)
itkImageToImageFilterICVF42IVF42.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF42IVF42_PushBackInput, None, itkImageToImageFilterICVF42IVF42)
itkImageToImageFilterICVF42IVF42.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF42IVF42_PopBackInput, None, itkImageToImageFilterICVF42IVF42)
itkImageToImageFilterICVF42IVF42.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF42IVF42_PushFrontInput, None, itkImageToImageFilterICVF42IVF42)
itkImageToImageFilterICVF42IVF42.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF42IVF42_PopFrontInput, None, itkImageToImageFilterICVF42IVF42)
itkImageToImageFilterICVF42IVF42.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF42IVF42_SetCoordinateTolerance, None, itkImageToImageFilterICVF42IVF42)
itkImageToImageFilterICVF42IVF42.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF42IVF42_GetCoordinateTolerance, None, itkImageToImageFilterICVF42IVF42)
itkImageToImageFilterICVF42IVF42.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF42IVF42_SetDirectionTolerance, None, itkImageToImageFilterICVF42IVF42)
itkImageToImageFilterICVF42IVF42.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF42IVF42_GetDirectionTolerance, None, itkImageToImageFilterICVF42IVF42)
itkImageToImageFilterICVF42IVF42_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterICVF42IVF42_swigregister
itkImageToImageFilterICVF42IVF42_swigregister(itkImageToImageFilterICVF42IVF42)

def itkImageToImageFilterICVF42IVF42_cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF42IVF42 *":
    """itkImageToImageFilterICVF42IVF42_cast(itkLightObject obj) -> itkImageToImageFilterICVF42IVF42"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterICVF42IVF42_cast(obj)

class itkImageToImageFilterICVF43ICVF43(itkImageSourcePython.itkImageSourceICVF43):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterICVF43ICVF43 self, itkImageCVF43 image)
        SetInput(itkImageToImageFilterICVF43ICVF43 self, unsigned int arg0, itkImageCVF43 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF43ICVF43_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageCVF43 const *":
        """
        GetInput(itkImageToImageFilterICVF43ICVF43 self) -> itkImageCVF43
        GetInput(itkImageToImageFilterICVF43ICVF43 self, unsigned int idx) -> itkImageCVF43
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF43ICVF43_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageCVF43') -> "void":
        """
        PushBackInput(itkImageToImageFilterICVF43ICVF43 self, itkImageCVF43 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF43ICVF43_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterICVF43ICVF43 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF43ICVF43_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageCVF43') -> "void":
        """PushFrontInput(itkImageToImageFilterICVF43ICVF43 self, itkImageCVF43 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF43ICVF43_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterICVF43ICVF43 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF43ICVF43_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterICVF43ICVF43 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF43ICVF43_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterICVF43ICVF43 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF43ICVF43_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterICVF43ICVF43 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF43ICVF43_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterICVF43ICVF43 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF43ICVF43_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterICVF43ICVF43

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF43ICVF43 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterICVF43ICVF43"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF43ICVF43_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterICVF43ICVF43

        Create a new object of the class itkImageToImageFilterICVF43ICVF43 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterICVF43ICVF43.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterICVF43ICVF43.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterICVF43ICVF43.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterICVF43ICVF43.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF43ICVF43_SetInput, None, itkImageToImageFilterICVF43ICVF43)
itkImageToImageFilterICVF43ICVF43.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF43ICVF43_GetInput, None, itkImageToImageFilterICVF43ICVF43)
itkImageToImageFilterICVF43ICVF43.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF43ICVF43_PushBackInput, None, itkImageToImageFilterICVF43ICVF43)
itkImageToImageFilterICVF43ICVF43.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF43ICVF43_PopBackInput, None, itkImageToImageFilterICVF43ICVF43)
itkImageToImageFilterICVF43ICVF43.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF43ICVF43_PushFrontInput, None, itkImageToImageFilterICVF43ICVF43)
itkImageToImageFilterICVF43ICVF43.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF43ICVF43_PopFrontInput, None, itkImageToImageFilterICVF43ICVF43)
itkImageToImageFilterICVF43ICVF43.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF43ICVF43_SetCoordinateTolerance, None, itkImageToImageFilterICVF43ICVF43)
itkImageToImageFilterICVF43ICVF43.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF43ICVF43_GetCoordinateTolerance, None, itkImageToImageFilterICVF43ICVF43)
itkImageToImageFilterICVF43ICVF43.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF43ICVF43_SetDirectionTolerance, None, itkImageToImageFilterICVF43ICVF43)
itkImageToImageFilterICVF43ICVF43.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF43ICVF43_GetDirectionTolerance, None, itkImageToImageFilterICVF43ICVF43)
itkImageToImageFilterICVF43ICVF43_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterICVF43ICVF43_swigregister
itkImageToImageFilterICVF43ICVF43_swigregister(itkImageToImageFilterICVF43ICVF43)

def itkImageToImageFilterICVF43ICVF43_cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF43ICVF43 *":
    """itkImageToImageFilterICVF43ICVF43_cast(itkLightObject obj) -> itkImageToImageFilterICVF43ICVF43"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterICVF43ICVF43_cast(obj)

class itkImageToImageFilterICVF43IVF43(itkImageSourcePython.itkImageSourceIVF43):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterICVF43IVF43 self, itkImageCVF43 image)
        SetInput(itkImageToImageFilterICVF43IVF43 self, unsigned int arg0, itkImageCVF43 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF43IVF43_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageCVF43 const *":
        """
        GetInput(itkImageToImageFilterICVF43IVF43 self) -> itkImageCVF43
        GetInput(itkImageToImageFilterICVF43IVF43 self, unsigned int idx) -> itkImageCVF43
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF43IVF43_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageCVF43') -> "void":
        """
        PushBackInput(itkImageToImageFilterICVF43IVF43 self, itkImageCVF43 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF43IVF43_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterICVF43IVF43 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF43IVF43_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageCVF43') -> "void":
        """PushFrontInput(itkImageToImageFilterICVF43IVF43 self, itkImageCVF43 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF43IVF43_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterICVF43IVF43 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF43IVF43_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterICVF43IVF43 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF43IVF43_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterICVF43IVF43 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF43IVF43_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterICVF43IVF43 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF43IVF43_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterICVF43IVF43 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF43IVF43_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterICVF43IVF43

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF43IVF43 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterICVF43IVF43"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterICVF43IVF43_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterICVF43IVF43

        Create a new object of the class itkImageToImageFilterICVF43IVF43 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterICVF43IVF43.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterICVF43IVF43.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterICVF43IVF43.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterICVF43IVF43.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF43IVF43_SetInput, None, itkImageToImageFilterICVF43IVF43)
itkImageToImageFilterICVF43IVF43.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF43IVF43_GetInput, None, itkImageToImageFilterICVF43IVF43)
itkImageToImageFilterICVF43IVF43.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF43IVF43_PushBackInput, None, itkImageToImageFilterICVF43IVF43)
itkImageToImageFilterICVF43IVF43.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF43IVF43_PopBackInput, None, itkImageToImageFilterICVF43IVF43)
itkImageToImageFilterICVF43IVF43.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF43IVF43_PushFrontInput, None, itkImageToImageFilterICVF43IVF43)
itkImageToImageFilterICVF43IVF43.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF43IVF43_PopFrontInput, None, itkImageToImageFilterICVF43IVF43)
itkImageToImageFilterICVF43IVF43.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF43IVF43_SetCoordinateTolerance, None, itkImageToImageFilterICVF43IVF43)
itkImageToImageFilterICVF43IVF43.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF43IVF43_GetCoordinateTolerance, None, itkImageToImageFilterICVF43IVF43)
itkImageToImageFilterICVF43IVF43.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF43IVF43_SetDirectionTolerance, None, itkImageToImageFilterICVF43IVF43)
itkImageToImageFilterICVF43IVF43.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterICVF43IVF43_GetDirectionTolerance, None, itkImageToImageFilterICVF43IVF43)
itkImageToImageFilterICVF43IVF43_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterICVF43IVF43_swigregister
itkImageToImageFilterICVF43IVF43_swigregister(itkImageToImageFilterICVF43IVF43)

def itkImageToImageFilterICVF43IVF43_cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF43IVF43 *":
    """itkImageToImageFilterICVF43IVF43_cast(itkLightObject obj) -> itkImageToImageFilterICVF43IVF43"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterICVF43IVF43_cast(obj)

class itkImageToImageFilterID2ID2(itkImageSourcePython.itkImageSourceID2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterID2ID2 self, itkImageD2 image)
        SetInput(itkImageToImageFilterID2ID2 self, unsigned int arg0, itkImageD2 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2ID2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageD2 const *":
        """
        GetInput(itkImageToImageFilterID2ID2 self) -> itkImageD2
        GetInput(itkImageToImageFilterID2ID2 self, unsigned int idx) -> itkImageD2
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2ID2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageD2') -> "void":
        """
        PushBackInput(itkImageToImageFilterID2ID2 self, itkImageD2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2ID2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterID2ID2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2ID2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageD2') -> "void":
        """PushFrontInput(itkImageToImageFilterID2ID2 self, itkImageD2 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2ID2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterID2ID2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2ID2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterID2ID2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2ID2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterID2ID2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2ID2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterID2ID2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2ID2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterID2ID2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2ID2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterID2ID2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterID2ID2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterID2ID2"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2ID2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterID2ID2

        Create a new object of the class itkImageToImageFilterID2ID2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterID2ID2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterID2ID2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterID2ID2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterID2ID2.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID2ID2_SetInput, None, itkImageToImageFilterID2ID2)
itkImageToImageFilterID2ID2.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID2ID2_GetInput, None, itkImageToImageFilterID2ID2)
itkImageToImageFilterID2ID2.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID2ID2_PushBackInput, None, itkImageToImageFilterID2ID2)
itkImageToImageFilterID2ID2.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID2ID2_PopBackInput, None, itkImageToImageFilterID2ID2)
itkImageToImageFilterID2ID2.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID2ID2_PushFrontInput, None, itkImageToImageFilterID2ID2)
itkImageToImageFilterID2ID2.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID2ID2_PopFrontInput, None, itkImageToImageFilterID2ID2)
itkImageToImageFilterID2ID2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID2ID2_SetCoordinateTolerance, None, itkImageToImageFilterID2ID2)
itkImageToImageFilterID2ID2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID2ID2_GetCoordinateTolerance, None, itkImageToImageFilterID2ID2)
itkImageToImageFilterID2ID2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID2ID2_SetDirectionTolerance, None, itkImageToImageFilterID2ID2)
itkImageToImageFilterID2ID2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID2ID2_GetDirectionTolerance, None, itkImageToImageFilterID2ID2)
itkImageToImageFilterID2ID2_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterID2ID2_swigregister
itkImageToImageFilterID2ID2_swigregister(itkImageToImageFilterID2ID2)

def itkImageToImageFilterID2ID2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterID2ID2 *":
    """itkImageToImageFilterID2ID2_cast(itkLightObject obj) -> itkImageToImageFilterID2ID2"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterID2ID2_cast(obj)

class itkImageToImageFilterID2IF2(itkImageSourcePython.itkImageSourceIF2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterID2IF2 self, itkImageD2 image)
        SetInput(itkImageToImageFilterID2IF2 self, unsigned int arg0, itkImageD2 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2IF2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageD2 const *":
        """
        GetInput(itkImageToImageFilterID2IF2 self) -> itkImageD2
        GetInput(itkImageToImageFilterID2IF2 self, unsigned int idx) -> itkImageD2
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2IF2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageD2') -> "void":
        """
        PushBackInput(itkImageToImageFilterID2IF2 self, itkImageD2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2IF2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterID2IF2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2IF2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageD2') -> "void":
        """PushFrontInput(itkImageToImageFilterID2IF2 self, itkImageD2 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2IF2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterID2IF2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2IF2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterID2IF2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2IF2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterID2IF2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2IF2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterID2IF2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2IF2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterID2IF2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2IF2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterID2IF2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterID2IF2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterID2IF2"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2IF2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterID2IF2

        Create a new object of the class itkImageToImageFilterID2IF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterID2IF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterID2IF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterID2IF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterID2IF2.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID2IF2_SetInput, None, itkImageToImageFilterID2IF2)
itkImageToImageFilterID2IF2.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID2IF2_GetInput, None, itkImageToImageFilterID2IF2)
itkImageToImageFilterID2IF2.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID2IF2_PushBackInput, None, itkImageToImageFilterID2IF2)
itkImageToImageFilterID2IF2.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID2IF2_PopBackInput, None, itkImageToImageFilterID2IF2)
itkImageToImageFilterID2IF2.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID2IF2_PushFrontInput, None, itkImageToImageFilterID2IF2)
itkImageToImageFilterID2IF2.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID2IF2_PopFrontInput, None, itkImageToImageFilterID2IF2)
itkImageToImageFilterID2IF2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID2IF2_SetCoordinateTolerance, None, itkImageToImageFilterID2IF2)
itkImageToImageFilterID2IF2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID2IF2_GetCoordinateTolerance, None, itkImageToImageFilterID2IF2)
itkImageToImageFilterID2IF2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID2IF2_SetDirectionTolerance, None, itkImageToImageFilterID2IF2)
itkImageToImageFilterID2IF2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID2IF2_GetDirectionTolerance, None, itkImageToImageFilterID2IF2)
itkImageToImageFilterID2IF2_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterID2IF2_swigregister
itkImageToImageFilterID2IF2_swigregister(itkImageToImageFilterID2IF2)

def itkImageToImageFilterID2IF2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterID2IF2 *":
    """itkImageToImageFilterID2IF2_cast(itkLightObject obj) -> itkImageToImageFilterID2IF2"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterID2IF2_cast(obj)

class itkImageToImageFilterID2ISS2(itkImageSourcePython.itkImageSourceISS2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterID2ISS2 self, itkImageD2 image)
        SetInput(itkImageToImageFilterID2ISS2 self, unsigned int arg0, itkImageD2 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2ISS2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageD2 const *":
        """
        GetInput(itkImageToImageFilterID2ISS2 self) -> itkImageD2
        GetInput(itkImageToImageFilterID2ISS2 self, unsigned int idx) -> itkImageD2
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2ISS2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageD2') -> "void":
        """
        PushBackInput(itkImageToImageFilterID2ISS2 self, itkImageD2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2ISS2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterID2ISS2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2ISS2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageD2') -> "void":
        """PushFrontInput(itkImageToImageFilterID2ISS2 self, itkImageD2 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2ISS2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterID2ISS2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2ISS2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterID2ISS2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2ISS2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterID2ISS2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2ISS2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterID2ISS2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2ISS2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterID2ISS2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2ISS2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterID2ISS2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterID2ISS2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterID2ISS2"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2ISS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterID2ISS2

        Create a new object of the class itkImageToImageFilterID2ISS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterID2ISS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterID2ISS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterID2ISS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterID2ISS2.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID2ISS2_SetInput, None, itkImageToImageFilterID2ISS2)
itkImageToImageFilterID2ISS2.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID2ISS2_GetInput, None, itkImageToImageFilterID2ISS2)
itkImageToImageFilterID2ISS2.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID2ISS2_PushBackInput, None, itkImageToImageFilterID2ISS2)
itkImageToImageFilterID2ISS2.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID2ISS2_PopBackInput, None, itkImageToImageFilterID2ISS2)
itkImageToImageFilterID2ISS2.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID2ISS2_PushFrontInput, None, itkImageToImageFilterID2ISS2)
itkImageToImageFilterID2ISS2.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID2ISS2_PopFrontInput, None, itkImageToImageFilterID2ISS2)
itkImageToImageFilterID2ISS2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID2ISS2_SetCoordinateTolerance, None, itkImageToImageFilterID2ISS2)
itkImageToImageFilterID2ISS2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID2ISS2_GetCoordinateTolerance, None, itkImageToImageFilterID2ISS2)
itkImageToImageFilterID2ISS2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID2ISS2_SetDirectionTolerance, None, itkImageToImageFilterID2ISS2)
itkImageToImageFilterID2ISS2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID2ISS2_GetDirectionTolerance, None, itkImageToImageFilterID2ISS2)
itkImageToImageFilterID2ISS2_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterID2ISS2_swigregister
itkImageToImageFilterID2ISS2_swigregister(itkImageToImageFilterID2ISS2)

def itkImageToImageFilterID2ISS2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterID2ISS2 *":
    """itkImageToImageFilterID2ISS2_cast(itkLightObject obj) -> itkImageToImageFilterID2ISS2"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterID2ISS2_cast(obj)

class itkImageToImageFilterID2IUC2(itkImageSourcePython.itkImageSourceIUC2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterID2IUC2 self, itkImageD2 image)
        SetInput(itkImageToImageFilterID2IUC2 self, unsigned int arg0, itkImageD2 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2IUC2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageD2 const *":
        """
        GetInput(itkImageToImageFilterID2IUC2 self) -> itkImageD2
        GetInput(itkImageToImageFilterID2IUC2 self, unsigned int idx) -> itkImageD2
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2IUC2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageD2') -> "void":
        """
        PushBackInput(itkImageToImageFilterID2IUC2 self, itkImageD2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2IUC2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterID2IUC2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2IUC2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageD2') -> "void":
        """PushFrontInput(itkImageToImageFilterID2IUC2 self, itkImageD2 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2IUC2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterID2IUC2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2IUC2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterID2IUC2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2IUC2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterID2IUC2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2IUC2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterID2IUC2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2IUC2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterID2IUC2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2IUC2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterID2IUC2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterID2IUC2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterID2IUC2"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2IUC2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterID2IUC2

        Create a new object of the class itkImageToImageFilterID2IUC2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterID2IUC2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterID2IUC2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterID2IUC2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterID2IUC2.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID2IUC2_SetInput, None, itkImageToImageFilterID2IUC2)
itkImageToImageFilterID2IUC2.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID2IUC2_GetInput, None, itkImageToImageFilterID2IUC2)
itkImageToImageFilterID2IUC2.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID2IUC2_PushBackInput, None, itkImageToImageFilterID2IUC2)
itkImageToImageFilterID2IUC2.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID2IUC2_PopBackInput, None, itkImageToImageFilterID2IUC2)
itkImageToImageFilterID2IUC2.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID2IUC2_PushFrontInput, None, itkImageToImageFilterID2IUC2)
itkImageToImageFilterID2IUC2.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID2IUC2_PopFrontInput, None, itkImageToImageFilterID2IUC2)
itkImageToImageFilterID2IUC2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID2IUC2_SetCoordinateTolerance, None, itkImageToImageFilterID2IUC2)
itkImageToImageFilterID2IUC2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID2IUC2_GetCoordinateTolerance, None, itkImageToImageFilterID2IUC2)
itkImageToImageFilterID2IUC2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID2IUC2_SetDirectionTolerance, None, itkImageToImageFilterID2IUC2)
itkImageToImageFilterID2IUC2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID2IUC2_GetDirectionTolerance, None, itkImageToImageFilterID2IUC2)
itkImageToImageFilterID2IUC2_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterID2IUC2_swigregister
itkImageToImageFilterID2IUC2_swigregister(itkImageToImageFilterID2IUC2)

def itkImageToImageFilterID2IUC2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterID2IUC2 *":
    """itkImageToImageFilterID2IUC2_cast(itkLightObject obj) -> itkImageToImageFilterID2IUC2"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterID2IUC2_cast(obj)

class itkImageToImageFilterID2IUL2(itkImageSourcePython.itkImageSourceIUL2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterID2IUL2 self, itkImageD2 image)
        SetInput(itkImageToImageFilterID2IUL2 self, unsigned int arg0, itkImageD2 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2IUL2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageD2 const *":
        """
        GetInput(itkImageToImageFilterID2IUL2 self) -> itkImageD2
        GetInput(itkImageToImageFilterID2IUL2 self, unsigned int idx) -> itkImageD2
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2IUL2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageD2') -> "void":
        """
        PushBackInput(itkImageToImageFilterID2IUL2 self, itkImageD2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2IUL2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterID2IUL2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2IUL2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageD2') -> "void":
        """PushFrontInput(itkImageToImageFilterID2IUL2 self, itkImageD2 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2IUL2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterID2IUL2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2IUL2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterID2IUL2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2IUL2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterID2IUL2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2IUL2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterID2IUL2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2IUL2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterID2IUL2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2IUL2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterID2IUL2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterID2IUL2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterID2IUL2"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2IUL2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterID2IUL2

        Create a new object of the class itkImageToImageFilterID2IUL2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterID2IUL2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterID2IUL2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterID2IUL2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterID2IUL2.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID2IUL2_SetInput, None, itkImageToImageFilterID2IUL2)
itkImageToImageFilterID2IUL2.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID2IUL2_GetInput, None, itkImageToImageFilterID2IUL2)
itkImageToImageFilterID2IUL2.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID2IUL2_PushBackInput, None, itkImageToImageFilterID2IUL2)
itkImageToImageFilterID2IUL2.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID2IUL2_PopBackInput, None, itkImageToImageFilterID2IUL2)
itkImageToImageFilterID2IUL2.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID2IUL2_PushFrontInput, None, itkImageToImageFilterID2IUL2)
itkImageToImageFilterID2IUL2.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID2IUL2_PopFrontInput, None, itkImageToImageFilterID2IUL2)
itkImageToImageFilterID2IUL2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID2IUL2_SetCoordinateTolerance, None, itkImageToImageFilterID2IUL2)
itkImageToImageFilterID2IUL2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID2IUL2_GetCoordinateTolerance, None, itkImageToImageFilterID2IUL2)
itkImageToImageFilterID2IUL2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID2IUL2_SetDirectionTolerance, None, itkImageToImageFilterID2IUL2)
itkImageToImageFilterID2IUL2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID2IUL2_GetDirectionTolerance, None, itkImageToImageFilterID2IUL2)
itkImageToImageFilterID2IUL2_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterID2IUL2_swigregister
itkImageToImageFilterID2IUL2_swigregister(itkImageToImageFilterID2IUL2)

def itkImageToImageFilterID2IUL2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterID2IUL2 *":
    """itkImageToImageFilterID2IUL2_cast(itkLightObject obj) -> itkImageToImageFilterID2IUL2"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterID2IUL2_cast(obj)

class itkImageToImageFilterID2IUS2(itkImageSourcePython.itkImageSourceIUS2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterID2IUS2 self, itkImageD2 image)
        SetInput(itkImageToImageFilterID2IUS2 self, unsigned int arg0, itkImageD2 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2IUS2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageD2 const *":
        """
        GetInput(itkImageToImageFilterID2IUS2 self) -> itkImageD2
        GetInput(itkImageToImageFilterID2IUS2 self, unsigned int idx) -> itkImageD2
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2IUS2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageD2') -> "void":
        """
        PushBackInput(itkImageToImageFilterID2IUS2 self, itkImageD2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2IUS2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterID2IUS2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2IUS2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageD2') -> "void":
        """PushFrontInput(itkImageToImageFilterID2IUS2 self, itkImageD2 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2IUS2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterID2IUS2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2IUS2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterID2IUS2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2IUS2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterID2IUS2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2IUS2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterID2IUS2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2IUS2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterID2IUS2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2IUS2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterID2IUS2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterID2IUS2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterID2IUS2"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID2IUS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterID2IUS2

        Create a new object of the class itkImageToImageFilterID2IUS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterID2IUS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterID2IUS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterID2IUS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterID2IUS2.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID2IUS2_SetInput, None, itkImageToImageFilterID2IUS2)
itkImageToImageFilterID2IUS2.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID2IUS2_GetInput, None, itkImageToImageFilterID2IUS2)
itkImageToImageFilterID2IUS2.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID2IUS2_PushBackInput, None, itkImageToImageFilterID2IUS2)
itkImageToImageFilterID2IUS2.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID2IUS2_PopBackInput, None, itkImageToImageFilterID2IUS2)
itkImageToImageFilterID2IUS2.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID2IUS2_PushFrontInput, None, itkImageToImageFilterID2IUS2)
itkImageToImageFilterID2IUS2.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID2IUS2_PopFrontInput, None, itkImageToImageFilterID2IUS2)
itkImageToImageFilterID2IUS2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID2IUS2_SetCoordinateTolerance, None, itkImageToImageFilterID2IUS2)
itkImageToImageFilterID2IUS2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID2IUS2_GetCoordinateTolerance, None, itkImageToImageFilterID2IUS2)
itkImageToImageFilterID2IUS2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID2IUS2_SetDirectionTolerance, None, itkImageToImageFilterID2IUS2)
itkImageToImageFilterID2IUS2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID2IUS2_GetDirectionTolerance, None, itkImageToImageFilterID2IUS2)
itkImageToImageFilterID2IUS2_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterID2IUS2_swigregister
itkImageToImageFilterID2IUS2_swigregister(itkImageToImageFilterID2IUS2)

def itkImageToImageFilterID2IUS2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterID2IUS2 *":
    """itkImageToImageFilterID2IUS2_cast(itkLightObject obj) -> itkImageToImageFilterID2IUS2"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterID2IUS2_cast(obj)

class itkImageToImageFilterID3ID3(itkImageSourcePython.itkImageSourceID3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterID3ID3 self, itkImageD3 image)
        SetInput(itkImageToImageFilterID3ID3 self, unsigned int arg0, itkImageD3 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3ID3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageD3 const *":
        """
        GetInput(itkImageToImageFilterID3ID3 self) -> itkImageD3
        GetInput(itkImageToImageFilterID3ID3 self, unsigned int idx) -> itkImageD3
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3ID3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageD3') -> "void":
        """
        PushBackInput(itkImageToImageFilterID3ID3 self, itkImageD3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3ID3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterID3ID3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3ID3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageD3') -> "void":
        """PushFrontInput(itkImageToImageFilterID3ID3 self, itkImageD3 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3ID3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterID3ID3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3ID3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterID3ID3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3ID3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterID3ID3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3ID3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterID3ID3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3ID3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterID3ID3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3ID3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterID3ID3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterID3ID3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterID3ID3"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3ID3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterID3ID3

        Create a new object of the class itkImageToImageFilterID3ID3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterID3ID3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterID3ID3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterID3ID3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterID3ID3.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID3ID3_SetInput, None, itkImageToImageFilterID3ID3)
itkImageToImageFilterID3ID3.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID3ID3_GetInput, None, itkImageToImageFilterID3ID3)
itkImageToImageFilterID3ID3.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID3ID3_PushBackInput, None, itkImageToImageFilterID3ID3)
itkImageToImageFilterID3ID3.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID3ID3_PopBackInput, None, itkImageToImageFilterID3ID3)
itkImageToImageFilterID3ID3.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID3ID3_PushFrontInput, None, itkImageToImageFilterID3ID3)
itkImageToImageFilterID3ID3.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID3ID3_PopFrontInput, None, itkImageToImageFilterID3ID3)
itkImageToImageFilterID3ID3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID3ID3_SetCoordinateTolerance, None, itkImageToImageFilterID3ID3)
itkImageToImageFilterID3ID3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID3ID3_GetCoordinateTolerance, None, itkImageToImageFilterID3ID3)
itkImageToImageFilterID3ID3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID3ID3_SetDirectionTolerance, None, itkImageToImageFilterID3ID3)
itkImageToImageFilterID3ID3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID3ID3_GetDirectionTolerance, None, itkImageToImageFilterID3ID3)
itkImageToImageFilterID3ID3_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterID3ID3_swigregister
itkImageToImageFilterID3ID3_swigregister(itkImageToImageFilterID3ID3)

def itkImageToImageFilterID3ID3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterID3ID3 *":
    """itkImageToImageFilterID3ID3_cast(itkLightObject obj) -> itkImageToImageFilterID3ID3"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterID3ID3_cast(obj)

class itkImageToImageFilterID3IF3(itkImageSourcePython.itkImageSourceIF3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterID3IF3 self, itkImageD3 image)
        SetInput(itkImageToImageFilterID3IF3 self, unsigned int arg0, itkImageD3 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3IF3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageD3 const *":
        """
        GetInput(itkImageToImageFilterID3IF3 self) -> itkImageD3
        GetInput(itkImageToImageFilterID3IF3 self, unsigned int idx) -> itkImageD3
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3IF3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageD3') -> "void":
        """
        PushBackInput(itkImageToImageFilterID3IF3 self, itkImageD3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3IF3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterID3IF3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3IF3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageD3') -> "void":
        """PushFrontInput(itkImageToImageFilterID3IF3 self, itkImageD3 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3IF3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterID3IF3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3IF3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterID3IF3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3IF3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterID3IF3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3IF3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterID3IF3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3IF3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterID3IF3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3IF3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterID3IF3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterID3IF3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterID3IF3"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3IF3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterID3IF3

        Create a new object of the class itkImageToImageFilterID3IF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterID3IF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterID3IF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterID3IF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterID3IF3.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID3IF3_SetInput, None, itkImageToImageFilterID3IF3)
itkImageToImageFilterID3IF3.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID3IF3_GetInput, None, itkImageToImageFilterID3IF3)
itkImageToImageFilterID3IF3.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID3IF3_PushBackInput, None, itkImageToImageFilterID3IF3)
itkImageToImageFilterID3IF3.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID3IF3_PopBackInput, None, itkImageToImageFilterID3IF3)
itkImageToImageFilterID3IF3.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID3IF3_PushFrontInput, None, itkImageToImageFilterID3IF3)
itkImageToImageFilterID3IF3.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID3IF3_PopFrontInput, None, itkImageToImageFilterID3IF3)
itkImageToImageFilterID3IF3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID3IF3_SetCoordinateTolerance, None, itkImageToImageFilterID3IF3)
itkImageToImageFilterID3IF3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID3IF3_GetCoordinateTolerance, None, itkImageToImageFilterID3IF3)
itkImageToImageFilterID3IF3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID3IF3_SetDirectionTolerance, None, itkImageToImageFilterID3IF3)
itkImageToImageFilterID3IF3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID3IF3_GetDirectionTolerance, None, itkImageToImageFilterID3IF3)
itkImageToImageFilterID3IF3_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterID3IF3_swigregister
itkImageToImageFilterID3IF3_swigregister(itkImageToImageFilterID3IF3)

def itkImageToImageFilterID3IF3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterID3IF3 *":
    """itkImageToImageFilterID3IF3_cast(itkLightObject obj) -> itkImageToImageFilterID3IF3"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterID3IF3_cast(obj)

class itkImageToImageFilterID3ISS3(itkImageSourcePython.itkImageSourceISS3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterID3ISS3 self, itkImageD3 image)
        SetInput(itkImageToImageFilterID3ISS3 self, unsigned int arg0, itkImageD3 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3ISS3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageD3 const *":
        """
        GetInput(itkImageToImageFilterID3ISS3 self) -> itkImageD3
        GetInput(itkImageToImageFilterID3ISS3 self, unsigned int idx) -> itkImageD3
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3ISS3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageD3') -> "void":
        """
        PushBackInput(itkImageToImageFilterID3ISS3 self, itkImageD3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3ISS3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterID3ISS3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3ISS3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageD3') -> "void":
        """PushFrontInput(itkImageToImageFilterID3ISS3 self, itkImageD3 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3ISS3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterID3ISS3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3ISS3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterID3ISS3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3ISS3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterID3ISS3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3ISS3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterID3ISS3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3ISS3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterID3ISS3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3ISS3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterID3ISS3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterID3ISS3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterID3ISS3"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3ISS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterID3ISS3

        Create a new object of the class itkImageToImageFilterID3ISS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterID3ISS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterID3ISS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterID3ISS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterID3ISS3.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID3ISS3_SetInput, None, itkImageToImageFilterID3ISS3)
itkImageToImageFilterID3ISS3.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID3ISS3_GetInput, None, itkImageToImageFilterID3ISS3)
itkImageToImageFilterID3ISS3.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID3ISS3_PushBackInput, None, itkImageToImageFilterID3ISS3)
itkImageToImageFilterID3ISS3.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID3ISS3_PopBackInput, None, itkImageToImageFilterID3ISS3)
itkImageToImageFilterID3ISS3.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID3ISS3_PushFrontInput, None, itkImageToImageFilterID3ISS3)
itkImageToImageFilterID3ISS3.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID3ISS3_PopFrontInput, None, itkImageToImageFilterID3ISS3)
itkImageToImageFilterID3ISS3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID3ISS3_SetCoordinateTolerance, None, itkImageToImageFilterID3ISS3)
itkImageToImageFilterID3ISS3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID3ISS3_GetCoordinateTolerance, None, itkImageToImageFilterID3ISS3)
itkImageToImageFilterID3ISS3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID3ISS3_SetDirectionTolerance, None, itkImageToImageFilterID3ISS3)
itkImageToImageFilterID3ISS3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID3ISS3_GetDirectionTolerance, None, itkImageToImageFilterID3ISS3)
itkImageToImageFilterID3ISS3_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterID3ISS3_swigregister
itkImageToImageFilterID3ISS3_swigregister(itkImageToImageFilterID3ISS3)

def itkImageToImageFilterID3ISS3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterID3ISS3 *":
    """itkImageToImageFilterID3ISS3_cast(itkLightObject obj) -> itkImageToImageFilterID3ISS3"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterID3ISS3_cast(obj)

class itkImageToImageFilterID3IUC3(itkImageSourcePython.itkImageSourceIUC3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterID3IUC3 self, itkImageD3 image)
        SetInput(itkImageToImageFilterID3IUC3 self, unsigned int arg0, itkImageD3 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3IUC3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageD3 const *":
        """
        GetInput(itkImageToImageFilterID3IUC3 self) -> itkImageD3
        GetInput(itkImageToImageFilterID3IUC3 self, unsigned int idx) -> itkImageD3
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3IUC3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageD3') -> "void":
        """
        PushBackInput(itkImageToImageFilterID3IUC3 self, itkImageD3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3IUC3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterID3IUC3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3IUC3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageD3') -> "void":
        """PushFrontInput(itkImageToImageFilterID3IUC3 self, itkImageD3 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3IUC3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterID3IUC3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3IUC3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterID3IUC3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3IUC3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterID3IUC3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3IUC3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterID3IUC3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3IUC3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterID3IUC3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3IUC3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterID3IUC3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterID3IUC3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterID3IUC3"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3IUC3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterID3IUC3

        Create a new object of the class itkImageToImageFilterID3IUC3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterID3IUC3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterID3IUC3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterID3IUC3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterID3IUC3.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID3IUC3_SetInput, None, itkImageToImageFilterID3IUC3)
itkImageToImageFilterID3IUC3.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID3IUC3_GetInput, None, itkImageToImageFilterID3IUC3)
itkImageToImageFilterID3IUC3.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID3IUC3_PushBackInput, None, itkImageToImageFilterID3IUC3)
itkImageToImageFilterID3IUC3.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID3IUC3_PopBackInput, None, itkImageToImageFilterID3IUC3)
itkImageToImageFilterID3IUC3.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID3IUC3_PushFrontInput, None, itkImageToImageFilterID3IUC3)
itkImageToImageFilterID3IUC3.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID3IUC3_PopFrontInput, None, itkImageToImageFilterID3IUC3)
itkImageToImageFilterID3IUC3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID3IUC3_SetCoordinateTolerance, None, itkImageToImageFilterID3IUC3)
itkImageToImageFilterID3IUC3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID3IUC3_GetCoordinateTolerance, None, itkImageToImageFilterID3IUC3)
itkImageToImageFilterID3IUC3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID3IUC3_SetDirectionTolerance, None, itkImageToImageFilterID3IUC3)
itkImageToImageFilterID3IUC3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID3IUC3_GetDirectionTolerance, None, itkImageToImageFilterID3IUC3)
itkImageToImageFilterID3IUC3_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterID3IUC3_swigregister
itkImageToImageFilterID3IUC3_swigregister(itkImageToImageFilterID3IUC3)

def itkImageToImageFilterID3IUC3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterID3IUC3 *":
    """itkImageToImageFilterID3IUC3_cast(itkLightObject obj) -> itkImageToImageFilterID3IUC3"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterID3IUC3_cast(obj)

class itkImageToImageFilterID3IUL3(itkImageSourcePython.itkImageSourceIUL3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterID3IUL3 self, itkImageD3 image)
        SetInput(itkImageToImageFilterID3IUL3 self, unsigned int arg0, itkImageD3 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3IUL3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageD3 const *":
        """
        GetInput(itkImageToImageFilterID3IUL3 self) -> itkImageD3
        GetInput(itkImageToImageFilterID3IUL3 self, unsigned int idx) -> itkImageD3
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3IUL3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageD3') -> "void":
        """
        PushBackInput(itkImageToImageFilterID3IUL3 self, itkImageD3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3IUL3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterID3IUL3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3IUL3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageD3') -> "void":
        """PushFrontInput(itkImageToImageFilterID3IUL3 self, itkImageD3 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3IUL3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterID3IUL3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3IUL3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterID3IUL3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3IUL3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterID3IUL3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3IUL3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterID3IUL3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3IUL3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterID3IUL3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3IUL3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterID3IUL3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterID3IUL3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterID3IUL3"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3IUL3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterID3IUL3

        Create a new object of the class itkImageToImageFilterID3IUL3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterID3IUL3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterID3IUL3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterID3IUL3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterID3IUL3.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID3IUL3_SetInput, None, itkImageToImageFilterID3IUL3)
itkImageToImageFilterID3IUL3.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID3IUL3_GetInput, None, itkImageToImageFilterID3IUL3)
itkImageToImageFilterID3IUL3.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID3IUL3_PushBackInput, None, itkImageToImageFilterID3IUL3)
itkImageToImageFilterID3IUL3.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID3IUL3_PopBackInput, None, itkImageToImageFilterID3IUL3)
itkImageToImageFilterID3IUL3.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID3IUL3_PushFrontInput, None, itkImageToImageFilterID3IUL3)
itkImageToImageFilterID3IUL3.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID3IUL3_PopFrontInput, None, itkImageToImageFilterID3IUL3)
itkImageToImageFilterID3IUL3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID3IUL3_SetCoordinateTolerance, None, itkImageToImageFilterID3IUL3)
itkImageToImageFilterID3IUL3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID3IUL3_GetCoordinateTolerance, None, itkImageToImageFilterID3IUL3)
itkImageToImageFilterID3IUL3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID3IUL3_SetDirectionTolerance, None, itkImageToImageFilterID3IUL3)
itkImageToImageFilterID3IUL3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID3IUL3_GetDirectionTolerance, None, itkImageToImageFilterID3IUL3)
itkImageToImageFilterID3IUL3_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterID3IUL3_swigregister
itkImageToImageFilterID3IUL3_swigregister(itkImageToImageFilterID3IUL3)

def itkImageToImageFilterID3IUL3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterID3IUL3 *":
    """itkImageToImageFilterID3IUL3_cast(itkLightObject obj) -> itkImageToImageFilterID3IUL3"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterID3IUL3_cast(obj)

class itkImageToImageFilterID3IUS3(itkImageSourcePython.itkImageSourceIUS3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterID3IUS3 self, itkImageD3 image)
        SetInput(itkImageToImageFilterID3IUS3 self, unsigned int arg0, itkImageD3 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3IUS3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageD3 const *":
        """
        GetInput(itkImageToImageFilterID3IUS3 self) -> itkImageD3
        GetInput(itkImageToImageFilterID3IUS3 self, unsigned int idx) -> itkImageD3
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3IUS3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageD3') -> "void":
        """
        PushBackInput(itkImageToImageFilterID3IUS3 self, itkImageD3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3IUS3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterID3IUS3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3IUS3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageD3') -> "void":
        """PushFrontInput(itkImageToImageFilterID3IUS3 self, itkImageD3 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3IUS3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterID3IUS3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3IUS3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterID3IUS3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3IUS3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterID3IUS3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3IUS3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterID3IUS3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3IUS3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterID3IUS3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3IUS3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterID3IUS3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterID3IUS3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterID3IUS3"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterID3IUS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterID3IUS3

        Create a new object of the class itkImageToImageFilterID3IUS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterID3IUS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterID3IUS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterID3IUS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterID3IUS3.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID3IUS3_SetInput, None, itkImageToImageFilterID3IUS3)
itkImageToImageFilterID3IUS3.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID3IUS3_GetInput, None, itkImageToImageFilterID3IUS3)
itkImageToImageFilterID3IUS3.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID3IUS3_PushBackInput, None, itkImageToImageFilterID3IUS3)
itkImageToImageFilterID3IUS3.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID3IUS3_PopBackInput, None, itkImageToImageFilterID3IUS3)
itkImageToImageFilterID3IUS3.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID3IUS3_PushFrontInput, None, itkImageToImageFilterID3IUS3)
itkImageToImageFilterID3IUS3.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID3IUS3_PopFrontInput, None, itkImageToImageFilterID3IUS3)
itkImageToImageFilterID3IUS3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID3IUS3_SetCoordinateTolerance, None, itkImageToImageFilterID3IUS3)
itkImageToImageFilterID3IUS3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID3IUS3_GetCoordinateTolerance, None, itkImageToImageFilterID3IUS3)
itkImageToImageFilterID3IUS3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID3IUS3_SetDirectionTolerance, None, itkImageToImageFilterID3IUS3)
itkImageToImageFilterID3IUS3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterID3IUS3_GetDirectionTolerance, None, itkImageToImageFilterID3IUS3)
itkImageToImageFilterID3IUS3_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterID3IUS3_swigregister
itkImageToImageFilterID3IUS3_swigregister(itkImageToImageFilterID3IUS3)

def itkImageToImageFilterID3IUS3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterID3IUS3 *":
    """itkImageToImageFilterID3IUS3_cast(itkLightObject obj) -> itkImageToImageFilterID3IUS3"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterID3IUS3_cast(obj)

class itkImageToImageFilterIF2ID2(itkImageSourcePython.itkImageSourceID2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIF2ID2 self, itkImageF2 image)
        SetInput(itkImageToImageFilterIF2ID2 self, unsigned int arg0, itkImageF2 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2ID2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageF2 const *":
        """
        GetInput(itkImageToImageFilterIF2ID2 self) -> itkImageF2
        GetInput(itkImageToImageFilterIF2ID2 self, unsigned int idx) -> itkImageF2
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2ID2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageF2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIF2ID2 self, itkImageF2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2ID2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIF2ID2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2ID2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageF2') -> "void":
        """PushFrontInput(itkImageToImageFilterIF2ID2 self, itkImageF2 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2ID2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIF2ID2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2ID2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIF2ID2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2ID2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIF2ID2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2ID2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIF2ID2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2ID2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIF2ID2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2ID2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIF2ID2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF2ID2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIF2ID2"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2ID2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIF2ID2

        Create a new object of the class itkImageToImageFilterIF2ID2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIF2ID2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIF2ID2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIF2ID2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIF2ID2.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF2ID2_SetInput, None, itkImageToImageFilterIF2ID2)
itkImageToImageFilterIF2ID2.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF2ID2_GetInput, None, itkImageToImageFilterIF2ID2)
itkImageToImageFilterIF2ID2.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF2ID2_PushBackInput, None, itkImageToImageFilterIF2ID2)
itkImageToImageFilterIF2ID2.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF2ID2_PopBackInput, None, itkImageToImageFilterIF2ID2)
itkImageToImageFilterIF2ID2.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF2ID2_PushFrontInput, None, itkImageToImageFilterIF2ID2)
itkImageToImageFilterIF2ID2.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF2ID2_PopFrontInput, None, itkImageToImageFilterIF2ID2)
itkImageToImageFilterIF2ID2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF2ID2_SetCoordinateTolerance, None, itkImageToImageFilterIF2ID2)
itkImageToImageFilterIF2ID2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF2ID2_GetCoordinateTolerance, None, itkImageToImageFilterIF2ID2)
itkImageToImageFilterIF2ID2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF2ID2_SetDirectionTolerance, None, itkImageToImageFilterIF2ID2)
itkImageToImageFilterIF2ID2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF2ID2_GetDirectionTolerance, None, itkImageToImageFilterIF2ID2)
itkImageToImageFilterIF2ID2_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIF2ID2_swigregister
itkImageToImageFilterIF2ID2_swigregister(itkImageToImageFilterIF2ID2)

def itkImageToImageFilterIF2ID2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF2ID2 *":
    """itkImageToImageFilterIF2ID2_cast(itkLightObject obj) -> itkImageToImageFilterIF2ID2"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIF2ID2_cast(obj)

class itkImageToImageFilterIF2IF2(itkImageSourcePython.itkImageSourceIF2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIF2IF2 self, itkImageF2 image)
        SetInput(itkImageToImageFilterIF2IF2 self, unsigned int arg0, itkImageF2 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2IF2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageF2 const *":
        """
        GetInput(itkImageToImageFilterIF2IF2 self) -> itkImageF2
        GetInput(itkImageToImageFilterIF2IF2 self, unsigned int idx) -> itkImageF2
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2IF2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageF2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIF2IF2 self, itkImageF2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2IF2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIF2IF2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2IF2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageF2') -> "void":
        """PushFrontInput(itkImageToImageFilterIF2IF2 self, itkImageF2 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2IF2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIF2IF2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2IF2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIF2IF2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2IF2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIF2IF2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2IF2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIF2IF2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2IF2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIF2IF2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2IF2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIF2IF2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF2IF2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIF2IF2"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2IF2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIF2IF2

        Create a new object of the class itkImageToImageFilterIF2IF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIF2IF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIF2IF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIF2IF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIF2IF2.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF2IF2_SetInput, None, itkImageToImageFilterIF2IF2)
itkImageToImageFilterIF2IF2.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF2IF2_GetInput, None, itkImageToImageFilterIF2IF2)
itkImageToImageFilterIF2IF2.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF2IF2_PushBackInput, None, itkImageToImageFilterIF2IF2)
itkImageToImageFilterIF2IF2.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF2IF2_PopBackInput, None, itkImageToImageFilterIF2IF2)
itkImageToImageFilterIF2IF2.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF2IF2_PushFrontInput, None, itkImageToImageFilterIF2IF2)
itkImageToImageFilterIF2IF2.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF2IF2_PopFrontInput, None, itkImageToImageFilterIF2IF2)
itkImageToImageFilterIF2IF2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF2IF2_SetCoordinateTolerance, None, itkImageToImageFilterIF2IF2)
itkImageToImageFilterIF2IF2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF2IF2_GetCoordinateTolerance, None, itkImageToImageFilterIF2IF2)
itkImageToImageFilterIF2IF2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF2IF2_SetDirectionTolerance, None, itkImageToImageFilterIF2IF2)
itkImageToImageFilterIF2IF2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF2IF2_GetDirectionTolerance, None, itkImageToImageFilterIF2IF2)
itkImageToImageFilterIF2IF2_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIF2IF2_swigregister
itkImageToImageFilterIF2IF2_swigregister(itkImageToImageFilterIF2IF2)

def itkImageToImageFilterIF2IF2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF2IF2 *":
    """itkImageToImageFilterIF2IF2_cast(itkLightObject obj) -> itkImageToImageFilterIF2IF2"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIF2IF2_cast(obj)

class itkImageToImageFilterIF2ISS2(itkImageSourcePython.itkImageSourceISS2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIF2ISS2 self, itkImageF2 image)
        SetInput(itkImageToImageFilterIF2ISS2 self, unsigned int arg0, itkImageF2 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2ISS2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageF2 const *":
        """
        GetInput(itkImageToImageFilterIF2ISS2 self) -> itkImageF2
        GetInput(itkImageToImageFilterIF2ISS2 self, unsigned int idx) -> itkImageF2
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2ISS2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageF2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIF2ISS2 self, itkImageF2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2ISS2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIF2ISS2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2ISS2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageF2') -> "void":
        """PushFrontInput(itkImageToImageFilterIF2ISS2 self, itkImageF2 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2ISS2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIF2ISS2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2ISS2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIF2ISS2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2ISS2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIF2ISS2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2ISS2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIF2ISS2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2ISS2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIF2ISS2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2ISS2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIF2ISS2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF2ISS2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIF2ISS2"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2ISS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIF2ISS2

        Create a new object of the class itkImageToImageFilterIF2ISS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIF2ISS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIF2ISS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIF2ISS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIF2ISS2.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF2ISS2_SetInput, None, itkImageToImageFilterIF2ISS2)
itkImageToImageFilterIF2ISS2.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF2ISS2_GetInput, None, itkImageToImageFilterIF2ISS2)
itkImageToImageFilterIF2ISS2.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF2ISS2_PushBackInput, None, itkImageToImageFilterIF2ISS2)
itkImageToImageFilterIF2ISS2.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF2ISS2_PopBackInput, None, itkImageToImageFilterIF2ISS2)
itkImageToImageFilterIF2ISS2.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF2ISS2_PushFrontInput, None, itkImageToImageFilterIF2ISS2)
itkImageToImageFilterIF2ISS2.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF2ISS2_PopFrontInput, None, itkImageToImageFilterIF2ISS2)
itkImageToImageFilterIF2ISS2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF2ISS2_SetCoordinateTolerance, None, itkImageToImageFilterIF2ISS2)
itkImageToImageFilterIF2ISS2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF2ISS2_GetCoordinateTolerance, None, itkImageToImageFilterIF2ISS2)
itkImageToImageFilterIF2ISS2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF2ISS2_SetDirectionTolerance, None, itkImageToImageFilterIF2ISS2)
itkImageToImageFilterIF2ISS2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF2ISS2_GetDirectionTolerance, None, itkImageToImageFilterIF2ISS2)
itkImageToImageFilterIF2ISS2_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIF2ISS2_swigregister
itkImageToImageFilterIF2ISS2_swigregister(itkImageToImageFilterIF2ISS2)

def itkImageToImageFilterIF2ISS2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF2ISS2 *":
    """itkImageToImageFilterIF2ISS2_cast(itkLightObject obj) -> itkImageToImageFilterIF2ISS2"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIF2ISS2_cast(obj)

class itkImageToImageFilterIF2IUC2(itkImageSourcePython.itkImageSourceIUC2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIF2IUC2 self, itkImageF2 image)
        SetInput(itkImageToImageFilterIF2IUC2 self, unsigned int arg0, itkImageF2 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2IUC2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageF2 const *":
        """
        GetInput(itkImageToImageFilterIF2IUC2 self) -> itkImageF2
        GetInput(itkImageToImageFilterIF2IUC2 self, unsigned int idx) -> itkImageF2
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2IUC2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageF2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIF2IUC2 self, itkImageF2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2IUC2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIF2IUC2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2IUC2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageF2') -> "void":
        """PushFrontInput(itkImageToImageFilterIF2IUC2 self, itkImageF2 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2IUC2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIF2IUC2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2IUC2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIF2IUC2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2IUC2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIF2IUC2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2IUC2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIF2IUC2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2IUC2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIF2IUC2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2IUC2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIF2IUC2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF2IUC2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIF2IUC2"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2IUC2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIF2IUC2

        Create a new object of the class itkImageToImageFilterIF2IUC2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIF2IUC2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIF2IUC2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIF2IUC2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIF2IUC2.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF2IUC2_SetInput, None, itkImageToImageFilterIF2IUC2)
itkImageToImageFilterIF2IUC2.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF2IUC2_GetInput, None, itkImageToImageFilterIF2IUC2)
itkImageToImageFilterIF2IUC2.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF2IUC2_PushBackInput, None, itkImageToImageFilterIF2IUC2)
itkImageToImageFilterIF2IUC2.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF2IUC2_PopBackInput, None, itkImageToImageFilterIF2IUC2)
itkImageToImageFilterIF2IUC2.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF2IUC2_PushFrontInput, None, itkImageToImageFilterIF2IUC2)
itkImageToImageFilterIF2IUC2.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF2IUC2_PopFrontInput, None, itkImageToImageFilterIF2IUC2)
itkImageToImageFilterIF2IUC2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF2IUC2_SetCoordinateTolerance, None, itkImageToImageFilterIF2IUC2)
itkImageToImageFilterIF2IUC2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF2IUC2_GetCoordinateTolerance, None, itkImageToImageFilterIF2IUC2)
itkImageToImageFilterIF2IUC2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF2IUC2_SetDirectionTolerance, None, itkImageToImageFilterIF2IUC2)
itkImageToImageFilterIF2IUC2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF2IUC2_GetDirectionTolerance, None, itkImageToImageFilterIF2IUC2)
itkImageToImageFilterIF2IUC2_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIF2IUC2_swigregister
itkImageToImageFilterIF2IUC2_swigregister(itkImageToImageFilterIF2IUC2)

def itkImageToImageFilterIF2IUC2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF2IUC2 *":
    """itkImageToImageFilterIF2IUC2_cast(itkLightObject obj) -> itkImageToImageFilterIF2IUC2"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIF2IUC2_cast(obj)

class itkImageToImageFilterIF2IUL2(itkImageSourcePython.itkImageSourceIUL2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIF2IUL2 self, itkImageF2 image)
        SetInput(itkImageToImageFilterIF2IUL2 self, unsigned int arg0, itkImageF2 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2IUL2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageF2 const *":
        """
        GetInput(itkImageToImageFilterIF2IUL2 self) -> itkImageF2
        GetInput(itkImageToImageFilterIF2IUL2 self, unsigned int idx) -> itkImageF2
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2IUL2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageF2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIF2IUL2 self, itkImageF2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2IUL2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIF2IUL2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2IUL2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageF2') -> "void":
        """PushFrontInput(itkImageToImageFilterIF2IUL2 self, itkImageF2 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2IUL2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIF2IUL2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2IUL2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIF2IUL2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2IUL2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIF2IUL2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2IUL2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIF2IUL2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2IUL2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIF2IUL2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2IUL2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIF2IUL2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF2IUL2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIF2IUL2"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2IUL2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIF2IUL2

        Create a new object of the class itkImageToImageFilterIF2IUL2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIF2IUL2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIF2IUL2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIF2IUL2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIF2IUL2.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF2IUL2_SetInput, None, itkImageToImageFilterIF2IUL2)
itkImageToImageFilterIF2IUL2.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF2IUL2_GetInput, None, itkImageToImageFilterIF2IUL2)
itkImageToImageFilterIF2IUL2.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF2IUL2_PushBackInput, None, itkImageToImageFilterIF2IUL2)
itkImageToImageFilterIF2IUL2.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF2IUL2_PopBackInput, None, itkImageToImageFilterIF2IUL2)
itkImageToImageFilterIF2IUL2.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF2IUL2_PushFrontInput, None, itkImageToImageFilterIF2IUL2)
itkImageToImageFilterIF2IUL2.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF2IUL2_PopFrontInput, None, itkImageToImageFilterIF2IUL2)
itkImageToImageFilterIF2IUL2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF2IUL2_SetCoordinateTolerance, None, itkImageToImageFilterIF2IUL2)
itkImageToImageFilterIF2IUL2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF2IUL2_GetCoordinateTolerance, None, itkImageToImageFilterIF2IUL2)
itkImageToImageFilterIF2IUL2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF2IUL2_SetDirectionTolerance, None, itkImageToImageFilterIF2IUL2)
itkImageToImageFilterIF2IUL2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF2IUL2_GetDirectionTolerance, None, itkImageToImageFilterIF2IUL2)
itkImageToImageFilterIF2IUL2_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIF2IUL2_swigregister
itkImageToImageFilterIF2IUL2_swigregister(itkImageToImageFilterIF2IUL2)

def itkImageToImageFilterIF2IUL2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF2IUL2 *":
    """itkImageToImageFilterIF2IUL2_cast(itkLightObject obj) -> itkImageToImageFilterIF2IUL2"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIF2IUL2_cast(obj)

class itkImageToImageFilterIF2IUS2(itkImageSourcePython.itkImageSourceIUS2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIF2IUS2 self, itkImageF2 image)
        SetInput(itkImageToImageFilterIF2IUS2 self, unsigned int arg0, itkImageF2 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2IUS2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageF2 const *":
        """
        GetInput(itkImageToImageFilterIF2IUS2 self) -> itkImageF2
        GetInput(itkImageToImageFilterIF2IUS2 self, unsigned int idx) -> itkImageF2
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2IUS2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageF2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIF2IUS2 self, itkImageF2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2IUS2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIF2IUS2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2IUS2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageF2') -> "void":
        """PushFrontInput(itkImageToImageFilterIF2IUS2 self, itkImageF2 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2IUS2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIF2IUS2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2IUS2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIF2IUS2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2IUS2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIF2IUS2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2IUS2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIF2IUS2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2IUS2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIF2IUS2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2IUS2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIF2IUS2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF2IUS2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIF2IUS2"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF2IUS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIF2IUS2

        Create a new object of the class itkImageToImageFilterIF2IUS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIF2IUS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIF2IUS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIF2IUS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIF2IUS2.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF2IUS2_SetInput, None, itkImageToImageFilterIF2IUS2)
itkImageToImageFilterIF2IUS2.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF2IUS2_GetInput, None, itkImageToImageFilterIF2IUS2)
itkImageToImageFilterIF2IUS2.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF2IUS2_PushBackInput, None, itkImageToImageFilterIF2IUS2)
itkImageToImageFilterIF2IUS2.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF2IUS2_PopBackInput, None, itkImageToImageFilterIF2IUS2)
itkImageToImageFilterIF2IUS2.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF2IUS2_PushFrontInput, None, itkImageToImageFilterIF2IUS2)
itkImageToImageFilterIF2IUS2.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF2IUS2_PopFrontInput, None, itkImageToImageFilterIF2IUS2)
itkImageToImageFilterIF2IUS2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF2IUS2_SetCoordinateTolerance, None, itkImageToImageFilterIF2IUS2)
itkImageToImageFilterIF2IUS2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF2IUS2_GetCoordinateTolerance, None, itkImageToImageFilterIF2IUS2)
itkImageToImageFilterIF2IUS2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF2IUS2_SetDirectionTolerance, None, itkImageToImageFilterIF2IUS2)
itkImageToImageFilterIF2IUS2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF2IUS2_GetDirectionTolerance, None, itkImageToImageFilterIF2IUS2)
itkImageToImageFilterIF2IUS2_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIF2IUS2_swigregister
itkImageToImageFilterIF2IUS2_swigregister(itkImageToImageFilterIF2IUS2)

def itkImageToImageFilterIF2IUS2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF2IUS2 *":
    """itkImageToImageFilterIF2IUS2_cast(itkLightObject obj) -> itkImageToImageFilterIF2IUS2"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIF2IUS2_cast(obj)

class itkImageToImageFilterIF3ID3(itkImageSourcePython.itkImageSourceID3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIF3ID3 self, itkImageF3 image)
        SetInput(itkImageToImageFilterIF3ID3 self, unsigned int arg0, itkImageF3 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3ID3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageF3 const *":
        """
        GetInput(itkImageToImageFilterIF3ID3 self) -> itkImageF3
        GetInput(itkImageToImageFilterIF3ID3 self, unsigned int idx) -> itkImageF3
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3ID3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageF3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIF3ID3 self, itkImageF3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3ID3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIF3ID3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3ID3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageF3') -> "void":
        """PushFrontInput(itkImageToImageFilterIF3ID3 self, itkImageF3 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3ID3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIF3ID3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3ID3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIF3ID3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3ID3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIF3ID3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3ID3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIF3ID3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3ID3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIF3ID3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3ID3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIF3ID3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF3ID3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIF3ID3"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3ID3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIF3ID3

        Create a new object of the class itkImageToImageFilterIF3ID3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIF3ID3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIF3ID3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIF3ID3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIF3ID3.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF3ID3_SetInput, None, itkImageToImageFilterIF3ID3)
itkImageToImageFilterIF3ID3.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF3ID3_GetInput, None, itkImageToImageFilterIF3ID3)
itkImageToImageFilterIF3ID3.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF3ID3_PushBackInput, None, itkImageToImageFilterIF3ID3)
itkImageToImageFilterIF3ID3.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF3ID3_PopBackInput, None, itkImageToImageFilterIF3ID3)
itkImageToImageFilterIF3ID3.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF3ID3_PushFrontInput, None, itkImageToImageFilterIF3ID3)
itkImageToImageFilterIF3ID3.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF3ID3_PopFrontInput, None, itkImageToImageFilterIF3ID3)
itkImageToImageFilterIF3ID3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF3ID3_SetCoordinateTolerance, None, itkImageToImageFilterIF3ID3)
itkImageToImageFilterIF3ID3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF3ID3_GetCoordinateTolerance, None, itkImageToImageFilterIF3ID3)
itkImageToImageFilterIF3ID3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF3ID3_SetDirectionTolerance, None, itkImageToImageFilterIF3ID3)
itkImageToImageFilterIF3ID3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF3ID3_GetDirectionTolerance, None, itkImageToImageFilterIF3ID3)
itkImageToImageFilterIF3ID3_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIF3ID3_swigregister
itkImageToImageFilterIF3ID3_swigregister(itkImageToImageFilterIF3ID3)

def itkImageToImageFilterIF3ID3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF3ID3 *":
    """itkImageToImageFilterIF3ID3_cast(itkLightObject obj) -> itkImageToImageFilterIF3ID3"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIF3ID3_cast(obj)

class itkImageToImageFilterIF3IF3(itkImageSourcePython.itkImageSourceIF3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIF3IF3 self, itkImageF3 image)
        SetInput(itkImageToImageFilterIF3IF3 self, unsigned int arg0, itkImageF3 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3IF3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageF3 const *":
        """
        GetInput(itkImageToImageFilterIF3IF3 self) -> itkImageF3
        GetInput(itkImageToImageFilterIF3IF3 self, unsigned int idx) -> itkImageF3
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3IF3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageF3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIF3IF3 self, itkImageF3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3IF3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIF3IF3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3IF3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageF3') -> "void":
        """PushFrontInput(itkImageToImageFilterIF3IF3 self, itkImageF3 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3IF3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIF3IF3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3IF3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIF3IF3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3IF3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIF3IF3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3IF3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIF3IF3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3IF3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIF3IF3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3IF3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIF3IF3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF3IF3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIF3IF3"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3IF3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIF3IF3

        Create a new object of the class itkImageToImageFilterIF3IF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIF3IF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIF3IF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIF3IF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIF3IF3.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF3IF3_SetInput, None, itkImageToImageFilterIF3IF3)
itkImageToImageFilterIF3IF3.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF3IF3_GetInput, None, itkImageToImageFilterIF3IF3)
itkImageToImageFilterIF3IF3.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF3IF3_PushBackInput, None, itkImageToImageFilterIF3IF3)
itkImageToImageFilterIF3IF3.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF3IF3_PopBackInput, None, itkImageToImageFilterIF3IF3)
itkImageToImageFilterIF3IF3.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF3IF3_PushFrontInput, None, itkImageToImageFilterIF3IF3)
itkImageToImageFilterIF3IF3.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF3IF3_PopFrontInput, None, itkImageToImageFilterIF3IF3)
itkImageToImageFilterIF3IF3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF3IF3_SetCoordinateTolerance, None, itkImageToImageFilterIF3IF3)
itkImageToImageFilterIF3IF3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF3IF3_GetCoordinateTolerance, None, itkImageToImageFilterIF3IF3)
itkImageToImageFilterIF3IF3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF3IF3_SetDirectionTolerance, None, itkImageToImageFilterIF3IF3)
itkImageToImageFilterIF3IF3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF3IF3_GetDirectionTolerance, None, itkImageToImageFilterIF3IF3)
itkImageToImageFilterIF3IF3_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIF3IF3_swigregister
itkImageToImageFilterIF3IF3_swigregister(itkImageToImageFilterIF3IF3)

def itkImageToImageFilterIF3IF3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF3IF3 *":
    """itkImageToImageFilterIF3IF3_cast(itkLightObject obj) -> itkImageToImageFilterIF3IF3"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIF3IF3_cast(obj)

class itkImageToImageFilterIF3ISS3(itkImageSourcePython.itkImageSourceISS3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIF3ISS3 self, itkImageF3 image)
        SetInput(itkImageToImageFilterIF3ISS3 self, unsigned int arg0, itkImageF3 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3ISS3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageF3 const *":
        """
        GetInput(itkImageToImageFilterIF3ISS3 self) -> itkImageF3
        GetInput(itkImageToImageFilterIF3ISS3 self, unsigned int idx) -> itkImageF3
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3ISS3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageF3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIF3ISS3 self, itkImageF3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3ISS3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIF3ISS3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3ISS3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageF3') -> "void":
        """PushFrontInput(itkImageToImageFilterIF3ISS3 self, itkImageF3 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3ISS3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIF3ISS3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3ISS3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIF3ISS3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3ISS3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIF3ISS3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3ISS3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIF3ISS3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3ISS3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIF3ISS3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3ISS3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIF3ISS3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF3ISS3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIF3ISS3"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3ISS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIF3ISS3

        Create a new object of the class itkImageToImageFilterIF3ISS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIF3ISS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIF3ISS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIF3ISS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIF3ISS3.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF3ISS3_SetInput, None, itkImageToImageFilterIF3ISS3)
itkImageToImageFilterIF3ISS3.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF3ISS3_GetInput, None, itkImageToImageFilterIF3ISS3)
itkImageToImageFilterIF3ISS3.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF3ISS3_PushBackInput, None, itkImageToImageFilterIF3ISS3)
itkImageToImageFilterIF3ISS3.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF3ISS3_PopBackInput, None, itkImageToImageFilterIF3ISS3)
itkImageToImageFilterIF3ISS3.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF3ISS3_PushFrontInput, None, itkImageToImageFilterIF3ISS3)
itkImageToImageFilterIF3ISS3.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF3ISS3_PopFrontInput, None, itkImageToImageFilterIF3ISS3)
itkImageToImageFilterIF3ISS3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF3ISS3_SetCoordinateTolerance, None, itkImageToImageFilterIF3ISS3)
itkImageToImageFilterIF3ISS3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF3ISS3_GetCoordinateTolerance, None, itkImageToImageFilterIF3ISS3)
itkImageToImageFilterIF3ISS3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF3ISS3_SetDirectionTolerance, None, itkImageToImageFilterIF3ISS3)
itkImageToImageFilterIF3ISS3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF3ISS3_GetDirectionTolerance, None, itkImageToImageFilterIF3ISS3)
itkImageToImageFilterIF3ISS3_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIF3ISS3_swigregister
itkImageToImageFilterIF3ISS3_swigregister(itkImageToImageFilterIF3ISS3)

def itkImageToImageFilterIF3ISS3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF3ISS3 *":
    """itkImageToImageFilterIF3ISS3_cast(itkLightObject obj) -> itkImageToImageFilterIF3ISS3"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIF3ISS3_cast(obj)

class itkImageToImageFilterIF3IUC3(itkImageSourcePython.itkImageSourceIUC3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIF3IUC3 self, itkImageF3 image)
        SetInput(itkImageToImageFilterIF3IUC3 self, unsigned int arg0, itkImageF3 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3IUC3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageF3 const *":
        """
        GetInput(itkImageToImageFilterIF3IUC3 self) -> itkImageF3
        GetInput(itkImageToImageFilterIF3IUC3 self, unsigned int idx) -> itkImageF3
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3IUC3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageF3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIF3IUC3 self, itkImageF3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3IUC3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIF3IUC3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3IUC3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageF3') -> "void":
        """PushFrontInput(itkImageToImageFilterIF3IUC3 self, itkImageF3 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3IUC3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIF3IUC3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3IUC3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIF3IUC3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3IUC3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIF3IUC3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3IUC3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIF3IUC3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3IUC3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIF3IUC3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3IUC3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIF3IUC3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF3IUC3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIF3IUC3"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3IUC3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIF3IUC3

        Create a new object of the class itkImageToImageFilterIF3IUC3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIF3IUC3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIF3IUC3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIF3IUC3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIF3IUC3.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF3IUC3_SetInput, None, itkImageToImageFilterIF3IUC3)
itkImageToImageFilterIF3IUC3.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF3IUC3_GetInput, None, itkImageToImageFilterIF3IUC3)
itkImageToImageFilterIF3IUC3.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF3IUC3_PushBackInput, None, itkImageToImageFilterIF3IUC3)
itkImageToImageFilterIF3IUC3.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF3IUC3_PopBackInput, None, itkImageToImageFilterIF3IUC3)
itkImageToImageFilterIF3IUC3.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF3IUC3_PushFrontInput, None, itkImageToImageFilterIF3IUC3)
itkImageToImageFilterIF3IUC3.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF3IUC3_PopFrontInput, None, itkImageToImageFilterIF3IUC3)
itkImageToImageFilterIF3IUC3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF3IUC3_SetCoordinateTolerance, None, itkImageToImageFilterIF3IUC3)
itkImageToImageFilterIF3IUC3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF3IUC3_GetCoordinateTolerance, None, itkImageToImageFilterIF3IUC3)
itkImageToImageFilterIF3IUC3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF3IUC3_SetDirectionTolerance, None, itkImageToImageFilterIF3IUC3)
itkImageToImageFilterIF3IUC3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF3IUC3_GetDirectionTolerance, None, itkImageToImageFilterIF3IUC3)
itkImageToImageFilterIF3IUC3_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIF3IUC3_swigregister
itkImageToImageFilterIF3IUC3_swigregister(itkImageToImageFilterIF3IUC3)

def itkImageToImageFilterIF3IUC3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF3IUC3 *":
    """itkImageToImageFilterIF3IUC3_cast(itkLightObject obj) -> itkImageToImageFilterIF3IUC3"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIF3IUC3_cast(obj)

class itkImageToImageFilterIF3IUL3(itkImageSourcePython.itkImageSourceIUL3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIF3IUL3 self, itkImageF3 image)
        SetInput(itkImageToImageFilterIF3IUL3 self, unsigned int arg0, itkImageF3 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3IUL3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageF3 const *":
        """
        GetInput(itkImageToImageFilterIF3IUL3 self) -> itkImageF3
        GetInput(itkImageToImageFilterIF3IUL3 self, unsigned int idx) -> itkImageF3
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3IUL3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageF3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIF3IUL3 self, itkImageF3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3IUL3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIF3IUL3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3IUL3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageF3') -> "void":
        """PushFrontInput(itkImageToImageFilterIF3IUL3 self, itkImageF3 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3IUL3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIF3IUL3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3IUL3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIF3IUL3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3IUL3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIF3IUL3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3IUL3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIF3IUL3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3IUL3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIF3IUL3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3IUL3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIF3IUL3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF3IUL3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIF3IUL3"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3IUL3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIF3IUL3

        Create a new object of the class itkImageToImageFilterIF3IUL3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIF3IUL3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIF3IUL3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIF3IUL3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIF3IUL3.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF3IUL3_SetInput, None, itkImageToImageFilterIF3IUL3)
itkImageToImageFilterIF3IUL3.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF3IUL3_GetInput, None, itkImageToImageFilterIF3IUL3)
itkImageToImageFilterIF3IUL3.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF3IUL3_PushBackInput, None, itkImageToImageFilterIF3IUL3)
itkImageToImageFilterIF3IUL3.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF3IUL3_PopBackInput, None, itkImageToImageFilterIF3IUL3)
itkImageToImageFilterIF3IUL3.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF3IUL3_PushFrontInput, None, itkImageToImageFilterIF3IUL3)
itkImageToImageFilterIF3IUL3.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF3IUL3_PopFrontInput, None, itkImageToImageFilterIF3IUL3)
itkImageToImageFilterIF3IUL3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF3IUL3_SetCoordinateTolerance, None, itkImageToImageFilterIF3IUL3)
itkImageToImageFilterIF3IUL3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF3IUL3_GetCoordinateTolerance, None, itkImageToImageFilterIF3IUL3)
itkImageToImageFilterIF3IUL3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF3IUL3_SetDirectionTolerance, None, itkImageToImageFilterIF3IUL3)
itkImageToImageFilterIF3IUL3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF3IUL3_GetDirectionTolerance, None, itkImageToImageFilterIF3IUL3)
itkImageToImageFilterIF3IUL3_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIF3IUL3_swigregister
itkImageToImageFilterIF3IUL3_swigregister(itkImageToImageFilterIF3IUL3)

def itkImageToImageFilterIF3IUL3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF3IUL3 *":
    """itkImageToImageFilterIF3IUL3_cast(itkLightObject obj) -> itkImageToImageFilterIF3IUL3"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIF3IUL3_cast(obj)

class itkImageToImageFilterIF3IUS3(itkImageSourcePython.itkImageSourceIUS3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIF3IUS3 self, itkImageF3 image)
        SetInput(itkImageToImageFilterIF3IUS3 self, unsigned int arg0, itkImageF3 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3IUS3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageF3 const *":
        """
        GetInput(itkImageToImageFilterIF3IUS3 self) -> itkImageF3
        GetInput(itkImageToImageFilterIF3IUS3 self, unsigned int idx) -> itkImageF3
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3IUS3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageF3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIF3IUS3 self, itkImageF3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3IUS3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIF3IUS3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3IUS3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageF3') -> "void":
        """PushFrontInput(itkImageToImageFilterIF3IUS3 self, itkImageF3 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3IUS3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIF3IUS3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3IUS3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIF3IUS3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3IUS3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIF3IUS3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3IUS3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIF3IUS3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3IUS3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIF3IUS3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3IUS3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIF3IUS3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF3IUS3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIF3IUS3"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIF3IUS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIF3IUS3

        Create a new object of the class itkImageToImageFilterIF3IUS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIF3IUS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIF3IUS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIF3IUS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIF3IUS3.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF3IUS3_SetInput, None, itkImageToImageFilterIF3IUS3)
itkImageToImageFilterIF3IUS3.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF3IUS3_GetInput, None, itkImageToImageFilterIF3IUS3)
itkImageToImageFilterIF3IUS3.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF3IUS3_PushBackInput, None, itkImageToImageFilterIF3IUS3)
itkImageToImageFilterIF3IUS3.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF3IUS3_PopBackInput, None, itkImageToImageFilterIF3IUS3)
itkImageToImageFilterIF3IUS3.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF3IUS3_PushFrontInput, None, itkImageToImageFilterIF3IUS3)
itkImageToImageFilterIF3IUS3.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF3IUS3_PopFrontInput, None, itkImageToImageFilterIF3IUS3)
itkImageToImageFilterIF3IUS3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF3IUS3_SetCoordinateTolerance, None, itkImageToImageFilterIF3IUS3)
itkImageToImageFilterIF3IUS3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF3IUS3_GetCoordinateTolerance, None, itkImageToImageFilterIF3IUS3)
itkImageToImageFilterIF3IUS3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF3IUS3_SetDirectionTolerance, None, itkImageToImageFilterIF3IUS3)
itkImageToImageFilterIF3IUS3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIF3IUS3_GetDirectionTolerance, None, itkImageToImageFilterIF3IUS3)
itkImageToImageFilterIF3IUS3_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIF3IUS3_swigregister
itkImageToImageFilterIF3IUS3_swigregister(itkImageToImageFilterIF3IUS3)

def itkImageToImageFilterIF3IUS3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF3IUS3 *":
    """itkImageToImageFilterIF3IUS3_cast(itkLightObject obj) -> itkImageToImageFilterIF3IUS3"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIF3IUS3_cast(obj)

class itkImageToImageFilterIRGBAUC2IRGBAUC2(itkImageSourcePython.itkImageSourceIRGBAUC2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIRGBAUC2IRGBAUC2 self, itkImageRGBAUC2 image)
        SetInput(itkImageToImageFilterIRGBAUC2IRGBAUC2 self, unsigned int arg0, itkImageRGBAUC2 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIRGBAUC2IRGBAUC2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageRGBAUC2 const *":
        """
        GetInput(itkImageToImageFilterIRGBAUC2IRGBAUC2 self) -> itkImageRGBAUC2
        GetInput(itkImageToImageFilterIRGBAUC2IRGBAUC2 self, unsigned int idx) -> itkImageRGBAUC2
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIRGBAUC2IRGBAUC2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageRGBAUC2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIRGBAUC2IRGBAUC2 self, itkImageRGBAUC2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIRGBAUC2IRGBAUC2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIRGBAUC2IRGBAUC2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIRGBAUC2IRGBAUC2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageRGBAUC2') -> "void":
        """PushFrontInput(itkImageToImageFilterIRGBAUC2IRGBAUC2 self, itkImageRGBAUC2 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIRGBAUC2IRGBAUC2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIRGBAUC2IRGBAUC2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIRGBAUC2IRGBAUC2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIRGBAUC2IRGBAUC2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIRGBAUC2IRGBAUC2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIRGBAUC2IRGBAUC2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIRGBAUC2IRGBAUC2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIRGBAUC2IRGBAUC2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIRGBAUC2IRGBAUC2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIRGBAUC2IRGBAUC2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIRGBAUC2IRGBAUC2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIRGBAUC2IRGBAUC2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIRGBAUC2IRGBAUC2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIRGBAUC2IRGBAUC2"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIRGBAUC2IRGBAUC2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIRGBAUC2IRGBAUC2

        Create a new object of the class itkImageToImageFilterIRGBAUC2IRGBAUC2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIRGBAUC2IRGBAUC2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIRGBAUC2IRGBAUC2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIRGBAUC2IRGBAUC2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIRGBAUC2IRGBAUC2.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIRGBAUC2IRGBAUC2_SetInput, None, itkImageToImageFilterIRGBAUC2IRGBAUC2)
itkImageToImageFilterIRGBAUC2IRGBAUC2.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIRGBAUC2IRGBAUC2_GetInput, None, itkImageToImageFilterIRGBAUC2IRGBAUC2)
itkImageToImageFilterIRGBAUC2IRGBAUC2.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIRGBAUC2IRGBAUC2_PushBackInput, None, itkImageToImageFilterIRGBAUC2IRGBAUC2)
itkImageToImageFilterIRGBAUC2IRGBAUC2.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIRGBAUC2IRGBAUC2_PopBackInput, None, itkImageToImageFilterIRGBAUC2IRGBAUC2)
itkImageToImageFilterIRGBAUC2IRGBAUC2.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIRGBAUC2IRGBAUC2_PushFrontInput, None, itkImageToImageFilterIRGBAUC2IRGBAUC2)
itkImageToImageFilterIRGBAUC2IRGBAUC2.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIRGBAUC2IRGBAUC2_PopFrontInput, None, itkImageToImageFilterIRGBAUC2IRGBAUC2)
itkImageToImageFilterIRGBAUC2IRGBAUC2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIRGBAUC2IRGBAUC2_SetCoordinateTolerance, None, itkImageToImageFilterIRGBAUC2IRGBAUC2)
itkImageToImageFilterIRGBAUC2IRGBAUC2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIRGBAUC2IRGBAUC2_GetCoordinateTolerance, None, itkImageToImageFilterIRGBAUC2IRGBAUC2)
itkImageToImageFilterIRGBAUC2IRGBAUC2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIRGBAUC2IRGBAUC2_SetDirectionTolerance, None, itkImageToImageFilterIRGBAUC2IRGBAUC2)
itkImageToImageFilterIRGBAUC2IRGBAUC2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIRGBAUC2IRGBAUC2_GetDirectionTolerance, None, itkImageToImageFilterIRGBAUC2IRGBAUC2)
itkImageToImageFilterIRGBAUC2IRGBAUC2_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIRGBAUC2IRGBAUC2_swigregister
itkImageToImageFilterIRGBAUC2IRGBAUC2_swigregister(itkImageToImageFilterIRGBAUC2IRGBAUC2)

def itkImageToImageFilterIRGBAUC2IRGBAUC2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIRGBAUC2IRGBAUC2 *":
    """itkImageToImageFilterIRGBAUC2IRGBAUC2_cast(itkLightObject obj) -> itkImageToImageFilterIRGBAUC2IRGBAUC2"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIRGBAUC2IRGBAUC2_cast(obj)

class itkImageToImageFilterIRGBAUC3IRGBAUC3(itkImageSourcePython.itkImageSourceIRGBAUC3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIRGBAUC3IRGBAUC3 self, itkImageRGBAUC3 image)
        SetInput(itkImageToImageFilterIRGBAUC3IRGBAUC3 self, unsigned int arg0, itkImageRGBAUC3 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIRGBAUC3IRGBAUC3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageRGBAUC3 const *":
        """
        GetInput(itkImageToImageFilterIRGBAUC3IRGBAUC3 self) -> itkImageRGBAUC3
        GetInput(itkImageToImageFilterIRGBAUC3IRGBAUC3 self, unsigned int idx) -> itkImageRGBAUC3
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIRGBAUC3IRGBAUC3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageRGBAUC3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIRGBAUC3IRGBAUC3 self, itkImageRGBAUC3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIRGBAUC3IRGBAUC3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIRGBAUC3IRGBAUC3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIRGBAUC3IRGBAUC3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageRGBAUC3') -> "void":
        """PushFrontInput(itkImageToImageFilterIRGBAUC3IRGBAUC3 self, itkImageRGBAUC3 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIRGBAUC3IRGBAUC3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIRGBAUC3IRGBAUC3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIRGBAUC3IRGBAUC3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIRGBAUC3IRGBAUC3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIRGBAUC3IRGBAUC3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIRGBAUC3IRGBAUC3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIRGBAUC3IRGBAUC3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIRGBAUC3IRGBAUC3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIRGBAUC3IRGBAUC3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIRGBAUC3IRGBAUC3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIRGBAUC3IRGBAUC3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIRGBAUC3IRGBAUC3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIRGBAUC3IRGBAUC3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIRGBAUC3IRGBAUC3"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIRGBAUC3IRGBAUC3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIRGBAUC3IRGBAUC3

        Create a new object of the class itkImageToImageFilterIRGBAUC3IRGBAUC3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIRGBAUC3IRGBAUC3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIRGBAUC3IRGBAUC3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIRGBAUC3IRGBAUC3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIRGBAUC3IRGBAUC3.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIRGBAUC3IRGBAUC3_SetInput, None, itkImageToImageFilterIRGBAUC3IRGBAUC3)
itkImageToImageFilterIRGBAUC3IRGBAUC3.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIRGBAUC3IRGBAUC3_GetInput, None, itkImageToImageFilterIRGBAUC3IRGBAUC3)
itkImageToImageFilterIRGBAUC3IRGBAUC3.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIRGBAUC3IRGBAUC3_PushBackInput, None, itkImageToImageFilterIRGBAUC3IRGBAUC3)
itkImageToImageFilterIRGBAUC3IRGBAUC3.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIRGBAUC3IRGBAUC3_PopBackInput, None, itkImageToImageFilterIRGBAUC3IRGBAUC3)
itkImageToImageFilterIRGBAUC3IRGBAUC3.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIRGBAUC3IRGBAUC3_PushFrontInput, None, itkImageToImageFilterIRGBAUC3IRGBAUC3)
itkImageToImageFilterIRGBAUC3IRGBAUC3.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIRGBAUC3IRGBAUC3_PopFrontInput, None, itkImageToImageFilterIRGBAUC3IRGBAUC3)
itkImageToImageFilterIRGBAUC3IRGBAUC3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIRGBAUC3IRGBAUC3_SetCoordinateTolerance, None, itkImageToImageFilterIRGBAUC3IRGBAUC3)
itkImageToImageFilterIRGBAUC3IRGBAUC3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIRGBAUC3IRGBAUC3_GetCoordinateTolerance, None, itkImageToImageFilterIRGBAUC3IRGBAUC3)
itkImageToImageFilterIRGBAUC3IRGBAUC3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIRGBAUC3IRGBAUC3_SetDirectionTolerance, None, itkImageToImageFilterIRGBAUC3IRGBAUC3)
itkImageToImageFilterIRGBAUC3IRGBAUC3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIRGBAUC3IRGBAUC3_GetDirectionTolerance, None, itkImageToImageFilterIRGBAUC3IRGBAUC3)
itkImageToImageFilterIRGBAUC3IRGBAUC3_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIRGBAUC3IRGBAUC3_swigregister
itkImageToImageFilterIRGBAUC3IRGBAUC3_swigregister(itkImageToImageFilterIRGBAUC3IRGBAUC3)

def itkImageToImageFilterIRGBAUC3IRGBAUC3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIRGBAUC3IRGBAUC3 *":
    """itkImageToImageFilterIRGBAUC3IRGBAUC3_cast(itkLightObject obj) -> itkImageToImageFilterIRGBAUC3IRGBAUC3"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIRGBAUC3IRGBAUC3_cast(obj)

class itkImageToImageFilterIRGBUC2IRGBUC2(itkImageSourcePython.itkImageSourceIRGBUC2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIRGBUC2IRGBUC2 self, itkImageRGBUC2 image)
        SetInput(itkImageToImageFilterIRGBUC2IRGBUC2 self, unsigned int arg0, itkImageRGBUC2 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIRGBUC2IRGBUC2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageRGBUC2 const *":
        """
        GetInput(itkImageToImageFilterIRGBUC2IRGBUC2 self) -> itkImageRGBUC2
        GetInput(itkImageToImageFilterIRGBUC2IRGBUC2 self, unsigned int idx) -> itkImageRGBUC2
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIRGBUC2IRGBUC2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageRGBUC2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIRGBUC2IRGBUC2 self, itkImageRGBUC2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIRGBUC2IRGBUC2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIRGBUC2IRGBUC2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIRGBUC2IRGBUC2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageRGBUC2') -> "void":
        """PushFrontInput(itkImageToImageFilterIRGBUC2IRGBUC2 self, itkImageRGBUC2 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIRGBUC2IRGBUC2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIRGBUC2IRGBUC2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIRGBUC2IRGBUC2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIRGBUC2IRGBUC2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIRGBUC2IRGBUC2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIRGBUC2IRGBUC2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIRGBUC2IRGBUC2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIRGBUC2IRGBUC2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIRGBUC2IRGBUC2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIRGBUC2IRGBUC2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIRGBUC2IRGBUC2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIRGBUC2IRGBUC2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIRGBUC2IRGBUC2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIRGBUC2IRGBUC2"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIRGBUC2IRGBUC2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIRGBUC2IRGBUC2

        Create a new object of the class itkImageToImageFilterIRGBUC2IRGBUC2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIRGBUC2IRGBUC2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIRGBUC2IRGBUC2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIRGBUC2IRGBUC2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIRGBUC2IRGBUC2.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIRGBUC2IRGBUC2_SetInput, None, itkImageToImageFilterIRGBUC2IRGBUC2)
itkImageToImageFilterIRGBUC2IRGBUC2.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIRGBUC2IRGBUC2_GetInput, None, itkImageToImageFilterIRGBUC2IRGBUC2)
itkImageToImageFilterIRGBUC2IRGBUC2.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIRGBUC2IRGBUC2_PushBackInput, None, itkImageToImageFilterIRGBUC2IRGBUC2)
itkImageToImageFilterIRGBUC2IRGBUC2.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIRGBUC2IRGBUC2_PopBackInput, None, itkImageToImageFilterIRGBUC2IRGBUC2)
itkImageToImageFilterIRGBUC2IRGBUC2.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIRGBUC2IRGBUC2_PushFrontInput, None, itkImageToImageFilterIRGBUC2IRGBUC2)
itkImageToImageFilterIRGBUC2IRGBUC2.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIRGBUC2IRGBUC2_PopFrontInput, None, itkImageToImageFilterIRGBUC2IRGBUC2)
itkImageToImageFilterIRGBUC2IRGBUC2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIRGBUC2IRGBUC2_SetCoordinateTolerance, None, itkImageToImageFilterIRGBUC2IRGBUC2)
itkImageToImageFilterIRGBUC2IRGBUC2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIRGBUC2IRGBUC2_GetCoordinateTolerance, None, itkImageToImageFilterIRGBUC2IRGBUC2)
itkImageToImageFilterIRGBUC2IRGBUC2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIRGBUC2IRGBUC2_SetDirectionTolerance, None, itkImageToImageFilterIRGBUC2IRGBUC2)
itkImageToImageFilterIRGBUC2IRGBUC2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIRGBUC2IRGBUC2_GetDirectionTolerance, None, itkImageToImageFilterIRGBUC2IRGBUC2)
itkImageToImageFilterIRGBUC2IRGBUC2_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIRGBUC2IRGBUC2_swigregister
itkImageToImageFilterIRGBUC2IRGBUC2_swigregister(itkImageToImageFilterIRGBUC2IRGBUC2)

def itkImageToImageFilterIRGBUC2IRGBUC2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIRGBUC2IRGBUC2 *":
    """itkImageToImageFilterIRGBUC2IRGBUC2_cast(itkLightObject obj) -> itkImageToImageFilterIRGBUC2IRGBUC2"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIRGBUC2IRGBUC2_cast(obj)

class itkImageToImageFilterIRGBUC3IRGBUC3(itkImageSourcePython.itkImageSourceIRGBUC3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIRGBUC3IRGBUC3 self, itkImageRGBUC3 image)
        SetInput(itkImageToImageFilterIRGBUC3IRGBUC3 self, unsigned int arg0, itkImageRGBUC3 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIRGBUC3IRGBUC3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageRGBUC3 const *":
        """
        GetInput(itkImageToImageFilterIRGBUC3IRGBUC3 self) -> itkImageRGBUC3
        GetInput(itkImageToImageFilterIRGBUC3IRGBUC3 self, unsigned int idx) -> itkImageRGBUC3
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIRGBUC3IRGBUC3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageRGBUC3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIRGBUC3IRGBUC3 self, itkImageRGBUC3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIRGBUC3IRGBUC3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIRGBUC3IRGBUC3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIRGBUC3IRGBUC3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageRGBUC3') -> "void":
        """PushFrontInput(itkImageToImageFilterIRGBUC3IRGBUC3 self, itkImageRGBUC3 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIRGBUC3IRGBUC3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIRGBUC3IRGBUC3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIRGBUC3IRGBUC3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIRGBUC3IRGBUC3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIRGBUC3IRGBUC3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIRGBUC3IRGBUC3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIRGBUC3IRGBUC3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIRGBUC3IRGBUC3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIRGBUC3IRGBUC3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIRGBUC3IRGBUC3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIRGBUC3IRGBUC3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIRGBUC3IRGBUC3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIRGBUC3IRGBUC3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIRGBUC3IRGBUC3"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIRGBUC3IRGBUC3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIRGBUC3IRGBUC3

        Create a new object of the class itkImageToImageFilterIRGBUC3IRGBUC3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIRGBUC3IRGBUC3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIRGBUC3IRGBUC3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIRGBUC3IRGBUC3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIRGBUC3IRGBUC3.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIRGBUC3IRGBUC3_SetInput, None, itkImageToImageFilterIRGBUC3IRGBUC3)
itkImageToImageFilterIRGBUC3IRGBUC3.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIRGBUC3IRGBUC3_GetInput, None, itkImageToImageFilterIRGBUC3IRGBUC3)
itkImageToImageFilterIRGBUC3IRGBUC3.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIRGBUC3IRGBUC3_PushBackInput, None, itkImageToImageFilterIRGBUC3IRGBUC3)
itkImageToImageFilterIRGBUC3IRGBUC3.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIRGBUC3IRGBUC3_PopBackInput, None, itkImageToImageFilterIRGBUC3IRGBUC3)
itkImageToImageFilterIRGBUC3IRGBUC3.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIRGBUC3IRGBUC3_PushFrontInput, None, itkImageToImageFilterIRGBUC3IRGBUC3)
itkImageToImageFilterIRGBUC3IRGBUC3.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIRGBUC3IRGBUC3_PopFrontInput, None, itkImageToImageFilterIRGBUC3IRGBUC3)
itkImageToImageFilterIRGBUC3IRGBUC3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIRGBUC3IRGBUC3_SetCoordinateTolerance, None, itkImageToImageFilterIRGBUC3IRGBUC3)
itkImageToImageFilterIRGBUC3IRGBUC3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIRGBUC3IRGBUC3_GetCoordinateTolerance, None, itkImageToImageFilterIRGBUC3IRGBUC3)
itkImageToImageFilterIRGBUC3IRGBUC3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIRGBUC3IRGBUC3_SetDirectionTolerance, None, itkImageToImageFilterIRGBUC3IRGBUC3)
itkImageToImageFilterIRGBUC3IRGBUC3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIRGBUC3IRGBUC3_GetDirectionTolerance, None, itkImageToImageFilterIRGBUC3IRGBUC3)
itkImageToImageFilterIRGBUC3IRGBUC3_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIRGBUC3IRGBUC3_swigregister
itkImageToImageFilterIRGBUC3IRGBUC3_swigregister(itkImageToImageFilterIRGBUC3IRGBUC3)

def itkImageToImageFilterIRGBUC3IRGBUC3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIRGBUC3IRGBUC3 *":
    """itkImageToImageFilterIRGBUC3IRGBUC3_cast(itkLightObject obj) -> itkImageToImageFilterIRGBUC3IRGBUC3"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIRGBUC3IRGBUC3_cast(obj)

class itkImageToImageFilterISS2ID2(itkImageSourcePython.itkImageSourceID2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterISS2ID2 self, itkImageSS2 image)
        SetInput(itkImageToImageFilterISS2ID2 self, unsigned int arg0, itkImageSS2 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2ID2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageSS2 const *":
        """
        GetInput(itkImageToImageFilterISS2ID2 self) -> itkImageSS2
        GetInput(itkImageToImageFilterISS2ID2 self, unsigned int idx) -> itkImageSS2
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2ID2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageSS2') -> "void":
        """
        PushBackInput(itkImageToImageFilterISS2ID2 self, itkImageSS2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2ID2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterISS2ID2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2ID2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageSS2') -> "void":
        """PushFrontInput(itkImageToImageFilterISS2ID2 self, itkImageSS2 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2ID2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterISS2ID2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2ID2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterISS2ID2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2ID2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterISS2ID2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2ID2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterISS2ID2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2ID2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterISS2ID2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2ID2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterISS2ID2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS2ID2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterISS2ID2"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2ID2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterISS2ID2

        Create a new object of the class itkImageToImageFilterISS2ID2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterISS2ID2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterISS2ID2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterISS2ID2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterISS2ID2.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS2ID2_SetInput, None, itkImageToImageFilterISS2ID2)
itkImageToImageFilterISS2ID2.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS2ID2_GetInput, None, itkImageToImageFilterISS2ID2)
itkImageToImageFilterISS2ID2.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS2ID2_PushBackInput, None, itkImageToImageFilterISS2ID2)
itkImageToImageFilterISS2ID2.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS2ID2_PopBackInput, None, itkImageToImageFilterISS2ID2)
itkImageToImageFilterISS2ID2.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS2ID2_PushFrontInput, None, itkImageToImageFilterISS2ID2)
itkImageToImageFilterISS2ID2.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS2ID2_PopFrontInput, None, itkImageToImageFilterISS2ID2)
itkImageToImageFilterISS2ID2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS2ID2_SetCoordinateTolerance, None, itkImageToImageFilterISS2ID2)
itkImageToImageFilterISS2ID2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS2ID2_GetCoordinateTolerance, None, itkImageToImageFilterISS2ID2)
itkImageToImageFilterISS2ID2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS2ID2_SetDirectionTolerance, None, itkImageToImageFilterISS2ID2)
itkImageToImageFilterISS2ID2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS2ID2_GetDirectionTolerance, None, itkImageToImageFilterISS2ID2)
itkImageToImageFilterISS2ID2_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterISS2ID2_swigregister
itkImageToImageFilterISS2ID2_swigregister(itkImageToImageFilterISS2ID2)

def itkImageToImageFilterISS2ID2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS2ID2 *":
    """itkImageToImageFilterISS2ID2_cast(itkLightObject obj) -> itkImageToImageFilterISS2ID2"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterISS2ID2_cast(obj)

class itkImageToImageFilterISS2IF2(itkImageSourcePython.itkImageSourceIF2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterISS2IF2 self, itkImageSS2 image)
        SetInput(itkImageToImageFilterISS2IF2 self, unsigned int arg0, itkImageSS2 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2IF2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageSS2 const *":
        """
        GetInput(itkImageToImageFilterISS2IF2 self) -> itkImageSS2
        GetInput(itkImageToImageFilterISS2IF2 self, unsigned int idx) -> itkImageSS2
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2IF2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageSS2') -> "void":
        """
        PushBackInput(itkImageToImageFilterISS2IF2 self, itkImageSS2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2IF2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterISS2IF2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2IF2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageSS2') -> "void":
        """PushFrontInput(itkImageToImageFilterISS2IF2 self, itkImageSS2 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2IF2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterISS2IF2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2IF2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterISS2IF2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2IF2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterISS2IF2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2IF2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterISS2IF2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2IF2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterISS2IF2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2IF2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterISS2IF2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS2IF2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterISS2IF2"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2IF2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterISS2IF2

        Create a new object of the class itkImageToImageFilterISS2IF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterISS2IF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterISS2IF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterISS2IF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterISS2IF2.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS2IF2_SetInput, None, itkImageToImageFilterISS2IF2)
itkImageToImageFilterISS2IF2.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS2IF2_GetInput, None, itkImageToImageFilterISS2IF2)
itkImageToImageFilterISS2IF2.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS2IF2_PushBackInput, None, itkImageToImageFilterISS2IF2)
itkImageToImageFilterISS2IF2.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS2IF2_PopBackInput, None, itkImageToImageFilterISS2IF2)
itkImageToImageFilterISS2IF2.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS2IF2_PushFrontInput, None, itkImageToImageFilterISS2IF2)
itkImageToImageFilterISS2IF2.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS2IF2_PopFrontInput, None, itkImageToImageFilterISS2IF2)
itkImageToImageFilterISS2IF2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS2IF2_SetCoordinateTolerance, None, itkImageToImageFilterISS2IF2)
itkImageToImageFilterISS2IF2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS2IF2_GetCoordinateTolerance, None, itkImageToImageFilterISS2IF2)
itkImageToImageFilterISS2IF2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS2IF2_SetDirectionTolerance, None, itkImageToImageFilterISS2IF2)
itkImageToImageFilterISS2IF2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS2IF2_GetDirectionTolerance, None, itkImageToImageFilterISS2IF2)
itkImageToImageFilterISS2IF2_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterISS2IF2_swigregister
itkImageToImageFilterISS2IF2_swigregister(itkImageToImageFilterISS2IF2)

def itkImageToImageFilterISS2IF2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS2IF2 *":
    """itkImageToImageFilterISS2IF2_cast(itkLightObject obj) -> itkImageToImageFilterISS2IF2"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterISS2IF2_cast(obj)

class itkImageToImageFilterISS2ISS2(itkImageSourcePython.itkImageSourceISS2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterISS2ISS2 self, itkImageSS2 image)
        SetInput(itkImageToImageFilterISS2ISS2 self, unsigned int arg0, itkImageSS2 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2ISS2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageSS2 const *":
        """
        GetInput(itkImageToImageFilterISS2ISS2 self) -> itkImageSS2
        GetInput(itkImageToImageFilterISS2ISS2 self, unsigned int idx) -> itkImageSS2
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2ISS2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageSS2') -> "void":
        """
        PushBackInput(itkImageToImageFilterISS2ISS2 self, itkImageSS2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2ISS2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterISS2ISS2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2ISS2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageSS2') -> "void":
        """PushFrontInput(itkImageToImageFilterISS2ISS2 self, itkImageSS2 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2ISS2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterISS2ISS2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2ISS2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterISS2ISS2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2ISS2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterISS2ISS2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2ISS2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterISS2ISS2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2ISS2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterISS2ISS2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2ISS2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterISS2ISS2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS2ISS2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterISS2ISS2"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2ISS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterISS2ISS2

        Create a new object of the class itkImageToImageFilterISS2ISS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterISS2ISS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterISS2ISS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterISS2ISS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterISS2ISS2.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS2ISS2_SetInput, None, itkImageToImageFilterISS2ISS2)
itkImageToImageFilterISS2ISS2.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS2ISS2_GetInput, None, itkImageToImageFilterISS2ISS2)
itkImageToImageFilterISS2ISS2.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS2ISS2_PushBackInput, None, itkImageToImageFilterISS2ISS2)
itkImageToImageFilterISS2ISS2.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS2ISS2_PopBackInput, None, itkImageToImageFilterISS2ISS2)
itkImageToImageFilterISS2ISS2.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS2ISS2_PushFrontInput, None, itkImageToImageFilterISS2ISS2)
itkImageToImageFilterISS2ISS2.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS2ISS2_PopFrontInput, None, itkImageToImageFilterISS2ISS2)
itkImageToImageFilterISS2ISS2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS2ISS2_SetCoordinateTolerance, None, itkImageToImageFilterISS2ISS2)
itkImageToImageFilterISS2ISS2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS2ISS2_GetCoordinateTolerance, None, itkImageToImageFilterISS2ISS2)
itkImageToImageFilterISS2ISS2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS2ISS2_SetDirectionTolerance, None, itkImageToImageFilterISS2ISS2)
itkImageToImageFilterISS2ISS2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS2ISS2_GetDirectionTolerance, None, itkImageToImageFilterISS2ISS2)
itkImageToImageFilterISS2ISS2_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterISS2ISS2_swigregister
itkImageToImageFilterISS2ISS2_swigregister(itkImageToImageFilterISS2ISS2)

def itkImageToImageFilterISS2ISS2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS2ISS2 *":
    """itkImageToImageFilterISS2ISS2_cast(itkLightObject obj) -> itkImageToImageFilterISS2ISS2"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterISS2ISS2_cast(obj)

class itkImageToImageFilterISS2IUC2(itkImageSourcePython.itkImageSourceIUC2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterISS2IUC2 self, itkImageSS2 image)
        SetInput(itkImageToImageFilterISS2IUC2 self, unsigned int arg0, itkImageSS2 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2IUC2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageSS2 const *":
        """
        GetInput(itkImageToImageFilterISS2IUC2 self) -> itkImageSS2
        GetInput(itkImageToImageFilterISS2IUC2 self, unsigned int idx) -> itkImageSS2
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2IUC2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageSS2') -> "void":
        """
        PushBackInput(itkImageToImageFilterISS2IUC2 self, itkImageSS2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2IUC2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterISS2IUC2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2IUC2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageSS2') -> "void":
        """PushFrontInput(itkImageToImageFilterISS2IUC2 self, itkImageSS2 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2IUC2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterISS2IUC2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2IUC2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterISS2IUC2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2IUC2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterISS2IUC2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2IUC2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterISS2IUC2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2IUC2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterISS2IUC2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2IUC2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterISS2IUC2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS2IUC2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterISS2IUC2"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2IUC2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterISS2IUC2

        Create a new object of the class itkImageToImageFilterISS2IUC2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterISS2IUC2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterISS2IUC2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterISS2IUC2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterISS2IUC2.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS2IUC2_SetInput, None, itkImageToImageFilterISS2IUC2)
itkImageToImageFilterISS2IUC2.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS2IUC2_GetInput, None, itkImageToImageFilterISS2IUC2)
itkImageToImageFilterISS2IUC2.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS2IUC2_PushBackInput, None, itkImageToImageFilterISS2IUC2)
itkImageToImageFilterISS2IUC2.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS2IUC2_PopBackInput, None, itkImageToImageFilterISS2IUC2)
itkImageToImageFilterISS2IUC2.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS2IUC2_PushFrontInput, None, itkImageToImageFilterISS2IUC2)
itkImageToImageFilterISS2IUC2.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS2IUC2_PopFrontInput, None, itkImageToImageFilterISS2IUC2)
itkImageToImageFilterISS2IUC2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS2IUC2_SetCoordinateTolerance, None, itkImageToImageFilterISS2IUC2)
itkImageToImageFilterISS2IUC2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS2IUC2_GetCoordinateTolerance, None, itkImageToImageFilterISS2IUC2)
itkImageToImageFilterISS2IUC2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS2IUC2_SetDirectionTolerance, None, itkImageToImageFilterISS2IUC2)
itkImageToImageFilterISS2IUC2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS2IUC2_GetDirectionTolerance, None, itkImageToImageFilterISS2IUC2)
itkImageToImageFilterISS2IUC2_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterISS2IUC2_swigregister
itkImageToImageFilterISS2IUC2_swigregister(itkImageToImageFilterISS2IUC2)

def itkImageToImageFilterISS2IUC2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS2IUC2 *":
    """itkImageToImageFilterISS2IUC2_cast(itkLightObject obj) -> itkImageToImageFilterISS2IUC2"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterISS2IUC2_cast(obj)

class itkImageToImageFilterISS2IUL2(itkImageSourcePython.itkImageSourceIUL2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterISS2IUL2 self, itkImageSS2 image)
        SetInput(itkImageToImageFilterISS2IUL2 self, unsigned int arg0, itkImageSS2 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2IUL2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageSS2 const *":
        """
        GetInput(itkImageToImageFilterISS2IUL2 self) -> itkImageSS2
        GetInput(itkImageToImageFilterISS2IUL2 self, unsigned int idx) -> itkImageSS2
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2IUL2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageSS2') -> "void":
        """
        PushBackInput(itkImageToImageFilterISS2IUL2 self, itkImageSS2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2IUL2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterISS2IUL2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2IUL2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageSS2') -> "void":
        """PushFrontInput(itkImageToImageFilterISS2IUL2 self, itkImageSS2 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2IUL2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterISS2IUL2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2IUL2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterISS2IUL2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2IUL2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterISS2IUL2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2IUL2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterISS2IUL2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2IUL2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterISS2IUL2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2IUL2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterISS2IUL2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS2IUL2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterISS2IUL2"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2IUL2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterISS2IUL2

        Create a new object of the class itkImageToImageFilterISS2IUL2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterISS2IUL2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterISS2IUL2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterISS2IUL2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterISS2IUL2.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS2IUL2_SetInput, None, itkImageToImageFilterISS2IUL2)
itkImageToImageFilterISS2IUL2.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS2IUL2_GetInput, None, itkImageToImageFilterISS2IUL2)
itkImageToImageFilterISS2IUL2.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS2IUL2_PushBackInput, None, itkImageToImageFilterISS2IUL2)
itkImageToImageFilterISS2IUL2.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS2IUL2_PopBackInput, None, itkImageToImageFilterISS2IUL2)
itkImageToImageFilterISS2IUL2.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS2IUL2_PushFrontInput, None, itkImageToImageFilterISS2IUL2)
itkImageToImageFilterISS2IUL2.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS2IUL2_PopFrontInput, None, itkImageToImageFilterISS2IUL2)
itkImageToImageFilterISS2IUL2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS2IUL2_SetCoordinateTolerance, None, itkImageToImageFilterISS2IUL2)
itkImageToImageFilterISS2IUL2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS2IUL2_GetCoordinateTolerance, None, itkImageToImageFilterISS2IUL2)
itkImageToImageFilterISS2IUL2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS2IUL2_SetDirectionTolerance, None, itkImageToImageFilterISS2IUL2)
itkImageToImageFilterISS2IUL2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS2IUL2_GetDirectionTolerance, None, itkImageToImageFilterISS2IUL2)
itkImageToImageFilterISS2IUL2_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterISS2IUL2_swigregister
itkImageToImageFilterISS2IUL2_swigregister(itkImageToImageFilterISS2IUL2)

def itkImageToImageFilterISS2IUL2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS2IUL2 *":
    """itkImageToImageFilterISS2IUL2_cast(itkLightObject obj) -> itkImageToImageFilterISS2IUL2"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterISS2IUL2_cast(obj)

class itkImageToImageFilterISS2IUS2(itkImageSourcePython.itkImageSourceIUS2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterISS2IUS2 self, itkImageSS2 image)
        SetInput(itkImageToImageFilterISS2IUS2 self, unsigned int arg0, itkImageSS2 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2IUS2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageSS2 const *":
        """
        GetInput(itkImageToImageFilterISS2IUS2 self) -> itkImageSS2
        GetInput(itkImageToImageFilterISS2IUS2 self, unsigned int idx) -> itkImageSS2
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2IUS2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageSS2') -> "void":
        """
        PushBackInput(itkImageToImageFilterISS2IUS2 self, itkImageSS2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2IUS2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterISS2IUS2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2IUS2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageSS2') -> "void":
        """PushFrontInput(itkImageToImageFilterISS2IUS2 self, itkImageSS2 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2IUS2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterISS2IUS2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2IUS2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterISS2IUS2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2IUS2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterISS2IUS2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2IUS2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterISS2IUS2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2IUS2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterISS2IUS2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2IUS2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterISS2IUS2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS2IUS2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterISS2IUS2"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS2IUS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterISS2IUS2

        Create a new object of the class itkImageToImageFilterISS2IUS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterISS2IUS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterISS2IUS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterISS2IUS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterISS2IUS2.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS2IUS2_SetInput, None, itkImageToImageFilterISS2IUS2)
itkImageToImageFilterISS2IUS2.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS2IUS2_GetInput, None, itkImageToImageFilterISS2IUS2)
itkImageToImageFilterISS2IUS2.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS2IUS2_PushBackInput, None, itkImageToImageFilterISS2IUS2)
itkImageToImageFilterISS2IUS2.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS2IUS2_PopBackInput, None, itkImageToImageFilterISS2IUS2)
itkImageToImageFilterISS2IUS2.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS2IUS2_PushFrontInput, None, itkImageToImageFilterISS2IUS2)
itkImageToImageFilterISS2IUS2.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS2IUS2_PopFrontInput, None, itkImageToImageFilterISS2IUS2)
itkImageToImageFilterISS2IUS2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS2IUS2_SetCoordinateTolerance, None, itkImageToImageFilterISS2IUS2)
itkImageToImageFilterISS2IUS2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS2IUS2_GetCoordinateTolerance, None, itkImageToImageFilterISS2IUS2)
itkImageToImageFilterISS2IUS2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS2IUS2_SetDirectionTolerance, None, itkImageToImageFilterISS2IUS2)
itkImageToImageFilterISS2IUS2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS2IUS2_GetDirectionTolerance, None, itkImageToImageFilterISS2IUS2)
itkImageToImageFilterISS2IUS2_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterISS2IUS2_swigregister
itkImageToImageFilterISS2IUS2_swigregister(itkImageToImageFilterISS2IUS2)

def itkImageToImageFilterISS2IUS2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS2IUS2 *":
    """itkImageToImageFilterISS2IUS2_cast(itkLightObject obj) -> itkImageToImageFilterISS2IUS2"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterISS2IUS2_cast(obj)

class itkImageToImageFilterISS3ID3(itkImageSourcePython.itkImageSourceID3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterISS3ID3 self, itkImageSS3 image)
        SetInput(itkImageToImageFilterISS3ID3 self, unsigned int arg0, itkImageSS3 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3ID3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageSS3 const *":
        """
        GetInput(itkImageToImageFilterISS3ID3 self) -> itkImageSS3
        GetInput(itkImageToImageFilterISS3ID3 self, unsigned int idx) -> itkImageSS3
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3ID3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageSS3') -> "void":
        """
        PushBackInput(itkImageToImageFilterISS3ID3 self, itkImageSS3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3ID3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterISS3ID3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3ID3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageSS3') -> "void":
        """PushFrontInput(itkImageToImageFilterISS3ID3 self, itkImageSS3 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3ID3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterISS3ID3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3ID3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterISS3ID3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3ID3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterISS3ID3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3ID3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterISS3ID3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3ID3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterISS3ID3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3ID3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterISS3ID3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS3ID3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterISS3ID3"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3ID3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterISS3ID3

        Create a new object of the class itkImageToImageFilterISS3ID3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterISS3ID3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterISS3ID3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterISS3ID3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterISS3ID3.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS3ID3_SetInput, None, itkImageToImageFilterISS3ID3)
itkImageToImageFilterISS3ID3.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS3ID3_GetInput, None, itkImageToImageFilterISS3ID3)
itkImageToImageFilterISS3ID3.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS3ID3_PushBackInput, None, itkImageToImageFilterISS3ID3)
itkImageToImageFilterISS3ID3.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS3ID3_PopBackInput, None, itkImageToImageFilterISS3ID3)
itkImageToImageFilterISS3ID3.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS3ID3_PushFrontInput, None, itkImageToImageFilterISS3ID3)
itkImageToImageFilterISS3ID3.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS3ID3_PopFrontInput, None, itkImageToImageFilterISS3ID3)
itkImageToImageFilterISS3ID3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS3ID3_SetCoordinateTolerance, None, itkImageToImageFilterISS3ID3)
itkImageToImageFilterISS3ID3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS3ID3_GetCoordinateTolerance, None, itkImageToImageFilterISS3ID3)
itkImageToImageFilterISS3ID3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS3ID3_SetDirectionTolerance, None, itkImageToImageFilterISS3ID3)
itkImageToImageFilterISS3ID3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS3ID3_GetDirectionTolerance, None, itkImageToImageFilterISS3ID3)
itkImageToImageFilterISS3ID3_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterISS3ID3_swigregister
itkImageToImageFilterISS3ID3_swigregister(itkImageToImageFilterISS3ID3)

def itkImageToImageFilterISS3ID3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS3ID3 *":
    """itkImageToImageFilterISS3ID3_cast(itkLightObject obj) -> itkImageToImageFilterISS3ID3"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterISS3ID3_cast(obj)

class itkImageToImageFilterISS3IF3(itkImageSourcePython.itkImageSourceIF3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterISS3IF3 self, itkImageSS3 image)
        SetInput(itkImageToImageFilterISS3IF3 self, unsigned int arg0, itkImageSS3 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3IF3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageSS3 const *":
        """
        GetInput(itkImageToImageFilterISS3IF3 self) -> itkImageSS3
        GetInput(itkImageToImageFilterISS3IF3 self, unsigned int idx) -> itkImageSS3
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3IF3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageSS3') -> "void":
        """
        PushBackInput(itkImageToImageFilterISS3IF3 self, itkImageSS3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3IF3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterISS3IF3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3IF3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageSS3') -> "void":
        """PushFrontInput(itkImageToImageFilterISS3IF3 self, itkImageSS3 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3IF3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterISS3IF3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3IF3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterISS3IF3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3IF3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterISS3IF3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3IF3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterISS3IF3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3IF3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterISS3IF3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3IF3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterISS3IF3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS3IF3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterISS3IF3"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3IF3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterISS3IF3

        Create a new object of the class itkImageToImageFilterISS3IF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterISS3IF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterISS3IF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterISS3IF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterISS3IF3.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS3IF3_SetInput, None, itkImageToImageFilterISS3IF3)
itkImageToImageFilterISS3IF3.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS3IF3_GetInput, None, itkImageToImageFilterISS3IF3)
itkImageToImageFilterISS3IF3.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS3IF3_PushBackInput, None, itkImageToImageFilterISS3IF3)
itkImageToImageFilterISS3IF3.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS3IF3_PopBackInput, None, itkImageToImageFilterISS3IF3)
itkImageToImageFilterISS3IF3.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS3IF3_PushFrontInput, None, itkImageToImageFilterISS3IF3)
itkImageToImageFilterISS3IF3.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS3IF3_PopFrontInput, None, itkImageToImageFilterISS3IF3)
itkImageToImageFilterISS3IF3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS3IF3_SetCoordinateTolerance, None, itkImageToImageFilterISS3IF3)
itkImageToImageFilterISS3IF3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS3IF3_GetCoordinateTolerance, None, itkImageToImageFilterISS3IF3)
itkImageToImageFilterISS3IF3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS3IF3_SetDirectionTolerance, None, itkImageToImageFilterISS3IF3)
itkImageToImageFilterISS3IF3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS3IF3_GetDirectionTolerance, None, itkImageToImageFilterISS3IF3)
itkImageToImageFilterISS3IF3_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterISS3IF3_swigregister
itkImageToImageFilterISS3IF3_swigregister(itkImageToImageFilterISS3IF3)

def itkImageToImageFilterISS3IF3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS3IF3 *":
    """itkImageToImageFilterISS3IF3_cast(itkLightObject obj) -> itkImageToImageFilterISS3IF3"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterISS3IF3_cast(obj)

class itkImageToImageFilterISS3ISS3(itkImageSourcePython.itkImageSourceISS3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterISS3ISS3 self, itkImageSS3 image)
        SetInput(itkImageToImageFilterISS3ISS3 self, unsigned int arg0, itkImageSS3 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3ISS3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageSS3 const *":
        """
        GetInput(itkImageToImageFilterISS3ISS3 self) -> itkImageSS3
        GetInput(itkImageToImageFilterISS3ISS3 self, unsigned int idx) -> itkImageSS3
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3ISS3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageSS3') -> "void":
        """
        PushBackInput(itkImageToImageFilterISS3ISS3 self, itkImageSS3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3ISS3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterISS3ISS3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3ISS3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageSS3') -> "void":
        """PushFrontInput(itkImageToImageFilterISS3ISS3 self, itkImageSS3 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3ISS3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterISS3ISS3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3ISS3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterISS3ISS3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3ISS3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterISS3ISS3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3ISS3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterISS3ISS3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3ISS3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterISS3ISS3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3ISS3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterISS3ISS3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS3ISS3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterISS3ISS3"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3ISS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterISS3ISS3

        Create a new object of the class itkImageToImageFilterISS3ISS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterISS3ISS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterISS3ISS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterISS3ISS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterISS3ISS3.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS3ISS3_SetInput, None, itkImageToImageFilterISS3ISS3)
itkImageToImageFilterISS3ISS3.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS3ISS3_GetInput, None, itkImageToImageFilterISS3ISS3)
itkImageToImageFilterISS3ISS3.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS3ISS3_PushBackInput, None, itkImageToImageFilterISS3ISS3)
itkImageToImageFilterISS3ISS3.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS3ISS3_PopBackInput, None, itkImageToImageFilterISS3ISS3)
itkImageToImageFilterISS3ISS3.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS3ISS3_PushFrontInput, None, itkImageToImageFilterISS3ISS3)
itkImageToImageFilterISS3ISS3.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS3ISS3_PopFrontInput, None, itkImageToImageFilterISS3ISS3)
itkImageToImageFilterISS3ISS3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS3ISS3_SetCoordinateTolerance, None, itkImageToImageFilterISS3ISS3)
itkImageToImageFilterISS3ISS3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS3ISS3_GetCoordinateTolerance, None, itkImageToImageFilterISS3ISS3)
itkImageToImageFilterISS3ISS3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS3ISS3_SetDirectionTolerance, None, itkImageToImageFilterISS3ISS3)
itkImageToImageFilterISS3ISS3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS3ISS3_GetDirectionTolerance, None, itkImageToImageFilterISS3ISS3)
itkImageToImageFilterISS3ISS3_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterISS3ISS3_swigregister
itkImageToImageFilterISS3ISS3_swigregister(itkImageToImageFilterISS3ISS3)

def itkImageToImageFilterISS3ISS3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS3ISS3 *":
    """itkImageToImageFilterISS3ISS3_cast(itkLightObject obj) -> itkImageToImageFilterISS3ISS3"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterISS3ISS3_cast(obj)

class itkImageToImageFilterISS3IUC3(itkImageSourcePython.itkImageSourceIUC3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterISS3IUC3 self, itkImageSS3 image)
        SetInput(itkImageToImageFilterISS3IUC3 self, unsigned int arg0, itkImageSS3 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3IUC3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageSS3 const *":
        """
        GetInput(itkImageToImageFilterISS3IUC3 self) -> itkImageSS3
        GetInput(itkImageToImageFilterISS3IUC3 self, unsigned int idx) -> itkImageSS3
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3IUC3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageSS3') -> "void":
        """
        PushBackInput(itkImageToImageFilterISS3IUC3 self, itkImageSS3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3IUC3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterISS3IUC3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3IUC3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageSS3') -> "void":
        """PushFrontInput(itkImageToImageFilterISS3IUC3 self, itkImageSS3 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3IUC3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterISS3IUC3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3IUC3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterISS3IUC3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3IUC3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterISS3IUC3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3IUC3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterISS3IUC3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3IUC3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterISS3IUC3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3IUC3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterISS3IUC3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS3IUC3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterISS3IUC3"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3IUC3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterISS3IUC3

        Create a new object of the class itkImageToImageFilterISS3IUC3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterISS3IUC3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterISS3IUC3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterISS3IUC3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterISS3IUC3.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS3IUC3_SetInput, None, itkImageToImageFilterISS3IUC3)
itkImageToImageFilterISS3IUC3.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS3IUC3_GetInput, None, itkImageToImageFilterISS3IUC3)
itkImageToImageFilterISS3IUC3.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS3IUC3_PushBackInput, None, itkImageToImageFilterISS3IUC3)
itkImageToImageFilterISS3IUC3.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS3IUC3_PopBackInput, None, itkImageToImageFilterISS3IUC3)
itkImageToImageFilterISS3IUC3.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS3IUC3_PushFrontInput, None, itkImageToImageFilterISS3IUC3)
itkImageToImageFilterISS3IUC3.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS3IUC3_PopFrontInput, None, itkImageToImageFilterISS3IUC3)
itkImageToImageFilterISS3IUC3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS3IUC3_SetCoordinateTolerance, None, itkImageToImageFilterISS3IUC3)
itkImageToImageFilterISS3IUC3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS3IUC3_GetCoordinateTolerance, None, itkImageToImageFilterISS3IUC3)
itkImageToImageFilterISS3IUC3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS3IUC3_SetDirectionTolerance, None, itkImageToImageFilterISS3IUC3)
itkImageToImageFilterISS3IUC3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS3IUC3_GetDirectionTolerance, None, itkImageToImageFilterISS3IUC3)
itkImageToImageFilterISS3IUC3_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterISS3IUC3_swigregister
itkImageToImageFilterISS3IUC3_swigregister(itkImageToImageFilterISS3IUC3)

def itkImageToImageFilterISS3IUC3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS3IUC3 *":
    """itkImageToImageFilterISS3IUC3_cast(itkLightObject obj) -> itkImageToImageFilterISS3IUC3"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterISS3IUC3_cast(obj)

class itkImageToImageFilterISS3IUL3(itkImageSourcePython.itkImageSourceIUL3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterISS3IUL3 self, itkImageSS3 image)
        SetInput(itkImageToImageFilterISS3IUL3 self, unsigned int arg0, itkImageSS3 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3IUL3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageSS3 const *":
        """
        GetInput(itkImageToImageFilterISS3IUL3 self) -> itkImageSS3
        GetInput(itkImageToImageFilterISS3IUL3 self, unsigned int idx) -> itkImageSS3
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3IUL3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageSS3') -> "void":
        """
        PushBackInput(itkImageToImageFilterISS3IUL3 self, itkImageSS3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3IUL3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterISS3IUL3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3IUL3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageSS3') -> "void":
        """PushFrontInput(itkImageToImageFilterISS3IUL3 self, itkImageSS3 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3IUL3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterISS3IUL3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3IUL3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterISS3IUL3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3IUL3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterISS3IUL3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3IUL3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterISS3IUL3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3IUL3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterISS3IUL3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3IUL3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterISS3IUL3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS3IUL3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterISS3IUL3"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3IUL3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterISS3IUL3

        Create a new object of the class itkImageToImageFilterISS3IUL3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterISS3IUL3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterISS3IUL3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterISS3IUL3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterISS3IUL3.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS3IUL3_SetInput, None, itkImageToImageFilterISS3IUL3)
itkImageToImageFilterISS3IUL3.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS3IUL3_GetInput, None, itkImageToImageFilterISS3IUL3)
itkImageToImageFilterISS3IUL3.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS3IUL3_PushBackInput, None, itkImageToImageFilterISS3IUL3)
itkImageToImageFilterISS3IUL3.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS3IUL3_PopBackInput, None, itkImageToImageFilterISS3IUL3)
itkImageToImageFilterISS3IUL3.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS3IUL3_PushFrontInput, None, itkImageToImageFilterISS3IUL3)
itkImageToImageFilterISS3IUL3.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS3IUL3_PopFrontInput, None, itkImageToImageFilterISS3IUL3)
itkImageToImageFilterISS3IUL3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS3IUL3_SetCoordinateTolerance, None, itkImageToImageFilterISS3IUL3)
itkImageToImageFilterISS3IUL3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS3IUL3_GetCoordinateTolerance, None, itkImageToImageFilterISS3IUL3)
itkImageToImageFilterISS3IUL3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS3IUL3_SetDirectionTolerance, None, itkImageToImageFilterISS3IUL3)
itkImageToImageFilterISS3IUL3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS3IUL3_GetDirectionTolerance, None, itkImageToImageFilterISS3IUL3)
itkImageToImageFilterISS3IUL3_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterISS3IUL3_swigregister
itkImageToImageFilterISS3IUL3_swigregister(itkImageToImageFilterISS3IUL3)

def itkImageToImageFilterISS3IUL3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS3IUL3 *":
    """itkImageToImageFilterISS3IUL3_cast(itkLightObject obj) -> itkImageToImageFilterISS3IUL3"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterISS3IUL3_cast(obj)

class itkImageToImageFilterISS3IUS3(itkImageSourcePython.itkImageSourceIUS3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterISS3IUS3 self, itkImageSS3 image)
        SetInput(itkImageToImageFilterISS3IUS3 self, unsigned int arg0, itkImageSS3 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3IUS3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageSS3 const *":
        """
        GetInput(itkImageToImageFilterISS3IUS3 self) -> itkImageSS3
        GetInput(itkImageToImageFilterISS3IUS3 self, unsigned int idx) -> itkImageSS3
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3IUS3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageSS3') -> "void":
        """
        PushBackInput(itkImageToImageFilterISS3IUS3 self, itkImageSS3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3IUS3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterISS3IUS3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3IUS3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageSS3') -> "void":
        """PushFrontInput(itkImageToImageFilterISS3IUS3 self, itkImageSS3 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3IUS3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterISS3IUS3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3IUS3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterISS3IUS3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3IUS3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterISS3IUS3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3IUS3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterISS3IUS3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3IUS3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterISS3IUS3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3IUS3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterISS3IUS3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS3IUS3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterISS3IUS3"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterISS3IUS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterISS3IUS3

        Create a new object of the class itkImageToImageFilterISS3IUS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterISS3IUS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterISS3IUS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterISS3IUS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterISS3IUS3.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS3IUS3_SetInput, None, itkImageToImageFilterISS3IUS3)
itkImageToImageFilterISS3IUS3.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS3IUS3_GetInput, None, itkImageToImageFilterISS3IUS3)
itkImageToImageFilterISS3IUS3.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS3IUS3_PushBackInput, None, itkImageToImageFilterISS3IUS3)
itkImageToImageFilterISS3IUS3.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS3IUS3_PopBackInput, None, itkImageToImageFilterISS3IUS3)
itkImageToImageFilterISS3IUS3.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS3IUS3_PushFrontInput, None, itkImageToImageFilterISS3IUS3)
itkImageToImageFilterISS3IUS3.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS3IUS3_PopFrontInput, None, itkImageToImageFilterISS3IUS3)
itkImageToImageFilterISS3IUS3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS3IUS3_SetCoordinateTolerance, None, itkImageToImageFilterISS3IUS3)
itkImageToImageFilterISS3IUS3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS3IUS3_GetCoordinateTolerance, None, itkImageToImageFilterISS3IUS3)
itkImageToImageFilterISS3IUS3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS3IUS3_SetDirectionTolerance, None, itkImageToImageFilterISS3IUS3)
itkImageToImageFilterISS3IUS3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterISS3IUS3_GetDirectionTolerance, None, itkImageToImageFilterISS3IUS3)
itkImageToImageFilterISS3IUS3_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterISS3IUS3_swigregister
itkImageToImageFilterISS3IUS3_swigregister(itkImageToImageFilterISS3IUS3)

def itkImageToImageFilterISS3IUS3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS3IUS3 *":
    """itkImageToImageFilterISS3IUS3_cast(itkLightObject obj) -> itkImageToImageFilterISS3IUS3"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterISS3IUS3_cast(obj)

class itkImageToImageFilterIUC2ID2(itkImageSourcePython.itkImageSourceID2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUC2ID2 self, itkImageUC2 image)
        SetInput(itkImageToImageFilterIUC2ID2 self, unsigned int arg0, itkImageUC2 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2ID2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUC2 const *":
        """
        GetInput(itkImageToImageFilterIUC2ID2 self) -> itkImageUC2
        GetInput(itkImageToImageFilterIUC2ID2 self, unsigned int idx) -> itkImageUC2
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2ID2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUC2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUC2ID2 self, itkImageUC2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2ID2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUC2ID2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2ID2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUC2') -> "void":
        """PushFrontInput(itkImageToImageFilterIUC2ID2 self, itkImageUC2 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2ID2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUC2ID2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2ID2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUC2ID2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2ID2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUC2ID2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2ID2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUC2ID2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2ID2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUC2ID2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2ID2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIUC2ID2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC2ID2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUC2ID2"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2ID2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUC2ID2

        Create a new object of the class itkImageToImageFilterIUC2ID2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUC2ID2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUC2ID2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUC2ID2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUC2ID2.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC2ID2_SetInput, None, itkImageToImageFilterIUC2ID2)
itkImageToImageFilterIUC2ID2.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC2ID2_GetInput, None, itkImageToImageFilterIUC2ID2)
itkImageToImageFilterIUC2ID2.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC2ID2_PushBackInput, None, itkImageToImageFilterIUC2ID2)
itkImageToImageFilterIUC2ID2.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC2ID2_PopBackInput, None, itkImageToImageFilterIUC2ID2)
itkImageToImageFilterIUC2ID2.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC2ID2_PushFrontInput, None, itkImageToImageFilterIUC2ID2)
itkImageToImageFilterIUC2ID2.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC2ID2_PopFrontInput, None, itkImageToImageFilterIUC2ID2)
itkImageToImageFilterIUC2ID2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC2ID2_SetCoordinateTolerance, None, itkImageToImageFilterIUC2ID2)
itkImageToImageFilterIUC2ID2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC2ID2_GetCoordinateTolerance, None, itkImageToImageFilterIUC2ID2)
itkImageToImageFilterIUC2ID2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC2ID2_SetDirectionTolerance, None, itkImageToImageFilterIUC2ID2)
itkImageToImageFilterIUC2ID2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC2ID2_GetDirectionTolerance, None, itkImageToImageFilterIUC2ID2)
itkImageToImageFilterIUC2ID2_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIUC2ID2_swigregister
itkImageToImageFilterIUC2ID2_swigregister(itkImageToImageFilterIUC2ID2)

def itkImageToImageFilterIUC2ID2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC2ID2 *":
    """itkImageToImageFilterIUC2ID2_cast(itkLightObject obj) -> itkImageToImageFilterIUC2ID2"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2ID2_cast(obj)

class itkImageToImageFilterIUC2IF2(itkImageSourcePython.itkImageSourceIF2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUC2IF2 self, itkImageUC2 image)
        SetInput(itkImageToImageFilterIUC2IF2 self, unsigned int arg0, itkImageUC2 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2IF2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUC2 const *":
        """
        GetInput(itkImageToImageFilterIUC2IF2 self) -> itkImageUC2
        GetInput(itkImageToImageFilterIUC2IF2 self, unsigned int idx) -> itkImageUC2
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2IF2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUC2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUC2IF2 self, itkImageUC2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2IF2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUC2IF2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2IF2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUC2') -> "void":
        """PushFrontInput(itkImageToImageFilterIUC2IF2 self, itkImageUC2 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2IF2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUC2IF2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2IF2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUC2IF2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2IF2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUC2IF2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2IF2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUC2IF2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2IF2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUC2IF2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2IF2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIUC2IF2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC2IF2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUC2IF2"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2IF2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUC2IF2

        Create a new object of the class itkImageToImageFilterIUC2IF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUC2IF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUC2IF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUC2IF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUC2IF2.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC2IF2_SetInput, None, itkImageToImageFilterIUC2IF2)
itkImageToImageFilterIUC2IF2.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC2IF2_GetInput, None, itkImageToImageFilterIUC2IF2)
itkImageToImageFilterIUC2IF2.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC2IF2_PushBackInput, None, itkImageToImageFilterIUC2IF2)
itkImageToImageFilterIUC2IF2.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC2IF2_PopBackInput, None, itkImageToImageFilterIUC2IF2)
itkImageToImageFilterIUC2IF2.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC2IF2_PushFrontInput, None, itkImageToImageFilterIUC2IF2)
itkImageToImageFilterIUC2IF2.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC2IF2_PopFrontInput, None, itkImageToImageFilterIUC2IF2)
itkImageToImageFilterIUC2IF2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC2IF2_SetCoordinateTolerance, None, itkImageToImageFilterIUC2IF2)
itkImageToImageFilterIUC2IF2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC2IF2_GetCoordinateTolerance, None, itkImageToImageFilterIUC2IF2)
itkImageToImageFilterIUC2IF2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC2IF2_SetDirectionTolerance, None, itkImageToImageFilterIUC2IF2)
itkImageToImageFilterIUC2IF2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC2IF2_GetDirectionTolerance, None, itkImageToImageFilterIUC2IF2)
itkImageToImageFilterIUC2IF2_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIUC2IF2_swigregister
itkImageToImageFilterIUC2IF2_swigregister(itkImageToImageFilterIUC2IF2)

def itkImageToImageFilterIUC2IF2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC2IF2 *":
    """itkImageToImageFilterIUC2IF2_cast(itkLightObject obj) -> itkImageToImageFilterIUC2IF2"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2IF2_cast(obj)

class itkImageToImageFilterIUC2ISS2(itkImageSourcePython.itkImageSourceISS2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUC2ISS2 self, itkImageUC2 image)
        SetInput(itkImageToImageFilterIUC2ISS2 self, unsigned int arg0, itkImageUC2 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2ISS2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUC2 const *":
        """
        GetInput(itkImageToImageFilterIUC2ISS2 self) -> itkImageUC2
        GetInput(itkImageToImageFilterIUC2ISS2 self, unsigned int idx) -> itkImageUC2
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2ISS2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUC2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUC2ISS2 self, itkImageUC2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2ISS2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUC2ISS2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2ISS2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUC2') -> "void":
        """PushFrontInput(itkImageToImageFilterIUC2ISS2 self, itkImageUC2 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2ISS2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUC2ISS2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2ISS2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUC2ISS2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2ISS2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUC2ISS2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2ISS2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUC2ISS2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2ISS2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUC2ISS2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2ISS2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIUC2ISS2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC2ISS2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUC2ISS2"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2ISS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUC2ISS2

        Create a new object of the class itkImageToImageFilterIUC2ISS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUC2ISS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUC2ISS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUC2ISS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUC2ISS2.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC2ISS2_SetInput, None, itkImageToImageFilterIUC2ISS2)
itkImageToImageFilterIUC2ISS2.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC2ISS2_GetInput, None, itkImageToImageFilterIUC2ISS2)
itkImageToImageFilterIUC2ISS2.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC2ISS2_PushBackInput, None, itkImageToImageFilterIUC2ISS2)
itkImageToImageFilterIUC2ISS2.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC2ISS2_PopBackInput, None, itkImageToImageFilterIUC2ISS2)
itkImageToImageFilterIUC2ISS2.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC2ISS2_PushFrontInput, None, itkImageToImageFilterIUC2ISS2)
itkImageToImageFilterIUC2ISS2.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC2ISS2_PopFrontInput, None, itkImageToImageFilterIUC2ISS2)
itkImageToImageFilterIUC2ISS2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC2ISS2_SetCoordinateTolerance, None, itkImageToImageFilterIUC2ISS2)
itkImageToImageFilterIUC2ISS2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC2ISS2_GetCoordinateTolerance, None, itkImageToImageFilterIUC2ISS2)
itkImageToImageFilterIUC2ISS2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC2ISS2_SetDirectionTolerance, None, itkImageToImageFilterIUC2ISS2)
itkImageToImageFilterIUC2ISS2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC2ISS2_GetDirectionTolerance, None, itkImageToImageFilterIUC2ISS2)
itkImageToImageFilterIUC2ISS2_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIUC2ISS2_swigregister
itkImageToImageFilterIUC2ISS2_swigregister(itkImageToImageFilterIUC2ISS2)

def itkImageToImageFilterIUC2ISS2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC2ISS2 *":
    """itkImageToImageFilterIUC2ISS2_cast(itkLightObject obj) -> itkImageToImageFilterIUC2ISS2"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2ISS2_cast(obj)

class itkImageToImageFilterIUC2IUC2(itkImageSourcePython.itkImageSourceIUC2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUC2IUC2 self, itkImageUC2 image)
        SetInput(itkImageToImageFilterIUC2IUC2 self, unsigned int arg0, itkImageUC2 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUC2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUC2 const *":
        """
        GetInput(itkImageToImageFilterIUC2IUC2 self) -> itkImageUC2
        GetInput(itkImageToImageFilterIUC2IUC2 self, unsigned int idx) -> itkImageUC2
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUC2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUC2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUC2IUC2 self, itkImageUC2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUC2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUC2IUC2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUC2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUC2') -> "void":
        """PushFrontInput(itkImageToImageFilterIUC2IUC2 self, itkImageUC2 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUC2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUC2IUC2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUC2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUC2IUC2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUC2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUC2IUC2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUC2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUC2IUC2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUC2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUC2IUC2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUC2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIUC2IUC2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC2IUC2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUC2IUC2"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUC2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUC2IUC2

        Create a new object of the class itkImageToImageFilterIUC2IUC2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUC2IUC2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUC2IUC2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUC2IUC2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUC2IUC2.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUC2_SetInput, None, itkImageToImageFilterIUC2IUC2)
itkImageToImageFilterIUC2IUC2.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUC2_GetInput, None, itkImageToImageFilterIUC2IUC2)
itkImageToImageFilterIUC2IUC2.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUC2_PushBackInput, None, itkImageToImageFilterIUC2IUC2)
itkImageToImageFilterIUC2IUC2.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUC2_PopBackInput, None, itkImageToImageFilterIUC2IUC2)
itkImageToImageFilterIUC2IUC2.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUC2_PushFrontInput, None, itkImageToImageFilterIUC2IUC2)
itkImageToImageFilterIUC2IUC2.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUC2_PopFrontInput, None, itkImageToImageFilterIUC2IUC2)
itkImageToImageFilterIUC2IUC2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUC2_SetCoordinateTolerance, None, itkImageToImageFilterIUC2IUC2)
itkImageToImageFilterIUC2IUC2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUC2_GetCoordinateTolerance, None, itkImageToImageFilterIUC2IUC2)
itkImageToImageFilterIUC2IUC2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUC2_SetDirectionTolerance, None, itkImageToImageFilterIUC2IUC2)
itkImageToImageFilterIUC2IUC2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUC2_GetDirectionTolerance, None, itkImageToImageFilterIUC2IUC2)
itkImageToImageFilterIUC2IUC2_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUC2_swigregister
itkImageToImageFilterIUC2IUC2_swigregister(itkImageToImageFilterIUC2IUC2)

def itkImageToImageFilterIUC2IUC2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC2IUC2 *":
    """itkImageToImageFilterIUC2IUC2_cast(itkLightObject obj) -> itkImageToImageFilterIUC2IUC2"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUC2_cast(obj)

class itkImageToImageFilterIUC2IUL2(itkImageSourcePython.itkImageSourceIUL2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUC2IUL2 self, itkImageUC2 image)
        SetInput(itkImageToImageFilterIUC2IUL2 self, unsigned int arg0, itkImageUC2 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUL2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUC2 const *":
        """
        GetInput(itkImageToImageFilterIUC2IUL2 self) -> itkImageUC2
        GetInput(itkImageToImageFilterIUC2IUL2 self, unsigned int idx) -> itkImageUC2
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUL2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUC2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUC2IUL2 self, itkImageUC2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUL2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUC2IUL2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUL2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUC2') -> "void":
        """PushFrontInput(itkImageToImageFilterIUC2IUL2 self, itkImageUC2 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUL2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUC2IUL2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUL2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUC2IUL2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUL2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUC2IUL2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUL2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUC2IUL2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUL2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUC2IUL2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUL2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIUC2IUL2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC2IUL2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUC2IUL2"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUL2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUC2IUL2

        Create a new object of the class itkImageToImageFilterIUC2IUL2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUC2IUL2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUC2IUL2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUC2IUL2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUC2IUL2.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUL2_SetInput, None, itkImageToImageFilterIUC2IUL2)
itkImageToImageFilterIUC2IUL2.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUL2_GetInput, None, itkImageToImageFilterIUC2IUL2)
itkImageToImageFilterIUC2IUL2.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUL2_PushBackInput, None, itkImageToImageFilterIUC2IUL2)
itkImageToImageFilterIUC2IUL2.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUL2_PopBackInput, None, itkImageToImageFilterIUC2IUL2)
itkImageToImageFilterIUC2IUL2.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUL2_PushFrontInput, None, itkImageToImageFilterIUC2IUL2)
itkImageToImageFilterIUC2IUL2.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUL2_PopFrontInput, None, itkImageToImageFilterIUC2IUL2)
itkImageToImageFilterIUC2IUL2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUL2_SetCoordinateTolerance, None, itkImageToImageFilterIUC2IUL2)
itkImageToImageFilterIUC2IUL2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUL2_GetCoordinateTolerance, None, itkImageToImageFilterIUC2IUL2)
itkImageToImageFilterIUC2IUL2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUL2_SetDirectionTolerance, None, itkImageToImageFilterIUC2IUL2)
itkImageToImageFilterIUC2IUL2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUL2_GetDirectionTolerance, None, itkImageToImageFilterIUC2IUL2)
itkImageToImageFilterIUC2IUL2_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUL2_swigregister
itkImageToImageFilterIUC2IUL2_swigregister(itkImageToImageFilterIUC2IUL2)

def itkImageToImageFilterIUC2IUL2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC2IUL2 *":
    """itkImageToImageFilterIUC2IUL2_cast(itkLightObject obj) -> itkImageToImageFilterIUC2IUL2"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUL2_cast(obj)

class itkImageToImageFilterIUC2IUS2(itkImageSourcePython.itkImageSourceIUS2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUC2IUS2 self, itkImageUC2 image)
        SetInput(itkImageToImageFilterIUC2IUS2 self, unsigned int arg0, itkImageUC2 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUS2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUC2 const *":
        """
        GetInput(itkImageToImageFilterIUC2IUS2 self) -> itkImageUC2
        GetInput(itkImageToImageFilterIUC2IUS2 self, unsigned int idx) -> itkImageUC2
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUS2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUC2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUC2IUS2 self, itkImageUC2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUS2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUC2IUS2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUS2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUC2') -> "void":
        """PushFrontInput(itkImageToImageFilterIUC2IUS2 self, itkImageUC2 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUS2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUC2IUS2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUS2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUC2IUS2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUS2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUC2IUS2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUS2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUC2IUS2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUS2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUC2IUS2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUS2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIUC2IUS2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC2IUS2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUC2IUS2"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUC2IUS2

        Create a new object of the class itkImageToImageFilterIUC2IUS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUC2IUS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUC2IUS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUC2IUS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUC2IUS2.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUS2_SetInput, None, itkImageToImageFilterIUC2IUS2)
itkImageToImageFilterIUC2IUS2.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUS2_GetInput, None, itkImageToImageFilterIUC2IUS2)
itkImageToImageFilterIUC2IUS2.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUS2_PushBackInput, None, itkImageToImageFilterIUC2IUS2)
itkImageToImageFilterIUC2IUS2.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUS2_PopBackInput, None, itkImageToImageFilterIUC2IUS2)
itkImageToImageFilterIUC2IUS2.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUS2_PushFrontInput, None, itkImageToImageFilterIUC2IUS2)
itkImageToImageFilterIUC2IUS2.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUS2_PopFrontInput, None, itkImageToImageFilterIUC2IUS2)
itkImageToImageFilterIUC2IUS2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUS2_SetCoordinateTolerance, None, itkImageToImageFilterIUC2IUS2)
itkImageToImageFilterIUC2IUS2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUS2_GetCoordinateTolerance, None, itkImageToImageFilterIUC2IUS2)
itkImageToImageFilterIUC2IUS2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUS2_SetDirectionTolerance, None, itkImageToImageFilterIUC2IUS2)
itkImageToImageFilterIUC2IUS2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUS2_GetDirectionTolerance, None, itkImageToImageFilterIUC2IUS2)
itkImageToImageFilterIUC2IUS2_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUS2_swigregister
itkImageToImageFilterIUC2IUS2_swigregister(itkImageToImageFilterIUC2IUS2)

def itkImageToImageFilterIUC2IUS2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC2IUS2 *":
    """itkImageToImageFilterIUC2IUS2_cast(itkLightObject obj) -> itkImageToImageFilterIUC2IUS2"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIUC2IUS2_cast(obj)

class itkImageToImageFilterIUC3ID3(itkImageSourcePython.itkImageSourceID3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUC3ID3 self, itkImageUC3 image)
        SetInput(itkImageToImageFilterIUC3ID3 self, unsigned int arg0, itkImageUC3 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3ID3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUC3 const *":
        """
        GetInput(itkImageToImageFilterIUC3ID3 self) -> itkImageUC3
        GetInput(itkImageToImageFilterIUC3ID3 self, unsigned int idx) -> itkImageUC3
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3ID3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUC3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUC3ID3 self, itkImageUC3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3ID3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUC3ID3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3ID3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUC3') -> "void":
        """PushFrontInput(itkImageToImageFilterIUC3ID3 self, itkImageUC3 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3ID3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUC3ID3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3ID3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUC3ID3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3ID3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUC3ID3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3ID3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUC3ID3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3ID3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUC3ID3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3ID3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIUC3ID3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC3ID3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUC3ID3"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3ID3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUC3ID3

        Create a new object of the class itkImageToImageFilterIUC3ID3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUC3ID3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUC3ID3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUC3ID3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUC3ID3.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC3ID3_SetInput, None, itkImageToImageFilterIUC3ID3)
itkImageToImageFilterIUC3ID3.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC3ID3_GetInput, None, itkImageToImageFilterIUC3ID3)
itkImageToImageFilterIUC3ID3.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC3ID3_PushBackInput, None, itkImageToImageFilterIUC3ID3)
itkImageToImageFilterIUC3ID3.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC3ID3_PopBackInput, None, itkImageToImageFilterIUC3ID3)
itkImageToImageFilterIUC3ID3.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC3ID3_PushFrontInput, None, itkImageToImageFilterIUC3ID3)
itkImageToImageFilterIUC3ID3.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC3ID3_PopFrontInput, None, itkImageToImageFilterIUC3ID3)
itkImageToImageFilterIUC3ID3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC3ID3_SetCoordinateTolerance, None, itkImageToImageFilterIUC3ID3)
itkImageToImageFilterIUC3ID3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC3ID3_GetCoordinateTolerance, None, itkImageToImageFilterIUC3ID3)
itkImageToImageFilterIUC3ID3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC3ID3_SetDirectionTolerance, None, itkImageToImageFilterIUC3ID3)
itkImageToImageFilterIUC3ID3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC3ID3_GetDirectionTolerance, None, itkImageToImageFilterIUC3ID3)
itkImageToImageFilterIUC3ID3_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIUC3ID3_swigregister
itkImageToImageFilterIUC3ID3_swigregister(itkImageToImageFilterIUC3ID3)

def itkImageToImageFilterIUC3ID3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC3ID3 *":
    """itkImageToImageFilterIUC3ID3_cast(itkLightObject obj) -> itkImageToImageFilterIUC3ID3"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3ID3_cast(obj)

class itkImageToImageFilterIUC3IF3(itkImageSourcePython.itkImageSourceIF3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUC3IF3 self, itkImageUC3 image)
        SetInput(itkImageToImageFilterIUC3IF3 self, unsigned int arg0, itkImageUC3 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3IF3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUC3 const *":
        """
        GetInput(itkImageToImageFilterIUC3IF3 self) -> itkImageUC3
        GetInput(itkImageToImageFilterIUC3IF3 self, unsigned int idx) -> itkImageUC3
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3IF3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUC3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUC3IF3 self, itkImageUC3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3IF3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUC3IF3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3IF3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUC3') -> "void":
        """PushFrontInput(itkImageToImageFilterIUC3IF3 self, itkImageUC3 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3IF3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUC3IF3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3IF3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUC3IF3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3IF3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUC3IF3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3IF3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUC3IF3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3IF3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUC3IF3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3IF3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIUC3IF3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC3IF3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUC3IF3"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3IF3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUC3IF3

        Create a new object of the class itkImageToImageFilterIUC3IF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUC3IF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUC3IF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUC3IF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUC3IF3.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC3IF3_SetInput, None, itkImageToImageFilterIUC3IF3)
itkImageToImageFilterIUC3IF3.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC3IF3_GetInput, None, itkImageToImageFilterIUC3IF3)
itkImageToImageFilterIUC3IF3.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC3IF3_PushBackInput, None, itkImageToImageFilterIUC3IF3)
itkImageToImageFilterIUC3IF3.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC3IF3_PopBackInput, None, itkImageToImageFilterIUC3IF3)
itkImageToImageFilterIUC3IF3.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC3IF3_PushFrontInput, None, itkImageToImageFilterIUC3IF3)
itkImageToImageFilterIUC3IF3.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC3IF3_PopFrontInput, None, itkImageToImageFilterIUC3IF3)
itkImageToImageFilterIUC3IF3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC3IF3_SetCoordinateTolerance, None, itkImageToImageFilterIUC3IF3)
itkImageToImageFilterIUC3IF3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC3IF3_GetCoordinateTolerance, None, itkImageToImageFilterIUC3IF3)
itkImageToImageFilterIUC3IF3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC3IF3_SetDirectionTolerance, None, itkImageToImageFilterIUC3IF3)
itkImageToImageFilterIUC3IF3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC3IF3_GetDirectionTolerance, None, itkImageToImageFilterIUC3IF3)
itkImageToImageFilterIUC3IF3_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIUC3IF3_swigregister
itkImageToImageFilterIUC3IF3_swigregister(itkImageToImageFilterIUC3IF3)

def itkImageToImageFilterIUC3IF3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC3IF3 *":
    """itkImageToImageFilterIUC3IF3_cast(itkLightObject obj) -> itkImageToImageFilterIUC3IF3"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3IF3_cast(obj)

class itkImageToImageFilterIUC3ISS3(itkImageSourcePython.itkImageSourceISS3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUC3ISS3 self, itkImageUC3 image)
        SetInput(itkImageToImageFilterIUC3ISS3 self, unsigned int arg0, itkImageUC3 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3ISS3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUC3 const *":
        """
        GetInput(itkImageToImageFilterIUC3ISS3 self) -> itkImageUC3
        GetInput(itkImageToImageFilterIUC3ISS3 self, unsigned int idx) -> itkImageUC3
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3ISS3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUC3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUC3ISS3 self, itkImageUC3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3ISS3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUC3ISS3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3ISS3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUC3') -> "void":
        """PushFrontInput(itkImageToImageFilterIUC3ISS3 self, itkImageUC3 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3ISS3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUC3ISS3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3ISS3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUC3ISS3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3ISS3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUC3ISS3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3ISS3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUC3ISS3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3ISS3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUC3ISS3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3ISS3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIUC3ISS3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC3ISS3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUC3ISS3"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3ISS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUC3ISS3

        Create a new object of the class itkImageToImageFilterIUC3ISS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUC3ISS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUC3ISS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUC3ISS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUC3ISS3.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC3ISS3_SetInput, None, itkImageToImageFilterIUC3ISS3)
itkImageToImageFilterIUC3ISS3.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC3ISS3_GetInput, None, itkImageToImageFilterIUC3ISS3)
itkImageToImageFilterIUC3ISS3.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC3ISS3_PushBackInput, None, itkImageToImageFilterIUC3ISS3)
itkImageToImageFilterIUC3ISS3.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC3ISS3_PopBackInput, None, itkImageToImageFilterIUC3ISS3)
itkImageToImageFilterIUC3ISS3.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC3ISS3_PushFrontInput, None, itkImageToImageFilterIUC3ISS3)
itkImageToImageFilterIUC3ISS3.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC3ISS3_PopFrontInput, None, itkImageToImageFilterIUC3ISS3)
itkImageToImageFilterIUC3ISS3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC3ISS3_SetCoordinateTolerance, None, itkImageToImageFilterIUC3ISS3)
itkImageToImageFilterIUC3ISS3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC3ISS3_GetCoordinateTolerance, None, itkImageToImageFilterIUC3ISS3)
itkImageToImageFilterIUC3ISS3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC3ISS3_SetDirectionTolerance, None, itkImageToImageFilterIUC3ISS3)
itkImageToImageFilterIUC3ISS3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC3ISS3_GetDirectionTolerance, None, itkImageToImageFilterIUC3ISS3)
itkImageToImageFilterIUC3ISS3_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIUC3ISS3_swigregister
itkImageToImageFilterIUC3ISS3_swigregister(itkImageToImageFilterIUC3ISS3)

def itkImageToImageFilterIUC3ISS3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC3ISS3 *":
    """itkImageToImageFilterIUC3ISS3_cast(itkLightObject obj) -> itkImageToImageFilterIUC3ISS3"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3ISS3_cast(obj)

class itkImageToImageFilterIUC3IUC3(itkImageSourcePython.itkImageSourceIUC3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUC3IUC3 self, itkImageUC3 image)
        SetInput(itkImageToImageFilterIUC3IUC3 self, unsigned int arg0, itkImageUC3 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUC3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUC3 const *":
        """
        GetInput(itkImageToImageFilterIUC3IUC3 self) -> itkImageUC3
        GetInput(itkImageToImageFilterIUC3IUC3 self, unsigned int idx) -> itkImageUC3
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUC3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUC3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUC3IUC3 self, itkImageUC3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUC3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUC3IUC3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUC3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUC3') -> "void":
        """PushFrontInput(itkImageToImageFilterIUC3IUC3 self, itkImageUC3 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUC3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUC3IUC3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUC3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUC3IUC3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUC3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUC3IUC3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUC3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUC3IUC3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUC3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUC3IUC3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUC3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIUC3IUC3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC3IUC3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUC3IUC3"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUC3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUC3IUC3

        Create a new object of the class itkImageToImageFilterIUC3IUC3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUC3IUC3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUC3IUC3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUC3IUC3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUC3IUC3.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUC3_SetInput, None, itkImageToImageFilterIUC3IUC3)
itkImageToImageFilterIUC3IUC3.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUC3_GetInput, None, itkImageToImageFilterIUC3IUC3)
itkImageToImageFilterIUC3IUC3.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUC3_PushBackInput, None, itkImageToImageFilterIUC3IUC3)
itkImageToImageFilterIUC3IUC3.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUC3_PopBackInput, None, itkImageToImageFilterIUC3IUC3)
itkImageToImageFilterIUC3IUC3.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUC3_PushFrontInput, None, itkImageToImageFilterIUC3IUC3)
itkImageToImageFilterIUC3IUC3.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUC3_PopFrontInput, None, itkImageToImageFilterIUC3IUC3)
itkImageToImageFilterIUC3IUC3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUC3_SetCoordinateTolerance, None, itkImageToImageFilterIUC3IUC3)
itkImageToImageFilterIUC3IUC3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUC3_GetCoordinateTolerance, None, itkImageToImageFilterIUC3IUC3)
itkImageToImageFilterIUC3IUC3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUC3_SetDirectionTolerance, None, itkImageToImageFilterIUC3IUC3)
itkImageToImageFilterIUC3IUC3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUC3_GetDirectionTolerance, None, itkImageToImageFilterIUC3IUC3)
itkImageToImageFilterIUC3IUC3_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUC3_swigregister
itkImageToImageFilterIUC3IUC3_swigregister(itkImageToImageFilterIUC3IUC3)

def itkImageToImageFilterIUC3IUC3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC3IUC3 *":
    """itkImageToImageFilterIUC3IUC3_cast(itkLightObject obj) -> itkImageToImageFilterIUC3IUC3"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUC3_cast(obj)

class itkImageToImageFilterIUC3IUL3(itkImageSourcePython.itkImageSourceIUL3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUC3IUL3 self, itkImageUC3 image)
        SetInput(itkImageToImageFilterIUC3IUL3 self, unsigned int arg0, itkImageUC3 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUL3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUC3 const *":
        """
        GetInput(itkImageToImageFilterIUC3IUL3 self) -> itkImageUC3
        GetInput(itkImageToImageFilterIUC3IUL3 self, unsigned int idx) -> itkImageUC3
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUL3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUC3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUC3IUL3 self, itkImageUC3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUL3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUC3IUL3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUL3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUC3') -> "void":
        """PushFrontInput(itkImageToImageFilterIUC3IUL3 self, itkImageUC3 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUL3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUC3IUL3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUL3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUC3IUL3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUL3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUC3IUL3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUL3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUC3IUL3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUL3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUC3IUL3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUL3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIUC3IUL3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC3IUL3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUC3IUL3"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUL3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUC3IUL3

        Create a new object of the class itkImageToImageFilterIUC3IUL3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUC3IUL3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUC3IUL3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUC3IUL3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUC3IUL3.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUL3_SetInput, None, itkImageToImageFilterIUC3IUL3)
itkImageToImageFilterIUC3IUL3.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUL3_GetInput, None, itkImageToImageFilterIUC3IUL3)
itkImageToImageFilterIUC3IUL3.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUL3_PushBackInput, None, itkImageToImageFilterIUC3IUL3)
itkImageToImageFilterIUC3IUL3.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUL3_PopBackInput, None, itkImageToImageFilterIUC3IUL3)
itkImageToImageFilterIUC3IUL3.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUL3_PushFrontInput, None, itkImageToImageFilterIUC3IUL3)
itkImageToImageFilterIUC3IUL3.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUL3_PopFrontInput, None, itkImageToImageFilterIUC3IUL3)
itkImageToImageFilterIUC3IUL3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUL3_SetCoordinateTolerance, None, itkImageToImageFilterIUC3IUL3)
itkImageToImageFilterIUC3IUL3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUL3_GetCoordinateTolerance, None, itkImageToImageFilterIUC3IUL3)
itkImageToImageFilterIUC3IUL3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUL3_SetDirectionTolerance, None, itkImageToImageFilterIUC3IUL3)
itkImageToImageFilterIUC3IUL3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUL3_GetDirectionTolerance, None, itkImageToImageFilterIUC3IUL3)
itkImageToImageFilterIUC3IUL3_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUL3_swigregister
itkImageToImageFilterIUC3IUL3_swigregister(itkImageToImageFilterIUC3IUL3)

def itkImageToImageFilterIUC3IUL3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC3IUL3 *":
    """itkImageToImageFilterIUC3IUL3_cast(itkLightObject obj) -> itkImageToImageFilterIUC3IUL3"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUL3_cast(obj)

class itkImageToImageFilterIUC3IUS3(itkImageSourcePython.itkImageSourceIUS3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUC3IUS3 self, itkImageUC3 image)
        SetInput(itkImageToImageFilterIUC3IUS3 self, unsigned int arg0, itkImageUC3 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUS3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUC3 const *":
        """
        GetInput(itkImageToImageFilterIUC3IUS3 self) -> itkImageUC3
        GetInput(itkImageToImageFilterIUC3IUS3 self, unsigned int idx) -> itkImageUC3
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUS3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUC3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUC3IUS3 self, itkImageUC3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUS3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUC3IUS3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUS3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUC3') -> "void":
        """PushFrontInput(itkImageToImageFilterIUC3IUS3 self, itkImageUC3 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUS3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUC3IUS3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUS3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUC3IUS3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUS3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUC3IUS3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUS3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUC3IUS3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUS3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUC3IUS3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUS3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIUC3IUS3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC3IUS3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUC3IUS3"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUC3IUS3

        Create a new object of the class itkImageToImageFilterIUC3IUS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUC3IUS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUC3IUS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUC3IUS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUC3IUS3.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUS3_SetInput, None, itkImageToImageFilterIUC3IUS3)
itkImageToImageFilterIUC3IUS3.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUS3_GetInput, None, itkImageToImageFilterIUC3IUS3)
itkImageToImageFilterIUC3IUS3.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUS3_PushBackInput, None, itkImageToImageFilterIUC3IUS3)
itkImageToImageFilterIUC3IUS3.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUS3_PopBackInput, None, itkImageToImageFilterIUC3IUS3)
itkImageToImageFilterIUC3IUS3.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUS3_PushFrontInput, None, itkImageToImageFilterIUC3IUS3)
itkImageToImageFilterIUC3IUS3.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUS3_PopFrontInput, None, itkImageToImageFilterIUC3IUS3)
itkImageToImageFilterIUC3IUS3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUS3_SetCoordinateTolerance, None, itkImageToImageFilterIUC3IUS3)
itkImageToImageFilterIUC3IUS3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUS3_GetCoordinateTolerance, None, itkImageToImageFilterIUC3IUS3)
itkImageToImageFilterIUC3IUS3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUS3_SetDirectionTolerance, None, itkImageToImageFilterIUC3IUS3)
itkImageToImageFilterIUC3IUS3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUS3_GetDirectionTolerance, None, itkImageToImageFilterIUC3IUS3)
itkImageToImageFilterIUC3IUS3_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUS3_swigregister
itkImageToImageFilterIUC3IUS3_swigregister(itkImageToImageFilterIUC3IUS3)

def itkImageToImageFilterIUC3IUS3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC3IUS3 *":
    """itkImageToImageFilterIUC3IUS3_cast(itkLightObject obj) -> itkImageToImageFilterIUC3IUS3"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIUC3IUS3_cast(obj)

class itkImageToImageFilterIUL2ID2(itkImageSourcePython.itkImageSourceID2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUL2ID2 self, itkImageUL2 image)
        SetInput(itkImageToImageFilterIUL2ID2 self, unsigned int arg0, itkImageUL2 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2ID2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUL2 const *":
        """
        GetInput(itkImageToImageFilterIUL2ID2 self) -> itkImageUL2
        GetInput(itkImageToImageFilterIUL2ID2 self, unsigned int idx) -> itkImageUL2
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2ID2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUL2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUL2ID2 self, itkImageUL2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2ID2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUL2ID2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2ID2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUL2') -> "void":
        """PushFrontInput(itkImageToImageFilterIUL2ID2 self, itkImageUL2 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2ID2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUL2ID2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2ID2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUL2ID2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2ID2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUL2ID2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2ID2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUL2ID2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2ID2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUL2ID2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2ID2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIUL2ID2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUL2ID2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUL2ID2"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2ID2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUL2ID2

        Create a new object of the class itkImageToImageFilterIUL2ID2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUL2ID2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUL2ID2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUL2ID2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUL2ID2.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL2ID2_SetInput, None, itkImageToImageFilterIUL2ID2)
itkImageToImageFilterIUL2ID2.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL2ID2_GetInput, None, itkImageToImageFilterIUL2ID2)
itkImageToImageFilterIUL2ID2.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL2ID2_PushBackInput, None, itkImageToImageFilterIUL2ID2)
itkImageToImageFilterIUL2ID2.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL2ID2_PopBackInput, None, itkImageToImageFilterIUL2ID2)
itkImageToImageFilterIUL2ID2.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL2ID2_PushFrontInput, None, itkImageToImageFilterIUL2ID2)
itkImageToImageFilterIUL2ID2.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL2ID2_PopFrontInput, None, itkImageToImageFilterIUL2ID2)
itkImageToImageFilterIUL2ID2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL2ID2_SetCoordinateTolerance, None, itkImageToImageFilterIUL2ID2)
itkImageToImageFilterIUL2ID2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL2ID2_GetCoordinateTolerance, None, itkImageToImageFilterIUL2ID2)
itkImageToImageFilterIUL2ID2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL2ID2_SetDirectionTolerance, None, itkImageToImageFilterIUL2ID2)
itkImageToImageFilterIUL2ID2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL2ID2_GetDirectionTolerance, None, itkImageToImageFilterIUL2ID2)
itkImageToImageFilterIUL2ID2_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIUL2ID2_swigregister
itkImageToImageFilterIUL2ID2_swigregister(itkImageToImageFilterIUL2ID2)

def itkImageToImageFilterIUL2ID2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUL2ID2 *":
    """itkImageToImageFilterIUL2ID2_cast(itkLightObject obj) -> itkImageToImageFilterIUL2ID2"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2ID2_cast(obj)

class itkImageToImageFilterIUL2IF2(itkImageSourcePython.itkImageSourceIF2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUL2IF2 self, itkImageUL2 image)
        SetInput(itkImageToImageFilterIUL2IF2 self, unsigned int arg0, itkImageUL2 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2IF2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUL2 const *":
        """
        GetInput(itkImageToImageFilterIUL2IF2 self) -> itkImageUL2
        GetInput(itkImageToImageFilterIUL2IF2 self, unsigned int idx) -> itkImageUL2
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2IF2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUL2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUL2IF2 self, itkImageUL2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2IF2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUL2IF2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2IF2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUL2') -> "void":
        """PushFrontInput(itkImageToImageFilterIUL2IF2 self, itkImageUL2 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2IF2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUL2IF2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2IF2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUL2IF2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2IF2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUL2IF2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2IF2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUL2IF2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2IF2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUL2IF2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2IF2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIUL2IF2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUL2IF2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUL2IF2"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2IF2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUL2IF2

        Create a new object of the class itkImageToImageFilterIUL2IF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUL2IF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUL2IF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUL2IF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUL2IF2.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL2IF2_SetInput, None, itkImageToImageFilterIUL2IF2)
itkImageToImageFilterIUL2IF2.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL2IF2_GetInput, None, itkImageToImageFilterIUL2IF2)
itkImageToImageFilterIUL2IF2.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL2IF2_PushBackInput, None, itkImageToImageFilterIUL2IF2)
itkImageToImageFilterIUL2IF2.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL2IF2_PopBackInput, None, itkImageToImageFilterIUL2IF2)
itkImageToImageFilterIUL2IF2.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL2IF2_PushFrontInput, None, itkImageToImageFilterIUL2IF2)
itkImageToImageFilterIUL2IF2.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL2IF2_PopFrontInput, None, itkImageToImageFilterIUL2IF2)
itkImageToImageFilterIUL2IF2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL2IF2_SetCoordinateTolerance, None, itkImageToImageFilterIUL2IF2)
itkImageToImageFilterIUL2IF2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL2IF2_GetCoordinateTolerance, None, itkImageToImageFilterIUL2IF2)
itkImageToImageFilterIUL2IF2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL2IF2_SetDirectionTolerance, None, itkImageToImageFilterIUL2IF2)
itkImageToImageFilterIUL2IF2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL2IF2_GetDirectionTolerance, None, itkImageToImageFilterIUL2IF2)
itkImageToImageFilterIUL2IF2_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIUL2IF2_swigregister
itkImageToImageFilterIUL2IF2_swigregister(itkImageToImageFilterIUL2IF2)

def itkImageToImageFilterIUL2IF2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUL2IF2 *":
    """itkImageToImageFilterIUL2IF2_cast(itkLightObject obj) -> itkImageToImageFilterIUL2IF2"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2IF2_cast(obj)

class itkImageToImageFilterIUL2ISS2(itkImageSourcePython.itkImageSourceISS2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUL2ISS2 self, itkImageUL2 image)
        SetInput(itkImageToImageFilterIUL2ISS2 self, unsigned int arg0, itkImageUL2 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2ISS2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUL2 const *":
        """
        GetInput(itkImageToImageFilterIUL2ISS2 self) -> itkImageUL2
        GetInput(itkImageToImageFilterIUL2ISS2 self, unsigned int idx) -> itkImageUL2
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2ISS2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUL2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUL2ISS2 self, itkImageUL2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2ISS2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUL2ISS2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2ISS2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUL2') -> "void":
        """PushFrontInput(itkImageToImageFilterIUL2ISS2 self, itkImageUL2 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2ISS2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUL2ISS2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2ISS2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUL2ISS2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2ISS2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUL2ISS2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2ISS2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUL2ISS2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2ISS2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUL2ISS2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2ISS2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIUL2ISS2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUL2ISS2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUL2ISS2"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2ISS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUL2ISS2

        Create a new object of the class itkImageToImageFilterIUL2ISS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUL2ISS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUL2ISS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUL2ISS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUL2ISS2.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL2ISS2_SetInput, None, itkImageToImageFilterIUL2ISS2)
itkImageToImageFilterIUL2ISS2.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL2ISS2_GetInput, None, itkImageToImageFilterIUL2ISS2)
itkImageToImageFilterIUL2ISS2.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL2ISS2_PushBackInput, None, itkImageToImageFilterIUL2ISS2)
itkImageToImageFilterIUL2ISS2.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL2ISS2_PopBackInput, None, itkImageToImageFilterIUL2ISS2)
itkImageToImageFilterIUL2ISS2.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL2ISS2_PushFrontInput, None, itkImageToImageFilterIUL2ISS2)
itkImageToImageFilterIUL2ISS2.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL2ISS2_PopFrontInput, None, itkImageToImageFilterIUL2ISS2)
itkImageToImageFilterIUL2ISS2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL2ISS2_SetCoordinateTolerance, None, itkImageToImageFilterIUL2ISS2)
itkImageToImageFilterIUL2ISS2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL2ISS2_GetCoordinateTolerance, None, itkImageToImageFilterIUL2ISS2)
itkImageToImageFilterIUL2ISS2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL2ISS2_SetDirectionTolerance, None, itkImageToImageFilterIUL2ISS2)
itkImageToImageFilterIUL2ISS2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL2ISS2_GetDirectionTolerance, None, itkImageToImageFilterIUL2ISS2)
itkImageToImageFilterIUL2ISS2_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIUL2ISS2_swigregister
itkImageToImageFilterIUL2ISS2_swigregister(itkImageToImageFilterIUL2ISS2)

def itkImageToImageFilterIUL2ISS2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUL2ISS2 *":
    """itkImageToImageFilterIUL2ISS2_cast(itkLightObject obj) -> itkImageToImageFilterIUL2ISS2"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2ISS2_cast(obj)

class itkImageToImageFilterIUL2IUC2(itkImageSourcePython.itkImageSourceIUC2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUL2IUC2 self, itkImageUL2 image)
        SetInput(itkImageToImageFilterIUL2IUC2 self, unsigned int arg0, itkImageUL2 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUC2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUL2 const *":
        """
        GetInput(itkImageToImageFilterIUL2IUC2 self) -> itkImageUL2
        GetInput(itkImageToImageFilterIUL2IUC2 self, unsigned int idx) -> itkImageUL2
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUC2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUL2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUL2IUC2 self, itkImageUL2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUC2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUL2IUC2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUC2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUL2') -> "void":
        """PushFrontInput(itkImageToImageFilterIUL2IUC2 self, itkImageUL2 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUC2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUL2IUC2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUC2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUL2IUC2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUC2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUL2IUC2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUC2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUL2IUC2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUC2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUL2IUC2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUC2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIUL2IUC2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUL2IUC2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUL2IUC2"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUC2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUL2IUC2

        Create a new object of the class itkImageToImageFilterIUL2IUC2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUL2IUC2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUL2IUC2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUL2IUC2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUL2IUC2.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUC2_SetInput, None, itkImageToImageFilterIUL2IUC2)
itkImageToImageFilterIUL2IUC2.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUC2_GetInput, None, itkImageToImageFilterIUL2IUC2)
itkImageToImageFilterIUL2IUC2.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUC2_PushBackInput, None, itkImageToImageFilterIUL2IUC2)
itkImageToImageFilterIUL2IUC2.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUC2_PopBackInput, None, itkImageToImageFilterIUL2IUC2)
itkImageToImageFilterIUL2IUC2.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUC2_PushFrontInput, None, itkImageToImageFilterIUL2IUC2)
itkImageToImageFilterIUL2IUC2.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUC2_PopFrontInput, None, itkImageToImageFilterIUL2IUC2)
itkImageToImageFilterIUL2IUC2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUC2_SetCoordinateTolerance, None, itkImageToImageFilterIUL2IUC2)
itkImageToImageFilterIUL2IUC2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUC2_GetCoordinateTolerance, None, itkImageToImageFilterIUL2IUC2)
itkImageToImageFilterIUL2IUC2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUC2_SetDirectionTolerance, None, itkImageToImageFilterIUL2IUC2)
itkImageToImageFilterIUL2IUC2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUC2_GetDirectionTolerance, None, itkImageToImageFilterIUL2IUC2)
itkImageToImageFilterIUL2IUC2_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUC2_swigregister
itkImageToImageFilterIUL2IUC2_swigregister(itkImageToImageFilterIUL2IUC2)

def itkImageToImageFilterIUL2IUC2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUL2IUC2 *":
    """itkImageToImageFilterIUL2IUC2_cast(itkLightObject obj) -> itkImageToImageFilterIUL2IUC2"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUC2_cast(obj)

class itkImageToImageFilterIUL2IUL2(itkImageSourcePython.itkImageSourceIUL2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUL2IUL2 self, itkImageUL2 image)
        SetInput(itkImageToImageFilterIUL2IUL2 self, unsigned int arg0, itkImageUL2 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUL2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUL2 const *":
        """
        GetInput(itkImageToImageFilterIUL2IUL2 self) -> itkImageUL2
        GetInput(itkImageToImageFilterIUL2IUL2 self, unsigned int idx) -> itkImageUL2
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUL2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUL2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUL2IUL2 self, itkImageUL2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUL2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUL2IUL2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUL2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUL2') -> "void":
        """PushFrontInput(itkImageToImageFilterIUL2IUL2 self, itkImageUL2 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUL2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUL2IUL2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUL2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUL2IUL2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUL2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUL2IUL2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUL2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUL2IUL2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUL2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUL2IUL2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUL2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIUL2IUL2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUL2IUL2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUL2IUL2"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUL2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUL2IUL2

        Create a new object of the class itkImageToImageFilterIUL2IUL2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUL2IUL2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUL2IUL2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUL2IUL2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUL2IUL2.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUL2_SetInput, None, itkImageToImageFilterIUL2IUL2)
itkImageToImageFilterIUL2IUL2.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUL2_GetInput, None, itkImageToImageFilterIUL2IUL2)
itkImageToImageFilterIUL2IUL2.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUL2_PushBackInput, None, itkImageToImageFilterIUL2IUL2)
itkImageToImageFilterIUL2IUL2.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUL2_PopBackInput, None, itkImageToImageFilterIUL2IUL2)
itkImageToImageFilterIUL2IUL2.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUL2_PushFrontInput, None, itkImageToImageFilterIUL2IUL2)
itkImageToImageFilterIUL2IUL2.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUL2_PopFrontInput, None, itkImageToImageFilterIUL2IUL2)
itkImageToImageFilterIUL2IUL2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUL2_SetCoordinateTolerance, None, itkImageToImageFilterIUL2IUL2)
itkImageToImageFilterIUL2IUL2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUL2_GetCoordinateTolerance, None, itkImageToImageFilterIUL2IUL2)
itkImageToImageFilterIUL2IUL2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUL2_SetDirectionTolerance, None, itkImageToImageFilterIUL2IUL2)
itkImageToImageFilterIUL2IUL2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUL2_GetDirectionTolerance, None, itkImageToImageFilterIUL2IUL2)
itkImageToImageFilterIUL2IUL2_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUL2_swigregister
itkImageToImageFilterIUL2IUL2_swigregister(itkImageToImageFilterIUL2IUL2)

def itkImageToImageFilterIUL2IUL2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUL2IUL2 *":
    """itkImageToImageFilterIUL2IUL2_cast(itkLightObject obj) -> itkImageToImageFilterIUL2IUL2"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUL2_cast(obj)

class itkImageToImageFilterIUL2IUS2(itkImageSourcePython.itkImageSourceIUS2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUL2IUS2 self, itkImageUL2 image)
        SetInput(itkImageToImageFilterIUL2IUS2 self, unsigned int arg0, itkImageUL2 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUS2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUL2 const *":
        """
        GetInput(itkImageToImageFilterIUL2IUS2 self) -> itkImageUL2
        GetInput(itkImageToImageFilterIUL2IUS2 self, unsigned int idx) -> itkImageUL2
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUS2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUL2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUL2IUS2 self, itkImageUL2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUS2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUL2IUS2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUS2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUL2') -> "void":
        """PushFrontInput(itkImageToImageFilterIUL2IUS2 self, itkImageUL2 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUS2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUL2IUS2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUS2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUL2IUS2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUS2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUL2IUS2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUS2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUL2IUS2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUS2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUL2IUS2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUS2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIUL2IUS2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUL2IUS2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUL2IUS2"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUL2IUS2

        Create a new object of the class itkImageToImageFilterIUL2IUS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUL2IUS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUL2IUS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUL2IUS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUL2IUS2.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUS2_SetInput, None, itkImageToImageFilterIUL2IUS2)
itkImageToImageFilterIUL2IUS2.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUS2_GetInput, None, itkImageToImageFilterIUL2IUS2)
itkImageToImageFilterIUL2IUS2.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUS2_PushBackInput, None, itkImageToImageFilterIUL2IUS2)
itkImageToImageFilterIUL2IUS2.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUS2_PopBackInput, None, itkImageToImageFilterIUL2IUS2)
itkImageToImageFilterIUL2IUS2.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUS2_PushFrontInput, None, itkImageToImageFilterIUL2IUS2)
itkImageToImageFilterIUL2IUS2.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUS2_PopFrontInput, None, itkImageToImageFilterIUL2IUS2)
itkImageToImageFilterIUL2IUS2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUS2_SetCoordinateTolerance, None, itkImageToImageFilterIUL2IUS2)
itkImageToImageFilterIUL2IUS2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUS2_GetCoordinateTolerance, None, itkImageToImageFilterIUL2IUS2)
itkImageToImageFilterIUL2IUS2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUS2_SetDirectionTolerance, None, itkImageToImageFilterIUL2IUS2)
itkImageToImageFilterIUL2IUS2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUS2_GetDirectionTolerance, None, itkImageToImageFilterIUL2IUS2)
itkImageToImageFilterIUL2IUS2_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUS2_swigregister
itkImageToImageFilterIUL2IUS2_swigregister(itkImageToImageFilterIUL2IUS2)

def itkImageToImageFilterIUL2IUS2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUL2IUS2 *":
    """itkImageToImageFilterIUL2IUS2_cast(itkLightObject obj) -> itkImageToImageFilterIUL2IUS2"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIUL2IUS2_cast(obj)

class itkImageToImageFilterIUL3ID3(itkImageSourcePython.itkImageSourceID3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUL3ID3 self, itkImageUL3 image)
        SetInput(itkImageToImageFilterIUL3ID3 self, unsigned int arg0, itkImageUL3 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3ID3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUL3 const *":
        """
        GetInput(itkImageToImageFilterIUL3ID3 self) -> itkImageUL3
        GetInput(itkImageToImageFilterIUL3ID3 self, unsigned int idx) -> itkImageUL3
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3ID3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUL3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUL3ID3 self, itkImageUL3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3ID3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUL3ID3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3ID3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUL3') -> "void":
        """PushFrontInput(itkImageToImageFilterIUL3ID3 self, itkImageUL3 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3ID3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUL3ID3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3ID3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUL3ID3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3ID3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUL3ID3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3ID3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUL3ID3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3ID3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUL3ID3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3ID3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIUL3ID3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUL3ID3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUL3ID3"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3ID3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUL3ID3

        Create a new object of the class itkImageToImageFilterIUL3ID3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUL3ID3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUL3ID3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUL3ID3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUL3ID3.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL3ID3_SetInput, None, itkImageToImageFilterIUL3ID3)
itkImageToImageFilterIUL3ID3.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL3ID3_GetInput, None, itkImageToImageFilterIUL3ID3)
itkImageToImageFilterIUL3ID3.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL3ID3_PushBackInput, None, itkImageToImageFilterIUL3ID3)
itkImageToImageFilterIUL3ID3.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL3ID3_PopBackInput, None, itkImageToImageFilterIUL3ID3)
itkImageToImageFilterIUL3ID3.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL3ID3_PushFrontInput, None, itkImageToImageFilterIUL3ID3)
itkImageToImageFilterIUL3ID3.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL3ID3_PopFrontInput, None, itkImageToImageFilterIUL3ID3)
itkImageToImageFilterIUL3ID3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL3ID3_SetCoordinateTolerance, None, itkImageToImageFilterIUL3ID3)
itkImageToImageFilterIUL3ID3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL3ID3_GetCoordinateTolerance, None, itkImageToImageFilterIUL3ID3)
itkImageToImageFilterIUL3ID3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL3ID3_SetDirectionTolerance, None, itkImageToImageFilterIUL3ID3)
itkImageToImageFilterIUL3ID3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL3ID3_GetDirectionTolerance, None, itkImageToImageFilterIUL3ID3)
itkImageToImageFilterIUL3ID3_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIUL3ID3_swigregister
itkImageToImageFilterIUL3ID3_swigregister(itkImageToImageFilterIUL3ID3)

def itkImageToImageFilterIUL3ID3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUL3ID3 *":
    """itkImageToImageFilterIUL3ID3_cast(itkLightObject obj) -> itkImageToImageFilterIUL3ID3"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3ID3_cast(obj)

class itkImageToImageFilterIUL3IF3(itkImageSourcePython.itkImageSourceIF3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUL3IF3 self, itkImageUL3 image)
        SetInput(itkImageToImageFilterIUL3IF3 self, unsigned int arg0, itkImageUL3 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3IF3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUL3 const *":
        """
        GetInput(itkImageToImageFilterIUL3IF3 self) -> itkImageUL3
        GetInput(itkImageToImageFilterIUL3IF3 self, unsigned int idx) -> itkImageUL3
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3IF3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUL3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUL3IF3 self, itkImageUL3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3IF3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUL3IF3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3IF3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUL3') -> "void":
        """PushFrontInput(itkImageToImageFilterIUL3IF3 self, itkImageUL3 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3IF3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUL3IF3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3IF3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUL3IF3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3IF3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUL3IF3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3IF3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUL3IF3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3IF3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUL3IF3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3IF3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIUL3IF3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUL3IF3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUL3IF3"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3IF3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUL3IF3

        Create a new object of the class itkImageToImageFilterIUL3IF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUL3IF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUL3IF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUL3IF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUL3IF3.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL3IF3_SetInput, None, itkImageToImageFilterIUL3IF3)
itkImageToImageFilterIUL3IF3.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL3IF3_GetInput, None, itkImageToImageFilterIUL3IF3)
itkImageToImageFilterIUL3IF3.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL3IF3_PushBackInput, None, itkImageToImageFilterIUL3IF3)
itkImageToImageFilterIUL3IF3.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL3IF3_PopBackInput, None, itkImageToImageFilterIUL3IF3)
itkImageToImageFilterIUL3IF3.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL3IF3_PushFrontInput, None, itkImageToImageFilterIUL3IF3)
itkImageToImageFilterIUL3IF3.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL3IF3_PopFrontInput, None, itkImageToImageFilterIUL3IF3)
itkImageToImageFilterIUL3IF3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL3IF3_SetCoordinateTolerance, None, itkImageToImageFilterIUL3IF3)
itkImageToImageFilterIUL3IF3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL3IF3_GetCoordinateTolerance, None, itkImageToImageFilterIUL3IF3)
itkImageToImageFilterIUL3IF3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL3IF3_SetDirectionTolerance, None, itkImageToImageFilterIUL3IF3)
itkImageToImageFilterIUL3IF3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL3IF3_GetDirectionTolerance, None, itkImageToImageFilterIUL3IF3)
itkImageToImageFilterIUL3IF3_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIUL3IF3_swigregister
itkImageToImageFilterIUL3IF3_swigregister(itkImageToImageFilterIUL3IF3)

def itkImageToImageFilterIUL3IF3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUL3IF3 *":
    """itkImageToImageFilterIUL3IF3_cast(itkLightObject obj) -> itkImageToImageFilterIUL3IF3"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3IF3_cast(obj)

class itkImageToImageFilterIUL3ISS3(itkImageSourcePython.itkImageSourceISS3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUL3ISS3 self, itkImageUL3 image)
        SetInput(itkImageToImageFilterIUL3ISS3 self, unsigned int arg0, itkImageUL3 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3ISS3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUL3 const *":
        """
        GetInput(itkImageToImageFilterIUL3ISS3 self) -> itkImageUL3
        GetInput(itkImageToImageFilterIUL3ISS3 self, unsigned int idx) -> itkImageUL3
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3ISS3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUL3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUL3ISS3 self, itkImageUL3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3ISS3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUL3ISS3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3ISS3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUL3') -> "void":
        """PushFrontInput(itkImageToImageFilterIUL3ISS3 self, itkImageUL3 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3ISS3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUL3ISS3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3ISS3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUL3ISS3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3ISS3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUL3ISS3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3ISS3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUL3ISS3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3ISS3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUL3ISS3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3ISS3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIUL3ISS3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUL3ISS3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUL3ISS3"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3ISS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUL3ISS3

        Create a new object of the class itkImageToImageFilterIUL3ISS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUL3ISS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUL3ISS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUL3ISS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUL3ISS3.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL3ISS3_SetInput, None, itkImageToImageFilterIUL3ISS3)
itkImageToImageFilterIUL3ISS3.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL3ISS3_GetInput, None, itkImageToImageFilterIUL3ISS3)
itkImageToImageFilterIUL3ISS3.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL3ISS3_PushBackInput, None, itkImageToImageFilterIUL3ISS3)
itkImageToImageFilterIUL3ISS3.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL3ISS3_PopBackInput, None, itkImageToImageFilterIUL3ISS3)
itkImageToImageFilterIUL3ISS3.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL3ISS3_PushFrontInput, None, itkImageToImageFilterIUL3ISS3)
itkImageToImageFilterIUL3ISS3.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL3ISS3_PopFrontInput, None, itkImageToImageFilterIUL3ISS3)
itkImageToImageFilterIUL3ISS3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL3ISS3_SetCoordinateTolerance, None, itkImageToImageFilterIUL3ISS3)
itkImageToImageFilterIUL3ISS3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL3ISS3_GetCoordinateTolerance, None, itkImageToImageFilterIUL3ISS3)
itkImageToImageFilterIUL3ISS3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL3ISS3_SetDirectionTolerance, None, itkImageToImageFilterIUL3ISS3)
itkImageToImageFilterIUL3ISS3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL3ISS3_GetDirectionTolerance, None, itkImageToImageFilterIUL3ISS3)
itkImageToImageFilterIUL3ISS3_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIUL3ISS3_swigregister
itkImageToImageFilterIUL3ISS3_swigregister(itkImageToImageFilterIUL3ISS3)

def itkImageToImageFilterIUL3ISS3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUL3ISS3 *":
    """itkImageToImageFilterIUL3ISS3_cast(itkLightObject obj) -> itkImageToImageFilterIUL3ISS3"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3ISS3_cast(obj)

class itkImageToImageFilterIUL3IUC3(itkImageSourcePython.itkImageSourceIUC3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUL3IUC3 self, itkImageUL3 image)
        SetInput(itkImageToImageFilterIUL3IUC3 self, unsigned int arg0, itkImageUL3 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUC3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUL3 const *":
        """
        GetInput(itkImageToImageFilterIUL3IUC3 self) -> itkImageUL3
        GetInput(itkImageToImageFilterIUL3IUC3 self, unsigned int idx) -> itkImageUL3
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUC3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUL3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUL3IUC3 self, itkImageUL3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUC3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUL3IUC3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUC3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUL3') -> "void":
        """PushFrontInput(itkImageToImageFilterIUL3IUC3 self, itkImageUL3 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUC3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUL3IUC3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUC3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUL3IUC3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUC3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUL3IUC3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUC3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUL3IUC3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUC3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUL3IUC3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUC3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIUL3IUC3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUL3IUC3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUL3IUC3"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUC3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUL3IUC3

        Create a new object of the class itkImageToImageFilterIUL3IUC3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUL3IUC3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUL3IUC3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUL3IUC3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUL3IUC3.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUC3_SetInput, None, itkImageToImageFilterIUL3IUC3)
itkImageToImageFilterIUL3IUC3.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUC3_GetInput, None, itkImageToImageFilterIUL3IUC3)
itkImageToImageFilterIUL3IUC3.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUC3_PushBackInput, None, itkImageToImageFilterIUL3IUC3)
itkImageToImageFilterIUL3IUC3.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUC3_PopBackInput, None, itkImageToImageFilterIUL3IUC3)
itkImageToImageFilterIUL3IUC3.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUC3_PushFrontInput, None, itkImageToImageFilterIUL3IUC3)
itkImageToImageFilterIUL3IUC3.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUC3_PopFrontInput, None, itkImageToImageFilterIUL3IUC3)
itkImageToImageFilterIUL3IUC3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUC3_SetCoordinateTolerance, None, itkImageToImageFilterIUL3IUC3)
itkImageToImageFilterIUL3IUC3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUC3_GetCoordinateTolerance, None, itkImageToImageFilterIUL3IUC3)
itkImageToImageFilterIUL3IUC3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUC3_SetDirectionTolerance, None, itkImageToImageFilterIUL3IUC3)
itkImageToImageFilterIUL3IUC3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUC3_GetDirectionTolerance, None, itkImageToImageFilterIUL3IUC3)
itkImageToImageFilterIUL3IUC3_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUC3_swigregister
itkImageToImageFilterIUL3IUC3_swigregister(itkImageToImageFilterIUL3IUC3)

def itkImageToImageFilterIUL3IUC3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUL3IUC3 *":
    """itkImageToImageFilterIUL3IUC3_cast(itkLightObject obj) -> itkImageToImageFilterIUL3IUC3"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUC3_cast(obj)

class itkImageToImageFilterIUL3IUL3(itkImageSourcePython.itkImageSourceIUL3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUL3IUL3 self, itkImageUL3 image)
        SetInput(itkImageToImageFilterIUL3IUL3 self, unsigned int arg0, itkImageUL3 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUL3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUL3 const *":
        """
        GetInput(itkImageToImageFilterIUL3IUL3 self) -> itkImageUL3
        GetInput(itkImageToImageFilterIUL3IUL3 self, unsigned int idx) -> itkImageUL3
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUL3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUL3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUL3IUL3 self, itkImageUL3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUL3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUL3IUL3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUL3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUL3') -> "void":
        """PushFrontInput(itkImageToImageFilterIUL3IUL3 self, itkImageUL3 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUL3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUL3IUL3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUL3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUL3IUL3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUL3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUL3IUL3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUL3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUL3IUL3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUL3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUL3IUL3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUL3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIUL3IUL3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUL3IUL3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUL3IUL3"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUL3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUL3IUL3

        Create a new object of the class itkImageToImageFilterIUL3IUL3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUL3IUL3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUL3IUL3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUL3IUL3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUL3IUL3.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUL3_SetInput, None, itkImageToImageFilterIUL3IUL3)
itkImageToImageFilterIUL3IUL3.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUL3_GetInput, None, itkImageToImageFilterIUL3IUL3)
itkImageToImageFilterIUL3IUL3.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUL3_PushBackInput, None, itkImageToImageFilterIUL3IUL3)
itkImageToImageFilterIUL3IUL3.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUL3_PopBackInput, None, itkImageToImageFilterIUL3IUL3)
itkImageToImageFilterIUL3IUL3.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUL3_PushFrontInput, None, itkImageToImageFilterIUL3IUL3)
itkImageToImageFilterIUL3IUL3.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUL3_PopFrontInput, None, itkImageToImageFilterIUL3IUL3)
itkImageToImageFilterIUL3IUL3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUL3_SetCoordinateTolerance, None, itkImageToImageFilterIUL3IUL3)
itkImageToImageFilterIUL3IUL3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUL3_GetCoordinateTolerance, None, itkImageToImageFilterIUL3IUL3)
itkImageToImageFilterIUL3IUL3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUL3_SetDirectionTolerance, None, itkImageToImageFilterIUL3IUL3)
itkImageToImageFilterIUL3IUL3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUL3_GetDirectionTolerance, None, itkImageToImageFilterIUL3IUL3)
itkImageToImageFilterIUL3IUL3_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUL3_swigregister
itkImageToImageFilterIUL3IUL3_swigregister(itkImageToImageFilterIUL3IUL3)

def itkImageToImageFilterIUL3IUL3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUL3IUL3 *":
    """itkImageToImageFilterIUL3IUL3_cast(itkLightObject obj) -> itkImageToImageFilterIUL3IUL3"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUL3_cast(obj)

class itkImageToImageFilterIUL3IUS3(itkImageSourcePython.itkImageSourceIUS3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUL3IUS3 self, itkImageUL3 image)
        SetInput(itkImageToImageFilterIUL3IUS3 self, unsigned int arg0, itkImageUL3 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUS3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUL3 const *":
        """
        GetInput(itkImageToImageFilterIUL3IUS3 self) -> itkImageUL3
        GetInput(itkImageToImageFilterIUL3IUS3 self, unsigned int idx) -> itkImageUL3
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUS3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUL3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUL3IUS3 self, itkImageUL3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUS3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUL3IUS3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUS3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUL3') -> "void":
        """PushFrontInput(itkImageToImageFilterIUL3IUS3 self, itkImageUL3 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUS3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUL3IUS3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUS3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUL3IUS3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUS3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUL3IUS3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUS3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUL3IUS3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUS3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUL3IUS3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUS3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIUL3IUS3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUL3IUS3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUL3IUS3"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUL3IUS3

        Create a new object of the class itkImageToImageFilterIUL3IUS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUL3IUS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUL3IUS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUL3IUS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUL3IUS3.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUS3_SetInput, None, itkImageToImageFilterIUL3IUS3)
itkImageToImageFilterIUL3IUS3.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUS3_GetInput, None, itkImageToImageFilterIUL3IUS3)
itkImageToImageFilterIUL3IUS3.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUS3_PushBackInput, None, itkImageToImageFilterIUL3IUS3)
itkImageToImageFilterIUL3IUS3.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUS3_PopBackInput, None, itkImageToImageFilterIUL3IUS3)
itkImageToImageFilterIUL3IUS3.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUS3_PushFrontInput, None, itkImageToImageFilterIUL3IUS3)
itkImageToImageFilterIUL3IUS3.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUS3_PopFrontInput, None, itkImageToImageFilterIUL3IUS3)
itkImageToImageFilterIUL3IUS3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUS3_SetCoordinateTolerance, None, itkImageToImageFilterIUL3IUS3)
itkImageToImageFilterIUL3IUS3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUS3_GetCoordinateTolerance, None, itkImageToImageFilterIUL3IUS3)
itkImageToImageFilterIUL3IUS3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUS3_SetDirectionTolerance, None, itkImageToImageFilterIUL3IUS3)
itkImageToImageFilterIUL3IUS3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUS3_GetDirectionTolerance, None, itkImageToImageFilterIUL3IUS3)
itkImageToImageFilterIUL3IUS3_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUS3_swigregister
itkImageToImageFilterIUL3IUS3_swigregister(itkImageToImageFilterIUL3IUS3)

def itkImageToImageFilterIUL3IUS3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUL3IUS3 *":
    """itkImageToImageFilterIUL3IUS3_cast(itkLightObject obj) -> itkImageToImageFilterIUL3IUS3"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIUL3IUS3_cast(obj)

class itkImageToImageFilterIULL2ID2(itkImageSourcePython.itkImageSourceID2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIULL2ID2 self, itkImageULL2 image)
        SetInput(itkImageToImageFilterIULL2ID2 self, unsigned int arg0, itkImageULL2 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2ID2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageULL2 const *":
        """
        GetInput(itkImageToImageFilterIULL2ID2 self) -> itkImageULL2
        GetInput(itkImageToImageFilterIULL2ID2 self, unsigned int idx) -> itkImageULL2
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2ID2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageULL2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIULL2ID2 self, itkImageULL2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2ID2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIULL2ID2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2ID2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageULL2') -> "void":
        """PushFrontInput(itkImageToImageFilterIULL2ID2 self, itkImageULL2 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2ID2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIULL2ID2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2ID2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIULL2ID2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2ID2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIULL2ID2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2ID2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIULL2ID2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2ID2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIULL2ID2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2ID2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIULL2ID2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIULL2ID2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIULL2ID2"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2ID2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIULL2ID2

        Create a new object of the class itkImageToImageFilterIULL2ID2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIULL2ID2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIULL2ID2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIULL2ID2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIULL2ID2.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL2ID2_SetInput, None, itkImageToImageFilterIULL2ID2)
itkImageToImageFilterIULL2ID2.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL2ID2_GetInput, None, itkImageToImageFilterIULL2ID2)
itkImageToImageFilterIULL2ID2.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL2ID2_PushBackInput, None, itkImageToImageFilterIULL2ID2)
itkImageToImageFilterIULL2ID2.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL2ID2_PopBackInput, None, itkImageToImageFilterIULL2ID2)
itkImageToImageFilterIULL2ID2.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL2ID2_PushFrontInput, None, itkImageToImageFilterIULL2ID2)
itkImageToImageFilterIULL2ID2.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL2ID2_PopFrontInput, None, itkImageToImageFilterIULL2ID2)
itkImageToImageFilterIULL2ID2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL2ID2_SetCoordinateTolerance, None, itkImageToImageFilterIULL2ID2)
itkImageToImageFilterIULL2ID2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL2ID2_GetCoordinateTolerance, None, itkImageToImageFilterIULL2ID2)
itkImageToImageFilterIULL2ID2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL2ID2_SetDirectionTolerance, None, itkImageToImageFilterIULL2ID2)
itkImageToImageFilterIULL2ID2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL2ID2_GetDirectionTolerance, None, itkImageToImageFilterIULL2ID2)
itkImageToImageFilterIULL2ID2_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIULL2ID2_swigregister
itkImageToImageFilterIULL2ID2_swigregister(itkImageToImageFilterIULL2ID2)

def itkImageToImageFilterIULL2ID2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIULL2ID2 *":
    """itkImageToImageFilterIULL2ID2_cast(itkLightObject obj) -> itkImageToImageFilterIULL2ID2"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2ID2_cast(obj)

class itkImageToImageFilterIULL2IF2(itkImageSourcePython.itkImageSourceIF2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIULL2IF2 self, itkImageULL2 image)
        SetInput(itkImageToImageFilterIULL2IF2 self, unsigned int arg0, itkImageULL2 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2IF2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageULL2 const *":
        """
        GetInput(itkImageToImageFilterIULL2IF2 self) -> itkImageULL2
        GetInput(itkImageToImageFilterIULL2IF2 self, unsigned int idx) -> itkImageULL2
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2IF2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageULL2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIULL2IF2 self, itkImageULL2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2IF2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIULL2IF2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2IF2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageULL2') -> "void":
        """PushFrontInput(itkImageToImageFilterIULL2IF2 self, itkImageULL2 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2IF2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIULL2IF2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2IF2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIULL2IF2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2IF2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIULL2IF2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2IF2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIULL2IF2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2IF2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIULL2IF2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2IF2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIULL2IF2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIULL2IF2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIULL2IF2"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2IF2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIULL2IF2

        Create a new object of the class itkImageToImageFilterIULL2IF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIULL2IF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIULL2IF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIULL2IF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIULL2IF2.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL2IF2_SetInput, None, itkImageToImageFilterIULL2IF2)
itkImageToImageFilterIULL2IF2.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL2IF2_GetInput, None, itkImageToImageFilterIULL2IF2)
itkImageToImageFilterIULL2IF2.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL2IF2_PushBackInput, None, itkImageToImageFilterIULL2IF2)
itkImageToImageFilterIULL2IF2.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL2IF2_PopBackInput, None, itkImageToImageFilterIULL2IF2)
itkImageToImageFilterIULL2IF2.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL2IF2_PushFrontInput, None, itkImageToImageFilterIULL2IF2)
itkImageToImageFilterIULL2IF2.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL2IF2_PopFrontInput, None, itkImageToImageFilterIULL2IF2)
itkImageToImageFilterIULL2IF2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL2IF2_SetCoordinateTolerance, None, itkImageToImageFilterIULL2IF2)
itkImageToImageFilterIULL2IF2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL2IF2_GetCoordinateTolerance, None, itkImageToImageFilterIULL2IF2)
itkImageToImageFilterIULL2IF2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL2IF2_SetDirectionTolerance, None, itkImageToImageFilterIULL2IF2)
itkImageToImageFilterIULL2IF2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL2IF2_GetDirectionTolerance, None, itkImageToImageFilterIULL2IF2)
itkImageToImageFilterIULL2IF2_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIULL2IF2_swigregister
itkImageToImageFilterIULL2IF2_swigregister(itkImageToImageFilterIULL2IF2)

def itkImageToImageFilterIULL2IF2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIULL2IF2 *":
    """itkImageToImageFilterIULL2IF2_cast(itkLightObject obj) -> itkImageToImageFilterIULL2IF2"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2IF2_cast(obj)

class itkImageToImageFilterIULL2ISS2(itkImageSourcePython.itkImageSourceISS2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIULL2ISS2 self, itkImageULL2 image)
        SetInput(itkImageToImageFilterIULL2ISS2 self, unsigned int arg0, itkImageULL2 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2ISS2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageULL2 const *":
        """
        GetInput(itkImageToImageFilterIULL2ISS2 self) -> itkImageULL2
        GetInput(itkImageToImageFilterIULL2ISS2 self, unsigned int idx) -> itkImageULL2
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2ISS2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageULL2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIULL2ISS2 self, itkImageULL2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2ISS2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIULL2ISS2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2ISS2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageULL2') -> "void":
        """PushFrontInput(itkImageToImageFilterIULL2ISS2 self, itkImageULL2 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2ISS2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIULL2ISS2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2ISS2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIULL2ISS2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2ISS2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIULL2ISS2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2ISS2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIULL2ISS2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2ISS2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIULL2ISS2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2ISS2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIULL2ISS2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIULL2ISS2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIULL2ISS2"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2ISS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIULL2ISS2

        Create a new object of the class itkImageToImageFilterIULL2ISS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIULL2ISS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIULL2ISS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIULL2ISS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIULL2ISS2.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL2ISS2_SetInput, None, itkImageToImageFilterIULL2ISS2)
itkImageToImageFilterIULL2ISS2.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL2ISS2_GetInput, None, itkImageToImageFilterIULL2ISS2)
itkImageToImageFilterIULL2ISS2.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL2ISS2_PushBackInput, None, itkImageToImageFilterIULL2ISS2)
itkImageToImageFilterIULL2ISS2.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL2ISS2_PopBackInput, None, itkImageToImageFilterIULL2ISS2)
itkImageToImageFilterIULL2ISS2.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL2ISS2_PushFrontInput, None, itkImageToImageFilterIULL2ISS2)
itkImageToImageFilterIULL2ISS2.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL2ISS2_PopFrontInput, None, itkImageToImageFilterIULL2ISS2)
itkImageToImageFilterIULL2ISS2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL2ISS2_SetCoordinateTolerance, None, itkImageToImageFilterIULL2ISS2)
itkImageToImageFilterIULL2ISS2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL2ISS2_GetCoordinateTolerance, None, itkImageToImageFilterIULL2ISS2)
itkImageToImageFilterIULL2ISS2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL2ISS2_SetDirectionTolerance, None, itkImageToImageFilterIULL2ISS2)
itkImageToImageFilterIULL2ISS2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL2ISS2_GetDirectionTolerance, None, itkImageToImageFilterIULL2ISS2)
itkImageToImageFilterIULL2ISS2_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIULL2ISS2_swigregister
itkImageToImageFilterIULL2ISS2_swigregister(itkImageToImageFilterIULL2ISS2)

def itkImageToImageFilterIULL2ISS2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIULL2ISS2 *":
    """itkImageToImageFilterIULL2ISS2_cast(itkLightObject obj) -> itkImageToImageFilterIULL2ISS2"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2ISS2_cast(obj)

class itkImageToImageFilterIULL2IUC2(itkImageSourcePython.itkImageSourceIUC2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIULL2IUC2 self, itkImageULL2 image)
        SetInput(itkImageToImageFilterIULL2IUC2 self, unsigned int arg0, itkImageULL2 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUC2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageULL2 const *":
        """
        GetInput(itkImageToImageFilterIULL2IUC2 self) -> itkImageULL2
        GetInput(itkImageToImageFilterIULL2IUC2 self, unsigned int idx) -> itkImageULL2
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUC2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageULL2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIULL2IUC2 self, itkImageULL2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUC2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIULL2IUC2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUC2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageULL2') -> "void":
        """PushFrontInput(itkImageToImageFilterIULL2IUC2 self, itkImageULL2 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUC2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIULL2IUC2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUC2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIULL2IUC2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUC2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIULL2IUC2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUC2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIULL2IUC2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUC2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIULL2IUC2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUC2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIULL2IUC2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIULL2IUC2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIULL2IUC2"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUC2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIULL2IUC2

        Create a new object of the class itkImageToImageFilterIULL2IUC2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIULL2IUC2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIULL2IUC2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIULL2IUC2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIULL2IUC2.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUC2_SetInput, None, itkImageToImageFilterIULL2IUC2)
itkImageToImageFilterIULL2IUC2.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUC2_GetInput, None, itkImageToImageFilterIULL2IUC2)
itkImageToImageFilterIULL2IUC2.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUC2_PushBackInput, None, itkImageToImageFilterIULL2IUC2)
itkImageToImageFilterIULL2IUC2.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUC2_PopBackInput, None, itkImageToImageFilterIULL2IUC2)
itkImageToImageFilterIULL2IUC2.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUC2_PushFrontInput, None, itkImageToImageFilterIULL2IUC2)
itkImageToImageFilterIULL2IUC2.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUC2_PopFrontInput, None, itkImageToImageFilterIULL2IUC2)
itkImageToImageFilterIULL2IUC2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUC2_SetCoordinateTolerance, None, itkImageToImageFilterIULL2IUC2)
itkImageToImageFilterIULL2IUC2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUC2_GetCoordinateTolerance, None, itkImageToImageFilterIULL2IUC2)
itkImageToImageFilterIULL2IUC2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUC2_SetDirectionTolerance, None, itkImageToImageFilterIULL2IUC2)
itkImageToImageFilterIULL2IUC2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUC2_GetDirectionTolerance, None, itkImageToImageFilterIULL2IUC2)
itkImageToImageFilterIULL2IUC2_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUC2_swigregister
itkImageToImageFilterIULL2IUC2_swigregister(itkImageToImageFilterIULL2IUC2)

def itkImageToImageFilterIULL2IUC2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIULL2IUC2 *":
    """itkImageToImageFilterIULL2IUC2_cast(itkLightObject obj) -> itkImageToImageFilterIULL2IUC2"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUC2_cast(obj)

class itkImageToImageFilterIULL2IUL2(itkImageSourcePython.itkImageSourceIUL2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIULL2IUL2 self, itkImageULL2 image)
        SetInput(itkImageToImageFilterIULL2IUL2 self, unsigned int arg0, itkImageULL2 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUL2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageULL2 const *":
        """
        GetInput(itkImageToImageFilterIULL2IUL2 self) -> itkImageULL2
        GetInput(itkImageToImageFilterIULL2IUL2 self, unsigned int idx) -> itkImageULL2
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUL2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageULL2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIULL2IUL2 self, itkImageULL2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUL2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIULL2IUL2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUL2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageULL2') -> "void":
        """PushFrontInput(itkImageToImageFilterIULL2IUL2 self, itkImageULL2 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUL2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIULL2IUL2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUL2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIULL2IUL2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUL2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIULL2IUL2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUL2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIULL2IUL2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUL2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIULL2IUL2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUL2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIULL2IUL2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIULL2IUL2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIULL2IUL2"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUL2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIULL2IUL2

        Create a new object of the class itkImageToImageFilterIULL2IUL2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIULL2IUL2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIULL2IUL2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIULL2IUL2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIULL2IUL2.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUL2_SetInput, None, itkImageToImageFilterIULL2IUL2)
itkImageToImageFilterIULL2IUL2.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUL2_GetInput, None, itkImageToImageFilterIULL2IUL2)
itkImageToImageFilterIULL2IUL2.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUL2_PushBackInput, None, itkImageToImageFilterIULL2IUL2)
itkImageToImageFilterIULL2IUL2.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUL2_PopBackInput, None, itkImageToImageFilterIULL2IUL2)
itkImageToImageFilterIULL2IUL2.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUL2_PushFrontInput, None, itkImageToImageFilterIULL2IUL2)
itkImageToImageFilterIULL2IUL2.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUL2_PopFrontInput, None, itkImageToImageFilterIULL2IUL2)
itkImageToImageFilterIULL2IUL2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUL2_SetCoordinateTolerance, None, itkImageToImageFilterIULL2IUL2)
itkImageToImageFilterIULL2IUL2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUL2_GetCoordinateTolerance, None, itkImageToImageFilterIULL2IUL2)
itkImageToImageFilterIULL2IUL2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUL2_SetDirectionTolerance, None, itkImageToImageFilterIULL2IUL2)
itkImageToImageFilterIULL2IUL2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUL2_GetDirectionTolerance, None, itkImageToImageFilterIULL2IUL2)
itkImageToImageFilterIULL2IUL2_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUL2_swigregister
itkImageToImageFilterIULL2IUL2_swigregister(itkImageToImageFilterIULL2IUL2)

def itkImageToImageFilterIULL2IUL2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIULL2IUL2 *":
    """itkImageToImageFilterIULL2IUL2_cast(itkLightObject obj) -> itkImageToImageFilterIULL2IUL2"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUL2_cast(obj)

class itkImageToImageFilterIULL2IUS2(itkImageSourcePython.itkImageSourceIUS2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIULL2IUS2 self, itkImageULL2 image)
        SetInput(itkImageToImageFilterIULL2IUS2 self, unsigned int arg0, itkImageULL2 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUS2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageULL2 const *":
        """
        GetInput(itkImageToImageFilterIULL2IUS2 self) -> itkImageULL2
        GetInput(itkImageToImageFilterIULL2IUS2 self, unsigned int idx) -> itkImageULL2
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUS2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageULL2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIULL2IUS2 self, itkImageULL2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUS2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIULL2IUS2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUS2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageULL2') -> "void":
        """PushFrontInput(itkImageToImageFilterIULL2IUS2 self, itkImageULL2 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUS2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIULL2IUS2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUS2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIULL2IUS2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUS2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIULL2IUS2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUS2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIULL2IUS2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUS2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIULL2IUS2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUS2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIULL2IUS2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIULL2IUS2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIULL2IUS2"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIULL2IUS2

        Create a new object of the class itkImageToImageFilterIULL2IUS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIULL2IUS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIULL2IUS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIULL2IUS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIULL2IUS2.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUS2_SetInput, None, itkImageToImageFilterIULL2IUS2)
itkImageToImageFilterIULL2IUS2.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUS2_GetInput, None, itkImageToImageFilterIULL2IUS2)
itkImageToImageFilterIULL2IUS2.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUS2_PushBackInput, None, itkImageToImageFilterIULL2IUS2)
itkImageToImageFilterIULL2IUS2.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUS2_PopBackInput, None, itkImageToImageFilterIULL2IUS2)
itkImageToImageFilterIULL2IUS2.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUS2_PushFrontInput, None, itkImageToImageFilterIULL2IUS2)
itkImageToImageFilterIULL2IUS2.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUS2_PopFrontInput, None, itkImageToImageFilterIULL2IUS2)
itkImageToImageFilterIULL2IUS2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUS2_SetCoordinateTolerance, None, itkImageToImageFilterIULL2IUS2)
itkImageToImageFilterIULL2IUS2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUS2_GetCoordinateTolerance, None, itkImageToImageFilterIULL2IUS2)
itkImageToImageFilterIULL2IUS2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUS2_SetDirectionTolerance, None, itkImageToImageFilterIULL2IUS2)
itkImageToImageFilterIULL2IUS2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUS2_GetDirectionTolerance, None, itkImageToImageFilterIULL2IUS2)
itkImageToImageFilterIULL2IUS2_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUS2_swigregister
itkImageToImageFilterIULL2IUS2_swigregister(itkImageToImageFilterIULL2IUS2)

def itkImageToImageFilterIULL2IUS2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIULL2IUS2 *":
    """itkImageToImageFilterIULL2IUS2_cast(itkLightObject obj) -> itkImageToImageFilterIULL2IUS2"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIULL2IUS2_cast(obj)

class itkImageToImageFilterIULL3ID3(itkImageSourcePython.itkImageSourceID3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIULL3ID3 self, itkImageULL3 image)
        SetInput(itkImageToImageFilterIULL3ID3 self, unsigned int arg0, itkImageULL3 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3ID3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageULL3 const *":
        """
        GetInput(itkImageToImageFilterIULL3ID3 self) -> itkImageULL3
        GetInput(itkImageToImageFilterIULL3ID3 self, unsigned int idx) -> itkImageULL3
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3ID3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageULL3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIULL3ID3 self, itkImageULL3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3ID3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIULL3ID3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3ID3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageULL3') -> "void":
        """PushFrontInput(itkImageToImageFilterIULL3ID3 self, itkImageULL3 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3ID3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIULL3ID3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3ID3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIULL3ID3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3ID3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIULL3ID3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3ID3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIULL3ID3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3ID3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIULL3ID3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3ID3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIULL3ID3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIULL3ID3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIULL3ID3"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3ID3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIULL3ID3

        Create a new object of the class itkImageToImageFilterIULL3ID3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIULL3ID3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIULL3ID3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIULL3ID3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIULL3ID3.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL3ID3_SetInput, None, itkImageToImageFilterIULL3ID3)
itkImageToImageFilterIULL3ID3.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL3ID3_GetInput, None, itkImageToImageFilterIULL3ID3)
itkImageToImageFilterIULL3ID3.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL3ID3_PushBackInput, None, itkImageToImageFilterIULL3ID3)
itkImageToImageFilterIULL3ID3.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL3ID3_PopBackInput, None, itkImageToImageFilterIULL3ID3)
itkImageToImageFilterIULL3ID3.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL3ID3_PushFrontInput, None, itkImageToImageFilterIULL3ID3)
itkImageToImageFilterIULL3ID3.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL3ID3_PopFrontInput, None, itkImageToImageFilterIULL3ID3)
itkImageToImageFilterIULL3ID3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL3ID3_SetCoordinateTolerance, None, itkImageToImageFilterIULL3ID3)
itkImageToImageFilterIULL3ID3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL3ID3_GetCoordinateTolerance, None, itkImageToImageFilterIULL3ID3)
itkImageToImageFilterIULL3ID3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL3ID3_SetDirectionTolerance, None, itkImageToImageFilterIULL3ID3)
itkImageToImageFilterIULL3ID3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL3ID3_GetDirectionTolerance, None, itkImageToImageFilterIULL3ID3)
itkImageToImageFilterIULL3ID3_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIULL3ID3_swigregister
itkImageToImageFilterIULL3ID3_swigregister(itkImageToImageFilterIULL3ID3)

def itkImageToImageFilterIULL3ID3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIULL3ID3 *":
    """itkImageToImageFilterIULL3ID3_cast(itkLightObject obj) -> itkImageToImageFilterIULL3ID3"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3ID3_cast(obj)

class itkImageToImageFilterIULL3IF3(itkImageSourcePython.itkImageSourceIF3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIULL3IF3 self, itkImageULL3 image)
        SetInput(itkImageToImageFilterIULL3IF3 self, unsigned int arg0, itkImageULL3 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3IF3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageULL3 const *":
        """
        GetInput(itkImageToImageFilterIULL3IF3 self) -> itkImageULL3
        GetInput(itkImageToImageFilterIULL3IF3 self, unsigned int idx) -> itkImageULL3
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3IF3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageULL3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIULL3IF3 self, itkImageULL3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3IF3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIULL3IF3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3IF3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageULL3') -> "void":
        """PushFrontInput(itkImageToImageFilterIULL3IF3 self, itkImageULL3 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3IF3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIULL3IF3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3IF3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIULL3IF3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3IF3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIULL3IF3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3IF3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIULL3IF3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3IF3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIULL3IF3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3IF3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIULL3IF3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIULL3IF3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIULL3IF3"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3IF3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIULL3IF3

        Create a new object of the class itkImageToImageFilterIULL3IF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIULL3IF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIULL3IF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIULL3IF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIULL3IF3.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL3IF3_SetInput, None, itkImageToImageFilterIULL3IF3)
itkImageToImageFilterIULL3IF3.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL3IF3_GetInput, None, itkImageToImageFilterIULL3IF3)
itkImageToImageFilterIULL3IF3.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL3IF3_PushBackInput, None, itkImageToImageFilterIULL3IF3)
itkImageToImageFilterIULL3IF3.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL3IF3_PopBackInput, None, itkImageToImageFilterIULL3IF3)
itkImageToImageFilterIULL3IF3.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL3IF3_PushFrontInput, None, itkImageToImageFilterIULL3IF3)
itkImageToImageFilterIULL3IF3.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL3IF3_PopFrontInput, None, itkImageToImageFilterIULL3IF3)
itkImageToImageFilterIULL3IF3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL3IF3_SetCoordinateTolerance, None, itkImageToImageFilterIULL3IF3)
itkImageToImageFilterIULL3IF3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL3IF3_GetCoordinateTolerance, None, itkImageToImageFilterIULL3IF3)
itkImageToImageFilterIULL3IF3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL3IF3_SetDirectionTolerance, None, itkImageToImageFilterIULL3IF3)
itkImageToImageFilterIULL3IF3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL3IF3_GetDirectionTolerance, None, itkImageToImageFilterIULL3IF3)
itkImageToImageFilterIULL3IF3_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIULL3IF3_swigregister
itkImageToImageFilterIULL3IF3_swigregister(itkImageToImageFilterIULL3IF3)

def itkImageToImageFilterIULL3IF3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIULL3IF3 *":
    """itkImageToImageFilterIULL3IF3_cast(itkLightObject obj) -> itkImageToImageFilterIULL3IF3"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3IF3_cast(obj)

class itkImageToImageFilterIULL3ISS3(itkImageSourcePython.itkImageSourceISS3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIULL3ISS3 self, itkImageULL3 image)
        SetInput(itkImageToImageFilterIULL3ISS3 self, unsigned int arg0, itkImageULL3 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3ISS3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageULL3 const *":
        """
        GetInput(itkImageToImageFilterIULL3ISS3 self) -> itkImageULL3
        GetInput(itkImageToImageFilterIULL3ISS3 self, unsigned int idx) -> itkImageULL3
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3ISS3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageULL3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIULL3ISS3 self, itkImageULL3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3ISS3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIULL3ISS3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3ISS3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageULL3') -> "void":
        """PushFrontInput(itkImageToImageFilterIULL3ISS3 self, itkImageULL3 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3ISS3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIULL3ISS3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3ISS3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIULL3ISS3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3ISS3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIULL3ISS3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3ISS3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIULL3ISS3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3ISS3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIULL3ISS3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3ISS3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIULL3ISS3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIULL3ISS3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIULL3ISS3"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3ISS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIULL3ISS3

        Create a new object of the class itkImageToImageFilterIULL3ISS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIULL3ISS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIULL3ISS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIULL3ISS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIULL3ISS3.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL3ISS3_SetInput, None, itkImageToImageFilterIULL3ISS3)
itkImageToImageFilterIULL3ISS3.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL3ISS3_GetInput, None, itkImageToImageFilterIULL3ISS3)
itkImageToImageFilterIULL3ISS3.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL3ISS3_PushBackInput, None, itkImageToImageFilterIULL3ISS3)
itkImageToImageFilterIULL3ISS3.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL3ISS3_PopBackInput, None, itkImageToImageFilterIULL3ISS3)
itkImageToImageFilterIULL3ISS3.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL3ISS3_PushFrontInput, None, itkImageToImageFilterIULL3ISS3)
itkImageToImageFilterIULL3ISS3.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL3ISS3_PopFrontInput, None, itkImageToImageFilterIULL3ISS3)
itkImageToImageFilterIULL3ISS3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL3ISS3_SetCoordinateTolerance, None, itkImageToImageFilterIULL3ISS3)
itkImageToImageFilterIULL3ISS3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL3ISS3_GetCoordinateTolerance, None, itkImageToImageFilterIULL3ISS3)
itkImageToImageFilterIULL3ISS3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL3ISS3_SetDirectionTolerance, None, itkImageToImageFilterIULL3ISS3)
itkImageToImageFilterIULL3ISS3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL3ISS3_GetDirectionTolerance, None, itkImageToImageFilterIULL3ISS3)
itkImageToImageFilterIULL3ISS3_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIULL3ISS3_swigregister
itkImageToImageFilterIULL3ISS3_swigregister(itkImageToImageFilterIULL3ISS3)

def itkImageToImageFilterIULL3ISS3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIULL3ISS3 *":
    """itkImageToImageFilterIULL3ISS3_cast(itkLightObject obj) -> itkImageToImageFilterIULL3ISS3"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3ISS3_cast(obj)

class itkImageToImageFilterIULL3IUC3(itkImageSourcePython.itkImageSourceIUC3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIULL3IUC3 self, itkImageULL3 image)
        SetInput(itkImageToImageFilterIULL3IUC3 self, unsigned int arg0, itkImageULL3 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUC3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageULL3 const *":
        """
        GetInput(itkImageToImageFilterIULL3IUC3 self) -> itkImageULL3
        GetInput(itkImageToImageFilterIULL3IUC3 self, unsigned int idx) -> itkImageULL3
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUC3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageULL3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIULL3IUC3 self, itkImageULL3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUC3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIULL3IUC3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUC3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageULL3') -> "void":
        """PushFrontInput(itkImageToImageFilterIULL3IUC3 self, itkImageULL3 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUC3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIULL3IUC3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUC3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIULL3IUC3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUC3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIULL3IUC3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUC3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIULL3IUC3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUC3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIULL3IUC3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUC3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIULL3IUC3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIULL3IUC3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIULL3IUC3"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUC3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIULL3IUC3

        Create a new object of the class itkImageToImageFilterIULL3IUC3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIULL3IUC3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIULL3IUC3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIULL3IUC3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIULL3IUC3.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUC3_SetInput, None, itkImageToImageFilterIULL3IUC3)
itkImageToImageFilterIULL3IUC3.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUC3_GetInput, None, itkImageToImageFilterIULL3IUC3)
itkImageToImageFilterIULL3IUC3.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUC3_PushBackInput, None, itkImageToImageFilterIULL3IUC3)
itkImageToImageFilterIULL3IUC3.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUC3_PopBackInput, None, itkImageToImageFilterIULL3IUC3)
itkImageToImageFilterIULL3IUC3.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUC3_PushFrontInput, None, itkImageToImageFilterIULL3IUC3)
itkImageToImageFilterIULL3IUC3.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUC3_PopFrontInput, None, itkImageToImageFilterIULL3IUC3)
itkImageToImageFilterIULL3IUC3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUC3_SetCoordinateTolerance, None, itkImageToImageFilterIULL3IUC3)
itkImageToImageFilterIULL3IUC3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUC3_GetCoordinateTolerance, None, itkImageToImageFilterIULL3IUC3)
itkImageToImageFilterIULL3IUC3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUC3_SetDirectionTolerance, None, itkImageToImageFilterIULL3IUC3)
itkImageToImageFilterIULL3IUC3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUC3_GetDirectionTolerance, None, itkImageToImageFilterIULL3IUC3)
itkImageToImageFilterIULL3IUC3_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUC3_swigregister
itkImageToImageFilterIULL3IUC3_swigregister(itkImageToImageFilterIULL3IUC3)

def itkImageToImageFilterIULL3IUC3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIULL3IUC3 *":
    """itkImageToImageFilterIULL3IUC3_cast(itkLightObject obj) -> itkImageToImageFilterIULL3IUC3"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUC3_cast(obj)

class itkImageToImageFilterIULL3IUL3(itkImageSourcePython.itkImageSourceIUL3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIULL3IUL3 self, itkImageULL3 image)
        SetInput(itkImageToImageFilterIULL3IUL3 self, unsigned int arg0, itkImageULL3 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUL3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageULL3 const *":
        """
        GetInput(itkImageToImageFilterIULL3IUL3 self) -> itkImageULL3
        GetInput(itkImageToImageFilterIULL3IUL3 self, unsigned int idx) -> itkImageULL3
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUL3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageULL3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIULL3IUL3 self, itkImageULL3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUL3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIULL3IUL3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUL3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageULL3') -> "void":
        """PushFrontInput(itkImageToImageFilterIULL3IUL3 self, itkImageULL3 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUL3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIULL3IUL3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUL3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIULL3IUL3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUL3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIULL3IUL3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUL3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIULL3IUL3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUL3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIULL3IUL3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUL3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIULL3IUL3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIULL3IUL3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIULL3IUL3"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUL3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIULL3IUL3

        Create a new object of the class itkImageToImageFilterIULL3IUL3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIULL3IUL3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIULL3IUL3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIULL3IUL3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIULL3IUL3.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUL3_SetInput, None, itkImageToImageFilterIULL3IUL3)
itkImageToImageFilterIULL3IUL3.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUL3_GetInput, None, itkImageToImageFilterIULL3IUL3)
itkImageToImageFilterIULL3IUL3.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUL3_PushBackInput, None, itkImageToImageFilterIULL3IUL3)
itkImageToImageFilterIULL3IUL3.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUL3_PopBackInput, None, itkImageToImageFilterIULL3IUL3)
itkImageToImageFilterIULL3IUL3.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUL3_PushFrontInput, None, itkImageToImageFilterIULL3IUL3)
itkImageToImageFilterIULL3IUL3.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUL3_PopFrontInput, None, itkImageToImageFilterIULL3IUL3)
itkImageToImageFilterIULL3IUL3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUL3_SetCoordinateTolerance, None, itkImageToImageFilterIULL3IUL3)
itkImageToImageFilterIULL3IUL3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUL3_GetCoordinateTolerance, None, itkImageToImageFilterIULL3IUL3)
itkImageToImageFilterIULL3IUL3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUL3_SetDirectionTolerance, None, itkImageToImageFilterIULL3IUL3)
itkImageToImageFilterIULL3IUL3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUL3_GetDirectionTolerance, None, itkImageToImageFilterIULL3IUL3)
itkImageToImageFilterIULL3IUL3_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUL3_swigregister
itkImageToImageFilterIULL3IUL3_swigregister(itkImageToImageFilterIULL3IUL3)

def itkImageToImageFilterIULL3IUL3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIULL3IUL3 *":
    """itkImageToImageFilterIULL3IUL3_cast(itkLightObject obj) -> itkImageToImageFilterIULL3IUL3"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUL3_cast(obj)

class itkImageToImageFilterIULL3IUS3(itkImageSourcePython.itkImageSourceIUS3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIULL3IUS3 self, itkImageULL3 image)
        SetInput(itkImageToImageFilterIULL3IUS3 self, unsigned int arg0, itkImageULL3 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUS3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageULL3 const *":
        """
        GetInput(itkImageToImageFilterIULL3IUS3 self) -> itkImageULL3
        GetInput(itkImageToImageFilterIULL3IUS3 self, unsigned int idx) -> itkImageULL3
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUS3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageULL3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIULL3IUS3 self, itkImageULL3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUS3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIULL3IUS3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUS3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageULL3') -> "void":
        """PushFrontInput(itkImageToImageFilterIULL3IUS3 self, itkImageULL3 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUS3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIULL3IUS3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUS3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIULL3IUS3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUS3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIULL3IUS3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUS3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIULL3IUS3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUS3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIULL3IUS3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUS3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIULL3IUS3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIULL3IUS3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIULL3IUS3"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIULL3IUS3

        Create a new object of the class itkImageToImageFilterIULL3IUS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIULL3IUS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIULL3IUS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIULL3IUS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIULL3IUS3.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUS3_SetInput, None, itkImageToImageFilterIULL3IUS3)
itkImageToImageFilterIULL3IUS3.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUS3_GetInput, None, itkImageToImageFilterIULL3IUS3)
itkImageToImageFilterIULL3IUS3.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUS3_PushBackInput, None, itkImageToImageFilterIULL3IUS3)
itkImageToImageFilterIULL3IUS3.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUS3_PopBackInput, None, itkImageToImageFilterIULL3IUS3)
itkImageToImageFilterIULL3IUS3.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUS3_PushFrontInput, None, itkImageToImageFilterIULL3IUS3)
itkImageToImageFilterIULL3IUS3.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUS3_PopFrontInput, None, itkImageToImageFilterIULL3IUS3)
itkImageToImageFilterIULL3IUS3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUS3_SetCoordinateTolerance, None, itkImageToImageFilterIULL3IUS3)
itkImageToImageFilterIULL3IUS3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUS3_GetCoordinateTolerance, None, itkImageToImageFilterIULL3IUS3)
itkImageToImageFilterIULL3IUS3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUS3_SetDirectionTolerance, None, itkImageToImageFilterIULL3IUS3)
itkImageToImageFilterIULL3IUS3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUS3_GetDirectionTolerance, None, itkImageToImageFilterIULL3IUS3)
itkImageToImageFilterIULL3IUS3_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUS3_swigregister
itkImageToImageFilterIULL3IUS3_swigregister(itkImageToImageFilterIULL3IUS3)

def itkImageToImageFilterIULL3IUS3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIULL3IUS3 *":
    """itkImageToImageFilterIULL3IUS3_cast(itkLightObject obj) -> itkImageToImageFilterIULL3IUS3"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIULL3IUS3_cast(obj)

class itkImageToImageFilterIUS2ID2(itkImageSourcePython.itkImageSourceID2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUS2ID2 self, itkImageUS2 image)
        SetInput(itkImageToImageFilterIUS2ID2 self, unsigned int arg0, itkImageUS2 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2ID2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUS2 const *":
        """
        GetInput(itkImageToImageFilterIUS2ID2 self) -> itkImageUS2
        GetInput(itkImageToImageFilterIUS2ID2 self, unsigned int idx) -> itkImageUS2
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2ID2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUS2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUS2ID2 self, itkImageUS2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2ID2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUS2ID2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2ID2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUS2') -> "void":
        """PushFrontInput(itkImageToImageFilterIUS2ID2 self, itkImageUS2 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2ID2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUS2ID2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2ID2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUS2ID2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2ID2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUS2ID2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2ID2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUS2ID2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2ID2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUS2ID2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2ID2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIUS2ID2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS2ID2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUS2ID2"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2ID2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUS2ID2

        Create a new object of the class itkImageToImageFilterIUS2ID2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUS2ID2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUS2ID2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUS2ID2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUS2ID2.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS2ID2_SetInput, None, itkImageToImageFilterIUS2ID2)
itkImageToImageFilterIUS2ID2.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS2ID2_GetInput, None, itkImageToImageFilterIUS2ID2)
itkImageToImageFilterIUS2ID2.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS2ID2_PushBackInput, None, itkImageToImageFilterIUS2ID2)
itkImageToImageFilterIUS2ID2.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS2ID2_PopBackInput, None, itkImageToImageFilterIUS2ID2)
itkImageToImageFilterIUS2ID2.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS2ID2_PushFrontInput, None, itkImageToImageFilterIUS2ID2)
itkImageToImageFilterIUS2ID2.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS2ID2_PopFrontInput, None, itkImageToImageFilterIUS2ID2)
itkImageToImageFilterIUS2ID2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS2ID2_SetCoordinateTolerance, None, itkImageToImageFilterIUS2ID2)
itkImageToImageFilterIUS2ID2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS2ID2_GetCoordinateTolerance, None, itkImageToImageFilterIUS2ID2)
itkImageToImageFilterIUS2ID2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS2ID2_SetDirectionTolerance, None, itkImageToImageFilterIUS2ID2)
itkImageToImageFilterIUS2ID2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS2ID2_GetDirectionTolerance, None, itkImageToImageFilterIUS2ID2)
itkImageToImageFilterIUS2ID2_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIUS2ID2_swigregister
itkImageToImageFilterIUS2ID2_swigregister(itkImageToImageFilterIUS2ID2)

def itkImageToImageFilterIUS2ID2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS2ID2 *":
    """itkImageToImageFilterIUS2ID2_cast(itkLightObject obj) -> itkImageToImageFilterIUS2ID2"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2ID2_cast(obj)

class itkImageToImageFilterIUS2IF2(itkImageSourcePython.itkImageSourceIF2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUS2IF2 self, itkImageUS2 image)
        SetInput(itkImageToImageFilterIUS2IF2 self, unsigned int arg0, itkImageUS2 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2IF2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUS2 const *":
        """
        GetInput(itkImageToImageFilterIUS2IF2 self) -> itkImageUS2
        GetInput(itkImageToImageFilterIUS2IF2 self, unsigned int idx) -> itkImageUS2
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2IF2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUS2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUS2IF2 self, itkImageUS2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2IF2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUS2IF2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2IF2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUS2') -> "void":
        """PushFrontInput(itkImageToImageFilterIUS2IF2 self, itkImageUS2 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2IF2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUS2IF2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2IF2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUS2IF2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2IF2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUS2IF2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2IF2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUS2IF2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2IF2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUS2IF2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2IF2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIUS2IF2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS2IF2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUS2IF2"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2IF2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUS2IF2

        Create a new object of the class itkImageToImageFilterIUS2IF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUS2IF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUS2IF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUS2IF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUS2IF2.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS2IF2_SetInput, None, itkImageToImageFilterIUS2IF2)
itkImageToImageFilterIUS2IF2.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS2IF2_GetInput, None, itkImageToImageFilterIUS2IF2)
itkImageToImageFilterIUS2IF2.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS2IF2_PushBackInput, None, itkImageToImageFilterIUS2IF2)
itkImageToImageFilterIUS2IF2.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS2IF2_PopBackInput, None, itkImageToImageFilterIUS2IF2)
itkImageToImageFilterIUS2IF2.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS2IF2_PushFrontInput, None, itkImageToImageFilterIUS2IF2)
itkImageToImageFilterIUS2IF2.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS2IF2_PopFrontInput, None, itkImageToImageFilterIUS2IF2)
itkImageToImageFilterIUS2IF2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS2IF2_SetCoordinateTolerance, None, itkImageToImageFilterIUS2IF2)
itkImageToImageFilterIUS2IF2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS2IF2_GetCoordinateTolerance, None, itkImageToImageFilterIUS2IF2)
itkImageToImageFilterIUS2IF2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS2IF2_SetDirectionTolerance, None, itkImageToImageFilterIUS2IF2)
itkImageToImageFilterIUS2IF2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS2IF2_GetDirectionTolerance, None, itkImageToImageFilterIUS2IF2)
itkImageToImageFilterIUS2IF2_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIUS2IF2_swigregister
itkImageToImageFilterIUS2IF2_swigregister(itkImageToImageFilterIUS2IF2)

def itkImageToImageFilterIUS2IF2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS2IF2 *":
    """itkImageToImageFilterIUS2IF2_cast(itkLightObject obj) -> itkImageToImageFilterIUS2IF2"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2IF2_cast(obj)

class itkImageToImageFilterIUS2ISS2(itkImageSourcePython.itkImageSourceISS2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUS2ISS2 self, itkImageUS2 image)
        SetInput(itkImageToImageFilterIUS2ISS2 self, unsigned int arg0, itkImageUS2 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2ISS2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUS2 const *":
        """
        GetInput(itkImageToImageFilterIUS2ISS2 self) -> itkImageUS2
        GetInput(itkImageToImageFilterIUS2ISS2 self, unsigned int idx) -> itkImageUS2
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2ISS2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUS2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUS2ISS2 self, itkImageUS2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2ISS2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUS2ISS2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2ISS2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUS2') -> "void":
        """PushFrontInput(itkImageToImageFilterIUS2ISS2 self, itkImageUS2 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2ISS2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUS2ISS2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2ISS2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUS2ISS2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2ISS2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUS2ISS2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2ISS2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUS2ISS2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2ISS2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUS2ISS2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2ISS2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIUS2ISS2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS2ISS2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUS2ISS2"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2ISS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUS2ISS2

        Create a new object of the class itkImageToImageFilterIUS2ISS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUS2ISS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUS2ISS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUS2ISS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUS2ISS2.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS2ISS2_SetInput, None, itkImageToImageFilterIUS2ISS2)
itkImageToImageFilterIUS2ISS2.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS2ISS2_GetInput, None, itkImageToImageFilterIUS2ISS2)
itkImageToImageFilterIUS2ISS2.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS2ISS2_PushBackInput, None, itkImageToImageFilterIUS2ISS2)
itkImageToImageFilterIUS2ISS2.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS2ISS2_PopBackInput, None, itkImageToImageFilterIUS2ISS2)
itkImageToImageFilterIUS2ISS2.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS2ISS2_PushFrontInput, None, itkImageToImageFilterIUS2ISS2)
itkImageToImageFilterIUS2ISS2.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS2ISS2_PopFrontInput, None, itkImageToImageFilterIUS2ISS2)
itkImageToImageFilterIUS2ISS2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS2ISS2_SetCoordinateTolerance, None, itkImageToImageFilterIUS2ISS2)
itkImageToImageFilterIUS2ISS2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS2ISS2_GetCoordinateTolerance, None, itkImageToImageFilterIUS2ISS2)
itkImageToImageFilterIUS2ISS2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS2ISS2_SetDirectionTolerance, None, itkImageToImageFilterIUS2ISS2)
itkImageToImageFilterIUS2ISS2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS2ISS2_GetDirectionTolerance, None, itkImageToImageFilterIUS2ISS2)
itkImageToImageFilterIUS2ISS2_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIUS2ISS2_swigregister
itkImageToImageFilterIUS2ISS2_swigregister(itkImageToImageFilterIUS2ISS2)

def itkImageToImageFilterIUS2ISS2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS2ISS2 *":
    """itkImageToImageFilterIUS2ISS2_cast(itkLightObject obj) -> itkImageToImageFilterIUS2ISS2"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2ISS2_cast(obj)

class itkImageToImageFilterIUS2IUC2(itkImageSourcePython.itkImageSourceIUC2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUS2IUC2 self, itkImageUS2 image)
        SetInput(itkImageToImageFilterIUS2IUC2 self, unsigned int arg0, itkImageUS2 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUC2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUS2 const *":
        """
        GetInput(itkImageToImageFilterIUS2IUC2 self) -> itkImageUS2
        GetInput(itkImageToImageFilterIUS2IUC2 self, unsigned int idx) -> itkImageUS2
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUC2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUS2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUS2IUC2 self, itkImageUS2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUC2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUS2IUC2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUC2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUS2') -> "void":
        """PushFrontInput(itkImageToImageFilterIUS2IUC2 self, itkImageUS2 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUC2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUS2IUC2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUC2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUS2IUC2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUC2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUS2IUC2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUC2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUS2IUC2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUC2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUS2IUC2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUC2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIUS2IUC2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS2IUC2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUS2IUC2"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUC2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUS2IUC2

        Create a new object of the class itkImageToImageFilterIUS2IUC2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUS2IUC2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUS2IUC2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUS2IUC2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUS2IUC2.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUC2_SetInput, None, itkImageToImageFilterIUS2IUC2)
itkImageToImageFilterIUS2IUC2.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUC2_GetInput, None, itkImageToImageFilterIUS2IUC2)
itkImageToImageFilterIUS2IUC2.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUC2_PushBackInput, None, itkImageToImageFilterIUS2IUC2)
itkImageToImageFilterIUS2IUC2.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUC2_PopBackInput, None, itkImageToImageFilterIUS2IUC2)
itkImageToImageFilterIUS2IUC2.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUC2_PushFrontInput, None, itkImageToImageFilterIUS2IUC2)
itkImageToImageFilterIUS2IUC2.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUC2_PopFrontInput, None, itkImageToImageFilterIUS2IUC2)
itkImageToImageFilterIUS2IUC2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUC2_SetCoordinateTolerance, None, itkImageToImageFilterIUS2IUC2)
itkImageToImageFilterIUS2IUC2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUC2_GetCoordinateTolerance, None, itkImageToImageFilterIUS2IUC2)
itkImageToImageFilterIUS2IUC2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUC2_SetDirectionTolerance, None, itkImageToImageFilterIUS2IUC2)
itkImageToImageFilterIUS2IUC2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUC2_GetDirectionTolerance, None, itkImageToImageFilterIUS2IUC2)
itkImageToImageFilterIUS2IUC2_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUC2_swigregister
itkImageToImageFilterIUS2IUC2_swigregister(itkImageToImageFilterIUS2IUC2)

def itkImageToImageFilterIUS2IUC2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS2IUC2 *":
    """itkImageToImageFilterIUS2IUC2_cast(itkLightObject obj) -> itkImageToImageFilterIUS2IUC2"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUC2_cast(obj)

class itkImageToImageFilterIUS2IUL2(itkImageSourcePython.itkImageSourceIUL2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUS2IUL2 self, itkImageUS2 image)
        SetInput(itkImageToImageFilterIUS2IUL2 self, unsigned int arg0, itkImageUS2 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUL2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUS2 const *":
        """
        GetInput(itkImageToImageFilterIUS2IUL2 self) -> itkImageUS2
        GetInput(itkImageToImageFilterIUS2IUL2 self, unsigned int idx) -> itkImageUS2
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUL2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUS2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUS2IUL2 self, itkImageUS2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUL2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUS2IUL2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUL2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUS2') -> "void":
        """PushFrontInput(itkImageToImageFilterIUS2IUL2 self, itkImageUS2 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUL2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUS2IUL2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUL2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUS2IUL2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUL2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUS2IUL2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUL2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUS2IUL2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUL2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUS2IUL2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUL2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIUS2IUL2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS2IUL2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUS2IUL2"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUL2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUS2IUL2

        Create a new object of the class itkImageToImageFilterIUS2IUL2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUS2IUL2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUS2IUL2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUS2IUL2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUS2IUL2.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUL2_SetInput, None, itkImageToImageFilterIUS2IUL2)
itkImageToImageFilterIUS2IUL2.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUL2_GetInput, None, itkImageToImageFilterIUS2IUL2)
itkImageToImageFilterIUS2IUL2.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUL2_PushBackInput, None, itkImageToImageFilterIUS2IUL2)
itkImageToImageFilterIUS2IUL2.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUL2_PopBackInput, None, itkImageToImageFilterIUS2IUL2)
itkImageToImageFilterIUS2IUL2.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUL2_PushFrontInput, None, itkImageToImageFilterIUS2IUL2)
itkImageToImageFilterIUS2IUL2.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUL2_PopFrontInput, None, itkImageToImageFilterIUS2IUL2)
itkImageToImageFilterIUS2IUL2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUL2_SetCoordinateTolerance, None, itkImageToImageFilterIUS2IUL2)
itkImageToImageFilterIUS2IUL2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUL2_GetCoordinateTolerance, None, itkImageToImageFilterIUS2IUL2)
itkImageToImageFilterIUS2IUL2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUL2_SetDirectionTolerance, None, itkImageToImageFilterIUS2IUL2)
itkImageToImageFilterIUS2IUL2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUL2_GetDirectionTolerance, None, itkImageToImageFilterIUS2IUL2)
itkImageToImageFilterIUS2IUL2_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUL2_swigregister
itkImageToImageFilterIUS2IUL2_swigregister(itkImageToImageFilterIUS2IUL2)

def itkImageToImageFilterIUS2IUL2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS2IUL2 *":
    """itkImageToImageFilterIUS2IUL2_cast(itkLightObject obj) -> itkImageToImageFilterIUS2IUL2"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUL2_cast(obj)

class itkImageToImageFilterIUS2IUS2(itkImageSourcePython.itkImageSourceIUS2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUS2IUS2 self, itkImageUS2 image)
        SetInput(itkImageToImageFilterIUS2IUS2 self, unsigned int arg0, itkImageUS2 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUS2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUS2 const *":
        """
        GetInput(itkImageToImageFilterIUS2IUS2 self) -> itkImageUS2
        GetInput(itkImageToImageFilterIUS2IUS2 self, unsigned int idx) -> itkImageUS2
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUS2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUS2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUS2IUS2 self, itkImageUS2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUS2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUS2IUS2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUS2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUS2') -> "void":
        """PushFrontInput(itkImageToImageFilterIUS2IUS2 self, itkImageUS2 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUS2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUS2IUS2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUS2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUS2IUS2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUS2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUS2IUS2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUS2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUS2IUS2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUS2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUS2IUS2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUS2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIUS2IUS2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS2IUS2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUS2IUS2"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUS2IUS2

        Create a new object of the class itkImageToImageFilterIUS2IUS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUS2IUS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUS2IUS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUS2IUS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUS2IUS2.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUS2_SetInput, None, itkImageToImageFilterIUS2IUS2)
itkImageToImageFilterIUS2IUS2.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUS2_GetInput, None, itkImageToImageFilterIUS2IUS2)
itkImageToImageFilterIUS2IUS2.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUS2_PushBackInput, None, itkImageToImageFilterIUS2IUS2)
itkImageToImageFilterIUS2IUS2.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUS2_PopBackInput, None, itkImageToImageFilterIUS2IUS2)
itkImageToImageFilterIUS2IUS2.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUS2_PushFrontInput, None, itkImageToImageFilterIUS2IUS2)
itkImageToImageFilterIUS2IUS2.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUS2_PopFrontInput, None, itkImageToImageFilterIUS2IUS2)
itkImageToImageFilterIUS2IUS2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUS2_SetCoordinateTolerance, None, itkImageToImageFilterIUS2IUS2)
itkImageToImageFilterIUS2IUS2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUS2_GetCoordinateTolerance, None, itkImageToImageFilterIUS2IUS2)
itkImageToImageFilterIUS2IUS2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUS2_SetDirectionTolerance, None, itkImageToImageFilterIUS2IUS2)
itkImageToImageFilterIUS2IUS2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUS2_GetDirectionTolerance, None, itkImageToImageFilterIUS2IUS2)
itkImageToImageFilterIUS2IUS2_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUS2_swigregister
itkImageToImageFilterIUS2IUS2_swigregister(itkImageToImageFilterIUS2IUS2)

def itkImageToImageFilterIUS2IUS2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS2IUS2 *":
    """itkImageToImageFilterIUS2IUS2_cast(itkLightObject obj) -> itkImageToImageFilterIUS2IUS2"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIUS2IUS2_cast(obj)

class itkImageToImageFilterIUS3ID3(itkImageSourcePython.itkImageSourceID3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUS3ID3 self, itkImageUS3 image)
        SetInput(itkImageToImageFilterIUS3ID3 self, unsigned int arg0, itkImageUS3 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3ID3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUS3 const *":
        """
        GetInput(itkImageToImageFilterIUS3ID3 self) -> itkImageUS3
        GetInput(itkImageToImageFilterIUS3ID3 self, unsigned int idx) -> itkImageUS3
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3ID3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUS3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUS3ID3 self, itkImageUS3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3ID3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUS3ID3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3ID3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUS3') -> "void":
        """PushFrontInput(itkImageToImageFilterIUS3ID3 self, itkImageUS3 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3ID3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUS3ID3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3ID3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUS3ID3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3ID3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUS3ID3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3ID3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUS3ID3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3ID3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUS3ID3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3ID3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIUS3ID3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS3ID3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUS3ID3"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3ID3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUS3ID3

        Create a new object of the class itkImageToImageFilterIUS3ID3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUS3ID3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUS3ID3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUS3ID3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUS3ID3.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS3ID3_SetInput, None, itkImageToImageFilterIUS3ID3)
itkImageToImageFilterIUS3ID3.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS3ID3_GetInput, None, itkImageToImageFilterIUS3ID3)
itkImageToImageFilterIUS3ID3.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS3ID3_PushBackInput, None, itkImageToImageFilterIUS3ID3)
itkImageToImageFilterIUS3ID3.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS3ID3_PopBackInput, None, itkImageToImageFilterIUS3ID3)
itkImageToImageFilterIUS3ID3.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS3ID3_PushFrontInput, None, itkImageToImageFilterIUS3ID3)
itkImageToImageFilterIUS3ID3.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS3ID3_PopFrontInput, None, itkImageToImageFilterIUS3ID3)
itkImageToImageFilterIUS3ID3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS3ID3_SetCoordinateTolerance, None, itkImageToImageFilterIUS3ID3)
itkImageToImageFilterIUS3ID3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS3ID3_GetCoordinateTolerance, None, itkImageToImageFilterIUS3ID3)
itkImageToImageFilterIUS3ID3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS3ID3_SetDirectionTolerance, None, itkImageToImageFilterIUS3ID3)
itkImageToImageFilterIUS3ID3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS3ID3_GetDirectionTolerance, None, itkImageToImageFilterIUS3ID3)
itkImageToImageFilterIUS3ID3_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIUS3ID3_swigregister
itkImageToImageFilterIUS3ID3_swigregister(itkImageToImageFilterIUS3ID3)

def itkImageToImageFilterIUS3ID3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS3ID3 *":
    """itkImageToImageFilterIUS3ID3_cast(itkLightObject obj) -> itkImageToImageFilterIUS3ID3"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3ID3_cast(obj)

class itkImageToImageFilterIUS3IF3(itkImageSourcePython.itkImageSourceIF3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUS3IF3 self, itkImageUS3 image)
        SetInput(itkImageToImageFilterIUS3IF3 self, unsigned int arg0, itkImageUS3 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3IF3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUS3 const *":
        """
        GetInput(itkImageToImageFilterIUS3IF3 self) -> itkImageUS3
        GetInput(itkImageToImageFilterIUS3IF3 self, unsigned int idx) -> itkImageUS3
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3IF3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUS3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUS3IF3 self, itkImageUS3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3IF3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUS3IF3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3IF3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUS3') -> "void":
        """PushFrontInput(itkImageToImageFilterIUS3IF3 self, itkImageUS3 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3IF3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUS3IF3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3IF3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUS3IF3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3IF3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUS3IF3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3IF3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUS3IF3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3IF3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUS3IF3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3IF3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIUS3IF3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS3IF3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUS3IF3"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3IF3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUS3IF3

        Create a new object of the class itkImageToImageFilterIUS3IF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUS3IF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUS3IF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUS3IF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUS3IF3.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS3IF3_SetInput, None, itkImageToImageFilterIUS3IF3)
itkImageToImageFilterIUS3IF3.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS3IF3_GetInput, None, itkImageToImageFilterIUS3IF3)
itkImageToImageFilterIUS3IF3.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS3IF3_PushBackInput, None, itkImageToImageFilterIUS3IF3)
itkImageToImageFilterIUS3IF3.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS3IF3_PopBackInput, None, itkImageToImageFilterIUS3IF3)
itkImageToImageFilterIUS3IF3.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS3IF3_PushFrontInput, None, itkImageToImageFilterIUS3IF3)
itkImageToImageFilterIUS3IF3.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS3IF3_PopFrontInput, None, itkImageToImageFilterIUS3IF3)
itkImageToImageFilterIUS3IF3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS3IF3_SetCoordinateTolerance, None, itkImageToImageFilterIUS3IF3)
itkImageToImageFilterIUS3IF3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS3IF3_GetCoordinateTolerance, None, itkImageToImageFilterIUS3IF3)
itkImageToImageFilterIUS3IF3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS3IF3_SetDirectionTolerance, None, itkImageToImageFilterIUS3IF3)
itkImageToImageFilterIUS3IF3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS3IF3_GetDirectionTolerance, None, itkImageToImageFilterIUS3IF3)
itkImageToImageFilterIUS3IF3_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIUS3IF3_swigregister
itkImageToImageFilterIUS3IF3_swigregister(itkImageToImageFilterIUS3IF3)

def itkImageToImageFilterIUS3IF3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS3IF3 *":
    """itkImageToImageFilterIUS3IF3_cast(itkLightObject obj) -> itkImageToImageFilterIUS3IF3"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3IF3_cast(obj)

class itkImageToImageFilterIUS3ISS3(itkImageSourcePython.itkImageSourceISS3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUS3ISS3 self, itkImageUS3 image)
        SetInput(itkImageToImageFilterIUS3ISS3 self, unsigned int arg0, itkImageUS3 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3ISS3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUS3 const *":
        """
        GetInput(itkImageToImageFilterIUS3ISS3 self) -> itkImageUS3
        GetInput(itkImageToImageFilterIUS3ISS3 self, unsigned int idx) -> itkImageUS3
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3ISS3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUS3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUS3ISS3 self, itkImageUS3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3ISS3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUS3ISS3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3ISS3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUS3') -> "void":
        """PushFrontInput(itkImageToImageFilterIUS3ISS3 self, itkImageUS3 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3ISS3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUS3ISS3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3ISS3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUS3ISS3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3ISS3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUS3ISS3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3ISS3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUS3ISS3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3ISS3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUS3ISS3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3ISS3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIUS3ISS3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS3ISS3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUS3ISS3"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3ISS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUS3ISS3

        Create a new object of the class itkImageToImageFilterIUS3ISS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUS3ISS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUS3ISS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUS3ISS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUS3ISS3.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS3ISS3_SetInput, None, itkImageToImageFilterIUS3ISS3)
itkImageToImageFilterIUS3ISS3.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS3ISS3_GetInput, None, itkImageToImageFilterIUS3ISS3)
itkImageToImageFilterIUS3ISS3.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS3ISS3_PushBackInput, None, itkImageToImageFilterIUS3ISS3)
itkImageToImageFilterIUS3ISS3.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS3ISS3_PopBackInput, None, itkImageToImageFilterIUS3ISS3)
itkImageToImageFilterIUS3ISS3.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS3ISS3_PushFrontInput, None, itkImageToImageFilterIUS3ISS3)
itkImageToImageFilterIUS3ISS3.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS3ISS3_PopFrontInput, None, itkImageToImageFilterIUS3ISS3)
itkImageToImageFilterIUS3ISS3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS3ISS3_SetCoordinateTolerance, None, itkImageToImageFilterIUS3ISS3)
itkImageToImageFilterIUS3ISS3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS3ISS3_GetCoordinateTolerance, None, itkImageToImageFilterIUS3ISS3)
itkImageToImageFilterIUS3ISS3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS3ISS3_SetDirectionTolerance, None, itkImageToImageFilterIUS3ISS3)
itkImageToImageFilterIUS3ISS3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS3ISS3_GetDirectionTolerance, None, itkImageToImageFilterIUS3ISS3)
itkImageToImageFilterIUS3ISS3_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIUS3ISS3_swigregister
itkImageToImageFilterIUS3ISS3_swigregister(itkImageToImageFilterIUS3ISS3)

def itkImageToImageFilterIUS3ISS3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS3ISS3 *":
    """itkImageToImageFilterIUS3ISS3_cast(itkLightObject obj) -> itkImageToImageFilterIUS3ISS3"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3ISS3_cast(obj)

class itkImageToImageFilterIUS3IUC3(itkImageSourcePython.itkImageSourceIUC3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUS3IUC3 self, itkImageUS3 image)
        SetInput(itkImageToImageFilterIUS3IUC3 self, unsigned int arg0, itkImageUS3 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUC3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUS3 const *":
        """
        GetInput(itkImageToImageFilterIUS3IUC3 self) -> itkImageUS3
        GetInput(itkImageToImageFilterIUS3IUC3 self, unsigned int idx) -> itkImageUS3
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUC3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUS3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUS3IUC3 self, itkImageUS3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUC3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUS3IUC3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUC3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUS3') -> "void":
        """PushFrontInput(itkImageToImageFilterIUS3IUC3 self, itkImageUS3 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUC3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUS3IUC3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUC3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUS3IUC3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUC3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUS3IUC3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUC3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUS3IUC3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUC3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUS3IUC3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUC3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIUS3IUC3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS3IUC3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUS3IUC3"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUC3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUS3IUC3

        Create a new object of the class itkImageToImageFilterIUS3IUC3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUS3IUC3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUS3IUC3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUS3IUC3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUS3IUC3.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUC3_SetInput, None, itkImageToImageFilterIUS3IUC3)
itkImageToImageFilterIUS3IUC3.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUC3_GetInput, None, itkImageToImageFilterIUS3IUC3)
itkImageToImageFilterIUS3IUC3.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUC3_PushBackInput, None, itkImageToImageFilterIUS3IUC3)
itkImageToImageFilterIUS3IUC3.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUC3_PopBackInput, None, itkImageToImageFilterIUS3IUC3)
itkImageToImageFilterIUS3IUC3.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUC3_PushFrontInput, None, itkImageToImageFilterIUS3IUC3)
itkImageToImageFilterIUS3IUC3.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUC3_PopFrontInput, None, itkImageToImageFilterIUS3IUC3)
itkImageToImageFilterIUS3IUC3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUC3_SetCoordinateTolerance, None, itkImageToImageFilterIUS3IUC3)
itkImageToImageFilterIUS3IUC3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUC3_GetCoordinateTolerance, None, itkImageToImageFilterIUS3IUC3)
itkImageToImageFilterIUS3IUC3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUC3_SetDirectionTolerance, None, itkImageToImageFilterIUS3IUC3)
itkImageToImageFilterIUS3IUC3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUC3_GetDirectionTolerance, None, itkImageToImageFilterIUS3IUC3)
itkImageToImageFilterIUS3IUC3_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUC3_swigregister
itkImageToImageFilterIUS3IUC3_swigregister(itkImageToImageFilterIUS3IUC3)

def itkImageToImageFilterIUS3IUC3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS3IUC3 *":
    """itkImageToImageFilterIUS3IUC3_cast(itkLightObject obj) -> itkImageToImageFilterIUS3IUC3"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUC3_cast(obj)

class itkImageToImageFilterIUS3IUL3(itkImageSourcePython.itkImageSourceIUL3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUS3IUL3 self, itkImageUS3 image)
        SetInput(itkImageToImageFilterIUS3IUL3 self, unsigned int arg0, itkImageUS3 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUL3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUS3 const *":
        """
        GetInput(itkImageToImageFilterIUS3IUL3 self) -> itkImageUS3
        GetInput(itkImageToImageFilterIUS3IUL3 self, unsigned int idx) -> itkImageUS3
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUL3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUS3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUS3IUL3 self, itkImageUS3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUL3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUS3IUL3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUL3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUS3') -> "void":
        """PushFrontInput(itkImageToImageFilterIUS3IUL3 self, itkImageUS3 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUL3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUS3IUL3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUL3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUS3IUL3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUL3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUS3IUL3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUL3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUS3IUL3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUL3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUS3IUL3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUL3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIUS3IUL3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS3IUL3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUS3IUL3"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUL3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUS3IUL3

        Create a new object of the class itkImageToImageFilterIUS3IUL3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUS3IUL3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUS3IUL3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUS3IUL3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUS3IUL3.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUL3_SetInput, None, itkImageToImageFilterIUS3IUL3)
itkImageToImageFilterIUS3IUL3.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUL3_GetInput, None, itkImageToImageFilterIUS3IUL3)
itkImageToImageFilterIUS3IUL3.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUL3_PushBackInput, None, itkImageToImageFilterIUS3IUL3)
itkImageToImageFilterIUS3IUL3.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUL3_PopBackInput, None, itkImageToImageFilterIUS3IUL3)
itkImageToImageFilterIUS3IUL3.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUL3_PushFrontInput, None, itkImageToImageFilterIUS3IUL3)
itkImageToImageFilterIUS3IUL3.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUL3_PopFrontInput, None, itkImageToImageFilterIUS3IUL3)
itkImageToImageFilterIUS3IUL3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUL3_SetCoordinateTolerance, None, itkImageToImageFilterIUS3IUL3)
itkImageToImageFilterIUS3IUL3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUL3_GetCoordinateTolerance, None, itkImageToImageFilterIUS3IUL3)
itkImageToImageFilterIUS3IUL3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUL3_SetDirectionTolerance, None, itkImageToImageFilterIUS3IUL3)
itkImageToImageFilterIUS3IUL3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUL3_GetDirectionTolerance, None, itkImageToImageFilterIUS3IUL3)
itkImageToImageFilterIUS3IUL3_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUL3_swigregister
itkImageToImageFilterIUS3IUL3_swigregister(itkImageToImageFilterIUS3IUL3)

def itkImageToImageFilterIUS3IUL3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS3IUL3 *":
    """itkImageToImageFilterIUS3IUL3_cast(itkLightObject obj) -> itkImageToImageFilterIUS3IUL3"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUL3_cast(obj)

class itkImageToImageFilterIUS3IUS3(itkImageSourcePython.itkImageSourceIUS3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUS3IUS3 self, itkImageUS3 image)
        SetInput(itkImageToImageFilterIUS3IUS3 self, unsigned int arg0, itkImageUS3 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUS3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUS3 const *":
        """
        GetInput(itkImageToImageFilterIUS3IUS3 self) -> itkImageUS3
        GetInput(itkImageToImageFilterIUS3IUS3 self, unsigned int idx) -> itkImageUS3
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUS3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUS3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUS3IUS3 self, itkImageUS3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUS3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUS3IUS3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUS3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUS3') -> "void":
        """PushFrontInput(itkImageToImageFilterIUS3IUS3 self, itkImageUS3 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUS3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUS3IUS3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUS3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUS3IUS3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUS3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUS3IUS3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUS3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUS3IUS3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUS3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUS3IUS3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUS3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIUS3IUS3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS3IUS3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUS3IUS3"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUS3IUS3

        Create a new object of the class itkImageToImageFilterIUS3IUS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUS3IUS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUS3IUS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUS3IUS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUS3IUS3.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUS3_SetInput, None, itkImageToImageFilterIUS3IUS3)
itkImageToImageFilterIUS3IUS3.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUS3_GetInput, None, itkImageToImageFilterIUS3IUS3)
itkImageToImageFilterIUS3IUS3.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUS3_PushBackInput, None, itkImageToImageFilterIUS3IUS3)
itkImageToImageFilterIUS3IUS3.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUS3_PopBackInput, None, itkImageToImageFilterIUS3IUS3)
itkImageToImageFilterIUS3IUS3.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUS3_PushFrontInput, None, itkImageToImageFilterIUS3IUS3)
itkImageToImageFilterIUS3IUS3.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUS3_PopFrontInput, None, itkImageToImageFilterIUS3IUS3)
itkImageToImageFilterIUS3IUS3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUS3_SetCoordinateTolerance, None, itkImageToImageFilterIUS3IUS3)
itkImageToImageFilterIUS3IUS3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUS3_GetCoordinateTolerance, None, itkImageToImageFilterIUS3IUS3)
itkImageToImageFilterIUS3IUS3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUS3_SetDirectionTolerance, None, itkImageToImageFilterIUS3IUS3)
itkImageToImageFilterIUS3IUS3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUS3_GetDirectionTolerance, None, itkImageToImageFilterIUS3IUS3)
itkImageToImageFilterIUS3IUS3_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUS3_swigregister
itkImageToImageFilterIUS3IUS3_swigregister(itkImageToImageFilterIUS3IUS3)

def itkImageToImageFilterIUS3IUS3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS3IUS3 *":
    """itkImageToImageFilterIUS3IUS3_cast(itkLightObject obj) -> itkImageToImageFilterIUS3IUS3"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIUS3IUS3_cast(obj)

class itkImageToImageFilterIVF22ICVF22(itkImageSourcePython.itkImageSourceICVF22):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIVF22ICVF22 self, itkImageVF22 image)
        SetInput(itkImageToImageFilterIVF22ICVF22 self, unsigned int arg0, itkImageVF22 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF22ICVF22_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageVF22 const *":
        """
        GetInput(itkImageToImageFilterIVF22ICVF22 self) -> itkImageVF22
        GetInput(itkImageToImageFilterIVF22ICVF22 self, unsigned int idx) -> itkImageVF22
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF22ICVF22_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageVF22') -> "void":
        """
        PushBackInput(itkImageToImageFilterIVF22ICVF22 self, itkImageVF22 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF22ICVF22_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIVF22ICVF22 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF22ICVF22_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageVF22') -> "void":
        """PushFrontInput(itkImageToImageFilterIVF22ICVF22 self, itkImageVF22 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF22ICVF22_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIVF22ICVF22 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF22ICVF22_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIVF22ICVF22 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF22ICVF22_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIVF22ICVF22 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF22ICVF22_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIVF22ICVF22 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF22ICVF22_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIVF22ICVF22 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF22ICVF22_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIVF22ICVF22

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF22ICVF22 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIVF22ICVF22"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF22ICVF22_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIVF22ICVF22

        Create a new object of the class itkImageToImageFilterIVF22ICVF22 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIVF22ICVF22.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIVF22ICVF22.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIVF22ICVF22.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIVF22ICVF22.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF22ICVF22_SetInput, None, itkImageToImageFilterIVF22ICVF22)
itkImageToImageFilterIVF22ICVF22.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF22ICVF22_GetInput, None, itkImageToImageFilterIVF22ICVF22)
itkImageToImageFilterIVF22ICVF22.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF22ICVF22_PushBackInput, None, itkImageToImageFilterIVF22ICVF22)
itkImageToImageFilterIVF22ICVF22.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF22ICVF22_PopBackInput, None, itkImageToImageFilterIVF22ICVF22)
itkImageToImageFilterIVF22ICVF22.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF22ICVF22_PushFrontInput, None, itkImageToImageFilterIVF22ICVF22)
itkImageToImageFilterIVF22ICVF22.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF22ICVF22_PopFrontInput, None, itkImageToImageFilterIVF22ICVF22)
itkImageToImageFilterIVF22ICVF22.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF22ICVF22_SetCoordinateTolerance, None, itkImageToImageFilterIVF22ICVF22)
itkImageToImageFilterIVF22ICVF22.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF22ICVF22_GetCoordinateTolerance, None, itkImageToImageFilterIVF22ICVF22)
itkImageToImageFilterIVF22ICVF22.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF22ICVF22_SetDirectionTolerance, None, itkImageToImageFilterIVF22ICVF22)
itkImageToImageFilterIVF22ICVF22.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF22ICVF22_GetDirectionTolerance, None, itkImageToImageFilterIVF22ICVF22)
itkImageToImageFilterIVF22ICVF22_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIVF22ICVF22_swigregister
itkImageToImageFilterIVF22ICVF22_swigregister(itkImageToImageFilterIVF22ICVF22)

def itkImageToImageFilterIVF22ICVF22_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF22ICVF22 *":
    """itkImageToImageFilterIVF22ICVF22_cast(itkLightObject obj) -> itkImageToImageFilterIVF22ICVF22"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIVF22ICVF22_cast(obj)

class itkImageToImageFilterIVF22ICVF42(itkImageSourcePython.itkImageSourceICVF42):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIVF22ICVF42 self, itkImageVF22 image)
        SetInput(itkImageToImageFilterIVF22ICVF42 self, unsigned int arg0, itkImageVF22 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF22ICVF42_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageVF22 const *":
        """
        GetInput(itkImageToImageFilterIVF22ICVF42 self) -> itkImageVF22
        GetInput(itkImageToImageFilterIVF22ICVF42 self, unsigned int idx) -> itkImageVF22
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF22ICVF42_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageVF22') -> "void":
        """
        PushBackInput(itkImageToImageFilterIVF22ICVF42 self, itkImageVF22 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF22ICVF42_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIVF22ICVF42 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF22ICVF42_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageVF22') -> "void":
        """PushFrontInput(itkImageToImageFilterIVF22ICVF42 self, itkImageVF22 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF22ICVF42_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIVF22ICVF42 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF22ICVF42_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIVF22ICVF42 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF22ICVF42_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIVF22ICVF42 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF22ICVF42_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIVF22ICVF42 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF22ICVF42_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIVF22ICVF42 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF22ICVF42_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIVF22ICVF42

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF22ICVF42 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIVF22ICVF42"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF22ICVF42_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIVF22ICVF42

        Create a new object of the class itkImageToImageFilterIVF22ICVF42 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIVF22ICVF42.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIVF22ICVF42.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIVF22ICVF42.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIVF22ICVF42.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF22ICVF42_SetInput, None, itkImageToImageFilterIVF22ICVF42)
itkImageToImageFilterIVF22ICVF42.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF22ICVF42_GetInput, None, itkImageToImageFilterIVF22ICVF42)
itkImageToImageFilterIVF22ICVF42.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF22ICVF42_PushBackInput, None, itkImageToImageFilterIVF22ICVF42)
itkImageToImageFilterIVF22ICVF42.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF22ICVF42_PopBackInput, None, itkImageToImageFilterIVF22ICVF42)
itkImageToImageFilterIVF22ICVF42.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF22ICVF42_PushFrontInput, None, itkImageToImageFilterIVF22ICVF42)
itkImageToImageFilterIVF22ICVF42.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF22ICVF42_PopFrontInput, None, itkImageToImageFilterIVF22ICVF42)
itkImageToImageFilterIVF22ICVF42.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF22ICVF42_SetCoordinateTolerance, None, itkImageToImageFilterIVF22ICVF42)
itkImageToImageFilterIVF22ICVF42.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF22ICVF42_GetCoordinateTolerance, None, itkImageToImageFilterIVF22ICVF42)
itkImageToImageFilterIVF22ICVF42.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF22ICVF42_SetDirectionTolerance, None, itkImageToImageFilterIVF22ICVF42)
itkImageToImageFilterIVF22ICVF42.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF22ICVF42_GetDirectionTolerance, None, itkImageToImageFilterIVF22ICVF42)
itkImageToImageFilterIVF22ICVF42_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIVF22ICVF42_swigregister
itkImageToImageFilterIVF22ICVF42_swigregister(itkImageToImageFilterIVF22ICVF42)

def itkImageToImageFilterIVF22ICVF42_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF22ICVF42 *":
    """itkImageToImageFilterIVF22ICVF42_cast(itkLightObject obj) -> itkImageToImageFilterIVF22ICVF42"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIVF22ICVF42_cast(obj)

class itkImageToImageFilterIVF22IVF22(itkImageSourcePython.itkImageSourceIVF22):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIVF22IVF22 self, itkImageVF22 image)
        SetInput(itkImageToImageFilterIVF22IVF22 self, unsigned int arg0, itkImageVF22 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF22IVF22_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageVF22 const *":
        """
        GetInput(itkImageToImageFilterIVF22IVF22 self) -> itkImageVF22
        GetInput(itkImageToImageFilterIVF22IVF22 self, unsigned int idx) -> itkImageVF22
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF22IVF22_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageVF22') -> "void":
        """
        PushBackInput(itkImageToImageFilterIVF22IVF22 self, itkImageVF22 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF22IVF22_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIVF22IVF22 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF22IVF22_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageVF22') -> "void":
        """PushFrontInput(itkImageToImageFilterIVF22IVF22 self, itkImageVF22 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF22IVF22_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIVF22IVF22 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF22IVF22_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIVF22IVF22 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF22IVF22_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIVF22IVF22 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF22IVF22_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIVF22IVF22 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF22IVF22_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIVF22IVF22 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF22IVF22_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIVF22IVF22

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF22IVF22 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIVF22IVF22"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF22IVF22_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIVF22IVF22

        Create a new object of the class itkImageToImageFilterIVF22IVF22 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIVF22IVF22.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIVF22IVF22.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIVF22IVF22.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIVF22IVF22.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF22IVF22_SetInput, None, itkImageToImageFilterIVF22IVF22)
itkImageToImageFilterIVF22IVF22.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF22IVF22_GetInput, None, itkImageToImageFilterIVF22IVF22)
itkImageToImageFilterIVF22IVF22.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF22IVF22_PushBackInput, None, itkImageToImageFilterIVF22IVF22)
itkImageToImageFilterIVF22IVF22.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF22IVF22_PopBackInput, None, itkImageToImageFilterIVF22IVF22)
itkImageToImageFilterIVF22IVF22.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF22IVF22_PushFrontInput, None, itkImageToImageFilterIVF22IVF22)
itkImageToImageFilterIVF22IVF22.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF22IVF22_PopFrontInput, None, itkImageToImageFilterIVF22IVF22)
itkImageToImageFilterIVF22IVF22.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF22IVF22_SetCoordinateTolerance, None, itkImageToImageFilterIVF22IVF22)
itkImageToImageFilterIVF22IVF22.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF22IVF22_GetCoordinateTolerance, None, itkImageToImageFilterIVF22IVF22)
itkImageToImageFilterIVF22IVF22.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF22IVF22_SetDirectionTolerance, None, itkImageToImageFilterIVF22IVF22)
itkImageToImageFilterIVF22IVF22.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF22IVF22_GetDirectionTolerance, None, itkImageToImageFilterIVF22IVF22)
itkImageToImageFilterIVF22IVF22_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIVF22IVF22_swigregister
itkImageToImageFilterIVF22IVF22_swigregister(itkImageToImageFilterIVF22IVF22)

def itkImageToImageFilterIVF22IVF22_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF22IVF22 *":
    """itkImageToImageFilterIVF22IVF22_cast(itkLightObject obj) -> itkImageToImageFilterIVF22IVF22"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIVF22IVF22_cast(obj)

class itkImageToImageFilterIVF23ICVF23(itkImageSourcePython.itkImageSourceICVF23):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIVF23ICVF23 self, itkImageVF23 image)
        SetInput(itkImageToImageFilterIVF23ICVF23 self, unsigned int arg0, itkImageVF23 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF23ICVF23_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageVF23 const *":
        """
        GetInput(itkImageToImageFilterIVF23ICVF23 self) -> itkImageVF23
        GetInput(itkImageToImageFilterIVF23ICVF23 self, unsigned int idx) -> itkImageVF23
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF23ICVF23_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageVF23') -> "void":
        """
        PushBackInput(itkImageToImageFilterIVF23ICVF23 self, itkImageVF23 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF23ICVF23_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIVF23ICVF23 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF23ICVF23_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageVF23') -> "void":
        """PushFrontInput(itkImageToImageFilterIVF23ICVF23 self, itkImageVF23 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF23ICVF23_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIVF23ICVF23 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF23ICVF23_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIVF23ICVF23 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF23ICVF23_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIVF23ICVF23 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF23ICVF23_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIVF23ICVF23 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF23ICVF23_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIVF23ICVF23 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF23ICVF23_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIVF23ICVF23

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF23ICVF23 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIVF23ICVF23"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF23ICVF23_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIVF23ICVF23

        Create a new object of the class itkImageToImageFilterIVF23ICVF23 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIVF23ICVF23.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIVF23ICVF23.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIVF23ICVF23.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIVF23ICVF23.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF23ICVF23_SetInput, None, itkImageToImageFilterIVF23ICVF23)
itkImageToImageFilterIVF23ICVF23.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF23ICVF23_GetInput, None, itkImageToImageFilterIVF23ICVF23)
itkImageToImageFilterIVF23ICVF23.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF23ICVF23_PushBackInput, None, itkImageToImageFilterIVF23ICVF23)
itkImageToImageFilterIVF23ICVF23.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF23ICVF23_PopBackInput, None, itkImageToImageFilterIVF23ICVF23)
itkImageToImageFilterIVF23ICVF23.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF23ICVF23_PushFrontInput, None, itkImageToImageFilterIVF23ICVF23)
itkImageToImageFilterIVF23ICVF23.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF23ICVF23_PopFrontInput, None, itkImageToImageFilterIVF23ICVF23)
itkImageToImageFilterIVF23ICVF23.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF23ICVF23_SetCoordinateTolerance, None, itkImageToImageFilterIVF23ICVF23)
itkImageToImageFilterIVF23ICVF23.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF23ICVF23_GetCoordinateTolerance, None, itkImageToImageFilterIVF23ICVF23)
itkImageToImageFilterIVF23ICVF23.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF23ICVF23_SetDirectionTolerance, None, itkImageToImageFilterIVF23ICVF23)
itkImageToImageFilterIVF23ICVF23.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF23ICVF23_GetDirectionTolerance, None, itkImageToImageFilterIVF23ICVF23)
itkImageToImageFilterIVF23ICVF23_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIVF23ICVF23_swigregister
itkImageToImageFilterIVF23ICVF23_swigregister(itkImageToImageFilterIVF23ICVF23)

def itkImageToImageFilterIVF23ICVF23_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF23ICVF23 *":
    """itkImageToImageFilterIVF23ICVF23_cast(itkLightObject obj) -> itkImageToImageFilterIVF23ICVF23"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIVF23ICVF23_cast(obj)

class itkImageToImageFilterIVF23ICVF43(itkImageSourcePython.itkImageSourceICVF43):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIVF23ICVF43 self, itkImageVF23 image)
        SetInput(itkImageToImageFilterIVF23ICVF43 self, unsigned int arg0, itkImageVF23 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF23ICVF43_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageVF23 const *":
        """
        GetInput(itkImageToImageFilterIVF23ICVF43 self) -> itkImageVF23
        GetInput(itkImageToImageFilterIVF23ICVF43 self, unsigned int idx) -> itkImageVF23
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF23ICVF43_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageVF23') -> "void":
        """
        PushBackInput(itkImageToImageFilterIVF23ICVF43 self, itkImageVF23 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF23ICVF43_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIVF23ICVF43 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF23ICVF43_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageVF23') -> "void":
        """PushFrontInput(itkImageToImageFilterIVF23ICVF43 self, itkImageVF23 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF23ICVF43_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIVF23ICVF43 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF23ICVF43_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIVF23ICVF43 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF23ICVF43_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIVF23ICVF43 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF23ICVF43_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIVF23ICVF43 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF23ICVF43_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIVF23ICVF43 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF23ICVF43_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIVF23ICVF43

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF23ICVF43 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIVF23ICVF43"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF23ICVF43_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIVF23ICVF43

        Create a new object of the class itkImageToImageFilterIVF23ICVF43 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIVF23ICVF43.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIVF23ICVF43.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIVF23ICVF43.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIVF23ICVF43.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF23ICVF43_SetInput, None, itkImageToImageFilterIVF23ICVF43)
itkImageToImageFilterIVF23ICVF43.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF23ICVF43_GetInput, None, itkImageToImageFilterIVF23ICVF43)
itkImageToImageFilterIVF23ICVF43.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF23ICVF43_PushBackInput, None, itkImageToImageFilterIVF23ICVF43)
itkImageToImageFilterIVF23ICVF43.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF23ICVF43_PopBackInput, None, itkImageToImageFilterIVF23ICVF43)
itkImageToImageFilterIVF23ICVF43.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF23ICVF43_PushFrontInput, None, itkImageToImageFilterIVF23ICVF43)
itkImageToImageFilterIVF23ICVF43.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF23ICVF43_PopFrontInput, None, itkImageToImageFilterIVF23ICVF43)
itkImageToImageFilterIVF23ICVF43.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF23ICVF43_SetCoordinateTolerance, None, itkImageToImageFilterIVF23ICVF43)
itkImageToImageFilterIVF23ICVF43.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF23ICVF43_GetCoordinateTolerance, None, itkImageToImageFilterIVF23ICVF43)
itkImageToImageFilterIVF23ICVF43.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF23ICVF43_SetDirectionTolerance, None, itkImageToImageFilterIVF23ICVF43)
itkImageToImageFilterIVF23ICVF43.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF23ICVF43_GetDirectionTolerance, None, itkImageToImageFilterIVF23ICVF43)
itkImageToImageFilterIVF23ICVF43_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIVF23ICVF43_swigregister
itkImageToImageFilterIVF23ICVF43_swigregister(itkImageToImageFilterIVF23ICVF43)

def itkImageToImageFilterIVF23ICVF43_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF23ICVF43 *":
    """itkImageToImageFilterIVF23ICVF43_cast(itkLightObject obj) -> itkImageToImageFilterIVF23ICVF43"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIVF23ICVF43_cast(obj)

class itkImageToImageFilterIVF23IVF23(itkImageSourcePython.itkImageSourceIVF23):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIVF23IVF23 self, itkImageVF23 image)
        SetInput(itkImageToImageFilterIVF23IVF23 self, unsigned int arg0, itkImageVF23 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF23IVF23_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageVF23 const *":
        """
        GetInput(itkImageToImageFilterIVF23IVF23 self) -> itkImageVF23
        GetInput(itkImageToImageFilterIVF23IVF23 self, unsigned int idx) -> itkImageVF23
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF23IVF23_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageVF23') -> "void":
        """
        PushBackInput(itkImageToImageFilterIVF23IVF23 self, itkImageVF23 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF23IVF23_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIVF23IVF23 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF23IVF23_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageVF23') -> "void":
        """PushFrontInput(itkImageToImageFilterIVF23IVF23 self, itkImageVF23 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF23IVF23_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIVF23IVF23 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF23IVF23_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIVF23IVF23 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF23IVF23_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIVF23IVF23 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF23IVF23_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIVF23IVF23 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF23IVF23_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIVF23IVF23 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF23IVF23_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIVF23IVF23

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF23IVF23 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIVF23IVF23"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF23IVF23_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIVF23IVF23

        Create a new object of the class itkImageToImageFilterIVF23IVF23 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIVF23IVF23.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIVF23IVF23.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIVF23IVF23.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIVF23IVF23.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF23IVF23_SetInput, None, itkImageToImageFilterIVF23IVF23)
itkImageToImageFilterIVF23IVF23.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF23IVF23_GetInput, None, itkImageToImageFilterIVF23IVF23)
itkImageToImageFilterIVF23IVF23.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF23IVF23_PushBackInput, None, itkImageToImageFilterIVF23IVF23)
itkImageToImageFilterIVF23IVF23.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF23IVF23_PopBackInput, None, itkImageToImageFilterIVF23IVF23)
itkImageToImageFilterIVF23IVF23.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF23IVF23_PushFrontInput, None, itkImageToImageFilterIVF23IVF23)
itkImageToImageFilterIVF23IVF23.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF23IVF23_PopFrontInput, None, itkImageToImageFilterIVF23IVF23)
itkImageToImageFilterIVF23IVF23.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF23IVF23_SetCoordinateTolerance, None, itkImageToImageFilterIVF23IVF23)
itkImageToImageFilterIVF23IVF23.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF23IVF23_GetCoordinateTolerance, None, itkImageToImageFilterIVF23IVF23)
itkImageToImageFilterIVF23IVF23.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF23IVF23_SetDirectionTolerance, None, itkImageToImageFilterIVF23IVF23)
itkImageToImageFilterIVF23IVF23.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF23IVF23_GetDirectionTolerance, None, itkImageToImageFilterIVF23IVF23)
itkImageToImageFilterIVF23IVF23_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIVF23IVF23_swigregister
itkImageToImageFilterIVF23IVF23_swigregister(itkImageToImageFilterIVF23IVF23)

def itkImageToImageFilterIVF23IVF23_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF23IVF23 *":
    """itkImageToImageFilterIVF23IVF23_cast(itkLightObject obj) -> itkImageToImageFilterIVF23IVF23"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIVF23IVF23_cast(obj)

class itkImageToImageFilterIVF32ICVF32(itkImageSourcePython.itkImageSourceICVF32):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIVF32ICVF32 self, itkImageVF32 image)
        SetInput(itkImageToImageFilterIVF32ICVF32 self, unsigned int arg0, itkImageVF32 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF32ICVF32_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageVF32 const *":
        """
        GetInput(itkImageToImageFilterIVF32ICVF32 self) -> itkImageVF32
        GetInput(itkImageToImageFilterIVF32ICVF32 self, unsigned int idx) -> itkImageVF32
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF32ICVF32_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageVF32') -> "void":
        """
        PushBackInput(itkImageToImageFilterIVF32ICVF32 self, itkImageVF32 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF32ICVF32_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIVF32ICVF32 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF32ICVF32_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageVF32') -> "void":
        """PushFrontInput(itkImageToImageFilterIVF32ICVF32 self, itkImageVF32 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF32ICVF32_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIVF32ICVF32 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF32ICVF32_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIVF32ICVF32 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF32ICVF32_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIVF32ICVF32 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF32ICVF32_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIVF32ICVF32 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF32ICVF32_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIVF32ICVF32 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF32ICVF32_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIVF32ICVF32

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF32ICVF32 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIVF32ICVF32"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF32ICVF32_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIVF32ICVF32

        Create a new object of the class itkImageToImageFilterIVF32ICVF32 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIVF32ICVF32.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIVF32ICVF32.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIVF32ICVF32.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIVF32ICVF32.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF32ICVF32_SetInput, None, itkImageToImageFilterIVF32ICVF32)
itkImageToImageFilterIVF32ICVF32.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF32ICVF32_GetInput, None, itkImageToImageFilterIVF32ICVF32)
itkImageToImageFilterIVF32ICVF32.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF32ICVF32_PushBackInput, None, itkImageToImageFilterIVF32ICVF32)
itkImageToImageFilterIVF32ICVF32.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF32ICVF32_PopBackInput, None, itkImageToImageFilterIVF32ICVF32)
itkImageToImageFilterIVF32ICVF32.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF32ICVF32_PushFrontInput, None, itkImageToImageFilterIVF32ICVF32)
itkImageToImageFilterIVF32ICVF32.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF32ICVF32_PopFrontInput, None, itkImageToImageFilterIVF32ICVF32)
itkImageToImageFilterIVF32ICVF32.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF32ICVF32_SetCoordinateTolerance, None, itkImageToImageFilterIVF32ICVF32)
itkImageToImageFilterIVF32ICVF32.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF32ICVF32_GetCoordinateTolerance, None, itkImageToImageFilterIVF32ICVF32)
itkImageToImageFilterIVF32ICVF32.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF32ICVF32_SetDirectionTolerance, None, itkImageToImageFilterIVF32ICVF32)
itkImageToImageFilterIVF32ICVF32.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF32ICVF32_GetDirectionTolerance, None, itkImageToImageFilterIVF32ICVF32)
itkImageToImageFilterIVF32ICVF32_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIVF32ICVF32_swigregister
itkImageToImageFilterIVF32ICVF32_swigregister(itkImageToImageFilterIVF32ICVF32)

def itkImageToImageFilterIVF32ICVF32_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF32ICVF32 *":
    """itkImageToImageFilterIVF32ICVF32_cast(itkLightObject obj) -> itkImageToImageFilterIVF32ICVF32"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIVF32ICVF32_cast(obj)

class itkImageToImageFilterIVF32IVF32(itkImageSourcePython.itkImageSourceIVF32):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIVF32IVF32 self, itkImageVF32 image)
        SetInput(itkImageToImageFilterIVF32IVF32 self, unsigned int arg0, itkImageVF32 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF32IVF32_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageVF32 const *":
        """
        GetInput(itkImageToImageFilterIVF32IVF32 self) -> itkImageVF32
        GetInput(itkImageToImageFilterIVF32IVF32 self, unsigned int idx) -> itkImageVF32
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF32IVF32_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageVF32') -> "void":
        """
        PushBackInput(itkImageToImageFilterIVF32IVF32 self, itkImageVF32 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF32IVF32_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIVF32IVF32 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF32IVF32_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageVF32') -> "void":
        """PushFrontInput(itkImageToImageFilterIVF32IVF32 self, itkImageVF32 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF32IVF32_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIVF32IVF32 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF32IVF32_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIVF32IVF32 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF32IVF32_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIVF32IVF32 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF32IVF32_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIVF32IVF32 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF32IVF32_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIVF32IVF32 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF32IVF32_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIVF32IVF32

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF32IVF32 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIVF32IVF32"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF32IVF32_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIVF32IVF32

        Create a new object of the class itkImageToImageFilterIVF32IVF32 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIVF32IVF32.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIVF32IVF32.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIVF32IVF32.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIVF32IVF32.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF32IVF32_SetInput, None, itkImageToImageFilterIVF32IVF32)
itkImageToImageFilterIVF32IVF32.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF32IVF32_GetInput, None, itkImageToImageFilterIVF32IVF32)
itkImageToImageFilterIVF32IVF32.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF32IVF32_PushBackInput, None, itkImageToImageFilterIVF32IVF32)
itkImageToImageFilterIVF32IVF32.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF32IVF32_PopBackInput, None, itkImageToImageFilterIVF32IVF32)
itkImageToImageFilterIVF32IVF32.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF32IVF32_PushFrontInput, None, itkImageToImageFilterIVF32IVF32)
itkImageToImageFilterIVF32IVF32.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF32IVF32_PopFrontInput, None, itkImageToImageFilterIVF32IVF32)
itkImageToImageFilterIVF32IVF32.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF32IVF32_SetCoordinateTolerance, None, itkImageToImageFilterIVF32IVF32)
itkImageToImageFilterIVF32IVF32.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF32IVF32_GetCoordinateTolerance, None, itkImageToImageFilterIVF32IVF32)
itkImageToImageFilterIVF32IVF32.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF32IVF32_SetDirectionTolerance, None, itkImageToImageFilterIVF32IVF32)
itkImageToImageFilterIVF32IVF32.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF32IVF32_GetDirectionTolerance, None, itkImageToImageFilterIVF32IVF32)
itkImageToImageFilterIVF32IVF32_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIVF32IVF32_swigregister
itkImageToImageFilterIVF32IVF32_swigregister(itkImageToImageFilterIVF32IVF32)

def itkImageToImageFilterIVF32IVF32_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF32IVF32 *":
    """itkImageToImageFilterIVF32IVF32_cast(itkLightObject obj) -> itkImageToImageFilterIVF32IVF32"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIVF32IVF32_cast(obj)

class itkImageToImageFilterIVF33ICVF33(itkImageSourcePython.itkImageSourceICVF33):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIVF33ICVF33 self, itkImageVF33 image)
        SetInput(itkImageToImageFilterIVF33ICVF33 self, unsigned int arg0, itkImageVF33 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF33ICVF33_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageVF33 const *":
        """
        GetInput(itkImageToImageFilterIVF33ICVF33 self) -> itkImageVF33
        GetInput(itkImageToImageFilterIVF33ICVF33 self, unsigned int idx) -> itkImageVF33
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF33ICVF33_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageVF33') -> "void":
        """
        PushBackInput(itkImageToImageFilterIVF33ICVF33 self, itkImageVF33 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF33ICVF33_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIVF33ICVF33 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF33ICVF33_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageVF33') -> "void":
        """PushFrontInput(itkImageToImageFilterIVF33ICVF33 self, itkImageVF33 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF33ICVF33_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIVF33ICVF33 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF33ICVF33_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIVF33ICVF33 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF33ICVF33_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIVF33ICVF33 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF33ICVF33_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIVF33ICVF33 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF33ICVF33_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIVF33ICVF33 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF33ICVF33_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIVF33ICVF33

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF33ICVF33 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIVF33ICVF33"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF33ICVF33_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIVF33ICVF33

        Create a new object of the class itkImageToImageFilterIVF33ICVF33 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIVF33ICVF33.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIVF33ICVF33.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIVF33ICVF33.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIVF33ICVF33.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF33ICVF33_SetInput, None, itkImageToImageFilterIVF33ICVF33)
itkImageToImageFilterIVF33ICVF33.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF33ICVF33_GetInput, None, itkImageToImageFilterIVF33ICVF33)
itkImageToImageFilterIVF33ICVF33.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF33ICVF33_PushBackInput, None, itkImageToImageFilterIVF33ICVF33)
itkImageToImageFilterIVF33ICVF33.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF33ICVF33_PopBackInput, None, itkImageToImageFilterIVF33ICVF33)
itkImageToImageFilterIVF33ICVF33.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF33ICVF33_PushFrontInput, None, itkImageToImageFilterIVF33ICVF33)
itkImageToImageFilterIVF33ICVF33.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF33ICVF33_PopFrontInput, None, itkImageToImageFilterIVF33ICVF33)
itkImageToImageFilterIVF33ICVF33.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF33ICVF33_SetCoordinateTolerance, None, itkImageToImageFilterIVF33ICVF33)
itkImageToImageFilterIVF33ICVF33.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF33ICVF33_GetCoordinateTolerance, None, itkImageToImageFilterIVF33ICVF33)
itkImageToImageFilterIVF33ICVF33.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF33ICVF33_SetDirectionTolerance, None, itkImageToImageFilterIVF33ICVF33)
itkImageToImageFilterIVF33ICVF33.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF33ICVF33_GetDirectionTolerance, None, itkImageToImageFilterIVF33ICVF33)
itkImageToImageFilterIVF33ICVF33_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIVF33ICVF33_swigregister
itkImageToImageFilterIVF33ICVF33_swigregister(itkImageToImageFilterIVF33ICVF33)

def itkImageToImageFilterIVF33ICVF33_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF33ICVF33 *":
    """itkImageToImageFilterIVF33ICVF33_cast(itkLightObject obj) -> itkImageToImageFilterIVF33ICVF33"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIVF33ICVF33_cast(obj)

class itkImageToImageFilterIVF33IVF33(itkImageSourcePython.itkImageSourceIVF33):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIVF33IVF33 self, itkImageVF33 image)
        SetInput(itkImageToImageFilterIVF33IVF33 self, unsigned int arg0, itkImageVF33 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF33IVF33_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageVF33 const *":
        """
        GetInput(itkImageToImageFilterIVF33IVF33 self) -> itkImageVF33
        GetInput(itkImageToImageFilterIVF33IVF33 self, unsigned int idx) -> itkImageVF33
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF33IVF33_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageVF33') -> "void":
        """
        PushBackInput(itkImageToImageFilterIVF33IVF33 self, itkImageVF33 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF33IVF33_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIVF33IVF33 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF33IVF33_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageVF33') -> "void":
        """PushFrontInput(itkImageToImageFilterIVF33IVF33 self, itkImageVF33 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF33IVF33_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIVF33IVF33 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF33IVF33_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIVF33IVF33 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF33IVF33_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIVF33IVF33 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF33IVF33_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIVF33IVF33 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF33IVF33_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIVF33IVF33 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF33IVF33_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIVF33IVF33

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF33IVF33 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIVF33IVF33"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF33IVF33_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIVF33IVF33

        Create a new object of the class itkImageToImageFilterIVF33IVF33 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIVF33IVF33.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIVF33IVF33.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIVF33IVF33.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIVF33IVF33.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF33IVF33_SetInput, None, itkImageToImageFilterIVF33IVF33)
itkImageToImageFilterIVF33IVF33.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF33IVF33_GetInput, None, itkImageToImageFilterIVF33IVF33)
itkImageToImageFilterIVF33IVF33.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF33IVF33_PushBackInput, None, itkImageToImageFilterIVF33IVF33)
itkImageToImageFilterIVF33IVF33.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF33IVF33_PopBackInput, None, itkImageToImageFilterIVF33IVF33)
itkImageToImageFilterIVF33IVF33.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF33IVF33_PushFrontInput, None, itkImageToImageFilterIVF33IVF33)
itkImageToImageFilterIVF33IVF33.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF33IVF33_PopFrontInput, None, itkImageToImageFilterIVF33IVF33)
itkImageToImageFilterIVF33IVF33.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF33IVF33_SetCoordinateTolerance, None, itkImageToImageFilterIVF33IVF33)
itkImageToImageFilterIVF33IVF33.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF33IVF33_GetCoordinateTolerance, None, itkImageToImageFilterIVF33IVF33)
itkImageToImageFilterIVF33IVF33.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF33IVF33_SetDirectionTolerance, None, itkImageToImageFilterIVF33IVF33)
itkImageToImageFilterIVF33IVF33.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF33IVF33_GetDirectionTolerance, None, itkImageToImageFilterIVF33IVF33)
itkImageToImageFilterIVF33IVF33_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIVF33IVF33_swigregister
itkImageToImageFilterIVF33IVF33_swigregister(itkImageToImageFilterIVF33IVF33)

def itkImageToImageFilterIVF33IVF33_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF33IVF33 *":
    """itkImageToImageFilterIVF33IVF33_cast(itkLightObject obj) -> itkImageToImageFilterIVF33IVF33"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIVF33IVF33_cast(obj)

class itkImageToImageFilterIVF42ICVF42(itkImageSourcePython.itkImageSourceICVF42):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIVF42ICVF42 self, itkImageVF42 image)
        SetInput(itkImageToImageFilterIVF42ICVF42 self, unsigned int arg0, itkImageVF42 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF42ICVF42_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageVF42 const *":
        """
        GetInput(itkImageToImageFilterIVF42ICVF42 self) -> itkImageVF42
        GetInput(itkImageToImageFilterIVF42ICVF42 self, unsigned int idx) -> itkImageVF42
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF42ICVF42_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageVF42') -> "void":
        """
        PushBackInput(itkImageToImageFilterIVF42ICVF42 self, itkImageVF42 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF42ICVF42_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIVF42ICVF42 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF42ICVF42_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageVF42') -> "void":
        """PushFrontInput(itkImageToImageFilterIVF42ICVF42 self, itkImageVF42 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF42ICVF42_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIVF42ICVF42 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF42ICVF42_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIVF42ICVF42 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF42ICVF42_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIVF42ICVF42 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF42ICVF42_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIVF42ICVF42 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF42ICVF42_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIVF42ICVF42 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF42ICVF42_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIVF42ICVF42

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF42ICVF42 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIVF42ICVF42"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF42ICVF42_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIVF42ICVF42

        Create a new object of the class itkImageToImageFilterIVF42ICVF42 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIVF42ICVF42.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIVF42ICVF42.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIVF42ICVF42.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIVF42ICVF42.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF42ICVF42_SetInput, None, itkImageToImageFilterIVF42ICVF42)
itkImageToImageFilterIVF42ICVF42.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF42ICVF42_GetInput, None, itkImageToImageFilterIVF42ICVF42)
itkImageToImageFilterIVF42ICVF42.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF42ICVF42_PushBackInput, None, itkImageToImageFilterIVF42ICVF42)
itkImageToImageFilterIVF42ICVF42.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF42ICVF42_PopBackInput, None, itkImageToImageFilterIVF42ICVF42)
itkImageToImageFilterIVF42ICVF42.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF42ICVF42_PushFrontInput, None, itkImageToImageFilterIVF42ICVF42)
itkImageToImageFilterIVF42ICVF42.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF42ICVF42_PopFrontInput, None, itkImageToImageFilterIVF42ICVF42)
itkImageToImageFilterIVF42ICVF42.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF42ICVF42_SetCoordinateTolerance, None, itkImageToImageFilterIVF42ICVF42)
itkImageToImageFilterIVF42ICVF42.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF42ICVF42_GetCoordinateTolerance, None, itkImageToImageFilterIVF42ICVF42)
itkImageToImageFilterIVF42ICVF42.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF42ICVF42_SetDirectionTolerance, None, itkImageToImageFilterIVF42ICVF42)
itkImageToImageFilterIVF42ICVF42.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF42ICVF42_GetDirectionTolerance, None, itkImageToImageFilterIVF42ICVF42)
itkImageToImageFilterIVF42ICVF42_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIVF42ICVF42_swigregister
itkImageToImageFilterIVF42ICVF42_swigregister(itkImageToImageFilterIVF42ICVF42)

def itkImageToImageFilterIVF42ICVF42_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF42ICVF42 *":
    """itkImageToImageFilterIVF42ICVF42_cast(itkLightObject obj) -> itkImageToImageFilterIVF42ICVF42"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIVF42ICVF42_cast(obj)

class itkImageToImageFilterIVF42IVF42(itkImageSourcePython.itkImageSourceIVF42):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIVF42IVF42 self, itkImageVF42 image)
        SetInput(itkImageToImageFilterIVF42IVF42 self, unsigned int arg0, itkImageVF42 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF42IVF42_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageVF42 const *":
        """
        GetInput(itkImageToImageFilterIVF42IVF42 self) -> itkImageVF42
        GetInput(itkImageToImageFilterIVF42IVF42 self, unsigned int idx) -> itkImageVF42
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF42IVF42_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageVF42') -> "void":
        """
        PushBackInput(itkImageToImageFilterIVF42IVF42 self, itkImageVF42 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF42IVF42_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIVF42IVF42 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF42IVF42_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageVF42') -> "void":
        """PushFrontInput(itkImageToImageFilterIVF42IVF42 self, itkImageVF42 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF42IVF42_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIVF42IVF42 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF42IVF42_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIVF42IVF42 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF42IVF42_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIVF42IVF42 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF42IVF42_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIVF42IVF42 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF42IVF42_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIVF42IVF42 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF42IVF42_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIVF42IVF42

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF42IVF42 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIVF42IVF42"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF42IVF42_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIVF42IVF42

        Create a new object of the class itkImageToImageFilterIVF42IVF42 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIVF42IVF42.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIVF42IVF42.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIVF42IVF42.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIVF42IVF42.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF42IVF42_SetInput, None, itkImageToImageFilterIVF42IVF42)
itkImageToImageFilterIVF42IVF42.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF42IVF42_GetInput, None, itkImageToImageFilterIVF42IVF42)
itkImageToImageFilterIVF42IVF42.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF42IVF42_PushBackInput, None, itkImageToImageFilterIVF42IVF42)
itkImageToImageFilterIVF42IVF42.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF42IVF42_PopBackInput, None, itkImageToImageFilterIVF42IVF42)
itkImageToImageFilterIVF42IVF42.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF42IVF42_PushFrontInput, None, itkImageToImageFilterIVF42IVF42)
itkImageToImageFilterIVF42IVF42.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF42IVF42_PopFrontInput, None, itkImageToImageFilterIVF42IVF42)
itkImageToImageFilterIVF42IVF42.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF42IVF42_SetCoordinateTolerance, None, itkImageToImageFilterIVF42IVF42)
itkImageToImageFilterIVF42IVF42.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF42IVF42_GetCoordinateTolerance, None, itkImageToImageFilterIVF42IVF42)
itkImageToImageFilterIVF42IVF42.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF42IVF42_SetDirectionTolerance, None, itkImageToImageFilterIVF42IVF42)
itkImageToImageFilterIVF42IVF42.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF42IVF42_GetDirectionTolerance, None, itkImageToImageFilterIVF42IVF42)
itkImageToImageFilterIVF42IVF42_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIVF42IVF42_swigregister
itkImageToImageFilterIVF42IVF42_swigregister(itkImageToImageFilterIVF42IVF42)

def itkImageToImageFilterIVF42IVF42_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF42IVF42 *":
    """itkImageToImageFilterIVF42IVF42_cast(itkLightObject obj) -> itkImageToImageFilterIVF42IVF42"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIVF42IVF42_cast(obj)

class itkImageToImageFilterIVF43ICVF43(itkImageSourcePython.itkImageSourceICVF43):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIVF43ICVF43 self, itkImageVF43 image)
        SetInput(itkImageToImageFilterIVF43ICVF43 self, unsigned int arg0, itkImageVF43 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF43ICVF43_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageVF43 const *":
        """
        GetInput(itkImageToImageFilterIVF43ICVF43 self) -> itkImageVF43
        GetInput(itkImageToImageFilterIVF43ICVF43 self, unsigned int idx) -> itkImageVF43
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF43ICVF43_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageVF43') -> "void":
        """
        PushBackInput(itkImageToImageFilterIVF43ICVF43 self, itkImageVF43 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF43ICVF43_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIVF43ICVF43 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF43ICVF43_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageVF43') -> "void":
        """PushFrontInput(itkImageToImageFilterIVF43ICVF43 self, itkImageVF43 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF43ICVF43_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIVF43ICVF43 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF43ICVF43_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIVF43ICVF43 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF43ICVF43_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIVF43ICVF43 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF43ICVF43_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIVF43ICVF43 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF43ICVF43_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIVF43ICVF43 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF43ICVF43_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIVF43ICVF43

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF43ICVF43 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIVF43ICVF43"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF43ICVF43_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIVF43ICVF43

        Create a new object of the class itkImageToImageFilterIVF43ICVF43 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIVF43ICVF43.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIVF43ICVF43.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIVF43ICVF43.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIVF43ICVF43.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF43ICVF43_SetInput, None, itkImageToImageFilterIVF43ICVF43)
itkImageToImageFilterIVF43ICVF43.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF43ICVF43_GetInput, None, itkImageToImageFilterIVF43ICVF43)
itkImageToImageFilterIVF43ICVF43.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF43ICVF43_PushBackInput, None, itkImageToImageFilterIVF43ICVF43)
itkImageToImageFilterIVF43ICVF43.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF43ICVF43_PopBackInput, None, itkImageToImageFilterIVF43ICVF43)
itkImageToImageFilterIVF43ICVF43.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF43ICVF43_PushFrontInput, None, itkImageToImageFilterIVF43ICVF43)
itkImageToImageFilterIVF43ICVF43.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF43ICVF43_PopFrontInput, None, itkImageToImageFilterIVF43ICVF43)
itkImageToImageFilterIVF43ICVF43.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF43ICVF43_SetCoordinateTolerance, None, itkImageToImageFilterIVF43ICVF43)
itkImageToImageFilterIVF43ICVF43.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF43ICVF43_GetCoordinateTolerance, None, itkImageToImageFilterIVF43ICVF43)
itkImageToImageFilterIVF43ICVF43.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF43ICVF43_SetDirectionTolerance, None, itkImageToImageFilterIVF43ICVF43)
itkImageToImageFilterIVF43ICVF43.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF43ICVF43_GetDirectionTolerance, None, itkImageToImageFilterIVF43ICVF43)
itkImageToImageFilterIVF43ICVF43_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIVF43ICVF43_swigregister
itkImageToImageFilterIVF43ICVF43_swigregister(itkImageToImageFilterIVF43ICVF43)

def itkImageToImageFilterIVF43ICVF43_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF43ICVF43 *":
    """itkImageToImageFilterIVF43ICVF43_cast(itkLightObject obj) -> itkImageToImageFilterIVF43ICVF43"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIVF43ICVF43_cast(obj)

class itkImageToImageFilterIVF43IVF43(itkImageSourcePython.itkImageSourceIVF43):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIVF43IVF43 self, itkImageVF43 image)
        SetInput(itkImageToImageFilterIVF43IVF43 self, unsigned int arg0, itkImageVF43 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF43IVF43_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageVF43 const *":
        """
        GetInput(itkImageToImageFilterIVF43IVF43 self) -> itkImageVF43
        GetInput(itkImageToImageFilterIVF43IVF43 self, unsigned int idx) -> itkImageVF43
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF43IVF43_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageVF43') -> "void":
        """
        PushBackInput(itkImageToImageFilterIVF43IVF43 self, itkImageVF43 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF43IVF43_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIVF43IVF43 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF43IVF43_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageVF43') -> "void":
        """PushFrontInput(itkImageToImageFilterIVF43IVF43 self, itkImageVF43 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF43IVF43_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIVF43IVF43 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF43IVF43_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIVF43IVF43 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF43IVF43_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIVF43IVF43 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF43IVF43_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIVF43IVF43 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF43IVF43_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIVF43IVF43 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF43IVF43_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterIVF43IVF43

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF43IVF43 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIVF43IVF43"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterIVF43IVF43_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIVF43IVF43

        Create a new object of the class itkImageToImageFilterIVF43IVF43 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIVF43IVF43.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIVF43IVF43.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIVF43IVF43.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIVF43IVF43.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF43IVF43_SetInput, None, itkImageToImageFilterIVF43IVF43)
itkImageToImageFilterIVF43IVF43.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF43IVF43_GetInput, None, itkImageToImageFilterIVF43IVF43)
itkImageToImageFilterIVF43IVF43.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF43IVF43_PushBackInput, None, itkImageToImageFilterIVF43IVF43)
itkImageToImageFilterIVF43IVF43.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF43IVF43_PopBackInput, None, itkImageToImageFilterIVF43IVF43)
itkImageToImageFilterIVF43IVF43.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF43IVF43_PushFrontInput, None, itkImageToImageFilterIVF43IVF43)
itkImageToImageFilterIVF43IVF43.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF43IVF43_PopFrontInput, None, itkImageToImageFilterIVF43IVF43)
itkImageToImageFilterIVF43IVF43.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF43IVF43_SetCoordinateTolerance, None, itkImageToImageFilterIVF43IVF43)
itkImageToImageFilterIVF43IVF43.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF43IVF43_GetCoordinateTolerance, None, itkImageToImageFilterIVF43IVF43)
itkImageToImageFilterIVF43IVF43.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF43IVF43_SetDirectionTolerance, None, itkImageToImageFilterIVF43IVF43)
itkImageToImageFilterIVF43IVF43.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterIVF43IVF43_GetDirectionTolerance, None, itkImageToImageFilterIVF43IVF43)
itkImageToImageFilterIVF43IVF43_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterIVF43IVF43_swigregister
itkImageToImageFilterIVF43IVF43_swigregister(itkImageToImageFilterIVF43IVF43)

def itkImageToImageFilterIVF43IVF43_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF43IVF43 *":
    """itkImageToImageFilterIVF43IVF43_cast(itkLightObject obj) -> itkImageToImageFilterIVF43IVF43"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterIVF43IVF43_cast(obj)

class itkImageToImageFilterVID2VID2(itkImageSourcePython.itkImageSourceVID2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterVID2VID2 self, itkVectorImageD2 image)
        SetInput(itkImageToImageFilterVID2VID2 self, unsigned int arg0, itkVectorImageD2 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterVID2VID2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkVectorImageD2 const *":
        """
        GetInput(itkImageToImageFilterVID2VID2 self) -> itkVectorImageD2
        GetInput(itkImageToImageFilterVID2VID2 self, unsigned int idx) -> itkVectorImageD2
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterVID2VID2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkVectorImageD2') -> "void":
        """
        PushBackInput(itkImageToImageFilterVID2VID2 self, itkVectorImageD2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterVID2VID2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterVID2VID2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterVID2VID2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkVectorImageD2') -> "void":
        """PushFrontInput(itkImageToImageFilterVID2VID2 self, itkVectorImageD2 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterVID2VID2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterVID2VID2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterVID2VID2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterVID2VID2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterVID2VID2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterVID2VID2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterVID2VID2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterVID2VID2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterVID2VID2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterVID2VID2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterVID2VID2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterVID2VID2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterVID2VID2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterVID2VID2"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterVID2VID2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterVID2VID2

        Create a new object of the class itkImageToImageFilterVID2VID2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterVID2VID2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterVID2VID2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterVID2VID2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterVID2VID2.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVID2VID2_SetInput, None, itkImageToImageFilterVID2VID2)
itkImageToImageFilterVID2VID2.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVID2VID2_GetInput, None, itkImageToImageFilterVID2VID2)
itkImageToImageFilterVID2VID2.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVID2VID2_PushBackInput, None, itkImageToImageFilterVID2VID2)
itkImageToImageFilterVID2VID2.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVID2VID2_PopBackInput, None, itkImageToImageFilterVID2VID2)
itkImageToImageFilterVID2VID2.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVID2VID2_PushFrontInput, None, itkImageToImageFilterVID2VID2)
itkImageToImageFilterVID2VID2.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVID2VID2_PopFrontInput, None, itkImageToImageFilterVID2VID2)
itkImageToImageFilterVID2VID2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVID2VID2_SetCoordinateTolerance, None, itkImageToImageFilterVID2VID2)
itkImageToImageFilterVID2VID2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVID2VID2_GetCoordinateTolerance, None, itkImageToImageFilterVID2VID2)
itkImageToImageFilterVID2VID2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVID2VID2_SetDirectionTolerance, None, itkImageToImageFilterVID2VID2)
itkImageToImageFilterVID2VID2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVID2VID2_GetDirectionTolerance, None, itkImageToImageFilterVID2VID2)
itkImageToImageFilterVID2VID2_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterVID2VID2_swigregister
itkImageToImageFilterVID2VID2_swigregister(itkImageToImageFilterVID2VID2)

def itkImageToImageFilterVID2VID2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterVID2VID2 *":
    """itkImageToImageFilterVID2VID2_cast(itkLightObject obj) -> itkImageToImageFilterVID2VID2"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterVID2VID2_cast(obj)

class itkImageToImageFilterVID3VID3(itkImageSourcePython.itkImageSourceVID3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterVID3VID3 self, itkVectorImageD3 image)
        SetInput(itkImageToImageFilterVID3VID3 self, unsigned int arg0, itkVectorImageD3 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterVID3VID3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkVectorImageD3 const *":
        """
        GetInput(itkImageToImageFilterVID3VID3 self) -> itkVectorImageD3
        GetInput(itkImageToImageFilterVID3VID3 self, unsigned int idx) -> itkVectorImageD3
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterVID3VID3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkVectorImageD3') -> "void":
        """
        PushBackInput(itkImageToImageFilterVID3VID3 self, itkVectorImageD3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterVID3VID3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterVID3VID3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterVID3VID3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkVectorImageD3') -> "void":
        """PushFrontInput(itkImageToImageFilterVID3VID3 self, itkVectorImageD3 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterVID3VID3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterVID3VID3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterVID3VID3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterVID3VID3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterVID3VID3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterVID3VID3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterVID3VID3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterVID3VID3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterVID3VID3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterVID3VID3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterVID3VID3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterVID3VID3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterVID3VID3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterVID3VID3"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterVID3VID3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterVID3VID3

        Create a new object of the class itkImageToImageFilterVID3VID3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterVID3VID3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterVID3VID3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterVID3VID3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterVID3VID3.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVID3VID3_SetInput, None, itkImageToImageFilterVID3VID3)
itkImageToImageFilterVID3VID3.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVID3VID3_GetInput, None, itkImageToImageFilterVID3VID3)
itkImageToImageFilterVID3VID3.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVID3VID3_PushBackInput, None, itkImageToImageFilterVID3VID3)
itkImageToImageFilterVID3VID3.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVID3VID3_PopBackInput, None, itkImageToImageFilterVID3VID3)
itkImageToImageFilterVID3VID3.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVID3VID3_PushFrontInput, None, itkImageToImageFilterVID3VID3)
itkImageToImageFilterVID3VID3.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVID3VID3_PopFrontInput, None, itkImageToImageFilterVID3VID3)
itkImageToImageFilterVID3VID3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVID3VID3_SetCoordinateTolerance, None, itkImageToImageFilterVID3VID3)
itkImageToImageFilterVID3VID3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVID3VID3_GetCoordinateTolerance, None, itkImageToImageFilterVID3VID3)
itkImageToImageFilterVID3VID3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVID3VID3_SetDirectionTolerance, None, itkImageToImageFilterVID3VID3)
itkImageToImageFilterVID3VID3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVID3VID3_GetDirectionTolerance, None, itkImageToImageFilterVID3VID3)
itkImageToImageFilterVID3VID3_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterVID3VID3_swigregister
itkImageToImageFilterVID3VID3_swigregister(itkImageToImageFilterVID3VID3)

def itkImageToImageFilterVID3VID3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterVID3VID3 *":
    """itkImageToImageFilterVID3VID3_cast(itkLightObject obj) -> itkImageToImageFilterVID3VID3"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterVID3VID3_cast(obj)

class itkImageToImageFilterVIF2VIF2(itkImageSourcePython.itkImageSourceVIF2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterVIF2VIF2 self, itkVectorImageF2 image)
        SetInput(itkImageToImageFilterVIF2VIF2 self, unsigned int arg0, itkVectorImageF2 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIF2VIF2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkVectorImageF2 const *":
        """
        GetInput(itkImageToImageFilterVIF2VIF2 self) -> itkVectorImageF2
        GetInput(itkImageToImageFilterVIF2VIF2 self, unsigned int idx) -> itkVectorImageF2
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIF2VIF2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkVectorImageF2') -> "void":
        """
        PushBackInput(itkImageToImageFilterVIF2VIF2 self, itkVectorImageF2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIF2VIF2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterVIF2VIF2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIF2VIF2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkVectorImageF2') -> "void":
        """PushFrontInput(itkImageToImageFilterVIF2VIF2 self, itkVectorImageF2 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIF2VIF2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterVIF2VIF2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIF2VIF2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterVIF2VIF2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIF2VIF2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterVIF2VIF2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIF2VIF2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterVIF2VIF2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIF2VIF2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterVIF2VIF2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIF2VIF2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterVIF2VIF2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIF2VIF2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterVIF2VIF2"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIF2VIF2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterVIF2VIF2

        Create a new object of the class itkImageToImageFilterVIF2VIF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterVIF2VIF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterVIF2VIF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterVIF2VIF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterVIF2VIF2.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVIF2VIF2_SetInput, None, itkImageToImageFilterVIF2VIF2)
itkImageToImageFilterVIF2VIF2.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVIF2VIF2_GetInput, None, itkImageToImageFilterVIF2VIF2)
itkImageToImageFilterVIF2VIF2.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVIF2VIF2_PushBackInput, None, itkImageToImageFilterVIF2VIF2)
itkImageToImageFilterVIF2VIF2.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVIF2VIF2_PopBackInput, None, itkImageToImageFilterVIF2VIF2)
itkImageToImageFilterVIF2VIF2.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVIF2VIF2_PushFrontInput, None, itkImageToImageFilterVIF2VIF2)
itkImageToImageFilterVIF2VIF2.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVIF2VIF2_PopFrontInput, None, itkImageToImageFilterVIF2VIF2)
itkImageToImageFilterVIF2VIF2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVIF2VIF2_SetCoordinateTolerance, None, itkImageToImageFilterVIF2VIF2)
itkImageToImageFilterVIF2VIF2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVIF2VIF2_GetCoordinateTolerance, None, itkImageToImageFilterVIF2VIF2)
itkImageToImageFilterVIF2VIF2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVIF2VIF2_SetDirectionTolerance, None, itkImageToImageFilterVIF2VIF2)
itkImageToImageFilterVIF2VIF2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVIF2VIF2_GetDirectionTolerance, None, itkImageToImageFilterVIF2VIF2)
itkImageToImageFilterVIF2VIF2_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterVIF2VIF2_swigregister
itkImageToImageFilterVIF2VIF2_swigregister(itkImageToImageFilterVIF2VIF2)

def itkImageToImageFilterVIF2VIF2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIF2VIF2 *":
    """itkImageToImageFilterVIF2VIF2_cast(itkLightObject obj) -> itkImageToImageFilterVIF2VIF2"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterVIF2VIF2_cast(obj)

class itkImageToImageFilterVIF3VIF3(itkImageSourcePython.itkImageSourceVIF3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterVIF3VIF3 self, itkVectorImageF3 image)
        SetInput(itkImageToImageFilterVIF3VIF3 self, unsigned int arg0, itkVectorImageF3 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIF3VIF3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkVectorImageF3 const *":
        """
        GetInput(itkImageToImageFilterVIF3VIF3 self) -> itkVectorImageF3
        GetInput(itkImageToImageFilterVIF3VIF3 self, unsigned int idx) -> itkVectorImageF3
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIF3VIF3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkVectorImageF3') -> "void":
        """
        PushBackInput(itkImageToImageFilterVIF3VIF3 self, itkVectorImageF3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIF3VIF3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterVIF3VIF3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIF3VIF3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkVectorImageF3') -> "void":
        """PushFrontInput(itkImageToImageFilterVIF3VIF3 self, itkVectorImageF3 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIF3VIF3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterVIF3VIF3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIF3VIF3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterVIF3VIF3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIF3VIF3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterVIF3VIF3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIF3VIF3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterVIF3VIF3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIF3VIF3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterVIF3VIF3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIF3VIF3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterVIF3VIF3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIF3VIF3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterVIF3VIF3"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIF3VIF3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterVIF3VIF3

        Create a new object of the class itkImageToImageFilterVIF3VIF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterVIF3VIF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterVIF3VIF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterVIF3VIF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterVIF3VIF3.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVIF3VIF3_SetInput, None, itkImageToImageFilterVIF3VIF3)
itkImageToImageFilterVIF3VIF3.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVIF3VIF3_GetInput, None, itkImageToImageFilterVIF3VIF3)
itkImageToImageFilterVIF3VIF3.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVIF3VIF3_PushBackInput, None, itkImageToImageFilterVIF3VIF3)
itkImageToImageFilterVIF3VIF3.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVIF3VIF3_PopBackInput, None, itkImageToImageFilterVIF3VIF3)
itkImageToImageFilterVIF3VIF3.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVIF3VIF3_PushFrontInput, None, itkImageToImageFilterVIF3VIF3)
itkImageToImageFilterVIF3VIF3.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVIF3VIF3_PopFrontInput, None, itkImageToImageFilterVIF3VIF3)
itkImageToImageFilterVIF3VIF3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVIF3VIF3_SetCoordinateTolerance, None, itkImageToImageFilterVIF3VIF3)
itkImageToImageFilterVIF3VIF3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVIF3VIF3_GetCoordinateTolerance, None, itkImageToImageFilterVIF3VIF3)
itkImageToImageFilterVIF3VIF3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVIF3VIF3_SetDirectionTolerance, None, itkImageToImageFilterVIF3VIF3)
itkImageToImageFilterVIF3VIF3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVIF3VIF3_GetDirectionTolerance, None, itkImageToImageFilterVIF3VIF3)
itkImageToImageFilterVIF3VIF3_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterVIF3VIF3_swigregister
itkImageToImageFilterVIF3VIF3_swigregister(itkImageToImageFilterVIF3VIF3)

def itkImageToImageFilterVIF3VIF3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIF3VIF3 *":
    """itkImageToImageFilterVIF3VIF3_cast(itkLightObject obj) -> itkImageToImageFilterVIF3VIF3"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterVIF3VIF3_cast(obj)

class itkImageToImageFilterVISS2VISS2(itkImageSourcePython.itkImageSourceVISS2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterVISS2VISS2 self, itkVectorImageSS2 image)
        SetInput(itkImageToImageFilterVISS2VISS2 self, unsigned int arg0, itkVectorImageSS2 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterVISS2VISS2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkVectorImageSS2 const *":
        """
        GetInput(itkImageToImageFilterVISS2VISS2 self) -> itkVectorImageSS2
        GetInput(itkImageToImageFilterVISS2VISS2 self, unsigned int idx) -> itkVectorImageSS2
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterVISS2VISS2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkVectorImageSS2') -> "void":
        """
        PushBackInput(itkImageToImageFilterVISS2VISS2 self, itkVectorImageSS2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterVISS2VISS2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterVISS2VISS2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterVISS2VISS2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkVectorImageSS2') -> "void":
        """PushFrontInput(itkImageToImageFilterVISS2VISS2 self, itkVectorImageSS2 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterVISS2VISS2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterVISS2VISS2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterVISS2VISS2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterVISS2VISS2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterVISS2VISS2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterVISS2VISS2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterVISS2VISS2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterVISS2VISS2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterVISS2VISS2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterVISS2VISS2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterVISS2VISS2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterVISS2VISS2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterVISS2VISS2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterVISS2VISS2"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterVISS2VISS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterVISS2VISS2

        Create a new object of the class itkImageToImageFilterVISS2VISS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterVISS2VISS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterVISS2VISS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterVISS2VISS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterVISS2VISS2.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVISS2VISS2_SetInput, None, itkImageToImageFilterVISS2VISS2)
itkImageToImageFilterVISS2VISS2.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVISS2VISS2_GetInput, None, itkImageToImageFilterVISS2VISS2)
itkImageToImageFilterVISS2VISS2.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVISS2VISS2_PushBackInput, None, itkImageToImageFilterVISS2VISS2)
itkImageToImageFilterVISS2VISS2.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVISS2VISS2_PopBackInput, None, itkImageToImageFilterVISS2VISS2)
itkImageToImageFilterVISS2VISS2.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVISS2VISS2_PushFrontInput, None, itkImageToImageFilterVISS2VISS2)
itkImageToImageFilterVISS2VISS2.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVISS2VISS2_PopFrontInput, None, itkImageToImageFilterVISS2VISS2)
itkImageToImageFilterVISS2VISS2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVISS2VISS2_SetCoordinateTolerance, None, itkImageToImageFilterVISS2VISS2)
itkImageToImageFilterVISS2VISS2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVISS2VISS2_GetCoordinateTolerance, None, itkImageToImageFilterVISS2VISS2)
itkImageToImageFilterVISS2VISS2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVISS2VISS2_SetDirectionTolerance, None, itkImageToImageFilterVISS2VISS2)
itkImageToImageFilterVISS2VISS2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVISS2VISS2_GetDirectionTolerance, None, itkImageToImageFilterVISS2VISS2)
itkImageToImageFilterVISS2VISS2_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterVISS2VISS2_swigregister
itkImageToImageFilterVISS2VISS2_swigregister(itkImageToImageFilterVISS2VISS2)

def itkImageToImageFilterVISS2VISS2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterVISS2VISS2 *":
    """itkImageToImageFilterVISS2VISS2_cast(itkLightObject obj) -> itkImageToImageFilterVISS2VISS2"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterVISS2VISS2_cast(obj)

class itkImageToImageFilterVISS3VISS3(itkImageSourcePython.itkImageSourceVISS3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterVISS3VISS3 self, itkVectorImageSS3 image)
        SetInput(itkImageToImageFilterVISS3VISS3 self, unsigned int arg0, itkVectorImageSS3 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterVISS3VISS3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkVectorImageSS3 const *":
        """
        GetInput(itkImageToImageFilterVISS3VISS3 self) -> itkVectorImageSS3
        GetInput(itkImageToImageFilterVISS3VISS3 self, unsigned int idx) -> itkVectorImageSS3
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterVISS3VISS3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkVectorImageSS3') -> "void":
        """
        PushBackInput(itkImageToImageFilterVISS3VISS3 self, itkVectorImageSS3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterVISS3VISS3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterVISS3VISS3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterVISS3VISS3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkVectorImageSS3') -> "void":
        """PushFrontInput(itkImageToImageFilterVISS3VISS3 self, itkVectorImageSS3 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterVISS3VISS3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterVISS3VISS3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterVISS3VISS3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterVISS3VISS3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterVISS3VISS3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterVISS3VISS3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterVISS3VISS3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterVISS3VISS3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterVISS3VISS3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterVISS3VISS3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterVISS3VISS3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterVISS3VISS3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterVISS3VISS3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterVISS3VISS3"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterVISS3VISS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterVISS3VISS3

        Create a new object of the class itkImageToImageFilterVISS3VISS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterVISS3VISS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterVISS3VISS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterVISS3VISS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterVISS3VISS3.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVISS3VISS3_SetInput, None, itkImageToImageFilterVISS3VISS3)
itkImageToImageFilterVISS3VISS3.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVISS3VISS3_GetInput, None, itkImageToImageFilterVISS3VISS3)
itkImageToImageFilterVISS3VISS3.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVISS3VISS3_PushBackInput, None, itkImageToImageFilterVISS3VISS3)
itkImageToImageFilterVISS3VISS3.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVISS3VISS3_PopBackInput, None, itkImageToImageFilterVISS3VISS3)
itkImageToImageFilterVISS3VISS3.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVISS3VISS3_PushFrontInput, None, itkImageToImageFilterVISS3VISS3)
itkImageToImageFilterVISS3VISS3.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVISS3VISS3_PopFrontInput, None, itkImageToImageFilterVISS3VISS3)
itkImageToImageFilterVISS3VISS3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVISS3VISS3_SetCoordinateTolerance, None, itkImageToImageFilterVISS3VISS3)
itkImageToImageFilterVISS3VISS3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVISS3VISS3_GetCoordinateTolerance, None, itkImageToImageFilterVISS3VISS3)
itkImageToImageFilterVISS3VISS3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVISS3VISS3_SetDirectionTolerance, None, itkImageToImageFilterVISS3VISS3)
itkImageToImageFilterVISS3VISS3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVISS3VISS3_GetDirectionTolerance, None, itkImageToImageFilterVISS3VISS3)
itkImageToImageFilterVISS3VISS3_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterVISS3VISS3_swigregister
itkImageToImageFilterVISS3VISS3_swigregister(itkImageToImageFilterVISS3VISS3)

def itkImageToImageFilterVISS3VISS3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterVISS3VISS3 *":
    """itkImageToImageFilterVISS3VISS3_cast(itkLightObject obj) -> itkImageToImageFilterVISS3VISS3"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterVISS3VISS3_cast(obj)

class itkImageToImageFilterVIUC2VIUC2(itkImageSourcePython.itkImageSourceVIUC2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterVIUC2VIUC2 self, itkVectorImageUC2 image)
        SetInput(itkImageToImageFilterVIUC2VIUC2 self, unsigned int arg0, itkVectorImageUC2 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIUC2VIUC2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkVectorImageUC2 const *":
        """
        GetInput(itkImageToImageFilterVIUC2VIUC2 self) -> itkVectorImageUC2
        GetInput(itkImageToImageFilterVIUC2VIUC2 self, unsigned int idx) -> itkVectorImageUC2
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIUC2VIUC2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkVectorImageUC2') -> "void":
        """
        PushBackInput(itkImageToImageFilterVIUC2VIUC2 self, itkVectorImageUC2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIUC2VIUC2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterVIUC2VIUC2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIUC2VIUC2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkVectorImageUC2') -> "void":
        """PushFrontInput(itkImageToImageFilterVIUC2VIUC2 self, itkVectorImageUC2 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIUC2VIUC2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterVIUC2VIUC2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIUC2VIUC2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterVIUC2VIUC2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIUC2VIUC2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterVIUC2VIUC2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIUC2VIUC2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterVIUC2VIUC2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIUC2VIUC2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterVIUC2VIUC2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIUC2VIUC2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterVIUC2VIUC2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIUC2VIUC2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterVIUC2VIUC2"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIUC2VIUC2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterVIUC2VIUC2

        Create a new object of the class itkImageToImageFilterVIUC2VIUC2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterVIUC2VIUC2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterVIUC2VIUC2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterVIUC2VIUC2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterVIUC2VIUC2.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVIUC2VIUC2_SetInput, None, itkImageToImageFilterVIUC2VIUC2)
itkImageToImageFilterVIUC2VIUC2.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVIUC2VIUC2_GetInput, None, itkImageToImageFilterVIUC2VIUC2)
itkImageToImageFilterVIUC2VIUC2.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVIUC2VIUC2_PushBackInput, None, itkImageToImageFilterVIUC2VIUC2)
itkImageToImageFilterVIUC2VIUC2.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVIUC2VIUC2_PopBackInput, None, itkImageToImageFilterVIUC2VIUC2)
itkImageToImageFilterVIUC2VIUC2.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVIUC2VIUC2_PushFrontInput, None, itkImageToImageFilterVIUC2VIUC2)
itkImageToImageFilterVIUC2VIUC2.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVIUC2VIUC2_PopFrontInput, None, itkImageToImageFilterVIUC2VIUC2)
itkImageToImageFilterVIUC2VIUC2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVIUC2VIUC2_SetCoordinateTolerance, None, itkImageToImageFilterVIUC2VIUC2)
itkImageToImageFilterVIUC2VIUC2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVIUC2VIUC2_GetCoordinateTolerance, None, itkImageToImageFilterVIUC2VIUC2)
itkImageToImageFilterVIUC2VIUC2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVIUC2VIUC2_SetDirectionTolerance, None, itkImageToImageFilterVIUC2VIUC2)
itkImageToImageFilterVIUC2VIUC2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVIUC2VIUC2_GetDirectionTolerance, None, itkImageToImageFilterVIUC2VIUC2)
itkImageToImageFilterVIUC2VIUC2_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterVIUC2VIUC2_swigregister
itkImageToImageFilterVIUC2VIUC2_swigregister(itkImageToImageFilterVIUC2VIUC2)

def itkImageToImageFilterVIUC2VIUC2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIUC2VIUC2 *":
    """itkImageToImageFilterVIUC2VIUC2_cast(itkLightObject obj) -> itkImageToImageFilterVIUC2VIUC2"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterVIUC2VIUC2_cast(obj)

class itkImageToImageFilterVIUC3VIUC3(itkImageSourcePython.itkImageSourceVIUC3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterVIUC3VIUC3 self, itkVectorImageUC3 image)
        SetInput(itkImageToImageFilterVIUC3VIUC3 self, unsigned int arg0, itkVectorImageUC3 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIUC3VIUC3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkVectorImageUC3 const *":
        """
        GetInput(itkImageToImageFilterVIUC3VIUC3 self) -> itkVectorImageUC3
        GetInput(itkImageToImageFilterVIUC3VIUC3 self, unsigned int idx) -> itkVectorImageUC3
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIUC3VIUC3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkVectorImageUC3') -> "void":
        """
        PushBackInput(itkImageToImageFilterVIUC3VIUC3 self, itkVectorImageUC3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIUC3VIUC3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterVIUC3VIUC3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIUC3VIUC3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkVectorImageUC3') -> "void":
        """PushFrontInput(itkImageToImageFilterVIUC3VIUC3 self, itkVectorImageUC3 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIUC3VIUC3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterVIUC3VIUC3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIUC3VIUC3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterVIUC3VIUC3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIUC3VIUC3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterVIUC3VIUC3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIUC3VIUC3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterVIUC3VIUC3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIUC3VIUC3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterVIUC3VIUC3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIUC3VIUC3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterVIUC3VIUC3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIUC3VIUC3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterVIUC3VIUC3"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIUC3VIUC3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterVIUC3VIUC3

        Create a new object of the class itkImageToImageFilterVIUC3VIUC3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterVIUC3VIUC3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterVIUC3VIUC3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterVIUC3VIUC3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterVIUC3VIUC3.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVIUC3VIUC3_SetInput, None, itkImageToImageFilterVIUC3VIUC3)
itkImageToImageFilterVIUC3VIUC3.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVIUC3VIUC3_GetInput, None, itkImageToImageFilterVIUC3VIUC3)
itkImageToImageFilterVIUC3VIUC3.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVIUC3VIUC3_PushBackInput, None, itkImageToImageFilterVIUC3VIUC3)
itkImageToImageFilterVIUC3VIUC3.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVIUC3VIUC3_PopBackInput, None, itkImageToImageFilterVIUC3VIUC3)
itkImageToImageFilterVIUC3VIUC3.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVIUC3VIUC3_PushFrontInput, None, itkImageToImageFilterVIUC3VIUC3)
itkImageToImageFilterVIUC3VIUC3.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVIUC3VIUC3_PopFrontInput, None, itkImageToImageFilterVIUC3VIUC3)
itkImageToImageFilterVIUC3VIUC3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVIUC3VIUC3_SetCoordinateTolerance, None, itkImageToImageFilterVIUC3VIUC3)
itkImageToImageFilterVIUC3VIUC3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVIUC3VIUC3_GetCoordinateTolerance, None, itkImageToImageFilterVIUC3VIUC3)
itkImageToImageFilterVIUC3VIUC3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVIUC3VIUC3_SetDirectionTolerance, None, itkImageToImageFilterVIUC3VIUC3)
itkImageToImageFilterVIUC3VIUC3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVIUC3VIUC3_GetDirectionTolerance, None, itkImageToImageFilterVIUC3VIUC3)
itkImageToImageFilterVIUC3VIUC3_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterVIUC3VIUC3_swigregister
itkImageToImageFilterVIUC3VIUC3_swigregister(itkImageToImageFilterVIUC3VIUC3)

def itkImageToImageFilterVIUC3VIUC3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIUC3VIUC3 *":
    """itkImageToImageFilterVIUC3VIUC3_cast(itkLightObject obj) -> itkImageToImageFilterVIUC3VIUC3"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterVIUC3VIUC3_cast(obj)

class itkImageToImageFilterVIUS2VIUS2(itkImageSourcePython.itkImageSourceVIUS2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterVIUS2VIUS2 self, itkVectorImageUS2 image)
        SetInput(itkImageToImageFilterVIUS2VIUS2 self, unsigned int arg0, itkVectorImageUS2 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIUS2VIUS2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkVectorImageUS2 const *":
        """
        GetInput(itkImageToImageFilterVIUS2VIUS2 self) -> itkVectorImageUS2
        GetInput(itkImageToImageFilterVIUS2VIUS2 self, unsigned int idx) -> itkVectorImageUS2
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIUS2VIUS2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkVectorImageUS2') -> "void":
        """
        PushBackInput(itkImageToImageFilterVIUS2VIUS2 self, itkVectorImageUS2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIUS2VIUS2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterVIUS2VIUS2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIUS2VIUS2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkVectorImageUS2') -> "void":
        """PushFrontInput(itkImageToImageFilterVIUS2VIUS2 self, itkVectorImageUS2 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIUS2VIUS2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterVIUS2VIUS2 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIUS2VIUS2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterVIUS2VIUS2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIUS2VIUS2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterVIUS2VIUS2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIUS2VIUS2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterVIUS2VIUS2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIUS2VIUS2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterVIUS2VIUS2 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIUS2VIUS2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterVIUS2VIUS2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIUS2VIUS2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterVIUS2VIUS2"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIUS2VIUS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterVIUS2VIUS2

        Create a new object of the class itkImageToImageFilterVIUS2VIUS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterVIUS2VIUS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterVIUS2VIUS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterVIUS2VIUS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterVIUS2VIUS2.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVIUS2VIUS2_SetInput, None, itkImageToImageFilterVIUS2VIUS2)
itkImageToImageFilterVIUS2VIUS2.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVIUS2VIUS2_GetInput, None, itkImageToImageFilterVIUS2VIUS2)
itkImageToImageFilterVIUS2VIUS2.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVIUS2VIUS2_PushBackInput, None, itkImageToImageFilterVIUS2VIUS2)
itkImageToImageFilterVIUS2VIUS2.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVIUS2VIUS2_PopBackInput, None, itkImageToImageFilterVIUS2VIUS2)
itkImageToImageFilterVIUS2VIUS2.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVIUS2VIUS2_PushFrontInput, None, itkImageToImageFilterVIUS2VIUS2)
itkImageToImageFilterVIUS2VIUS2.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVIUS2VIUS2_PopFrontInput, None, itkImageToImageFilterVIUS2VIUS2)
itkImageToImageFilterVIUS2VIUS2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVIUS2VIUS2_SetCoordinateTolerance, None, itkImageToImageFilterVIUS2VIUS2)
itkImageToImageFilterVIUS2VIUS2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVIUS2VIUS2_GetCoordinateTolerance, None, itkImageToImageFilterVIUS2VIUS2)
itkImageToImageFilterVIUS2VIUS2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVIUS2VIUS2_SetDirectionTolerance, None, itkImageToImageFilterVIUS2VIUS2)
itkImageToImageFilterVIUS2VIUS2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVIUS2VIUS2_GetDirectionTolerance, None, itkImageToImageFilterVIUS2VIUS2)
itkImageToImageFilterVIUS2VIUS2_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterVIUS2VIUS2_swigregister
itkImageToImageFilterVIUS2VIUS2_swigregister(itkImageToImageFilterVIUS2VIUS2)

def itkImageToImageFilterVIUS2VIUS2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIUS2VIUS2 *":
    """itkImageToImageFilterVIUS2VIUS2_cast(itkLightObject obj) -> itkImageToImageFilterVIUS2VIUS2"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterVIUS2VIUS2_cast(obj)

class itkImageToImageFilterVIUS3VIUS3(itkImageSourcePython.itkImageSourceVIUS3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterVIUS3VIUS3 self, itkVectorImageUS3 image)
        SetInput(itkImageToImageFilterVIUS3VIUS3 self, unsigned int arg0, itkVectorImageUS3 image)
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIUS3VIUS3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkVectorImageUS3 const *":
        """
        GetInput(itkImageToImageFilterVIUS3VIUS3 self) -> itkVectorImageUS3
        GetInput(itkImageToImageFilterVIUS3VIUS3 self, unsigned int idx) -> itkVectorImageUS3
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIUS3VIUS3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkVectorImageUS3') -> "void":
        """
        PushBackInput(itkImageToImageFilterVIUS3VIUS3 self, itkVectorImageUS3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIUS3VIUS3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterVIUS3VIUS3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIUS3VIUS3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkVectorImageUS3') -> "void":
        """PushFrontInput(itkImageToImageFilterVIUS3VIUS3 self, itkVectorImageUS3 image)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIUS3VIUS3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterVIUS3VIUS3 self)"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIUS3VIUS3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterVIUS3VIUS3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIUS3VIUS3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterVIUS3VIUS3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIUS3VIUS3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterVIUS3VIUS3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIUS3VIUS3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterVIUS3VIUS3 self) -> double"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIUS3VIUS3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterAPython.delete_itkImageToImageFilterVIUS3VIUS3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIUS3VIUS3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterVIUS3VIUS3"""
        return _itkImageToImageFilterAPython.itkImageToImageFilterVIUS3VIUS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterVIUS3VIUS3

        Create a new object of the class itkImageToImageFilterVIUS3VIUS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterVIUS3VIUS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterVIUS3VIUS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterVIUS3VIUS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterVIUS3VIUS3.SetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVIUS3VIUS3_SetInput, None, itkImageToImageFilterVIUS3VIUS3)
itkImageToImageFilterVIUS3VIUS3.GetInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVIUS3VIUS3_GetInput, None, itkImageToImageFilterVIUS3VIUS3)
itkImageToImageFilterVIUS3VIUS3.PushBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVIUS3VIUS3_PushBackInput, None, itkImageToImageFilterVIUS3VIUS3)
itkImageToImageFilterVIUS3VIUS3.PopBackInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVIUS3VIUS3_PopBackInput, None, itkImageToImageFilterVIUS3VIUS3)
itkImageToImageFilterVIUS3VIUS3.PushFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVIUS3VIUS3_PushFrontInput, None, itkImageToImageFilterVIUS3VIUS3)
itkImageToImageFilterVIUS3VIUS3.PopFrontInput = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVIUS3VIUS3_PopFrontInput, None, itkImageToImageFilterVIUS3VIUS3)
itkImageToImageFilterVIUS3VIUS3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVIUS3VIUS3_SetCoordinateTolerance, None, itkImageToImageFilterVIUS3VIUS3)
itkImageToImageFilterVIUS3VIUS3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVIUS3VIUS3_GetCoordinateTolerance, None, itkImageToImageFilterVIUS3VIUS3)
itkImageToImageFilterVIUS3VIUS3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVIUS3VIUS3_SetDirectionTolerance, None, itkImageToImageFilterVIUS3VIUS3)
itkImageToImageFilterVIUS3VIUS3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterAPython.itkImageToImageFilterVIUS3VIUS3_GetDirectionTolerance, None, itkImageToImageFilterVIUS3VIUS3)
itkImageToImageFilterVIUS3VIUS3_swigregister = _itkImageToImageFilterAPython.itkImageToImageFilterVIUS3VIUS3_swigregister
itkImageToImageFilterVIUS3VIUS3_swigregister(itkImageToImageFilterVIUS3VIUS3)

def itkImageToImageFilterVIUS3VIUS3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIUS3VIUS3 *":
    """itkImageToImageFilterVIUS3VIUS3_cast(itkLightObject obj) -> itkImageToImageFilterVIUS3VIUS3"""
    return _itkImageToImageFilterAPython.itkImageToImageFilterVIUS3VIUS3_cast(obj)


import itkHelpers
@itkHelpers.accept_numpy_array_like_xarray
def image_to_image_filter(*args, **kwargs):
    """Procedural interface for ImageToImageFilter"""
    import itk
    instance = itk.ImageToImageFilter.New(*args, **kwargs)
    return instance.__internal_call__()

def image_to_image_filter_init_docstring():
    import itk
    import itkTemplate
    import itkHelpers
    if isinstance(itk.ImageToImageFilter, itkTemplate.itkTemplate):
        filter_object = itk.ImageToImageFilter.values()[0]
    else:
        filter_object = itk.ImageToImageFilter

    image_to_image_filter.__doc__ = filter_object.__doc__
    image_to_image_filter.__doc__ += "\n Args are Input(s) to the filter.\n"
    image_to_image_filter.__doc__ += "Available Keyword Arguments:\n"
    image_to_image_filter.__doc__ += "".join([
        "  " + itkHelpers.camel_to_snake_case(item[3:]) + "\n"
        for item in dir(filter_object)
        if item[:3] == "Set"])



