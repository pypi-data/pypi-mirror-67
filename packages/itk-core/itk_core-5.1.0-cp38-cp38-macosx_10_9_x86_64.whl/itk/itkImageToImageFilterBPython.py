# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.8
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _itkImageToImageFilterBPython.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_itkImageToImageFilterBPython', [dirname(__file__)])
        except ImportError:
            import _itkImageToImageFilterBPython
            return _itkImageToImageFilterBPython
        if fp is not None:
            try:
                _mod = imp.load_module('_itkImageToImageFilterBPython', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _itkImageToImageFilterBPython = swig_import_helper()
    del swig_import_helper
else:
    import _itkImageToImageFilterBPython
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0



def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


import ITKCommonBasePython
import pyBasePython
import itkImageSourcePython
import itkImagePython
import itkCovariantVectorPython
import itkVectorPython
import vnl_vectorPython
import vnl_matrixPython
import stdcomplexPython
import vnl_vector_refPython
import itkFixedArrayPython
import itkRGBPixelPython
import itkPointPython
import itkOffsetPython
import itkSizePython
import itkMatrixPython
import vnl_matrix_fixedPython
import itkIndexPython
import itkRGBAPixelPython
import itkSymmetricSecondRankTensorPython
import itkImageRegionPython
import itkImageSourceCommonPython
import itkVectorImagePython
import itkVariableLengthVectorPython
import itkImageToImageFilterCommonPython

def itkImageToImageFilterID3ICVD33_New():
  return itkImageToImageFilterID3ICVD33.New()


def itkImageToImageFilterIF3ICVD33_New():
  return itkImageToImageFilterIF3ICVD33.New()


def itkImageToImageFilterID2ICVD22_New():
  return itkImageToImageFilterID2ICVD22.New()


def itkImageToImageFilterIF2ICVD22_New():
  return itkImageToImageFilterIF2ICVD22.New()


def itkImageToImageFilterICF3ICF2_New():
  return itkImageToImageFilterICF3ICF2.New()


def itkImageToImageFilterIRGBUC3IRGBUC2_New():
  return itkImageToImageFilterIRGBUC3IRGBUC2.New()


def itkImageToImageFilterID3ID2_New():
  return itkImageToImageFilterID3ID2.New()


def itkImageToImageFilterIF3IF2_New():
  return itkImageToImageFilterIF3IF2.New()


def itkImageToImageFilterIUS3IUS2_New():
  return itkImageToImageFilterIUS3IUS2.New()


def itkImageToImageFilterIUC3IUC2_New():
  return itkImageToImageFilterIUC3IUC2.New()


def itkImageToImageFilterISS3ISS2_New():
  return itkImageToImageFilterISS3ISS2.New()


def itkImageToImageFilterICF2ICF3_New():
  return itkImageToImageFilterICF2ICF3.New()


def itkImageToImageFilterIRGBUC2IRGBUC3_New():
  return itkImageToImageFilterIRGBUC2IRGBUC3.New()


def itkImageToImageFilterID2ID3_New():
  return itkImageToImageFilterID2ID3.New()


def itkImageToImageFilterIF2IF3_New():
  return itkImageToImageFilterIF2IF3.New()


def itkImageToImageFilterIUS2IUS3_New():
  return itkImageToImageFilterIUS2IUS3.New()


def itkImageToImageFilterIUC2IUC3_New():
  return itkImageToImageFilterIUC2IUC3.New()


def itkImageToImageFilterISS2ISS3_New():
  return itkImageToImageFilterISS2ISS3.New()


def itkImageToImageFilterISSRTD33ISSRTD33_New():
  return itkImageToImageFilterISSRTD33ISSRTD33.New()


def itkImageToImageFilterISSRTD33ID3_New():
  return itkImageToImageFilterISSRTD33ID3.New()


def itkImageToImageFilterID3ISSRTD33_New():
  return itkImageToImageFilterID3ISSRTD33.New()


def itkImageToImageFilterISSRTD33IF3_New():
  return itkImageToImageFilterISSRTD33IF3.New()


def itkImageToImageFilterIF3ISSRTD33_New():
  return itkImageToImageFilterIF3ISSRTD33.New()


def itkImageToImageFilterISSRTD33IUS3_New():
  return itkImageToImageFilterISSRTD33IUS3.New()


def itkImageToImageFilterIUS3ISSRTD33_New():
  return itkImageToImageFilterIUS3ISSRTD33.New()


def itkImageToImageFilterISSRTD33IUC3_New():
  return itkImageToImageFilterISSRTD33IUC3.New()


def itkImageToImageFilterIUC3ISSRTD33_New():
  return itkImageToImageFilterIUC3ISSRTD33.New()


def itkImageToImageFilterISSRTD33ISS3_New():
  return itkImageToImageFilterISSRTD33ISS3.New()


def itkImageToImageFilterISS3ISSRTD33_New():
  return itkImageToImageFilterISS3ISSRTD33.New()


def itkImageToImageFilterISSRTD22ISSRTD22_New():
  return itkImageToImageFilterISSRTD22ISSRTD22.New()


def itkImageToImageFilterISSRTD22ID2_New():
  return itkImageToImageFilterISSRTD22ID2.New()


def itkImageToImageFilterID2ISSRTD22_New():
  return itkImageToImageFilterID2ISSRTD22.New()


def itkImageToImageFilterISSRTD22IF2_New():
  return itkImageToImageFilterISSRTD22IF2.New()


def itkImageToImageFilterIF2ISSRTD22_New():
  return itkImageToImageFilterIF2ISSRTD22.New()


def itkImageToImageFilterISSRTD22IUS2_New():
  return itkImageToImageFilterISSRTD22IUS2.New()


def itkImageToImageFilterIUS2ISSRTD22_New():
  return itkImageToImageFilterIUS2ISSRTD22.New()


def itkImageToImageFilterISSRTD22IUC2_New():
  return itkImageToImageFilterISSRTD22IUC2.New()


def itkImageToImageFilterIUC2ISSRTD22_New():
  return itkImageToImageFilterIUC2ISSRTD22.New()


def itkImageToImageFilterISSRTD22ISS2_New():
  return itkImageToImageFilterISSRTD22ISS2.New()


def itkImageToImageFilterISS2ISSRTD22_New():
  return itkImageToImageFilterISS2ISSRTD22.New()


def itkImageToImageFilterICF3ID3_New():
  return itkImageToImageFilterICF3ID3.New()


def itkImageToImageFilterICF2ID2_New():
  return itkImageToImageFilterICF2ID2.New()


def itkImageToImageFilterICF3IF3_New():
  return itkImageToImageFilterICF3IF3.New()


def itkImageToImageFilterICF2IF2_New():
  return itkImageToImageFilterICF2IF2.New()


def itkImageToImageFilterICF3IUS3_New():
  return itkImageToImageFilterICF3IUS3.New()


def itkImageToImageFilterICF2IUS2_New():
  return itkImageToImageFilterICF2IUS2.New()


def itkImageToImageFilterICF3IUC3_New():
  return itkImageToImageFilterICF3IUC3.New()


def itkImageToImageFilterICF2IUC2_New():
  return itkImageToImageFilterICF2IUC2.New()


def itkImageToImageFilterICF3ISS3_New():
  return itkImageToImageFilterICF3ISS3.New()


def itkImageToImageFilterICF2ISS2_New():
  return itkImageToImageFilterICF2ISS2.New()


def itkImageToImageFilterID3ICF3_New():
  return itkImageToImageFilterID3ICF3.New()


def itkImageToImageFilterID2ICF2_New():
  return itkImageToImageFilterID2ICF2.New()


def itkImageToImageFilterIF3ICF3_New():
  return itkImageToImageFilterIF3ICF3.New()


def itkImageToImageFilterIF2ICF2_New():
  return itkImageToImageFilterIF2ICF2.New()


def itkImageToImageFilterIUS3ICF3_New():
  return itkImageToImageFilterIUS3ICF3.New()


def itkImageToImageFilterIUS2ICF2_New():
  return itkImageToImageFilterIUS2ICF2.New()


def itkImageToImageFilterIUC3ICF3_New():
  return itkImageToImageFilterIUC3ICF3.New()


def itkImageToImageFilterIUC2ICF2_New():
  return itkImageToImageFilterIUC2ICF2.New()


def itkImageToImageFilterISS3ICF3_New():
  return itkImageToImageFilterISS3ICF3.New()


def itkImageToImageFilterISS2ICF2_New():
  return itkImageToImageFilterISS2ICF2.New()


def itkImageToImageFilterICF3ICF3_New():
  return itkImageToImageFilterICF3ICF3.New()


def itkImageToImageFilterICF2ICF2_New():
  return itkImageToImageFilterICF2ICF2.New()


def itkImageToImageFilterID3ICVF43_New():
  return itkImageToImageFilterID3ICVF43.New()


def itkImageToImageFilterID2ICVF42_New():
  return itkImageToImageFilterID2ICVF42.New()


def itkImageToImageFilterID3ICVF33_New():
  return itkImageToImageFilterID3ICVF33.New()


def itkImageToImageFilterID2ICVF32_New():
  return itkImageToImageFilterID2ICVF32.New()


def itkImageToImageFilterID3ICVF23_New():
  return itkImageToImageFilterID3ICVF23.New()


def itkImageToImageFilterID2ICVF22_New():
  return itkImageToImageFilterID2ICVF22.New()


def itkImageToImageFilterID3IVF43_New():
  return itkImageToImageFilterID3IVF43.New()


def itkImageToImageFilterID2IVF42_New():
  return itkImageToImageFilterID2IVF42.New()


def itkImageToImageFilterID3IVF33_New():
  return itkImageToImageFilterID3IVF33.New()


def itkImageToImageFilterID2IVF32_New():
  return itkImageToImageFilterID2IVF32.New()


def itkImageToImageFilterID3IVF23_New():
  return itkImageToImageFilterID3IVF23.New()


def itkImageToImageFilterID2IVF22_New():
  return itkImageToImageFilterID2IVF22.New()


def itkImageToImageFilterIF3ICVF43_New():
  return itkImageToImageFilterIF3ICVF43.New()


def itkImageToImageFilterIF2ICVF42_New():
  return itkImageToImageFilterIF2ICVF42.New()


def itkImageToImageFilterIF3ICVF33_New():
  return itkImageToImageFilterIF3ICVF33.New()


def itkImageToImageFilterIF2ICVF32_New():
  return itkImageToImageFilterIF2ICVF32.New()


def itkImageToImageFilterIF3ICVF23_New():
  return itkImageToImageFilterIF3ICVF23.New()


def itkImageToImageFilterIF2ICVF22_New():
  return itkImageToImageFilterIF2ICVF22.New()


def itkImageToImageFilterIF3IVF43_New():
  return itkImageToImageFilterIF3IVF43.New()


def itkImageToImageFilterIF2IVF42_New():
  return itkImageToImageFilterIF2IVF42.New()


def itkImageToImageFilterIF3IVF33_New():
  return itkImageToImageFilterIF3IVF33.New()


def itkImageToImageFilterIF2IVF32_New():
  return itkImageToImageFilterIF2IVF32.New()


def itkImageToImageFilterIF3IVF23_New():
  return itkImageToImageFilterIF3IVF23.New()


def itkImageToImageFilterIF2IVF22_New():
  return itkImageToImageFilterIF2IVF22.New()


def itkImageToImageFilterIUS3ICVF43_New():
  return itkImageToImageFilterIUS3ICVF43.New()


def itkImageToImageFilterIUS2ICVF42_New():
  return itkImageToImageFilterIUS2ICVF42.New()


def itkImageToImageFilterIUS3ICVF33_New():
  return itkImageToImageFilterIUS3ICVF33.New()


def itkImageToImageFilterIUS2ICVF32_New():
  return itkImageToImageFilterIUS2ICVF32.New()


def itkImageToImageFilterIUS3ICVF23_New():
  return itkImageToImageFilterIUS3ICVF23.New()


def itkImageToImageFilterIUS2ICVF22_New():
  return itkImageToImageFilterIUS2ICVF22.New()


def itkImageToImageFilterIUS3IVF43_New():
  return itkImageToImageFilterIUS3IVF43.New()


def itkImageToImageFilterIUS2IVF42_New():
  return itkImageToImageFilterIUS2IVF42.New()


def itkImageToImageFilterIUS3IVF33_New():
  return itkImageToImageFilterIUS3IVF33.New()


def itkImageToImageFilterIUS2IVF32_New():
  return itkImageToImageFilterIUS2IVF32.New()


def itkImageToImageFilterIUS3IVF23_New():
  return itkImageToImageFilterIUS3IVF23.New()


def itkImageToImageFilterIUS2IVF22_New():
  return itkImageToImageFilterIUS2IVF22.New()


def itkImageToImageFilterIUC3ICVF43_New():
  return itkImageToImageFilterIUC3ICVF43.New()


def itkImageToImageFilterIUC2ICVF42_New():
  return itkImageToImageFilterIUC2ICVF42.New()


def itkImageToImageFilterIUC3ICVF33_New():
  return itkImageToImageFilterIUC3ICVF33.New()


def itkImageToImageFilterIUC2ICVF32_New():
  return itkImageToImageFilterIUC2ICVF32.New()


def itkImageToImageFilterIUC3ICVF23_New():
  return itkImageToImageFilterIUC3ICVF23.New()


def itkImageToImageFilterIUC2ICVF22_New():
  return itkImageToImageFilterIUC2ICVF22.New()


def itkImageToImageFilterIUC3IVF43_New():
  return itkImageToImageFilterIUC3IVF43.New()


def itkImageToImageFilterIUC2IVF42_New():
  return itkImageToImageFilterIUC2IVF42.New()


def itkImageToImageFilterIUC3IVF33_New():
  return itkImageToImageFilterIUC3IVF33.New()


def itkImageToImageFilterIUC2IVF32_New():
  return itkImageToImageFilterIUC2IVF32.New()


def itkImageToImageFilterIUC3IVF23_New():
  return itkImageToImageFilterIUC3IVF23.New()


def itkImageToImageFilterIUC2IVF22_New():
  return itkImageToImageFilterIUC2IVF22.New()


def itkImageToImageFilterISS3ICVF43_New():
  return itkImageToImageFilterISS3ICVF43.New()


def itkImageToImageFilterISS2ICVF42_New():
  return itkImageToImageFilterISS2ICVF42.New()


def itkImageToImageFilterISS3ICVF33_New():
  return itkImageToImageFilterISS3ICVF33.New()


def itkImageToImageFilterISS2ICVF32_New():
  return itkImageToImageFilterISS2ICVF32.New()


def itkImageToImageFilterISS3ICVF23_New():
  return itkImageToImageFilterISS3ICVF23.New()


def itkImageToImageFilterISS2ICVF22_New():
  return itkImageToImageFilterISS2ICVF22.New()


def itkImageToImageFilterISS3IVF43_New():
  return itkImageToImageFilterISS3IVF43.New()


def itkImageToImageFilterISS2IVF42_New():
  return itkImageToImageFilterISS2IVF42.New()


def itkImageToImageFilterISS3IVF33_New():
  return itkImageToImageFilterISS3IVF33.New()


def itkImageToImageFilterISS2IVF32_New():
  return itkImageToImageFilterISS2IVF32.New()


def itkImageToImageFilterISS3IVF23_New():
  return itkImageToImageFilterISS3IVF23.New()


def itkImageToImageFilterISS2IVF22_New():
  return itkImageToImageFilterISS2IVF22.New()


def itkImageToImageFilterICVF43ID3_New():
  return itkImageToImageFilterICVF43ID3.New()


def itkImageToImageFilterICVF42ID2_New():
  return itkImageToImageFilterICVF42ID2.New()


def itkImageToImageFilterICVF33ID3_New():
  return itkImageToImageFilterICVF33ID3.New()


def itkImageToImageFilterICVF32ID2_New():
  return itkImageToImageFilterICVF32ID2.New()


def itkImageToImageFilterICVF23ID3_New():
  return itkImageToImageFilterICVF23ID3.New()


def itkImageToImageFilterICVF22ID2_New():
  return itkImageToImageFilterICVF22ID2.New()


def itkImageToImageFilterICVF43IF3_New():
  return itkImageToImageFilterICVF43IF3.New()


def itkImageToImageFilterICVF42IF2_New():
  return itkImageToImageFilterICVF42IF2.New()


def itkImageToImageFilterICVF33IF3_New():
  return itkImageToImageFilterICVF33IF3.New()


def itkImageToImageFilterICVF32IF2_New():
  return itkImageToImageFilterICVF32IF2.New()


def itkImageToImageFilterICVF23IF3_New():
  return itkImageToImageFilterICVF23IF3.New()


def itkImageToImageFilterICVF22IF2_New():
  return itkImageToImageFilterICVF22IF2.New()


def itkImageToImageFilterICVF43IUS3_New():
  return itkImageToImageFilterICVF43IUS3.New()


def itkImageToImageFilterICVF42IUS2_New():
  return itkImageToImageFilterICVF42IUS2.New()


def itkImageToImageFilterICVF33IUS3_New():
  return itkImageToImageFilterICVF33IUS3.New()


def itkImageToImageFilterICVF32IUS2_New():
  return itkImageToImageFilterICVF32IUS2.New()


def itkImageToImageFilterICVF23IUS3_New():
  return itkImageToImageFilterICVF23IUS3.New()


def itkImageToImageFilterICVF22IUS2_New():
  return itkImageToImageFilterICVF22IUS2.New()


def itkImageToImageFilterICVF43IUC3_New():
  return itkImageToImageFilterICVF43IUC3.New()


def itkImageToImageFilterICVF42IUC2_New():
  return itkImageToImageFilterICVF42IUC2.New()


def itkImageToImageFilterICVF33IUC3_New():
  return itkImageToImageFilterICVF33IUC3.New()


def itkImageToImageFilterICVF32IUC2_New():
  return itkImageToImageFilterICVF32IUC2.New()


def itkImageToImageFilterICVF23IUC3_New():
  return itkImageToImageFilterICVF23IUC3.New()


def itkImageToImageFilterICVF22IUC2_New():
  return itkImageToImageFilterICVF22IUC2.New()


def itkImageToImageFilterICVF43ISS3_New():
  return itkImageToImageFilterICVF43ISS3.New()


def itkImageToImageFilterICVF42ISS2_New():
  return itkImageToImageFilterICVF42ISS2.New()


def itkImageToImageFilterICVF33ISS3_New():
  return itkImageToImageFilterICVF33ISS3.New()


def itkImageToImageFilterICVF32ISS2_New():
  return itkImageToImageFilterICVF32ISS2.New()


def itkImageToImageFilterICVF23ISS3_New():
  return itkImageToImageFilterICVF23ISS3.New()


def itkImageToImageFilterICVF22ISS2_New():
  return itkImageToImageFilterICVF22ISS2.New()


def itkImageToImageFilterIVF43ID3_New():
  return itkImageToImageFilterIVF43ID3.New()


def itkImageToImageFilterIVF42ID2_New():
  return itkImageToImageFilterIVF42ID2.New()


def itkImageToImageFilterIVF33ID3_New():
  return itkImageToImageFilterIVF33ID3.New()


def itkImageToImageFilterIVF32ID2_New():
  return itkImageToImageFilterIVF32ID2.New()


def itkImageToImageFilterIVF23ID3_New():
  return itkImageToImageFilterIVF23ID3.New()


def itkImageToImageFilterIVF22ID2_New():
  return itkImageToImageFilterIVF22ID2.New()


def itkImageToImageFilterIVF43IF3_New():
  return itkImageToImageFilterIVF43IF3.New()


def itkImageToImageFilterIVF42IF2_New():
  return itkImageToImageFilterIVF42IF2.New()


def itkImageToImageFilterIVF33IF3_New():
  return itkImageToImageFilterIVF33IF3.New()


def itkImageToImageFilterIVF32IF2_New():
  return itkImageToImageFilterIVF32IF2.New()


def itkImageToImageFilterIVF23IF3_New():
  return itkImageToImageFilterIVF23IF3.New()


def itkImageToImageFilterIVF22IF2_New():
  return itkImageToImageFilterIVF22IF2.New()


def itkImageToImageFilterIVF43IUS3_New():
  return itkImageToImageFilterIVF43IUS3.New()


def itkImageToImageFilterIVF42IUS2_New():
  return itkImageToImageFilterIVF42IUS2.New()


def itkImageToImageFilterIVF33IUS3_New():
  return itkImageToImageFilterIVF33IUS3.New()


def itkImageToImageFilterIVF32IUS2_New():
  return itkImageToImageFilterIVF32IUS2.New()


def itkImageToImageFilterIVF23IUS3_New():
  return itkImageToImageFilterIVF23IUS3.New()


def itkImageToImageFilterIVF22IUS2_New():
  return itkImageToImageFilterIVF22IUS2.New()


def itkImageToImageFilterIVF43IUC3_New():
  return itkImageToImageFilterIVF43IUC3.New()


def itkImageToImageFilterIVF42IUC2_New():
  return itkImageToImageFilterIVF42IUC2.New()


def itkImageToImageFilterIVF33IUC3_New():
  return itkImageToImageFilterIVF33IUC3.New()


def itkImageToImageFilterIVF32IUC2_New():
  return itkImageToImageFilterIVF32IUC2.New()


def itkImageToImageFilterIVF23IUC3_New():
  return itkImageToImageFilterIVF23IUC3.New()


def itkImageToImageFilterIVF22IUC2_New():
  return itkImageToImageFilterIVF22IUC2.New()


def itkImageToImageFilterIVF43ISS3_New():
  return itkImageToImageFilterIVF43ISS3.New()


def itkImageToImageFilterIVF42ISS2_New():
  return itkImageToImageFilterIVF42ISS2.New()


def itkImageToImageFilterIVF33ISS3_New():
  return itkImageToImageFilterIVF33ISS3.New()


def itkImageToImageFilterIVF32ISS2_New():
  return itkImageToImageFilterIVF32ISS2.New()


def itkImageToImageFilterIVF23ISS3_New():
  return itkImageToImageFilterIVF23ISS3.New()


def itkImageToImageFilterIVF22ISS2_New():
  return itkImageToImageFilterIVF22ISS2.New()


def itkImageToImageFilterID3VID3_New():
  return itkImageToImageFilterID3VID3.New()


def itkImageToImageFilterVID3ID3_New():
  return itkImageToImageFilterVID3ID3.New()


def itkImageToImageFilterIF3VID3_New():
  return itkImageToImageFilterIF3VID3.New()


def itkImageToImageFilterVID3IF3_New():
  return itkImageToImageFilterVID3IF3.New()


def itkImageToImageFilterIUS3VID3_New():
  return itkImageToImageFilterIUS3VID3.New()


def itkImageToImageFilterVID3IUS3_New():
  return itkImageToImageFilterVID3IUS3.New()


def itkImageToImageFilterISS3VID3_New():
  return itkImageToImageFilterISS3VID3.New()


def itkImageToImageFilterVID3ISS3_New():
  return itkImageToImageFilterVID3ISS3.New()


def itkImageToImageFilterIUC3VID3_New():
  return itkImageToImageFilterIUC3VID3.New()


def itkImageToImageFilterVID3IUC3_New():
  return itkImageToImageFilterVID3IUC3.New()


def itkImageToImageFilterID3VIF3_New():
  return itkImageToImageFilterID3VIF3.New()


def itkImageToImageFilterVIF3ID3_New():
  return itkImageToImageFilterVIF3ID3.New()


def itkImageToImageFilterIF3VIF3_New():
  return itkImageToImageFilterIF3VIF3.New()


def itkImageToImageFilterVIF3IF3_New():
  return itkImageToImageFilterVIF3IF3.New()


def itkImageToImageFilterIUS3VIF3_New():
  return itkImageToImageFilterIUS3VIF3.New()


def itkImageToImageFilterVIF3IUS3_New():
  return itkImageToImageFilterVIF3IUS3.New()


def itkImageToImageFilterISS3VIF3_New():
  return itkImageToImageFilterISS3VIF3.New()


def itkImageToImageFilterVIF3ISS3_New():
  return itkImageToImageFilterVIF3ISS3.New()


def itkImageToImageFilterIUC3VIF3_New():
  return itkImageToImageFilterIUC3VIF3.New()


def itkImageToImageFilterVIF3IUC3_New():
  return itkImageToImageFilterVIF3IUC3.New()


def itkImageToImageFilterID3VIUS3_New():
  return itkImageToImageFilterID3VIUS3.New()


def itkImageToImageFilterVIUS3ID3_New():
  return itkImageToImageFilterVIUS3ID3.New()


def itkImageToImageFilterIF3VIUS3_New():
  return itkImageToImageFilterIF3VIUS3.New()


def itkImageToImageFilterVIUS3IF3_New():
  return itkImageToImageFilterVIUS3IF3.New()


def itkImageToImageFilterIUS3VIUS3_New():
  return itkImageToImageFilterIUS3VIUS3.New()


def itkImageToImageFilterVIUS3IUS3_New():
  return itkImageToImageFilterVIUS3IUS3.New()


def itkImageToImageFilterISS3VIUS3_New():
  return itkImageToImageFilterISS3VIUS3.New()


def itkImageToImageFilterVIUS3ISS3_New():
  return itkImageToImageFilterVIUS3ISS3.New()


def itkImageToImageFilterIUC3VIUS3_New():
  return itkImageToImageFilterIUC3VIUS3.New()


def itkImageToImageFilterVIUS3IUC3_New():
  return itkImageToImageFilterVIUS3IUC3.New()


def itkImageToImageFilterID3VISS3_New():
  return itkImageToImageFilterID3VISS3.New()


def itkImageToImageFilterVISS3ID3_New():
  return itkImageToImageFilterVISS3ID3.New()


def itkImageToImageFilterIF3VISS3_New():
  return itkImageToImageFilterIF3VISS3.New()


def itkImageToImageFilterVISS3IF3_New():
  return itkImageToImageFilterVISS3IF3.New()


def itkImageToImageFilterIUS3VISS3_New():
  return itkImageToImageFilterIUS3VISS3.New()


def itkImageToImageFilterVISS3IUS3_New():
  return itkImageToImageFilterVISS3IUS3.New()


def itkImageToImageFilterISS3VISS3_New():
  return itkImageToImageFilterISS3VISS3.New()


def itkImageToImageFilterVISS3ISS3_New():
  return itkImageToImageFilterVISS3ISS3.New()


def itkImageToImageFilterIUC3VISS3_New():
  return itkImageToImageFilterIUC3VISS3.New()


def itkImageToImageFilterVISS3IUC3_New():
  return itkImageToImageFilterVISS3IUC3.New()


def itkImageToImageFilterID3VIUC3_New():
  return itkImageToImageFilterID3VIUC3.New()


def itkImageToImageFilterVIUC3ID3_New():
  return itkImageToImageFilterVIUC3ID3.New()


def itkImageToImageFilterIF3VIUC3_New():
  return itkImageToImageFilterIF3VIUC3.New()


def itkImageToImageFilterVIUC3IF3_New():
  return itkImageToImageFilterVIUC3IF3.New()


def itkImageToImageFilterIUS3VIUC3_New():
  return itkImageToImageFilterIUS3VIUC3.New()


def itkImageToImageFilterVIUC3IUS3_New():
  return itkImageToImageFilterVIUC3IUS3.New()


def itkImageToImageFilterISS3VIUC3_New():
  return itkImageToImageFilterISS3VIUC3.New()


def itkImageToImageFilterVIUC3ISS3_New():
  return itkImageToImageFilterVIUC3ISS3.New()


def itkImageToImageFilterIUC3VIUC3_New():
  return itkImageToImageFilterIUC3VIUC3.New()


def itkImageToImageFilterVIUC3IUC3_New():
  return itkImageToImageFilterVIUC3IUC3.New()


def itkImageToImageFilterID2VID2_New():
  return itkImageToImageFilterID2VID2.New()


def itkImageToImageFilterVID2ID2_New():
  return itkImageToImageFilterVID2ID2.New()


def itkImageToImageFilterIF2VID2_New():
  return itkImageToImageFilterIF2VID2.New()


def itkImageToImageFilterVID2IF2_New():
  return itkImageToImageFilterVID2IF2.New()


def itkImageToImageFilterIUS2VID2_New():
  return itkImageToImageFilterIUS2VID2.New()


def itkImageToImageFilterVID2IUS2_New():
  return itkImageToImageFilterVID2IUS2.New()


def itkImageToImageFilterISS2VID2_New():
  return itkImageToImageFilterISS2VID2.New()


def itkImageToImageFilterVID2ISS2_New():
  return itkImageToImageFilterVID2ISS2.New()


def itkImageToImageFilterIUC2VID2_New():
  return itkImageToImageFilterIUC2VID2.New()


def itkImageToImageFilterVID2IUC2_New():
  return itkImageToImageFilterVID2IUC2.New()


def itkImageToImageFilterID2VIF2_New():
  return itkImageToImageFilterID2VIF2.New()


def itkImageToImageFilterVIF2ID2_New():
  return itkImageToImageFilterVIF2ID2.New()


def itkImageToImageFilterIF2VIF2_New():
  return itkImageToImageFilterIF2VIF2.New()


def itkImageToImageFilterVIF2IF2_New():
  return itkImageToImageFilterVIF2IF2.New()


def itkImageToImageFilterIUS2VIF2_New():
  return itkImageToImageFilterIUS2VIF2.New()


def itkImageToImageFilterVIF2IUS2_New():
  return itkImageToImageFilterVIF2IUS2.New()


def itkImageToImageFilterISS2VIF2_New():
  return itkImageToImageFilterISS2VIF2.New()


def itkImageToImageFilterVIF2ISS2_New():
  return itkImageToImageFilterVIF2ISS2.New()


def itkImageToImageFilterIUC2VIF2_New():
  return itkImageToImageFilterIUC2VIF2.New()


def itkImageToImageFilterVIF2IUC2_New():
  return itkImageToImageFilterVIF2IUC2.New()


def itkImageToImageFilterID2VIUS2_New():
  return itkImageToImageFilterID2VIUS2.New()


def itkImageToImageFilterVIUS2ID2_New():
  return itkImageToImageFilterVIUS2ID2.New()


def itkImageToImageFilterIF2VIUS2_New():
  return itkImageToImageFilterIF2VIUS2.New()


def itkImageToImageFilterVIUS2IF2_New():
  return itkImageToImageFilterVIUS2IF2.New()


def itkImageToImageFilterIUS2VIUS2_New():
  return itkImageToImageFilterIUS2VIUS2.New()


def itkImageToImageFilterVIUS2IUS2_New():
  return itkImageToImageFilterVIUS2IUS2.New()


def itkImageToImageFilterISS2VIUS2_New():
  return itkImageToImageFilterISS2VIUS2.New()


def itkImageToImageFilterVIUS2ISS2_New():
  return itkImageToImageFilterVIUS2ISS2.New()


def itkImageToImageFilterIUC2VIUS2_New():
  return itkImageToImageFilterIUC2VIUS2.New()


def itkImageToImageFilterVIUS2IUC2_New():
  return itkImageToImageFilterVIUS2IUC2.New()


def itkImageToImageFilterID2VISS2_New():
  return itkImageToImageFilterID2VISS2.New()


def itkImageToImageFilterVISS2ID2_New():
  return itkImageToImageFilterVISS2ID2.New()


def itkImageToImageFilterIF2VISS2_New():
  return itkImageToImageFilterIF2VISS2.New()


def itkImageToImageFilterVISS2IF2_New():
  return itkImageToImageFilterVISS2IF2.New()


def itkImageToImageFilterIUS2VISS2_New():
  return itkImageToImageFilterIUS2VISS2.New()


def itkImageToImageFilterVISS2IUS2_New():
  return itkImageToImageFilterVISS2IUS2.New()


def itkImageToImageFilterISS2VISS2_New():
  return itkImageToImageFilterISS2VISS2.New()


def itkImageToImageFilterVISS2ISS2_New():
  return itkImageToImageFilterVISS2ISS2.New()


def itkImageToImageFilterIUC2VISS2_New():
  return itkImageToImageFilterIUC2VISS2.New()


def itkImageToImageFilterVISS2IUC2_New():
  return itkImageToImageFilterVISS2IUC2.New()


def itkImageToImageFilterID2VIUC2_New():
  return itkImageToImageFilterID2VIUC2.New()


def itkImageToImageFilterVIUC2ID2_New():
  return itkImageToImageFilterVIUC2ID2.New()


def itkImageToImageFilterIF2VIUC2_New():
  return itkImageToImageFilterIF2VIUC2.New()


def itkImageToImageFilterVIUC2IF2_New():
  return itkImageToImageFilterVIUC2IF2.New()


def itkImageToImageFilterIUS2VIUC2_New():
  return itkImageToImageFilterIUS2VIUC2.New()


def itkImageToImageFilterVIUC2IUS2_New():
  return itkImageToImageFilterVIUC2IUS2.New()


def itkImageToImageFilterISS2VIUC2_New():
  return itkImageToImageFilterISS2VIUC2.New()


def itkImageToImageFilterVIUC2ISS2_New():
  return itkImageToImageFilterVIUC2ISS2.New()


def itkImageToImageFilterIUC2VIUC2_New():
  return itkImageToImageFilterIUC2VIUC2.New()


def itkImageToImageFilterVIUC2IUC2_New():
  return itkImageToImageFilterVIUC2IUC2.New()


def itkImageToImageFilterIRGBAUC3ID3_New():
  return itkImageToImageFilterIRGBAUC3ID3.New()


def itkImageToImageFilterIRGBAUC2ID2_New():
  return itkImageToImageFilterIRGBAUC2ID2.New()


def itkImageToImageFilterIRGBAUC3IF3_New():
  return itkImageToImageFilterIRGBAUC3IF3.New()


def itkImageToImageFilterIRGBAUC2IF2_New():
  return itkImageToImageFilterIRGBAUC2IF2.New()


def itkImageToImageFilterIRGBAUC3IUS3_New():
  return itkImageToImageFilterIRGBAUC3IUS3.New()


def itkImageToImageFilterIRGBAUC2IUS2_New():
  return itkImageToImageFilterIRGBAUC2IUS2.New()


def itkImageToImageFilterIRGBAUC3IUC3_New():
  return itkImageToImageFilterIRGBAUC3IUC3.New()


def itkImageToImageFilterIRGBAUC2IUC2_New():
  return itkImageToImageFilterIRGBAUC2IUC2.New()


def itkImageToImageFilterIRGBAUC3ISS3_New():
  return itkImageToImageFilterIRGBAUC3ISS3.New()


def itkImageToImageFilterIRGBAUC2ISS2_New():
  return itkImageToImageFilterIRGBAUC2ISS2.New()


def itkImageToImageFilterIRGBAUC3IUL3_New():
  return itkImageToImageFilterIRGBAUC3IUL3.New()


def itkImageToImageFilterIRGBAUC2IUL2_New():
  return itkImageToImageFilterIRGBAUC2IUL2.New()


def itkImageToImageFilterID3IRGBAUC3_New():
  return itkImageToImageFilterID3IRGBAUC3.New()


def itkImageToImageFilterID2IRGBAUC2_New():
  return itkImageToImageFilterID2IRGBAUC2.New()


def itkImageToImageFilterIF3IRGBAUC3_New():
  return itkImageToImageFilterIF3IRGBAUC3.New()


def itkImageToImageFilterIF2IRGBAUC2_New():
  return itkImageToImageFilterIF2IRGBAUC2.New()


def itkImageToImageFilterIUS3IRGBAUC3_New():
  return itkImageToImageFilterIUS3IRGBAUC3.New()


def itkImageToImageFilterIUS2IRGBAUC2_New():
  return itkImageToImageFilterIUS2IRGBAUC2.New()


def itkImageToImageFilterIUC3IRGBAUC3_New():
  return itkImageToImageFilterIUC3IRGBAUC3.New()


def itkImageToImageFilterIUC2IRGBAUC2_New():
  return itkImageToImageFilterIUC2IRGBAUC2.New()


def itkImageToImageFilterISS3IRGBAUC3_New():
  return itkImageToImageFilterISS3IRGBAUC3.New()


def itkImageToImageFilterISS2IRGBAUC2_New():
  return itkImageToImageFilterISS2IRGBAUC2.New()


def itkImageToImageFilterIUL3IRGBAUC3_New():
  return itkImageToImageFilterIUL3IRGBAUC3.New()


def itkImageToImageFilterIUL2IRGBAUC2_New():
  return itkImageToImageFilterIUL2IRGBAUC2.New()


def itkImageToImageFilterIRGBUC3ID3_New():
  return itkImageToImageFilterIRGBUC3ID3.New()


def itkImageToImageFilterIRGBUC2ID2_New():
  return itkImageToImageFilterIRGBUC2ID2.New()


def itkImageToImageFilterIRGBUC3IF3_New():
  return itkImageToImageFilterIRGBUC3IF3.New()


def itkImageToImageFilterIRGBUC2IF2_New():
  return itkImageToImageFilterIRGBUC2IF2.New()


def itkImageToImageFilterIRGBUC3IUS3_New():
  return itkImageToImageFilterIRGBUC3IUS3.New()


def itkImageToImageFilterIRGBUC2IUS2_New():
  return itkImageToImageFilterIRGBUC2IUS2.New()


def itkImageToImageFilterIRGBUC3IUC3_New():
  return itkImageToImageFilterIRGBUC3IUC3.New()


def itkImageToImageFilterIRGBUC2IUC2_New():
  return itkImageToImageFilterIRGBUC2IUC2.New()


def itkImageToImageFilterIRGBUC3ISS3_New():
  return itkImageToImageFilterIRGBUC3ISS3.New()


def itkImageToImageFilterIRGBUC2ISS2_New():
  return itkImageToImageFilterIRGBUC2ISS2.New()


def itkImageToImageFilterIRGBUC3IUL3_New():
  return itkImageToImageFilterIRGBUC3IUL3.New()


def itkImageToImageFilterIRGBUC2IUL2_New():
  return itkImageToImageFilterIRGBUC2IUL2.New()


def itkImageToImageFilterID3IRGBUC3_New():
  return itkImageToImageFilterID3IRGBUC3.New()


def itkImageToImageFilterID2IRGBUC2_New():
  return itkImageToImageFilterID2IRGBUC2.New()


def itkImageToImageFilterIF3IRGBUC3_New():
  return itkImageToImageFilterIF3IRGBUC3.New()


def itkImageToImageFilterIF2IRGBUC2_New():
  return itkImageToImageFilterIF2IRGBUC2.New()


def itkImageToImageFilterIUS3IRGBUC3_New():
  return itkImageToImageFilterIUS3IRGBUC3.New()


def itkImageToImageFilterIUS2IRGBUC2_New():
  return itkImageToImageFilterIUS2IRGBUC2.New()


def itkImageToImageFilterIUC3IRGBUC3_New():
  return itkImageToImageFilterIUC3IRGBUC3.New()


def itkImageToImageFilterIUC2IRGBUC2_New():
  return itkImageToImageFilterIUC2IRGBUC2.New()


def itkImageToImageFilterISS3IRGBUC3_New():
  return itkImageToImageFilterISS3IRGBUC3.New()


def itkImageToImageFilterISS2IRGBUC2_New():
  return itkImageToImageFilterISS2IRGBUC2.New()


def itkImageToImageFilterIUL3IRGBUC3_New():
  return itkImageToImageFilterIUL3IRGBUC3.New()


def itkImageToImageFilterIUL2IRGBUC2_New():
  return itkImageToImageFilterIUL2IRGBUC2.New()

class itkImageToImageFilterICF2ICF2(itkImageSourcePython.itkImageSourceICF2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterICF2ICF2 self, itkImageCF2 image)
        SetInput(itkImageToImageFilterICF2ICF2 self, unsigned int arg0, itkImageCF2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2ICF2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageCF2 const *":
        """
        GetInput(itkImageToImageFilterICF2ICF2 self) -> itkImageCF2
        GetInput(itkImageToImageFilterICF2ICF2 self, unsigned int idx) -> itkImageCF2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2ICF2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageCF2') -> "void":
        """
        PushBackInput(itkImageToImageFilterICF2ICF2 self, itkImageCF2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2ICF2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterICF2ICF2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2ICF2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageCF2') -> "void":
        """PushFrontInput(itkImageToImageFilterICF2ICF2 self, itkImageCF2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2ICF2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterICF2ICF2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2ICF2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterICF2ICF2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2ICF2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterICF2ICF2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2ICF2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterICF2ICF2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2ICF2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterICF2ICF2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2ICF2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterICF2ICF2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterICF2ICF2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterICF2ICF2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2ICF2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterICF2ICF2

        Create a new object of the class itkImageToImageFilterICF2ICF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterICF2ICF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterICF2ICF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterICF2ICF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterICF2ICF2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2ICF2_SetInput, None, itkImageToImageFilterICF2ICF2)
itkImageToImageFilterICF2ICF2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2ICF2_GetInput, None, itkImageToImageFilterICF2ICF2)
itkImageToImageFilterICF2ICF2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2ICF2_PushBackInput, None, itkImageToImageFilterICF2ICF2)
itkImageToImageFilterICF2ICF2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2ICF2_PopBackInput, None, itkImageToImageFilterICF2ICF2)
itkImageToImageFilterICF2ICF2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2ICF2_PushFrontInput, None, itkImageToImageFilterICF2ICF2)
itkImageToImageFilterICF2ICF2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2ICF2_PopFrontInput, None, itkImageToImageFilterICF2ICF2)
itkImageToImageFilterICF2ICF2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2ICF2_SetCoordinateTolerance, None, itkImageToImageFilterICF2ICF2)
itkImageToImageFilterICF2ICF2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2ICF2_GetCoordinateTolerance, None, itkImageToImageFilterICF2ICF2)
itkImageToImageFilterICF2ICF2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2ICF2_SetDirectionTolerance, None, itkImageToImageFilterICF2ICF2)
itkImageToImageFilterICF2ICF2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2ICF2_GetDirectionTolerance, None, itkImageToImageFilterICF2ICF2)
itkImageToImageFilterICF2ICF2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterICF2ICF2_swigregister
itkImageToImageFilterICF2ICF2_swigregister(itkImageToImageFilterICF2ICF2)

def itkImageToImageFilterICF2ICF2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterICF2ICF2 *":
    """itkImageToImageFilterICF2ICF2_cast(itkLightObject obj) -> itkImageToImageFilterICF2ICF2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterICF2ICF2_cast(obj)

class itkImageToImageFilterICF2ICF3(itkImageSourcePython.itkImageSourceICF3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterICF2ICF3 self, itkImageCF2 image)
        SetInput(itkImageToImageFilterICF2ICF3 self, unsigned int arg0, itkImageCF2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2ICF3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageCF2 const *":
        """
        GetInput(itkImageToImageFilterICF2ICF3 self) -> itkImageCF2
        GetInput(itkImageToImageFilterICF2ICF3 self, unsigned int idx) -> itkImageCF2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2ICF3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageCF2') -> "void":
        """
        PushBackInput(itkImageToImageFilterICF2ICF3 self, itkImageCF2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2ICF3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterICF2ICF3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2ICF3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageCF2') -> "void":
        """PushFrontInput(itkImageToImageFilterICF2ICF3 self, itkImageCF2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2ICF3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterICF2ICF3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2ICF3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterICF2ICF3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2ICF3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterICF2ICF3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2ICF3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterICF2ICF3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2ICF3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterICF2ICF3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2ICF3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterICF2ICF3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterICF2ICF3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterICF2ICF3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2ICF3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterICF2ICF3

        Create a new object of the class itkImageToImageFilterICF2ICF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterICF2ICF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterICF2ICF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterICF2ICF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterICF2ICF3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2ICF3_SetInput, None, itkImageToImageFilterICF2ICF3)
itkImageToImageFilterICF2ICF3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2ICF3_GetInput, None, itkImageToImageFilterICF2ICF3)
itkImageToImageFilterICF2ICF3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2ICF3_PushBackInput, None, itkImageToImageFilterICF2ICF3)
itkImageToImageFilterICF2ICF3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2ICF3_PopBackInput, None, itkImageToImageFilterICF2ICF3)
itkImageToImageFilterICF2ICF3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2ICF3_PushFrontInput, None, itkImageToImageFilterICF2ICF3)
itkImageToImageFilterICF2ICF3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2ICF3_PopFrontInput, None, itkImageToImageFilterICF2ICF3)
itkImageToImageFilterICF2ICF3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2ICF3_SetCoordinateTolerance, None, itkImageToImageFilterICF2ICF3)
itkImageToImageFilterICF2ICF3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2ICF3_GetCoordinateTolerance, None, itkImageToImageFilterICF2ICF3)
itkImageToImageFilterICF2ICF3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2ICF3_SetDirectionTolerance, None, itkImageToImageFilterICF2ICF3)
itkImageToImageFilterICF2ICF3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2ICF3_GetDirectionTolerance, None, itkImageToImageFilterICF2ICF3)
itkImageToImageFilterICF2ICF3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterICF2ICF3_swigregister
itkImageToImageFilterICF2ICF3_swigregister(itkImageToImageFilterICF2ICF3)

def itkImageToImageFilterICF2ICF3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterICF2ICF3 *":
    """itkImageToImageFilterICF2ICF3_cast(itkLightObject obj) -> itkImageToImageFilterICF2ICF3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterICF2ICF3_cast(obj)

class itkImageToImageFilterICF2ID2(itkImageSourcePython.itkImageSourceID2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterICF2ID2 self, itkImageCF2 image)
        SetInput(itkImageToImageFilterICF2ID2 self, unsigned int arg0, itkImageCF2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2ID2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageCF2 const *":
        """
        GetInput(itkImageToImageFilterICF2ID2 self) -> itkImageCF2
        GetInput(itkImageToImageFilterICF2ID2 self, unsigned int idx) -> itkImageCF2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2ID2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageCF2') -> "void":
        """
        PushBackInput(itkImageToImageFilterICF2ID2 self, itkImageCF2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2ID2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterICF2ID2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2ID2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageCF2') -> "void":
        """PushFrontInput(itkImageToImageFilterICF2ID2 self, itkImageCF2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2ID2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterICF2ID2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2ID2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterICF2ID2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2ID2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterICF2ID2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2ID2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterICF2ID2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2ID2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterICF2ID2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2ID2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterICF2ID2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterICF2ID2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterICF2ID2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2ID2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterICF2ID2

        Create a new object of the class itkImageToImageFilterICF2ID2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterICF2ID2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterICF2ID2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterICF2ID2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterICF2ID2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2ID2_SetInput, None, itkImageToImageFilterICF2ID2)
itkImageToImageFilterICF2ID2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2ID2_GetInput, None, itkImageToImageFilterICF2ID2)
itkImageToImageFilterICF2ID2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2ID2_PushBackInput, None, itkImageToImageFilterICF2ID2)
itkImageToImageFilterICF2ID2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2ID2_PopBackInput, None, itkImageToImageFilterICF2ID2)
itkImageToImageFilterICF2ID2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2ID2_PushFrontInput, None, itkImageToImageFilterICF2ID2)
itkImageToImageFilterICF2ID2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2ID2_PopFrontInput, None, itkImageToImageFilterICF2ID2)
itkImageToImageFilterICF2ID2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2ID2_SetCoordinateTolerance, None, itkImageToImageFilterICF2ID2)
itkImageToImageFilterICF2ID2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2ID2_GetCoordinateTolerance, None, itkImageToImageFilterICF2ID2)
itkImageToImageFilterICF2ID2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2ID2_SetDirectionTolerance, None, itkImageToImageFilterICF2ID2)
itkImageToImageFilterICF2ID2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2ID2_GetDirectionTolerance, None, itkImageToImageFilterICF2ID2)
itkImageToImageFilterICF2ID2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterICF2ID2_swigregister
itkImageToImageFilterICF2ID2_swigregister(itkImageToImageFilterICF2ID2)

def itkImageToImageFilterICF2ID2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterICF2ID2 *":
    """itkImageToImageFilterICF2ID2_cast(itkLightObject obj) -> itkImageToImageFilterICF2ID2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterICF2ID2_cast(obj)

class itkImageToImageFilterICF2IF2(itkImageSourcePython.itkImageSourceIF2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterICF2IF2 self, itkImageCF2 image)
        SetInput(itkImageToImageFilterICF2IF2 self, unsigned int arg0, itkImageCF2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2IF2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageCF2 const *":
        """
        GetInput(itkImageToImageFilterICF2IF2 self) -> itkImageCF2
        GetInput(itkImageToImageFilterICF2IF2 self, unsigned int idx) -> itkImageCF2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2IF2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageCF2') -> "void":
        """
        PushBackInput(itkImageToImageFilterICF2IF2 self, itkImageCF2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2IF2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterICF2IF2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2IF2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageCF2') -> "void":
        """PushFrontInput(itkImageToImageFilterICF2IF2 self, itkImageCF2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2IF2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterICF2IF2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2IF2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterICF2IF2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2IF2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterICF2IF2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2IF2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterICF2IF2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2IF2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterICF2IF2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2IF2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterICF2IF2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterICF2IF2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterICF2IF2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2IF2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterICF2IF2

        Create a new object of the class itkImageToImageFilterICF2IF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterICF2IF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterICF2IF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterICF2IF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterICF2IF2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2IF2_SetInput, None, itkImageToImageFilterICF2IF2)
itkImageToImageFilterICF2IF2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2IF2_GetInput, None, itkImageToImageFilterICF2IF2)
itkImageToImageFilterICF2IF2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2IF2_PushBackInput, None, itkImageToImageFilterICF2IF2)
itkImageToImageFilterICF2IF2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2IF2_PopBackInput, None, itkImageToImageFilterICF2IF2)
itkImageToImageFilterICF2IF2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2IF2_PushFrontInput, None, itkImageToImageFilterICF2IF2)
itkImageToImageFilterICF2IF2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2IF2_PopFrontInput, None, itkImageToImageFilterICF2IF2)
itkImageToImageFilterICF2IF2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2IF2_SetCoordinateTolerance, None, itkImageToImageFilterICF2IF2)
itkImageToImageFilterICF2IF2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2IF2_GetCoordinateTolerance, None, itkImageToImageFilterICF2IF2)
itkImageToImageFilterICF2IF2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2IF2_SetDirectionTolerance, None, itkImageToImageFilterICF2IF2)
itkImageToImageFilterICF2IF2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2IF2_GetDirectionTolerance, None, itkImageToImageFilterICF2IF2)
itkImageToImageFilterICF2IF2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterICF2IF2_swigregister
itkImageToImageFilterICF2IF2_swigregister(itkImageToImageFilterICF2IF2)

def itkImageToImageFilterICF2IF2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterICF2IF2 *":
    """itkImageToImageFilterICF2IF2_cast(itkLightObject obj) -> itkImageToImageFilterICF2IF2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterICF2IF2_cast(obj)

class itkImageToImageFilterICF2ISS2(itkImageSourcePython.itkImageSourceISS2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterICF2ISS2 self, itkImageCF2 image)
        SetInput(itkImageToImageFilterICF2ISS2 self, unsigned int arg0, itkImageCF2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2ISS2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageCF2 const *":
        """
        GetInput(itkImageToImageFilterICF2ISS2 self) -> itkImageCF2
        GetInput(itkImageToImageFilterICF2ISS2 self, unsigned int idx) -> itkImageCF2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2ISS2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageCF2') -> "void":
        """
        PushBackInput(itkImageToImageFilterICF2ISS2 self, itkImageCF2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2ISS2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterICF2ISS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2ISS2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageCF2') -> "void":
        """PushFrontInput(itkImageToImageFilterICF2ISS2 self, itkImageCF2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2ISS2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterICF2ISS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2ISS2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterICF2ISS2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2ISS2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterICF2ISS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2ISS2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterICF2ISS2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2ISS2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterICF2ISS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2ISS2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterICF2ISS2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterICF2ISS2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterICF2ISS2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2ISS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterICF2ISS2

        Create a new object of the class itkImageToImageFilterICF2ISS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterICF2ISS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterICF2ISS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterICF2ISS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterICF2ISS2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2ISS2_SetInput, None, itkImageToImageFilterICF2ISS2)
itkImageToImageFilterICF2ISS2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2ISS2_GetInput, None, itkImageToImageFilterICF2ISS2)
itkImageToImageFilterICF2ISS2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2ISS2_PushBackInput, None, itkImageToImageFilterICF2ISS2)
itkImageToImageFilterICF2ISS2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2ISS2_PopBackInput, None, itkImageToImageFilterICF2ISS2)
itkImageToImageFilterICF2ISS2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2ISS2_PushFrontInput, None, itkImageToImageFilterICF2ISS2)
itkImageToImageFilterICF2ISS2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2ISS2_PopFrontInput, None, itkImageToImageFilterICF2ISS2)
itkImageToImageFilterICF2ISS2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2ISS2_SetCoordinateTolerance, None, itkImageToImageFilterICF2ISS2)
itkImageToImageFilterICF2ISS2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2ISS2_GetCoordinateTolerance, None, itkImageToImageFilterICF2ISS2)
itkImageToImageFilterICF2ISS2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2ISS2_SetDirectionTolerance, None, itkImageToImageFilterICF2ISS2)
itkImageToImageFilterICF2ISS2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2ISS2_GetDirectionTolerance, None, itkImageToImageFilterICF2ISS2)
itkImageToImageFilterICF2ISS2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterICF2ISS2_swigregister
itkImageToImageFilterICF2ISS2_swigregister(itkImageToImageFilterICF2ISS2)

def itkImageToImageFilterICF2ISS2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterICF2ISS2 *":
    """itkImageToImageFilterICF2ISS2_cast(itkLightObject obj) -> itkImageToImageFilterICF2ISS2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterICF2ISS2_cast(obj)

class itkImageToImageFilterICF2IUC2(itkImageSourcePython.itkImageSourceIUC2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterICF2IUC2 self, itkImageCF2 image)
        SetInput(itkImageToImageFilterICF2IUC2 self, unsigned int arg0, itkImageCF2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2IUC2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageCF2 const *":
        """
        GetInput(itkImageToImageFilterICF2IUC2 self) -> itkImageCF2
        GetInput(itkImageToImageFilterICF2IUC2 self, unsigned int idx) -> itkImageCF2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2IUC2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageCF2') -> "void":
        """
        PushBackInput(itkImageToImageFilterICF2IUC2 self, itkImageCF2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2IUC2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterICF2IUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2IUC2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageCF2') -> "void":
        """PushFrontInput(itkImageToImageFilterICF2IUC2 self, itkImageCF2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2IUC2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterICF2IUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2IUC2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterICF2IUC2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2IUC2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterICF2IUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2IUC2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterICF2IUC2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2IUC2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterICF2IUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2IUC2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterICF2IUC2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterICF2IUC2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterICF2IUC2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2IUC2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterICF2IUC2

        Create a new object of the class itkImageToImageFilterICF2IUC2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterICF2IUC2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterICF2IUC2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterICF2IUC2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterICF2IUC2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2IUC2_SetInput, None, itkImageToImageFilterICF2IUC2)
itkImageToImageFilterICF2IUC2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2IUC2_GetInput, None, itkImageToImageFilterICF2IUC2)
itkImageToImageFilterICF2IUC2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2IUC2_PushBackInput, None, itkImageToImageFilterICF2IUC2)
itkImageToImageFilterICF2IUC2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2IUC2_PopBackInput, None, itkImageToImageFilterICF2IUC2)
itkImageToImageFilterICF2IUC2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2IUC2_PushFrontInput, None, itkImageToImageFilterICF2IUC2)
itkImageToImageFilterICF2IUC2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2IUC2_PopFrontInput, None, itkImageToImageFilterICF2IUC2)
itkImageToImageFilterICF2IUC2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2IUC2_SetCoordinateTolerance, None, itkImageToImageFilterICF2IUC2)
itkImageToImageFilterICF2IUC2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2IUC2_GetCoordinateTolerance, None, itkImageToImageFilterICF2IUC2)
itkImageToImageFilterICF2IUC2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2IUC2_SetDirectionTolerance, None, itkImageToImageFilterICF2IUC2)
itkImageToImageFilterICF2IUC2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2IUC2_GetDirectionTolerance, None, itkImageToImageFilterICF2IUC2)
itkImageToImageFilterICF2IUC2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterICF2IUC2_swigregister
itkImageToImageFilterICF2IUC2_swigregister(itkImageToImageFilterICF2IUC2)

def itkImageToImageFilterICF2IUC2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterICF2IUC2 *":
    """itkImageToImageFilterICF2IUC2_cast(itkLightObject obj) -> itkImageToImageFilterICF2IUC2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterICF2IUC2_cast(obj)

class itkImageToImageFilterICF2IUS2(itkImageSourcePython.itkImageSourceIUS2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterICF2IUS2 self, itkImageCF2 image)
        SetInput(itkImageToImageFilterICF2IUS2 self, unsigned int arg0, itkImageCF2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2IUS2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageCF2 const *":
        """
        GetInput(itkImageToImageFilterICF2IUS2 self) -> itkImageCF2
        GetInput(itkImageToImageFilterICF2IUS2 self, unsigned int idx) -> itkImageCF2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2IUS2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageCF2') -> "void":
        """
        PushBackInput(itkImageToImageFilterICF2IUS2 self, itkImageCF2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2IUS2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterICF2IUS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2IUS2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageCF2') -> "void":
        """PushFrontInput(itkImageToImageFilterICF2IUS2 self, itkImageCF2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2IUS2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterICF2IUS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2IUS2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterICF2IUS2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2IUS2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterICF2IUS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2IUS2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterICF2IUS2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2IUS2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterICF2IUS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2IUS2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterICF2IUS2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterICF2IUS2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterICF2IUS2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF2IUS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterICF2IUS2

        Create a new object of the class itkImageToImageFilterICF2IUS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterICF2IUS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterICF2IUS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterICF2IUS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterICF2IUS2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2IUS2_SetInput, None, itkImageToImageFilterICF2IUS2)
itkImageToImageFilterICF2IUS2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2IUS2_GetInput, None, itkImageToImageFilterICF2IUS2)
itkImageToImageFilterICF2IUS2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2IUS2_PushBackInput, None, itkImageToImageFilterICF2IUS2)
itkImageToImageFilterICF2IUS2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2IUS2_PopBackInput, None, itkImageToImageFilterICF2IUS2)
itkImageToImageFilterICF2IUS2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2IUS2_PushFrontInput, None, itkImageToImageFilterICF2IUS2)
itkImageToImageFilterICF2IUS2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2IUS2_PopFrontInput, None, itkImageToImageFilterICF2IUS2)
itkImageToImageFilterICF2IUS2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2IUS2_SetCoordinateTolerance, None, itkImageToImageFilterICF2IUS2)
itkImageToImageFilterICF2IUS2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2IUS2_GetCoordinateTolerance, None, itkImageToImageFilterICF2IUS2)
itkImageToImageFilterICF2IUS2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2IUS2_SetDirectionTolerance, None, itkImageToImageFilterICF2IUS2)
itkImageToImageFilterICF2IUS2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF2IUS2_GetDirectionTolerance, None, itkImageToImageFilterICF2IUS2)
itkImageToImageFilterICF2IUS2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterICF2IUS2_swigregister
itkImageToImageFilterICF2IUS2_swigregister(itkImageToImageFilterICF2IUS2)

def itkImageToImageFilterICF2IUS2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterICF2IUS2 *":
    """itkImageToImageFilterICF2IUS2_cast(itkLightObject obj) -> itkImageToImageFilterICF2IUS2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterICF2IUS2_cast(obj)

class itkImageToImageFilterICF3ICF2(itkImageSourcePython.itkImageSourceICF2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterICF3ICF2 self, itkImageCF3 image)
        SetInput(itkImageToImageFilterICF3ICF2 self, unsigned int arg0, itkImageCF3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3ICF2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageCF3 const *":
        """
        GetInput(itkImageToImageFilterICF3ICF2 self) -> itkImageCF3
        GetInput(itkImageToImageFilterICF3ICF2 self, unsigned int idx) -> itkImageCF3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3ICF2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageCF3') -> "void":
        """
        PushBackInput(itkImageToImageFilterICF3ICF2 self, itkImageCF3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3ICF2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterICF3ICF2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3ICF2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageCF3') -> "void":
        """PushFrontInput(itkImageToImageFilterICF3ICF2 self, itkImageCF3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3ICF2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterICF3ICF2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3ICF2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterICF3ICF2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3ICF2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterICF3ICF2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3ICF2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterICF3ICF2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3ICF2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterICF3ICF2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3ICF2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterICF3ICF2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterICF3ICF2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterICF3ICF2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3ICF2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterICF3ICF2

        Create a new object of the class itkImageToImageFilterICF3ICF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterICF3ICF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterICF3ICF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterICF3ICF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterICF3ICF2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3ICF2_SetInput, None, itkImageToImageFilterICF3ICF2)
itkImageToImageFilterICF3ICF2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3ICF2_GetInput, None, itkImageToImageFilterICF3ICF2)
itkImageToImageFilterICF3ICF2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3ICF2_PushBackInput, None, itkImageToImageFilterICF3ICF2)
itkImageToImageFilterICF3ICF2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3ICF2_PopBackInput, None, itkImageToImageFilterICF3ICF2)
itkImageToImageFilterICF3ICF2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3ICF2_PushFrontInput, None, itkImageToImageFilterICF3ICF2)
itkImageToImageFilterICF3ICF2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3ICF2_PopFrontInput, None, itkImageToImageFilterICF3ICF2)
itkImageToImageFilterICF3ICF2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3ICF2_SetCoordinateTolerance, None, itkImageToImageFilterICF3ICF2)
itkImageToImageFilterICF3ICF2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3ICF2_GetCoordinateTolerance, None, itkImageToImageFilterICF3ICF2)
itkImageToImageFilterICF3ICF2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3ICF2_SetDirectionTolerance, None, itkImageToImageFilterICF3ICF2)
itkImageToImageFilterICF3ICF2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3ICF2_GetDirectionTolerance, None, itkImageToImageFilterICF3ICF2)
itkImageToImageFilterICF3ICF2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterICF3ICF2_swigregister
itkImageToImageFilterICF3ICF2_swigregister(itkImageToImageFilterICF3ICF2)

def itkImageToImageFilterICF3ICF2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterICF3ICF2 *":
    """itkImageToImageFilterICF3ICF2_cast(itkLightObject obj) -> itkImageToImageFilterICF3ICF2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterICF3ICF2_cast(obj)

class itkImageToImageFilterICF3ICF3(itkImageSourcePython.itkImageSourceICF3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterICF3ICF3 self, itkImageCF3 image)
        SetInput(itkImageToImageFilterICF3ICF3 self, unsigned int arg0, itkImageCF3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3ICF3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageCF3 const *":
        """
        GetInput(itkImageToImageFilterICF3ICF3 self) -> itkImageCF3
        GetInput(itkImageToImageFilterICF3ICF3 self, unsigned int idx) -> itkImageCF3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3ICF3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageCF3') -> "void":
        """
        PushBackInput(itkImageToImageFilterICF3ICF3 self, itkImageCF3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3ICF3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterICF3ICF3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3ICF3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageCF3') -> "void":
        """PushFrontInput(itkImageToImageFilterICF3ICF3 self, itkImageCF3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3ICF3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterICF3ICF3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3ICF3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterICF3ICF3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3ICF3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterICF3ICF3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3ICF3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterICF3ICF3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3ICF3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterICF3ICF3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3ICF3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterICF3ICF3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterICF3ICF3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterICF3ICF3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3ICF3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterICF3ICF3

        Create a new object of the class itkImageToImageFilterICF3ICF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterICF3ICF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterICF3ICF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterICF3ICF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterICF3ICF3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3ICF3_SetInput, None, itkImageToImageFilterICF3ICF3)
itkImageToImageFilterICF3ICF3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3ICF3_GetInput, None, itkImageToImageFilterICF3ICF3)
itkImageToImageFilterICF3ICF3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3ICF3_PushBackInput, None, itkImageToImageFilterICF3ICF3)
itkImageToImageFilterICF3ICF3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3ICF3_PopBackInput, None, itkImageToImageFilterICF3ICF3)
itkImageToImageFilterICF3ICF3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3ICF3_PushFrontInput, None, itkImageToImageFilterICF3ICF3)
itkImageToImageFilterICF3ICF3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3ICF3_PopFrontInput, None, itkImageToImageFilterICF3ICF3)
itkImageToImageFilterICF3ICF3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3ICF3_SetCoordinateTolerance, None, itkImageToImageFilterICF3ICF3)
itkImageToImageFilterICF3ICF3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3ICF3_GetCoordinateTolerance, None, itkImageToImageFilterICF3ICF3)
itkImageToImageFilterICF3ICF3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3ICF3_SetDirectionTolerance, None, itkImageToImageFilterICF3ICF3)
itkImageToImageFilterICF3ICF3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3ICF3_GetDirectionTolerance, None, itkImageToImageFilterICF3ICF3)
itkImageToImageFilterICF3ICF3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterICF3ICF3_swigregister
itkImageToImageFilterICF3ICF3_swigregister(itkImageToImageFilterICF3ICF3)

def itkImageToImageFilterICF3ICF3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterICF3ICF3 *":
    """itkImageToImageFilterICF3ICF3_cast(itkLightObject obj) -> itkImageToImageFilterICF3ICF3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterICF3ICF3_cast(obj)

class itkImageToImageFilterICF3ID3(itkImageSourcePython.itkImageSourceID3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterICF3ID3 self, itkImageCF3 image)
        SetInput(itkImageToImageFilterICF3ID3 self, unsigned int arg0, itkImageCF3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3ID3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageCF3 const *":
        """
        GetInput(itkImageToImageFilterICF3ID3 self) -> itkImageCF3
        GetInput(itkImageToImageFilterICF3ID3 self, unsigned int idx) -> itkImageCF3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3ID3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageCF3') -> "void":
        """
        PushBackInput(itkImageToImageFilterICF3ID3 self, itkImageCF3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3ID3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterICF3ID3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3ID3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageCF3') -> "void":
        """PushFrontInput(itkImageToImageFilterICF3ID3 self, itkImageCF3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3ID3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterICF3ID3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3ID3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterICF3ID3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3ID3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterICF3ID3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3ID3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterICF3ID3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3ID3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterICF3ID3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3ID3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterICF3ID3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterICF3ID3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterICF3ID3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3ID3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterICF3ID3

        Create a new object of the class itkImageToImageFilterICF3ID3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterICF3ID3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterICF3ID3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterICF3ID3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterICF3ID3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3ID3_SetInput, None, itkImageToImageFilterICF3ID3)
itkImageToImageFilterICF3ID3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3ID3_GetInput, None, itkImageToImageFilterICF3ID3)
itkImageToImageFilterICF3ID3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3ID3_PushBackInput, None, itkImageToImageFilterICF3ID3)
itkImageToImageFilterICF3ID3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3ID3_PopBackInput, None, itkImageToImageFilterICF3ID3)
itkImageToImageFilterICF3ID3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3ID3_PushFrontInput, None, itkImageToImageFilterICF3ID3)
itkImageToImageFilterICF3ID3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3ID3_PopFrontInput, None, itkImageToImageFilterICF3ID3)
itkImageToImageFilterICF3ID3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3ID3_SetCoordinateTolerance, None, itkImageToImageFilterICF3ID3)
itkImageToImageFilterICF3ID3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3ID3_GetCoordinateTolerance, None, itkImageToImageFilterICF3ID3)
itkImageToImageFilterICF3ID3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3ID3_SetDirectionTolerance, None, itkImageToImageFilterICF3ID3)
itkImageToImageFilterICF3ID3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3ID3_GetDirectionTolerance, None, itkImageToImageFilterICF3ID3)
itkImageToImageFilterICF3ID3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterICF3ID3_swigregister
itkImageToImageFilterICF3ID3_swigregister(itkImageToImageFilterICF3ID3)

def itkImageToImageFilterICF3ID3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterICF3ID3 *":
    """itkImageToImageFilterICF3ID3_cast(itkLightObject obj) -> itkImageToImageFilterICF3ID3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterICF3ID3_cast(obj)

class itkImageToImageFilterICF3IF3(itkImageSourcePython.itkImageSourceIF3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterICF3IF3 self, itkImageCF3 image)
        SetInput(itkImageToImageFilterICF3IF3 self, unsigned int arg0, itkImageCF3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3IF3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageCF3 const *":
        """
        GetInput(itkImageToImageFilterICF3IF3 self) -> itkImageCF3
        GetInput(itkImageToImageFilterICF3IF3 self, unsigned int idx) -> itkImageCF3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3IF3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageCF3') -> "void":
        """
        PushBackInput(itkImageToImageFilterICF3IF3 self, itkImageCF3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3IF3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterICF3IF3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3IF3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageCF3') -> "void":
        """PushFrontInput(itkImageToImageFilterICF3IF3 self, itkImageCF3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3IF3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterICF3IF3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3IF3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterICF3IF3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3IF3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterICF3IF3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3IF3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterICF3IF3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3IF3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterICF3IF3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3IF3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterICF3IF3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterICF3IF3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterICF3IF3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3IF3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterICF3IF3

        Create a new object of the class itkImageToImageFilterICF3IF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterICF3IF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterICF3IF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterICF3IF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterICF3IF3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3IF3_SetInput, None, itkImageToImageFilterICF3IF3)
itkImageToImageFilterICF3IF3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3IF3_GetInput, None, itkImageToImageFilterICF3IF3)
itkImageToImageFilterICF3IF3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3IF3_PushBackInput, None, itkImageToImageFilterICF3IF3)
itkImageToImageFilterICF3IF3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3IF3_PopBackInput, None, itkImageToImageFilterICF3IF3)
itkImageToImageFilterICF3IF3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3IF3_PushFrontInput, None, itkImageToImageFilterICF3IF3)
itkImageToImageFilterICF3IF3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3IF3_PopFrontInput, None, itkImageToImageFilterICF3IF3)
itkImageToImageFilterICF3IF3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3IF3_SetCoordinateTolerance, None, itkImageToImageFilterICF3IF3)
itkImageToImageFilterICF3IF3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3IF3_GetCoordinateTolerance, None, itkImageToImageFilterICF3IF3)
itkImageToImageFilterICF3IF3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3IF3_SetDirectionTolerance, None, itkImageToImageFilterICF3IF3)
itkImageToImageFilterICF3IF3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3IF3_GetDirectionTolerance, None, itkImageToImageFilterICF3IF3)
itkImageToImageFilterICF3IF3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterICF3IF3_swigregister
itkImageToImageFilterICF3IF3_swigregister(itkImageToImageFilterICF3IF3)

def itkImageToImageFilterICF3IF3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterICF3IF3 *":
    """itkImageToImageFilterICF3IF3_cast(itkLightObject obj) -> itkImageToImageFilterICF3IF3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterICF3IF3_cast(obj)

class itkImageToImageFilterICF3ISS3(itkImageSourcePython.itkImageSourceISS3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterICF3ISS3 self, itkImageCF3 image)
        SetInput(itkImageToImageFilterICF3ISS3 self, unsigned int arg0, itkImageCF3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3ISS3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageCF3 const *":
        """
        GetInput(itkImageToImageFilterICF3ISS3 self) -> itkImageCF3
        GetInput(itkImageToImageFilterICF3ISS3 self, unsigned int idx) -> itkImageCF3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3ISS3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageCF3') -> "void":
        """
        PushBackInput(itkImageToImageFilterICF3ISS3 self, itkImageCF3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3ISS3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterICF3ISS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3ISS3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageCF3') -> "void":
        """PushFrontInput(itkImageToImageFilterICF3ISS3 self, itkImageCF3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3ISS3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterICF3ISS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3ISS3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterICF3ISS3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3ISS3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterICF3ISS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3ISS3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterICF3ISS3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3ISS3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterICF3ISS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3ISS3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterICF3ISS3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterICF3ISS3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterICF3ISS3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3ISS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterICF3ISS3

        Create a new object of the class itkImageToImageFilterICF3ISS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterICF3ISS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterICF3ISS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterICF3ISS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterICF3ISS3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3ISS3_SetInput, None, itkImageToImageFilterICF3ISS3)
itkImageToImageFilterICF3ISS3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3ISS3_GetInput, None, itkImageToImageFilterICF3ISS3)
itkImageToImageFilterICF3ISS3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3ISS3_PushBackInput, None, itkImageToImageFilterICF3ISS3)
itkImageToImageFilterICF3ISS3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3ISS3_PopBackInput, None, itkImageToImageFilterICF3ISS3)
itkImageToImageFilterICF3ISS3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3ISS3_PushFrontInput, None, itkImageToImageFilterICF3ISS3)
itkImageToImageFilterICF3ISS3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3ISS3_PopFrontInput, None, itkImageToImageFilterICF3ISS3)
itkImageToImageFilterICF3ISS3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3ISS3_SetCoordinateTolerance, None, itkImageToImageFilterICF3ISS3)
itkImageToImageFilterICF3ISS3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3ISS3_GetCoordinateTolerance, None, itkImageToImageFilterICF3ISS3)
itkImageToImageFilterICF3ISS3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3ISS3_SetDirectionTolerance, None, itkImageToImageFilterICF3ISS3)
itkImageToImageFilterICF3ISS3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3ISS3_GetDirectionTolerance, None, itkImageToImageFilterICF3ISS3)
itkImageToImageFilterICF3ISS3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterICF3ISS3_swigregister
itkImageToImageFilterICF3ISS3_swigregister(itkImageToImageFilterICF3ISS3)

def itkImageToImageFilterICF3ISS3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterICF3ISS3 *":
    """itkImageToImageFilterICF3ISS3_cast(itkLightObject obj) -> itkImageToImageFilterICF3ISS3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterICF3ISS3_cast(obj)

class itkImageToImageFilterICF3IUC3(itkImageSourcePython.itkImageSourceIUC3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterICF3IUC3 self, itkImageCF3 image)
        SetInput(itkImageToImageFilterICF3IUC3 self, unsigned int arg0, itkImageCF3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3IUC3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageCF3 const *":
        """
        GetInput(itkImageToImageFilterICF3IUC3 self) -> itkImageCF3
        GetInput(itkImageToImageFilterICF3IUC3 self, unsigned int idx) -> itkImageCF3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3IUC3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageCF3') -> "void":
        """
        PushBackInput(itkImageToImageFilterICF3IUC3 self, itkImageCF3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3IUC3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterICF3IUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3IUC3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageCF3') -> "void":
        """PushFrontInput(itkImageToImageFilterICF3IUC3 self, itkImageCF3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3IUC3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterICF3IUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3IUC3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterICF3IUC3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3IUC3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterICF3IUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3IUC3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterICF3IUC3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3IUC3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterICF3IUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3IUC3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterICF3IUC3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterICF3IUC3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterICF3IUC3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3IUC3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterICF3IUC3

        Create a new object of the class itkImageToImageFilterICF3IUC3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterICF3IUC3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterICF3IUC3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterICF3IUC3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterICF3IUC3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3IUC3_SetInput, None, itkImageToImageFilterICF3IUC3)
itkImageToImageFilterICF3IUC3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3IUC3_GetInput, None, itkImageToImageFilterICF3IUC3)
itkImageToImageFilterICF3IUC3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3IUC3_PushBackInput, None, itkImageToImageFilterICF3IUC3)
itkImageToImageFilterICF3IUC3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3IUC3_PopBackInput, None, itkImageToImageFilterICF3IUC3)
itkImageToImageFilterICF3IUC3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3IUC3_PushFrontInput, None, itkImageToImageFilterICF3IUC3)
itkImageToImageFilterICF3IUC3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3IUC3_PopFrontInput, None, itkImageToImageFilterICF3IUC3)
itkImageToImageFilterICF3IUC3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3IUC3_SetCoordinateTolerance, None, itkImageToImageFilterICF3IUC3)
itkImageToImageFilterICF3IUC3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3IUC3_GetCoordinateTolerance, None, itkImageToImageFilterICF3IUC3)
itkImageToImageFilterICF3IUC3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3IUC3_SetDirectionTolerance, None, itkImageToImageFilterICF3IUC3)
itkImageToImageFilterICF3IUC3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3IUC3_GetDirectionTolerance, None, itkImageToImageFilterICF3IUC3)
itkImageToImageFilterICF3IUC3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterICF3IUC3_swigregister
itkImageToImageFilterICF3IUC3_swigregister(itkImageToImageFilterICF3IUC3)

def itkImageToImageFilterICF3IUC3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterICF3IUC3 *":
    """itkImageToImageFilterICF3IUC3_cast(itkLightObject obj) -> itkImageToImageFilterICF3IUC3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterICF3IUC3_cast(obj)

class itkImageToImageFilterICF3IUS3(itkImageSourcePython.itkImageSourceIUS3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterICF3IUS3 self, itkImageCF3 image)
        SetInput(itkImageToImageFilterICF3IUS3 self, unsigned int arg0, itkImageCF3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3IUS3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageCF3 const *":
        """
        GetInput(itkImageToImageFilterICF3IUS3 self) -> itkImageCF3
        GetInput(itkImageToImageFilterICF3IUS3 self, unsigned int idx) -> itkImageCF3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3IUS3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageCF3') -> "void":
        """
        PushBackInput(itkImageToImageFilterICF3IUS3 self, itkImageCF3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3IUS3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterICF3IUS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3IUS3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageCF3') -> "void":
        """PushFrontInput(itkImageToImageFilterICF3IUS3 self, itkImageCF3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3IUS3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterICF3IUS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3IUS3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterICF3IUS3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3IUS3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterICF3IUS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3IUS3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterICF3IUS3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3IUS3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterICF3IUS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3IUS3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterICF3IUS3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterICF3IUS3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterICF3IUS3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICF3IUS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterICF3IUS3

        Create a new object of the class itkImageToImageFilterICF3IUS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterICF3IUS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterICF3IUS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterICF3IUS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterICF3IUS3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3IUS3_SetInput, None, itkImageToImageFilterICF3IUS3)
itkImageToImageFilterICF3IUS3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3IUS3_GetInput, None, itkImageToImageFilterICF3IUS3)
itkImageToImageFilterICF3IUS3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3IUS3_PushBackInput, None, itkImageToImageFilterICF3IUS3)
itkImageToImageFilterICF3IUS3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3IUS3_PopBackInput, None, itkImageToImageFilterICF3IUS3)
itkImageToImageFilterICF3IUS3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3IUS3_PushFrontInput, None, itkImageToImageFilterICF3IUS3)
itkImageToImageFilterICF3IUS3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3IUS3_PopFrontInput, None, itkImageToImageFilterICF3IUS3)
itkImageToImageFilterICF3IUS3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3IUS3_SetCoordinateTolerance, None, itkImageToImageFilterICF3IUS3)
itkImageToImageFilterICF3IUS3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3IUS3_GetCoordinateTolerance, None, itkImageToImageFilterICF3IUS3)
itkImageToImageFilterICF3IUS3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3IUS3_SetDirectionTolerance, None, itkImageToImageFilterICF3IUS3)
itkImageToImageFilterICF3IUS3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICF3IUS3_GetDirectionTolerance, None, itkImageToImageFilterICF3IUS3)
itkImageToImageFilterICF3IUS3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterICF3IUS3_swigregister
itkImageToImageFilterICF3IUS3_swigregister(itkImageToImageFilterICF3IUS3)

def itkImageToImageFilterICF3IUS3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterICF3IUS3 *":
    """itkImageToImageFilterICF3IUS3_cast(itkLightObject obj) -> itkImageToImageFilterICF3IUS3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterICF3IUS3_cast(obj)

class itkImageToImageFilterICVF22ID2(itkImageSourcePython.itkImageSourceID2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterICVF22ID2 self, itkImageCVF22 image)
        SetInput(itkImageToImageFilterICVF22ID2 self, unsigned int arg0, itkImageCVF22 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF22ID2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageCVF22 const *":
        """
        GetInput(itkImageToImageFilterICVF22ID2 self) -> itkImageCVF22
        GetInput(itkImageToImageFilterICVF22ID2 self, unsigned int idx) -> itkImageCVF22
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF22ID2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageCVF22') -> "void":
        """
        PushBackInput(itkImageToImageFilterICVF22ID2 self, itkImageCVF22 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF22ID2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterICVF22ID2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF22ID2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageCVF22') -> "void":
        """PushFrontInput(itkImageToImageFilterICVF22ID2 self, itkImageCVF22 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF22ID2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterICVF22ID2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF22ID2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterICVF22ID2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF22ID2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterICVF22ID2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF22ID2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterICVF22ID2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF22ID2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterICVF22ID2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF22ID2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterICVF22ID2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF22ID2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterICVF22ID2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF22ID2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterICVF22ID2

        Create a new object of the class itkImageToImageFilterICVF22ID2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterICVF22ID2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterICVF22ID2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterICVF22ID2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterICVF22ID2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF22ID2_SetInput, None, itkImageToImageFilterICVF22ID2)
itkImageToImageFilterICVF22ID2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF22ID2_GetInput, None, itkImageToImageFilterICVF22ID2)
itkImageToImageFilterICVF22ID2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF22ID2_PushBackInput, None, itkImageToImageFilterICVF22ID2)
itkImageToImageFilterICVF22ID2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF22ID2_PopBackInput, None, itkImageToImageFilterICVF22ID2)
itkImageToImageFilterICVF22ID2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF22ID2_PushFrontInput, None, itkImageToImageFilterICVF22ID2)
itkImageToImageFilterICVF22ID2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF22ID2_PopFrontInput, None, itkImageToImageFilterICVF22ID2)
itkImageToImageFilterICVF22ID2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF22ID2_SetCoordinateTolerance, None, itkImageToImageFilterICVF22ID2)
itkImageToImageFilterICVF22ID2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF22ID2_GetCoordinateTolerance, None, itkImageToImageFilterICVF22ID2)
itkImageToImageFilterICVF22ID2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF22ID2_SetDirectionTolerance, None, itkImageToImageFilterICVF22ID2)
itkImageToImageFilterICVF22ID2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF22ID2_GetDirectionTolerance, None, itkImageToImageFilterICVF22ID2)
itkImageToImageFilterICVF22ID2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterICVF22ID2_swigregister
itkImageToImageFilterICVF22ID2_swigregister(itkImageToImageFilterICVF22ID2)

def itkImageToImageFilterICVF22ID2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF22ID2 *":
    """itkImageToImageFilterICVF22ID2_cast(itkLightObject obj) -> itkImageToImageFilterICVF22ID2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterICVF22ID2_cast(obj)

class itkImageToImageFilterICVF22IF2(itkImageSourcePython.itkImageSourceIF2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterICVF22IF2 self, itkImageCVF22 image)
        SetInput(itkImageToImageFilterICVF22IF2 self, unsigned int arg0, itkImageCVF22 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF22IF2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageCVF22 const *":
        """
        GetInput(itkImageToImageFilterICVF22IF2 self) -> itkImageCVF22
        GetInput(itkImageToImageFilterICVF22IF2 self, unsigned int idx) -> itkImageCVF22
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF22IF2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageCVF22') -> "void":
        """
        PushBackInput(itkImageToImageFilterICVF22IF2 self, itkImageCVF22 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF22IF2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterICVF22IF2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF22IF2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageCVF22') -> "void":
        """PushFrontInput(itkImageToImageFilterICVF22IF2 self, itkImageCVF22 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF22IF2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterICVF22IF2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF22IF2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterICVF22IF2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF22IF2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterICVF22IF2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF22IF2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterICVF22IF2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF22IF2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterICVF22IF2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF22IF2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterICVF22IF2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF22IF2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterICVF22IF2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF22IF2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterICVF22IF2

        Create a new object of the class itkImageToImageFilterICVF22IF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterICVF22IF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterICVF22IF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterICVF22IF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterICVF22IF2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF22IF2_SetInput, None, itkImageToImageFilterICVF22IF2)
itkImageToImageFilterICVF22IF2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF22IF2_GetInput, None, itkImageToImageFilterICVF22IF2)
itkImageToImageFilterICVF22IF2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF22IF2_PushBackInput, None, itkImageToImageFilterICVF22IF2)
itkImageToImageFilterICVF22IF2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF22IF2_PopBackInput, None, itkImageToImageFilterICVF22IF2)
itkImageToImageFilterICVF22IF2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF22IF2_PushFrontInput, None, itkImageToImageFilterICVF22IF2)
itkImageToImageFilterICVF22IF2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF22IF2_PopFrontInput, None, itkImageToImageFilterICVF22IF2)
itkImageToImageFilterICVF22IF2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF22IF2_SetCoordinateTolerance, None, itkImageToImageFilterICVF22IF2)
itkImageToImageFilterICVF22IF2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF22IF2_GetCoordinateTolerance, None, itkImageToImageFilterICVF22IF2)
itkImageToImageFilterICVF22IF2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF22IF2_SetDirectionTolerance, None, itkImageToImageFilterICVF22IF2)
itkImageToImageFilterICVF22IF2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF22IF2_GetDirectionTolerance, None, itkImageToImageFilterICVF22IF2)
itkImageToImageFilterICVF22IF2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterICVF22IF2_swigregister
itkImageToImageFilterICVF22IF2_swigregister(itkImageToImageFilterICVF22IF2)

def itkImageToImageFilterICVF22IF2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF22IF2 *":
    """itkImageToImageFilterICVF22IF2_cast(itkLightObject obj) -> itkImageToImageFilterICVF22IF2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterICVF22IF2_cast(obj)

class itkImageToImageFilterICVF22ISS2(itkImageSourcePython.itkImageSourceISS2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterICVF22ISS2 self, itkImageCVF22 image)
        SetInput(itkImageToImageFilterICVF22ISS2 self, unsigned int arg0, itkImageCVF22 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF22ISS2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageCVF22 const *":
        """
        GetInput(itkImageToImageFilterICVF22ISS2 self) -> itkImageCVF22
        GetInput(itkImageToImageFilterICVF22ISS2 self, unsigned int idx) -> itkImageCVF22
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF22ISS2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageCVF22') -> "void":
        """
        PushBackInput(itkImageToImageFilterICVF22ISS2 self, itkImageCVF22 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF22ISS2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterICVF22ISS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF22ISS2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageCVF22') -> "void":
        """PushFrontInput(itkImageToImageFilterICVF22ISS2 self, itkImageCVF22 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF22ISS2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterICVF22ISS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF22ISS2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterICVF22ISS2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF22ISS2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterICVF22ISS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF22ISS2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterICVF22ISS2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF22ISS2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterICVF22ISS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF22ISS2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterICVF22ISS2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF22ISS2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterICVF22ISS2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF22ISS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterICVF22ISS2

        Create a new object of the class itkImageToImageFilterICVF22ISS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterICVF22ISS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterICVF22ISS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterICVF22ISS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterICVF22ISS2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF22ISS2_SetInput, None, itkImageToImageFilterICVF22ISS2)
itkImageToImageFilterICVF22ISS2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF22ISS2_GetInput, None, itkImageToImageFilterICVF22ISS2)
itkImageToImageFilterICVF22ISS2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF22ISS2_PushBackInput, None, itkImageToImageFilterICVF22ISS2)
itkImageToImageFilterICVF22ISS2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF22ISS2_PopBackInput, None, itkImageToImageFilterICVF22ISS2)
itkImageToImageFilterICVF22ISS2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF22ISS2_PushFrontInput, None, itkImageToImageFilterICVF22ISS2)
itkImageToImageFilterICVF22ISS2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF22ISS2_PopFrontInput, None, itkImageToImageFilterICVF22ISS2)
itkImageToImageFilterICVF22ISS2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF22ISS2_SetCoordinateTolerance, None, itkImageToImageFilterICVF22ISS2)
itkImageToImageFilterICVF22ISS2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF22ISS2_GetCoordinateTolerance, None, itkImageToImageFilterICVF22ISS2)
itkImageToImageFilterICVF22ISS2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF22ISS2_SetDirectionTolerance, None, itkImageToImageFilterICVF22ISS2)
itkImageToImageFilterICVF22ISS2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF22ISS2_GetDirectionTolerance, None, itkImageToImageFilterICVF22ISS2)
itkImageToImageFilterICVF22ISS2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterICVF22ISS2_swigregister
itkImageToImageFilterICVF22ISS2_swigregister(itkImageToImageFilterICVF22ISS2)

def itkImageToImageFilterICVF22ISS2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF22ISS2 *":
    """itkImageToImageFilterICVF22ISS2_cast(itkLightObject obj) -> itkImageToImageFilterICVF22ISS2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterICVF22ISS2_cast(obj)

class itkImageToImageFilterICVF22IUC2(itkImageSourcePython.itkImageSourceIUC2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterICVF22IUC2 self, itkImageCVF22 image)
        SetInput(itkImageToImageFilterICVF22IUC2 self, unsigned int arg0, itkImageCVF22 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF22IUC2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageCVF22 const *":
        """
        GetInput(itkImageToImageFilterICVF22IUC2 self) -> itkImageCVF22
        GetInput(itkImageToImageFilterICVF22IUC2 self, unsigned int idx) -> itkImageCVF22
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF22IUC2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageCVF22') -> "void":
        """
        PushBackInput(itkImageToImageFilterICVF22IUC2 self, itkImageCVF22 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF22IUC2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterICVF22IUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF22IUC2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageCVF22') -> "void":
        """PushFrontInput(itkImageToImageFilterICVF22IUC2 self, itkImageCVF22 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF22IUC2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterICVF22IUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF22IUC2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterICVF22IUC2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF22IUC2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterICVF22IUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF22IUC2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterICVF22IUC2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF22IUC2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterICVF22IUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF22IUC2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterICVF22IUC2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF22IUC2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterICVF22IUC2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF22IUC2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterICVF22IUC2

        Create a new object of the class itkImageToImageFilterICVF22IUC2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterICVF22IUC2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterICVF22IUC2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterICVF22IUC2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterICVF22IUC2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF22IUC2_SetInput, None, itkImageToImageFilterICVF22IUC2)
itkImageToImageFilterICVF22IUC2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF22IUC2_GetInput, None, itkImageToImageFilterICVF22IUC2)
itkImageToImageFilterICVF22IUC2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF22IUC2_PushBackInput, None, itkImageToImageFilterICVF22IUC2)
itkImageToImageFilterICVF22IUC2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF22IUC2_PopBackInput, None, itkImageToImageFilterICVF22IUC2)
itkImageToImageFilterICVF22IUC2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF22IUC2_PushFrontInput, None, itkImageToImageFilterICVF22IUC2)
itkImageToImageFilterICVF22IUC2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF22IUC2_PopFrontInput, None, itkImageToImageFilterICVF22IUC2)
itkImageToImageFilterICVF22IUC2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF22IUC2_SetCoordinateTolerance, None, itkImageToImageFilterICVF22IUC2)
itkImageToImageFilterICVF22IUC2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF22IUC2_GetCoordinateTolerance, None, itkImageToImageFilterICVF22IUC2)
itkImageToImageFilterICVF22IUC2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF22IUC2_SetDirectionTolerance, None, itkImageToImageFilterICVF22IUC2)
itkImageToImageFilterICVF22IUC2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF22IUC2_GetDirectionTolerance, None, itkImageToImageFilterICVF22IUC2)
itkImageToImageFilterICVF22IUC2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterICVF22IUC2_swigregister
itkImageToImageFilterICVF22IUC2_swigregister(itkImageToImageFilterICVF22IUC2)

def itkImageToImageFilterICVF22IUC2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF22IUC2 *":
    """itkImageToImageFilterICVF22IUC2_cast(itkLightObject obj) -> itkImageToImageFilterICVF22IUC2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterICVF22IUC2_cast(obj)

class itkImageToImageFilterICVF22IUS2(itkImageSourcePython.itkImageSourceIUS2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterICVF22IUS2 self, itkImageCVF22 image)
        SetInput(itkImageToImageFilterICVF22IUS2 self, unsigned int arg0, itkImageCVF22 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF22IUS2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageCVF22 const *":
        """
        GetInput(itkImageToImageFilterICVF22IUS2 self) -> itkImageCVF22
        GetInput(itkImageToImageFilterICVF22IUS2 self, unsigned int idx) -> itkImageCVF22
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF22IUS2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageCVF22') -> "void":
        """
        PushBackInput(itkImageToImageFilterICVF22IUS2 self, itkImageCVF22 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF22IUS2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterICVF22IUS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF22IUS2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageCVF22') -> "void":
        """PushFrontInput(itkImageToImageFilterICVF22IUS2 self, itkImageCVF22 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF22IUS2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterICVF22IUS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF22IUS2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterICVF22IUS2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF22IUS2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterICVF22IUS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF22IUS2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterICVF22IUS2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF22IUS2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterICVF22IUS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF22IUS2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterICVF22IUS2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF22IUS2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterICVF22IUS2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF22IUS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterICVF22IUS2

        Create a new object of the class itkImageToImageFilterICVF22IUS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterICVF22IUS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterICVF22IUS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterICVF22IUS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterICVF22IUS2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF22IUS2_SetInput, None, itkImageToImageFilterICVF22IUS2)
itkImageToImageFilterICVF22IUS2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF22IUS2_GetInput, None, itkImageToImageFilterICVF22IUS2)
itkImageToImageFilterICVF22IUS2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF22IUS2_PushBackInput, None, itkImageToImageFilterICVF22IUS2)
itkImageToImageFilterICVF22IUS2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF22IUS2_PopBackInput, None, itkImageToImageFilterICVF22IUS2)
itkImageToImageFilterICVF22IUS2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF22IUS2_PushFrontInput, None, itkImageToImageFilterICVF22IUS2)
itkImageToImageFilterICVF22IUS2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF22IUS2_PopFrontInput, None, itkImageToImageFilterICVF22IUS2)
itkImageToImageFilterICVF22IUS2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF22IUS2_SetCoordinateTolerance, None, itkImageToImageFilterICVF22IUS2)
itkImageToImageFilterICVF22IUS2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF22IUS2_GetCoordinateTolerance, None, itkImageToImageFilterICVF22IUS2)
itkImageToImageFilterICVF22IUS2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF22IUS2_SetDirectionTolerance, None, itkImageToImageFilterICVF22IUS2)
itkImageToImageFilterICVF22IUS2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF22IUS2_GetDirectionTolerance, None, itkImageToImageFilterICVF22IUS2)
itkImageToImageFilterICVF22IUS2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterICVF22IUS2_swigregister
itkImageToImageFilterICVF22IUS2_swigregister(itkImageToImageFilterICVF22IUS2)

def itkImageToImageFilterICVF22IUS2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF22IUS2 *":
    """itkImageToImageFilterICVF22IUS2_cast(itkLightObject obj) -> itkImageToImageFilterICVF22IUS2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterICVF22IUS2_cast(obj)

class itkImageToImageFilterICVF23ID3(itkImageSourcePython.itkImageSourceID3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterICVF23ID3 self, itkImageCVF23 image)
        SetInput(itkImageToImageFilterICVF23ID3 self, unsigned int arg0, itkImageCVF23 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF23ID3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageCVF23 const *":
        """
        GetInput(itkImageToImageFilterICVF23ID3 self) -> itkImageCVF23
        GetInput(itkImageToImageFilterICVF23ID3 self, unsigned int idx) -> itkImageCVF23
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF23ID3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageCVF23') -> "void":
        """
        PushBackInput(itkImageToImageFilterICVF23ID3 self, itkImageCVF23 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF23ID3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterICVF23ID3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF23ID3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageCVF23') -> "void":
        """PushFrontInput(itkImageToImageFilterICVF23ID3 self, itkImageCVF23 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF23ID3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterICVF23ID3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF23ID3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterICVF23ID3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF23ID3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterICVF23ID3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF23ID3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterICVF23ID3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF23ID3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterICVF23ID3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF23ID3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterICVF23ID3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF23ID3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterICVF23ID3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF23ID3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterICVF23ID3

        Create a new object of the class itkImageToImageFilterICVF23ID3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterICVF23ID3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterICVF23ID3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterICVF23ID3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterICVF23ID3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF23ID3_SetInput, None, itkImageToImageFilterICVF23ID3)
itkImageToImageFilterICVF23ID3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF23ID3_GetInput, None, itkImageToImageFilterICVF23ID3)
itkImageToImageFilterICVF23ID3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF23ID3_PushBackInput, None, itkImageToImageFilterICVF23ID3)
itkImageToImageFilterICVF23ID3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF23ID3_PopBackInput, None, itkImageToImageFilterICVF23ID3)
itkImageToImageFilterICVF23ID3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF23ID3_PushFrontInput, None, itkImageToImageFilterICVF23ID3)
itkImageToImageFilterICVF23ID3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF23ID3_PopFrontInput, None, itkImageToImageFilterICVF23ID3)
itkImageToImageFilterICVF23ID3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF23ID3_SetCoordinateTolerance, None, itkImageToImageFilterICVF23ID3)
itkImageToImageFilterICVF23ID3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF23ID3_GetCoordinateTolerance, None, itkImageToImageFilterICVF23ID3)
itkImageToImageFilterICVF23ID3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF23ID3_SetDirectionTolerance, None, itkImageToImageFilterICVF23ID3)
itkImageToImageFilterICVF23ID3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF23ID3_GetDirectionTolerance, None, itkImageToImageFilterICVF23ID3)
itkImageToImageFilterICVF23ID3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterICVF23ID3_swigregister
itkImageToImageFilterICVF23ID3_swigregister(itkImageToImageFilterICVF23ID3)

def itkImageToImageFilterICVF23ID3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF23ID3 *":
    """itkImageToImageFilterICVF23ID3_cast(itkLightObject obj) -> itkImageToImageFilterICVF23ID3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterICVF23ID3_cast(obj)

class itkImageToImageFilterICVF23IF3(itkImageSourcePython.itkImageSourceIF3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterICVF23IF3 self, itkImageCVF23 image)
        SetInput(itkImageToImageFilterICVF23IF3 self, unsigned int arg0, itkImageCVF23 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF23IF3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageCVF23 const *":
        """
        GetInput(itkImageToImageFilterICVF23IF3 self) -> itkImageCVF23
        GetInput(itkImageToImageFilterICVF23IF3 self, unsigned int idx) -> itkImageCVF23
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF23IF3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageCVF23') -> "void":
        """
        PushBackInput(itkImageToImageFilterICVF23IF3 self, itkImageCVF23 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF23IF3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterICVF23IF3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF23IF3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageCVF23') -> "void":
        """PushFrontInput(itkImageToImageFilterICVF23IF3 self, itkImageCVF23 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF23IF3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterICVF23IF3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF23IF3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterICVF23IF3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF23IF3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterICVF23IF3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF23IF3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterICVF23IF3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF23IF3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterICVF23IF3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF23IF3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterICVF23IF3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF23IF3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterICVF23IF3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF23IF3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterICVF23IF3

        Create a new object of the class itkImageToImageFilterICVF23IF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterICVF23IF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterICVF23IF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterICVF23IF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterICVF23IF3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF23IF3_SetInput, None, itkImageToImageFilterICVF23IF3)
itkImageToImageFilterICVF23IF3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF23IF3_GetInput, None, itkImageToImageFilterICVF23IF3)
itkImageToImageFilterICVF23IF3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF23IF3_PushBackInput, None, itkImageToImageFilterICVF23IF3)
itkImageToImageFilterICVF23IF3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF23IF3_PopBackInput, None, itkImageToImageFilterICVF23IF3)
itkImageToImageFilterICVF23IF3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF23IF3_PushFrontInput, None, itkImageToImageFilterICVF23IF3)
itkImageToImageFilterICVF23IF3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF23IF3_PopFrontInput, None, itkImageToImageFilterICVF23IF3)
itkImageToImageFilterICVF23IF3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF23IF3_SetCoordinateTolerance, None, itkImageToImageFilterICVF23IF3)
itkImageToImageFilterICVF23IF3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF23IF3_GetCoordinateTolerance, None, itkImageToImageFilterICVF23IF3)
itkImageToImageFilterICVF23IF3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF23IF3_SetDirectionTolerance, None, itkImageToImageFilterICVF23IF3)
itkImageToImageFilterICVF23IF3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF23IF3_GetDirectionTolerance, None, itkImageToImageFilterICVF23IF3)
itkImageToImageFilterICVF23IF3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterICVF23IF3_swigregister
itkImageToImageFilterICVF23IF3_swigregister(itkImageToImageFilterICVF23IF3)

def itkImageToImageFilterICVF23IF3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF23IF3 *":
    """itkImageToImageFilterICVF23IF3_cast(itkLightObject obj) -> itkImageToImageFilterICVF23IF3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterICVF23IF3_cast(obj)

class itkImageToImageFilterICVF23ISS3(itkImageSourcePython.itkImageSourceISS3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterICVF23ISS3 self, itkImageCVF23 image)
        SetInput(itkImageToImageFilterICVF23ISS3 self, unsigned int arg0, itkImageCVF23 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF23ISS3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageCVF23 const *":
        """
        GetInput(itkImageToImageFilterICVF23ISS3 self) -> itkImageCVF23
        GetInput(itkImageToImageFilterICVF23ISS3 self, unsigned int idx) -> itkImageCVF23
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF23ISS3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageCVF23') -> "void":
        """
        PushBackInput(itkImageToImageFilterICVF23ISS3 self, itkImageCVF23 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF23ISS3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterICVF23ISS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF23ISS3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageCVF23') -> "void":
        """PushFrontInput(itkImageToImageFilterICVF23ISS3 self, itkImageCVF23 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF23ISS3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterICVF23ISS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF23ISS3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterICVF23ISS3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF23ISS3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterICVF23ISS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF23ISS3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterICVF23ISS3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF23ISS3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterICVF23ISS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF23ISS3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterICVF23ISS3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF23ISS3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterICVF23ISS3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF23ISS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterICVF23ISS3

        Create a new object of the class itkImageToImageFilterICVF23ISS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterICVF23ISS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterICVF23ISS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterICVF23ISS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterICVF23ISS3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF23ISS3_SetInput, None, itkImageToImageFilterICVF23ISS3)
itkImageToImageFilterICVF23ISS3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF23ISS3_GetInput, None, itkImageToImageFilterICVF23ISS3)
itkImageToImageFilterICVF23ISS3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF23ISS3_PushBackInput, None, itkImageToImageFilterICVF23ISS3)
itkImageToImageFilterICVF23ISS3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF23ISS3_PopBackInput, None, itkImageToImageFilterICVF23ISS3)
itkImageToImageFilterICVF23ISS3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF23ISS3_PushFrontInput, None, itkImageToImageFilterICVF23ISS3)
itkImageToImageFilterICVF23ISS3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF23ISS3_PopFrontInput, None, itkImageToImageFilterICVF23ISS3)
itkImageToImageFilterICVF23ISS3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF23ISS3_SetCoordinateTolerance, None, itkImageToImageFilterICVF23ISS3)
itkImageToImageFilterICVF23ISS3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF23ISS3_GetCoordinateTolerance, None, itkImageToImageFilterICVF23ISS3)
itkImageToImageFilterICVF23ISS3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF23ISS3_SetDirectionTolerance, None, itkImageToImageFilterICVF23ISS3)
itkImageToImageFilterICVF23ISS3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF23ISS3_GetDirectionTolerance, None, itkImageToImageFilterICVF23ISS3)
itkImageToImageFilterICVF23ISS3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterICVF23ISS3_swigregister
itkImageToImageFilterICVF23ISS3_swigregister(itkImageToImageFilterICVF23ISS3)

def itkImageToImageFilterICVF23ISS3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF23ISS3 *":
    """itkImageToImageFilterICVF23ISS3_cast(itkLightObject obj) -> itkImageToImageFilterICVF23ISS3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterICVF23ISS3_cast(obj)

class itkImageToImageFilterICVF23IUC3(itkImageSourcePython.itkImageSourceIUC3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterICVF23IUC3 self, itkImageCVF23 image)
        SetInput(itkImageToImageFilterICVF23IUC3 self, unsigned int arg0, itkImageCVF23 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF23IUC3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageCVF23 const *":
        """
        GetInput(itkImageToImageFilterICVF23IUC3 self) -> itkImageCVF23
        GetInput(itkImageToImageFilterICVF23IUC3 self, unsigned int idx) -> itkImageCVF23
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF23IUC3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageCVF23') -> "void":
        """
        PushBackInput(itkImageToImageFilterICVF23IUC3 self, itkImageCVF23 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF23IUC3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterICVF23IUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF23IUC3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageCVF23') -> "void":
        """PushFrontInput(itkImageToImageFilterICVF23IUC3 self, itkImageCVF23 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF23IUC3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterICVF23IUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF23IUC3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterICVF23IUC3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF23IUC3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterICVF23IUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF23IUC3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterICVF23IUC3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF23IUC3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterICVF23IUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF23IUC3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterICVF23IUC3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF23IUC3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterICVF23IUC3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF23IUC3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterICVF23IUC3

        Create a new object of the class itkImageToImageFilterICVF23IUC3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterICVF23IUC3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterICVF23IUC3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterICVF23IUC3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterICVF23IUC3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF23IUC3_SetInput, None, itkImageToImageFilterICVF23IUC3)
itkImageToImageFilterICVF23IUC3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF23IUC3_GetInput, None, itkImageToImageFilterICVF23IUC3)
itkImageToImageFilterICVF23IUC3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF23IUC3_PushBackInput, None, itkImageToImageFilterICVF23IUC3)
itkImageToImageFilterICVF23IUC3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF23IUC3_PopBackInput, None, itkImageToImageFilterICVF23IUC3)
itkImageToImageFilterICVF23IUC3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF23IUC3_PushFrontInput, None, itkImageToImageFilterICVF23IUC3)
itkImageToImageFilterICVF23IUC3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF23IUC3_PopFrontInput, None, itkImageToImageFilterICVF23IUC3)
itkImageToImageFilterICVF23IUC3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF23IUC3_SetCoordinateTolerance, None, itkImageToImageFilterICVF23IUC3)
itkImageToImageFilterICVF23IUC3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF23IUC3_GetCoordinateTolerance, None, itkImageToImageFilterICVF23IUC3)
itkImageToImageFilterICVF23IUC3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF23IUC3_SetDirectionTolerance, None, itkImageToImageFilterICVF23IUC3)
itkImageToImageFilterICVF23IUC3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF23IUC3_GetDirectionTolerance, None, itkImageToImageFilterICVF23IUC3)
itkImageToImageFilterICVF23IUC3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterICVF23IUC3_swigregister
itkImageToImageFilterICVF23IUC3_swigregister(itkImageToImageFilterICVF23IUC3)

def itkImageToImageFilterICVF23IUC3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF23IUC3 *":
    """itkImageToImageFilterICVF23IUC3_cast(itkLightObject obj) -> itkImageToImageFilterICVF23IUC3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterICVF23IUC3_cast(obj)

class itkImageToImageFilterICVF23IUS3(itkImageSourcePython.itkImageSourceIUS3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterICVF23IUS3 self, itkImageCVF23 image)
        SetInput(itkImageToImageFilterICVF23IUS3 self, unsigned int arg0, itkImageCVF23 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF23IUS3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageCVF23 const *":
        """
        GetInput(itkImageToImageFilterICVF23IUS3 self) -> itkImageCVF23
        GetInput(itkImageToImageFilterICVF23IUS3 self, unsigned int idx) -> itkImageCVF23
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF23IUS3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageCVF23') -> "void":
        """
        PushBackInput(itkImageToImageFilterICVF23IUS3 self, itkImageCVF23 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF23IUS3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterICVF23IUS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF23IUS3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageCVF23') -> "void":
        """PushFrontInput(itkImageToImageFilterICVF23IUS3 self, itkImageCVF23 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF23IUS3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterICVF23IUS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF23IUS3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterICVF23IUS3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF23IUS3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterICVF23IUS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF23IUS3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterICVF23IUS3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF23IUS3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterICVF23IUS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF23IUS3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterICVF23IUS3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF23IUS3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterICVF23IUS3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF23IUS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterICVF23IUS3

        Create a new object of the class itkImageToImageFilterICVF23IUS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterICVF23IUS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterICVF23IUS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterICVF23IUS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterICVF23IUS3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF23IUS3_SetInput, None, itkImageToImageFilterICVF23IUS3)
itkImageToImageFilterICVF23IUS3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF23IUS3_GetInput, None, itkImageToImageFilterICVF23IUS3)
itkImageToImageFilterICVF23IUS3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF23IUS3_PushBackInput, None, itkImageToImageFilterICVF23IUS3)
itkImageToImageFilterICVF23IUS3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF23IUS3_PopBackInput, None, itkImageToImageFilterICVF23IUS3)
itkImageToImageFilterICVF23IUS3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF23IUS3_PushFrontInput, None, itkImageToImageFilterICVF23IUS3)
itkImageToImageFilterICVF23IUS3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF23IUS3_PopFrontInput, None, itkImageToImageFilterICVF23IUS3)
itkImageToImageFilterICVF23IUS3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF23IUS3_SetCoordinateTolerance, None, itkImageToImageFilterICVF23IUS3)
itkImageToImageFilterICVF23IUS3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF23IUS3_GetCoordinateTolerance, None, itkImageToImageFilterICVF23IUS3)
itkImageToImageFilterICVF23IUS3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF23IUS3_SetDirectionTolerance, None, itkImageToImageFilterICVF23IUS3)
itkImageToImageFilterICVF23IUS3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF23IUS3_GetDirectionTolerance, None, itkImageToImageFilterICVF23IUS3)
itkImageToImageFilterICVF23IUS3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterICVF23IUS3_swigregister
itkImageToImageFilterICVF23IUS3_swigregister(itkImageToImageFilterICVF23IUS3)

def itkImageToImageFilterICVF23IUS3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF23IUS3 *":
    """itkImageToImageFilterICVF23IUS3_cast(itkLightObject obj) -> itkImageToImageFilterICVF23IUS3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterICVF23IUS3_cast(obj)

class itkImageToImageFilterICVF32ID2(itkImageSourcePython.itkImageSourceID2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterICVF32ID2 self, itkImageCVF32 image)
        SetInput(itkImageToImageFilterICVF32ID2 self, unsigned int arg0, itkImageCVF32 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF32ID2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageCVF32 const *":
        """
        GetInput(itkImageToImageFilterICVF32ID2 self) -> itkImageCVF32
        GetInput(itkImageToImageFilterICVF32ID2 self, unsigned int idx) -> itkImageCVF32
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF32ID2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageCVF32') -> "void":
        """
        PushBackInput(itkImageToImageFilterICVF32ID2 self, itkImageCVF32 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF32ID2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterICVF32ID2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF32ID2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageCVF32') -> "void":
        """PushFrontInput(itkImageToImageFilterICVF32ID2 self, itkImageCVF32 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF32ID2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterICVF32ID2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF32ID2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterICVF32ID2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF32ID2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterICVF32ID2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF32ID2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterICVF32ID2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF32ID2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterICVF32ID2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF32ID2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterICVF32ID2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF32ID2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterICVF32ID2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF32ID2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterICVF32ID2

        Create a new object of the class itkImageToImageFilterICVF32ID2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterICVF32ID2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterICVF32ID2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterICVF32ID2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterICVF32ID2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF32ID2_SetInput, None, itkImageToImageFilterICVF32ID2)
itkImageToImageFilterICVF32ID2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF32ID2_GetInput, None, itkImageToImageFilterICVF32ID2)
itkImageToImageFilterICVF32ID2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF32ID2_PushBackInput, None, itkImageToImageFilterICVF32ID2)
itkImageToImageFilterICVF32ID2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF32ID2_PopBackInput, None, itkImageToImageFilterICVF32ID2)
itkImageToImageFilterICVF32ID2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF32ID2_PushFrontInput, None, itkImageToImageFilterICVF32ID2)
itkImageToImageFilterICVF32ID2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF32ID2_PopFrontInput, None, itkImageToImageFilterICVF32ID2)
itkImageToImageFilterICVF32ID2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF32ID2_SetCoordinateTolerance, None, itkImageToImageFilterICVF32ID2)
itkImageToImageFilterICVF32ID2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF32ID2_GetCoordinateTolerance, None, itkImageToImageFilterICVF32ID2)
itkImageToImageFilterICVF32ID2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF32ID2_SetDirectionTolerance, None, itkImageToImageFilterICVF32ID2)
itkImageToImageFilterICVF32ID2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF32ID2_GetDirectionTolerance, None, itkImageToImageFilterICVF32ID2)
itkImageToImageFilterICVF32ID2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterICVF32ID2_swigregister
itkImageToImageFilterICVF32ID2_swigregister(itkImageToImageFilterICVF32ID2)

def itkImageToImageFilterICVF32ID2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF32ID2 *":
    """itkImageToImageFilterICVF32ID2_cast(itkLightObject obj) -> itkImageToImageFilterICVF32ID2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterICVF32ID2_cast(obj)

class itkImageToImageFilterICVF32IF2(itkImageSourcePython.itkImageSourceIF2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterICVF32IF2 self, itkImageCVF32 image)
        SetInput(itkImageToImageFilterICVF32IF2 self, unsigned int arg0, itkImageCVF32 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF32IF2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageCVF32 const *":
        """
        GetInput(itkImageToImageFilterICVF32IF2 self) -> itkImageCVF32
        GetInput(itkImageToImageFilterICVF32IF2 self, unsigned int idx) -> itkImageCVF32
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF32IF2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageCVF32') -> "void":
        """
        PushBackInput(itkImageToImageFilterICVF32IF2 self, itkImageCVF32 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF32IF2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterICVF32IF2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF32IF2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageCVF32') -> "void":
        """PushFrontInput(itkImageToImageFilterICVF32IF2 self, itkImageCVF32 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF32IF2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterICVF32IF2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF32IF2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterICVF32IF2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF32IF2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterICVF32IF2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF32IF2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterICVF32IF2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF32IF2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterICVF32IF2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF32IF2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterICVF32IF2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF32IF2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterICVF32IF2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF32IF2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterICVF32IF2

        Create a new object of the class itkImageToImageFilterICVF32IF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterICVF32IF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterICVF32IF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterICVF32IF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterICVF32IF2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF32IF2_SetInput, None, itkImageToImageFilterICVF32IF2)
itkImageToImageFilterICVF32IF2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF32IF2_GetInput, None, itkImageToImageFilterICVF32IF2)
itkImageToImageFilterICVF32IF2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF32IF2_PushBackInput, None, itkImageToImageFilterICVF32IF2)
itkImageToImageFilterICVF32IF2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF32IF2_PopBackInput, None, itkImageToImageFilterICVF32IF2)
itkImageToImageFilterICVF32IF2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF32IF2_PushFrontInput, None, itkImageToImageFilterICVF32IF2)
itkImageToImageFilterICVF32IF2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF32IF2_PopFrontInput, None, itkImageToImageFilterICVF32IF2)
itkImageToImageFilterICVF32IF2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF32IF2_SetCoordinateTolerance, None, itkImageToImageFilterICVF32IF2)
itkImageToImageFilterICVF32IF2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF32IF2_GetCoordinateTolerance, None, itkImageToImageFilterICVF32IF2)
itkImageToImageFilterICVF32IF2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF32IF2_SetDirectionTolerance, None, itkImageToImageFilterICVF32IF2)
itkImageToImageFilterICVF32IF2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF32IF2_GetDirectionTolerance, None, itkImageToImageFilterICVF32IF2)
itkImageToImageFilterICVF32IF2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterICVF32IF2_swigregister
itkImageToImageFilterICVF32IF2_swigregister(itkImageToImageFilterICVF32IF2)

def itkImageToImageFilterICVF32IF2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF32IF2 *":
    """itkImageToImageFilterICVF32IF2_cast(itkLightObject obj) -> itkImageToImageFilterICVF32IF2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterICVF32IF2_cast(obj)

class itkImageToImageFilterICVF32ISS2(itkImageSourcePython.itkImageSourceISS2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterICVF32ISS2 self, itkImageCVF32 image)
        SetInput(itkImageToImageFilterICVF32ISS2 self, unsigned int arg0, itkImageCVF32 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF32ISS2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageCVF32 const *":
        """
        GetInput(itkImageToImageFilterICVF32ISS2 self) -> itkImageCVF32
        GetInput(itkImageToImageFilterICVF32ISS2 self, unsigned int idx) -> itkImageCVF32
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF32ISS2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageCVF32') -> "void":
        """
        PushBackInput(itkImageToImageFilterICVF32ISS2 self, itkImageCVF32 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF32ISS2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterICVF32ISS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF32ISS2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageCVF32') -> "void":
        """PushFrontInput(itkImageToImageFilterICVF32ISS2 self, itkImageCVF32 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF32ISS2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterICVF32ISS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF32ISS2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterICVF32ISS2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF32ISS2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterICVF32ISS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF32ISS2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterICVF32ISS2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF32ISS2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterICVF32ISS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF32ISS2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterICVF32ISS2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF32ISS2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterICVF32ISS2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF32ISS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterICVF32ISS2

        Create a new object of the class itkImageToImageFilterICVF32ISS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterICVF32ISS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterICVF32ISS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterICVF32ISS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterICVF32ISS2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF32ISS2_SetInput, None, itkImageToImageFilterICVF32ISS2)
itkImageToImageFilterICVF32ISS2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF32ISS2_GetInput, None, itkImageToImageFilterICVF32ISS2)
itkImageToImageFilterICVF32ISS2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF32ISS2_PushBackInput, None, itkImageToImageFilterICVF32ISS2)
itkImageToImageFilterICVF32ISS2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF32ISS2_PopBackInput, None, itkImageToImageFilterICVF32ISS2)
itkImageToImageFilterICVF32ISS2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF32ISS2_PushFrontInput, None, itkImageToImageFilterICVF32ISS2)
itkImageToImageFilterICVF32ISS2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF32ISS2_PopFrontInput, None, itkImageToImageFilterICVF32ISS2)
itkImageToImageFilterICVF32ISS2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF32ISS2_SetCoordinateTolerance, None, itkImageToImageFilterICVF32ISS2)
itkImageToImageFilterICVF32ISS2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF32ISS2_GetCoordinateTolerance, None, itkImageToImageFilterICVF32ISS2)
itkImageToImageFilterICVF32ISS2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF32ISS2_SetDirectionTolerance, None, itkImageToImageFilterICVF32ISS2)
itkImageToImageFilterICVF32ISS2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF32ISS2_GetDirectionTolerance, None, itkImageToImageFilterICVF32ISS2)
itkImageToImageFilterICVF32ISS2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterICVF32ISS2_swigregister
itkImageToImageFilterICVF32ISS2_swigregister(itkImageToImageFilterICVF32ISS2)

def itkImageToImageFilterICVF32ISS2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF32ISS2 *":
    """itkImageToImageFilterICVF32ISS2_cast(itkLightObject obj) -> itkImageToImageFilterICVF32ISS2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterICVF32ISS2_cast(obj)

class itkImageToImageFilterICVF32IUC2(itkImageSourcePython.itkImageSourceIUC2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterICVF32IUC2 self, itkImageCVF32 image)
        SetInput(itkImageToImageFilterICVF32IUC2 self, unsigned int arg0, itkImageCVF32 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF32IUC2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageCVF32 const *":
        """
        GetInput(itkImageToImageFilterICVF32IUC2 self) -> itkImageCVF32
        GetInput(itkImageToImageFilterICVF32IUC2 self, unsigned int idx) -> itkImageCVF32
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF32IUC2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageCVF32') -> "void":
        """
        PushBackInput(itkImageToImageFilterICVF32IUC2 self, itkImageCVF32 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF32IUC2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterICVF32IUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF32IUC2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageCVF32') -> "void":
        """PushFrontInput(itkImageToImageFilterICVF32IUC2 self, itkImageCVF32 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF32IUC2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterICVF32IUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF32IUC2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterICVF32IUC2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF32IUC2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterICVF32IUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF32IUC2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterICVF32IUC2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF32IUC2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterICVF32IUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF32IUC2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterICVF32IUC2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF32IUC2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterICVF32IUC2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF32IUC2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterICVF32IUC2

        Create a new object of the class itkImageToImageFilterICVF32IUC2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterICVF32IUC2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterICVF32IUC2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterICVF32IUC2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterICVF32IUC2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF32IUC2_SetInput, None, itkImageToImageFilterICVF32IUC2)
itkImageToImageFilterICVF32IUC2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF32IUC2_GetInput, None, itkImageToImageFilterICVF32IUC2)
itkImageToImageFilterICVF32IUC2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF32IUC2_PushBackInput, None, itkImageToImageFilterICVF32IUC2)
itkImageToImageFilterICVF32IUC2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF32IUC2_PopBackInput, None, itkImageToImageFilterICVF32IUC2)
itkImageToImageFilterICVF32IUC2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF32IUC2_PushFrontInput, None, itkImageToImageFilterICVF32IUC2)
itkImageToImageFilterICVF32IUC2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF32IUC2_PopFrontInput, None, itkImageToImageFilterICVF32IUC2)
itkImageToImageFilterICVF32IUC2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF32IUC2_SetCoordinateTolerance, None, itkImageToImageFilterICVF32IUC2)
itkImageToImageFilterICVF32IUC2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF32IUC2_GetCoordinateTolerance, None, itkImageToImageFilterICVF32IUC2)
itkImageToImageFilterICVF32IUC2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF32IUC2_SetDirectionTolerance, None, itkImageToImageFilterICVF32IUC2)
itkImageToImageFilterICVF32IUC2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF32IUC2_GetDirectionTolerance, None, itkImageToImageFilterICVF32IUC2)
itkImageToImageFilterICVF32IUC2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterICVF32IUC2_swigregister
itkImageToImageFilterICVF32IUC2_swigregister(itkImageToImageFilterICVF32IUC2)

def itkImageToImageFilterICVF32IUC2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF32IUC2 *":
    """itkImageToImageFilterICVF32IUC2_cast(itkLightObject obj) -> itkImageToImageFilterICVF32IUC2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterICVF32IUC2_cast(obj)

class itkImageToImageFilterICVF32IUS2(itkImageSourcePython.itkImageSourceIUS2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterICVF32IUS2 self, itkImageCVF32 image)
        SetInput(itkImageToImageFilterICVF32IUS2 self, unsigned int arg0, itkImageCVF32 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF32IUS2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageCVF32 const *":
        """
        GetInput(itkImageToImageFilterICVF32IUS2 self) -> itkImageCVF32
        GetInput(itkImageToImageFilterICVF32IUS2 self, unsigned int idx) -> itkImageCVF32
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF32IUS2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageCVF32') -> "void":
        """
        PushBackInput(itkImageToImageFilterICVF32IUS2 self, itkImageCVF32 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF32IUS2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterICVF32IUS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF32IUS2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageCVF32') -> "void":
        """PushFrontInput(itkImageToImageFilterICVF32IUS2 self, itkImageCVF32 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF32IUS2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterICVF32IUS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF32IUS2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterICVF32IUS2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF32IUS2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterICVF32IUS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF32IUS2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterICVF32IUS2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF32IUS2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterICVF32IUS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF32IUS2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterICVF32IUS2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF32IUS2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterICVF32IUS2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF32IUS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterICVF32IUS2

        Create a new object of the class itkImageToImageFilterICVF32IUS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterICVF32IUS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterICVF32IUS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterICVF32IUS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterICVF32IUS2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF32IUS2_SetInput, None, itkImageToImageFilterICVF32IUS2)
itkImageToImageFilterICVF32IUS2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF32IUS2_GetInput, None, itkImageToImageFilterICVF32IUS2)
itkImageToImageFilterICVF32IUS2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF32IUS2_PushBackInput, None, itkImageToImageFilterICVF32IUS2)
itkImageToImageFilterICVF32IUS2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF32IUS2_PopBackInput, None, itkImageToImageFilterICVF32IUS2)
itkImageToImageFilterICVF32IUS2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF32IUS2_PushFrontInput, None, itkImageToImageFilterICVF32IUS2)
itkImageToImageFilterICVF32IUS2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF32IUS2_PopFrontInput, None, itkImageToImageFilterICVF32IUS2)
itkImageToImageFilterICVF32IUS2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF32IUS2_SetCoordinateTolerance, None, itkImageToImageFilterICVF32IUS2)
itkImageToImageFilterICVF32IUS2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF32IUS2_GetCoordinateTolerance, None, itkImageToImageFilterICVF32IUS2)
itkImageToImageFilterICVF32IUS2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF32IUS2_SetDirectionTolerance, None, itkImageToImageFilterICVF32IUS2)
itkImageToImageFilterICVF32IUS2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF32IUS2_GetDirectionTolerance, None, itkImageToImageFilterICVF32IUS2)
itkImageToImageFilterICVF32IUS2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterICVF32IUS2_swigregister
itkImageToImageFilterICVF32IUS2_swigregister(itkImageToImageFilterICVF32IUS2)

def itkImageToImageFilterICVF32IUS2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF32IUS2 *":
    """itkImageToImageFilterICVF32IUS2_cast(itkLightObject obj) -> itkImageToImageFilterICVF32IUS2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterICVF32IUS2_cast(obj)

class itkImageToImageFilterICVF33ID3(itkImageSourcePython.itkImageSourceID3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterICVF33ID3 self, itkImageCVF33 image)
        SetInput(itkImageToImageFilterICVF33ID3 self, unsigned int arg0, itkImageCVF33 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF33ID3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageCVF33 const *":
        """
        GetInput(itkImageToImageFilterICVF33ID3 self) -> itkImageCVF33
        GetInput(itkImageToImageFilterICVF33ID3 self, unsigned int idx) -> itkImageCVF33
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF33ID3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageCVF33') -> "void":
        """
        PushBackInput(itkImageToImageFilterICVF33ID3 self, itkImageCVF33 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF33ID3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterICVF33ID3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF33ID3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageCVF33') -> "void":
        """PushFrontInput(itkImageToImageFilterICVF33ID3 self, itkImageCVF33 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF33ID3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterICVF33ID3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF33ID3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterICVF33ID3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF33ID3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterICVF33ID3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF33ID3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterICVF33ID3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF33ID3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterICVF33ID3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF33ID3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterICVF33ID3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF33ID3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterICVF33ID3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF33ID3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterICVF33ID3

        Create a new object of the class itkImageToImageFilterICVF33ID3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterICVF33ID3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterICVF33ID3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterICVF33ID3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterICVF33ID3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF33ID3_SetInput, None, itkImageToImageFilterICVF33ID3)
itkImageToImageFilterICVF33ID3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF33ID3_GetInput, None, itkImageToImageFilterICVF33ID3)
itkImageToImageFilterICVF33ID3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF33ID3_PushBackInput, None, itkImageToImageFilterICVF33ID3)
itkImageToImageFilterICVF33ID3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF33ID3_PopBackInput, None, itkImageToImageFilterICVF33ID3)
itkImageToImageFilterICVF33ID3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF33ID3_PushFrontInput, None, itkImageToImageFilterICVF33ID3)
itkImageToImageFilterICVF33ID3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF33ID3_PopFrontInput, None, itkImageToImageFilterICVF33ID3)
itkImageToImageFilterICVF33ID3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF33ID3_SetCoordinateTolerance, None, itkImageToImageFilterICVF33ID3)
itkImageToImageFilterICVF33ID3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF33ID3_GetCoordinateTolerance, None, itkImageToImageFilterICVF33ID3)
itkImageToImageFilterICVF33ID3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF33ID3_SetDirectionTolerance, None, itkImageToImageFilterICVF33ID3)
itkImageToImageFilterICVF33ID3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF33ID3_GetDirectionTolerance, None, itkImageToImageFilterICVF33ID3)
itkImageToImageFilterICVF33ID3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterICVF33ID3_swigregister
itkImageToImageFilterICVF33ID3_swigregister(itkImageToImageFilterICVF33ID3)

def itkImageToImageFilterICVF33ID3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF33ID3 *":
    """itkImageToImageFilterICVF33ID3_cast(itkLightObject obj) -> itkImageToImageFilterICVF33ID3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterICVF33ID3_cast(obj)

class itkImageToImageFilterICVF33IF3(itkImageSourcePython.itkImageSourceIF3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterICVF33IF3 self, itkImageCVF33 image)
        SetInput(itkImageToImageFilterICVF33IF3 self, unsigned int arg0, itkImageCVF33 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF33IF3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageCVF33 const *":
        """
        GetInput(itkImageToImageFilterICVF33IF3 self) -> itkImageCVF33
        GetInput(itkImageToImageFilterICVF33IF3 self, unsigned int idx) -> itkImageCVF33
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF33IF3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageCVF33') -> "void":
        """
        PushBackInput(itkImageToImageFilterICVF33IF3 self, itkImageCVF33 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF33IF3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterICVF33IF3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF33IF3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageCVF33') -> "void":
        """PushFrontInput(itkImageToImageFilterICVF33IF3 self, itkImageCVF33 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF33IF3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterICVF33IF3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF33IF3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterICVF33IF3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF33IF3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterICVF33IF3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF33IF3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterICVF33IF3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF33IF3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterICVF33IF3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF33IF3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterICVF33IF3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF33IF3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterICVF33IF3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF33IF3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterICVF33IF3

        Create a new object of the class itkImageToImageFilterICVF33IF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterICVF33IF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterICVF33IF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterICVF33IF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterICVF33IF3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF33IF3_SetInput, None, itkImageToImageFilterICVF33IF3)
itkImageToImageFilterICVF33IF3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF33IF3_GetInput, None, itkImageToImageFilterICVF33IF3)
itkImageToImageFilterICVF33IF3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF33IF3_PushBackInput, None, itkImageToImageFilterICVF33IF3)
itkImageToImageFilterICVF33IF3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF33IF3_PopBackInput, None, itkImageToImageFilterICVF33IF3)
itkImageToImageFilterICVF33IF3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF33IF3_PushFrontInput, None, itkImageToImageFilterICVF33IF3)
itkImageToImageFilterICVF33IF3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF33IF3_PopFrontInput, None, itkImageToImageFilterICVF33IF3)
itkImageToImageFilterICVF33IF3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF33IF3_SetCoordinateTolerance, None, itkImageToImageFilterICVF33IF3)
itkImageToImageFilterICVF33IF3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF33IF3_GetCoordinateTolerance, None, itkImageToImageFilterICVF33IF3)
itkImageToImageFilterICVF33IF3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF33IF3_SetDirectionTolerance, None, itkImageToImageFilterICVF33IF3)
itkImageToImageFilterICVF33IF3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF33IF3_GetDirectionTolerance, None, itkImageToImageFilterICVF33IF3)
itkImageToImageFilterICVF33IF3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterICVF33IF3_swigregister
itkImageToImageFilterICVF33IF3_swigregister(itkImageToImageFilterICVF33IF3)

def itkImageToImageFilterICVF33IF3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF33IF3 *":
    """itkImageToImageFilterICVF33IF3_cast(itkLightObject obj) -> itkImageToImageFilterICVF33IF3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterICVF33IF3_cast(obj)

class itkImageToImageFilterICVF33ISS3(itkImageSourcePython.itkImageSourceISS3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterICVF33ISS3 self, itkImageCVF33 image)
        SetInput(itkImageToImageFilterICVF33ISS3 self, unsigned int arg0, itkImageCVF33 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF33ISS3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageCVF33 const *":
        """
        GetInput(itkImageToImageFilterICVF33ISS3 self) -> itkImageCVF33
        GetInput(itkImageToImageFilterICVF33ISS3 self, unsigned int idx) -> itkImageCVF33
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF33ISS3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageCVF33') -> "void":
        """
        PushBackInput(itkImageToImageFilterICVF33ISS3 self, itkImageCVF33 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF33ISS3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterICVF33ISS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF33ISS3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageCVF33') -> "void":
        """PushFrontInput(itkImageToImageFilterICVF33ISS3 self, itkImageCVF33 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF33ISS3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterICVF33ISS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF33ISS3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterICVF33ISS3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF33ISS3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterICVF33ISS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF33ISS3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterICVF33ISS3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF33ISS3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterICVF33ISS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF33ISS3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterICVF33ISS3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF33ISS3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterICVF33ISS3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF33ISS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterICVF33ISS3

        Create a new object of the class itkImageToImageFilterICVF33ISS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterICVF33ISS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterICVF33ISS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterICVF33ISS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterICVF33ISS3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF33ISS3_SetInput, None, itkImageToImageFilterICVF33ISS3)
itkImageToImageFilterICVF33ISS3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF33ISS3_GetInput, None, itkImageToImageFilterICVF33ISS3)
itkImageToImageFilterICVF33ISS3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF33ISS3_PushBackInput, None, itkImageToImageFilterICVF33ISS3)
itkImageToImageFilterICVF33ISS3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF33ISS3_PopBackInput, None, itkImageToImageFilterICVF33ISS3)
itkImageToImageFilterICVF33ISS3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF33ISS3_PushFrontInput, None, itkImageToImageFilterICVF33ISS3)
itkImageToImageFilterICVF33ISS3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF33ISS3_PopFrontInput, None, itkImageToImageFilterICVF33ISS3)
itkImageToImageFilterICVF33ISS3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF33ISS3_SetCoordinateTolerance, None, itkImageToImageFilterICVF33ISS3)
itkImageToImageFilterICVF33ISS3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF33ISS3_GetCoordinateTolerance, None, itkImageToImageFilterICVF33ISS3)
itkImageToImageFilterICVF33ISS3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF33ISS3_SetDirectionTolerance, None, itkImageToImageFilterICVF33ISS3)
itkImageToImageFilterICVF33ISS3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF33ISS3_GetDirectionTolerance, None, itkImageToImageFilterICVF33ISS3)
itkImageToImageFilterICVF33ISS3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterICVF33ISS3_swigregister
itkImageToImageFilterICVF33ISS3_swigregister(itkImageToImageFilterICVF33ISS3)

def itkImageToImageFilterICVF33ISS3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF33ISS3 *":
    """itkImageToImageFilterICVF33ISS3_cast(itkLightObject obj) -> itkImageToImageFilterICVF33ISS3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterICVF33ISS3_cast(obj)

class itkImageToImageFilterICVF33IUC3(itkImageSourcePython.itkImageSourceIUC3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterICVF33IUC3 self, itkImageCVF33 image)
        SetInput(itkImageToImageFilterICVF33IUC3 self, unsigned int arg0, itkImageCVF33 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF33IUC3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageCVF33 const *":
        """
        GetInput(itkImageToImageFilterICVF33IUC3 self) -> itkImageCVF33
        GetInput(itkImageToImageFilterICVF33IUC3 self, unsigned int idx) -> itkImageCVF33
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF33IUC3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageCVF33') -> "void":
        """
        PushBackInput(itkImageToImageFilterICVF33IUC3 self, itkImageCVF33 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF33IUC3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterICVF33IUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF33IUC3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageCVF33') -> "void":
        """PushFrontInput(itkImageToImageFilterICVF33IUC3 self, itkImageCVF33 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF33IUC3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterICVF33IUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF33IUC3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterICVF33IUC3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF33IUC3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterICVF33IUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF33IUC3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterICVF33IUC3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF33IUC3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterICVF33IUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF33IUC3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterICVF33IUC3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF33IUC3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterICVF33IUC3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF33IUC3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterICVF33IUC3

        Create a new object of the class itkImageToImageFilterICVF33IUC3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterICVF33IUC3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterICVF33IUC3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterICVF33IUC3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterICVF33IUC3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF33IUC3_SetInput, None, itkImageToImageFilterICVF33IUC3)
itkImageToImageFilterICVF33IUC3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF33IUC3_GetInput, None, itkImageToImageFilterICVF33IUC3)
itkImageToImageFilterICVF33IUC3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF33IUC3_PushBackInput, None, itkImageToImageFilterICVF33IUC3)
itkImageToImageFilterICVF33IUC3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF33IUC3_PopBackInput, None, itkImageToImageFilterICVF33IUC3)
itkImageToImageFilterICVF33IUC3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF33IUC3_PushFrontInput, None, itkImageToImageFilterICVF33IUC3)
itkImageToImageFilterICVF33IUC3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF33IUC3_PopFrontInput, None, itkImageToImageFilterICVF33IUC3)
itkImageToImageFilterICVF33IUC3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF33IUC3_SetCoordinateTolerance, None, itkImageToImageFilterICVF33IUC3)
itkImageToImageFilterICVF33IUC3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF33IUC3_GetCoordinateTolerance, None, itkImageToImageFilterICVF33IUC3)
itkImageToImageFilterICVF33IUC3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF33IUC3_SetDirectionTolerance, None, itkImageToImageFilterICVF33IUC3)
itkImageToImageFilterICVF33IUC3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF33IUC3_GetDirectionTolerance, None, itkImageToImageFilterICVF33IUC3)
itkImageToImageFilterICVF33IUC3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterICVF33IUC3_swigregister
itkImageToImageFilterICVF33IUC3_swigregister(itkImageToImageFilterICVF33IUC3)

def itkImageToImageFilterICVF33IUC3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF33IUC3 *":
    """itkImageToImageFilterICVF33IUC3_cast(itkLightObject obj) -> itkImageToImageFilterICVF33IUC3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterICVF33IUC3_cast(obj)

class itkImageToImageFilterICVF33IUS3(itkImageSourcePython.itkImageSourceIUS3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterICVF33IUS3 self, itkImageCVF33 image)
        SetInput(itkImageToImageFilterICVF33IUS3 self, unsigned int arg0, itkImageCVF33 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF33IUS3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageCVF33 const *":
        """
        GetInput(itkImageToImageFilterICVF33IUS3 self) -> itkImageCVF33
        GetInput(itkImageToImageFilterICVF33IUS3 self, unsigned int idx) -> itkImageCVF33
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF33IUS3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageCVF33') -> "void":
        """
        PushBackInput(itkImageToImageFilterICVF33IUS3 self, itkImageCVF33 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF33IUS3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterICVF33IUS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF33IUS3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageCVF33') -> "void":
        """PushFrontInput(itkImageToImageFilterICVF33IUS3 self, itkImageCVF33 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF33IUS3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterICVF33IUS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF33IUS3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterICVF33IUS3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF33IUS3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterICVF33IUS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF33IUS3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterICVF33IUS3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF33IUS3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterICVF33IUS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF33IUS3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterICVF33IUS3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF33IUS3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterICVF33IUS3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF33IUS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterICVF33IUS3

        Create a new object of the class itkImageToImageFilterICVF33IUS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterICVF33IUS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterICVF33IUS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterICVF33IUS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterICVF33IUS3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF33IUS3_SetInput, None, itkImageToImageFilterICVF33IUS3)
itkImageToImageFilterICVF33IUS3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF33IUS3_GetInput, None, itkImageToImageFilterICVF33IUS3)
itkImageToImageFilterICVF33IUS3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF33IUS3_PushBackInput, None, itkImageToImageFilterICVF33IUS3)
itkImageToImageFilterICVF33IUS3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF33IUS3_PopBackInput, None, itkImageToImageFilterICVF33IUS3)
itkImageToImageFilterICVF33IUS3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF33IUS3_PushFrontInput, None, itkImageToImageFilterICVF33IUS3)
itkImageToImageFilterICVF33IUS3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF33IUS3_PopFrontInput, None, itkImageToImageFilterICVF33IUS3)
itkImageToImageFilterICVF33IUS3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF33IUS3_SetCoordinateTolerance, None, itkImageToImageFilterICVF33IUS3)
itkImageToImageFilterICVF33IUS3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF33IUS3_GetCoordinateTolerance, None, itkImageToImageFilterICVF33IUS3)
itkImageToImageFilterICVF33IUS3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF33IUS3_SetDirectionTolerance, None, itkImageToImageFilterICVF33IUS3)
itkImageToImageFilterICVF33IUS3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF33IUS3_GetDirectionTolerance, None, itkImageToImageFilterICVF33IUS3)
itkImageToImageFilterICVF33IUS3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterICVF33IUS3_swigregister
itkImageToImageFilterICVF33IUS3_swigregister(itkImageToImageFilterICVF33IUS3)

def itkImageToImageFilterICVF33IUS3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF33IUS3 *":
    """itkImageToImageFilterICVF33IUS3_cast(itkLightObject obj) -> itkImageToImageFilterICVF33IUS3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterICVF33IUS3_cast(obj)

class itkImageToImageFilterICVF42ID2(itkImageSourcePython.itkImageSourceID2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterICVF42ID2 self, itkImageCVF42 image)
        SetInput(itkImageToImageFilterICVF42ID2 self, unsigned int arg0, itkImageCVF42 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF42ID2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageCVF42 const *":
        """
        GetInput(itkImageToImageFilterICVF42ID2 self) -> itkImageCVF42
        GetInput(itkImageToImageFilterICVF42ID2 self, unsigned int idx) -> itkImageCVF42
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF42ID2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageCVF42') -> "void":
        """
        PushBackInput(itkImageToImageFilterICVF42ID2 self, itkImageCVF42 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF42ID2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterICVF42ID2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF42ID2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageCVF42') -> "void":
        """PushFrontInput(itkImageToImageFilterICVF42ID2 self, itkImageCVF42 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF42ID2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterICVF42ID2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF42ID2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterICVF42ID2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF42ID2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterICVF42ID2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF42ID2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterICVF42ID2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF42ID2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterICVF42ID2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF42ID2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterICVF42ID2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF42ID2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterICVF42ID2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF42ID2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterICVF42ID2

        Create a new object of the class itkImageToImageFilterICVF42ID2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterICVF42ID2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterICVF42ID2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterICVF42ID2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterICVF42ID2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF42ID2_SetInput, None, itkImageToImageFilterICVF42ID2)
itkImageToImageFilterICVF42ID2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF42ID2_GetInput, None, itkImageToImageFilterICVF42ID2)
itkImageToImageFilterICVF42ID2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF42ID2_PushBackInput, None, itkImageToImageFilterICVF42ID2)
itkImageToImageFilterICVF42ID2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF42ID2_PopBackInput, None, itkImageToImageFilterICVF42ID2)
itkImageToImageFilterICVF42ID2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF42ID2_PushFrontInput, None, itkImageToImageFilterICVF42ID2)
itkImageToImageFilterICVF42ID2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF42ID2_PopFrontInput, None, itkImageToImageFilterICVF42ID2)
itkImageToImageFilterICVF42ID2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF42ID2_SetCoordinateTolerance, None, itkImageToImageFilterICVF42ID2)
itkImageToImageFilterICVF42ID2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF42ID2_GetCoordinateTolerance, None, itkImageToImageFilterICVF42ID2)
itkImageToImageFilterICVF42ID2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF42ID2_SetDirectionTolerance, None, itkImageToImageFilterICVF42ID2)
itkImageToImageFilterICVF42ID2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF42ID2_GetDirectionTolerance, None, itkImageToImageFilterICVF42ID2)
itkImageToImageFilterICVF42ID2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterICVF42ID2_swigregister
itkImageToImageFilterICVF42ID2_swigregister(itkImageToImageFilterICVF42ID2)

def itkImageToImageFilterICVF42ID2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF42ID2 *":
    """itkImageToImageFilterICVF42ID2_cast(itkLightObject obj) -> itkImageToImageFilterICVF42ID2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterICVF42ID2_cast(obj)

class itkImageToImageFilterICVF42IF2(itkImageSourcePython.itkImageSourceIF2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterICVF42IF2 self, itkImageCVF42 image)
        SetInput(itkImageToImageFilterICVF42IF2 self, unsigned int arg0, itkImageCVF42 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF42IF2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageCVF42 const *":
        """
        GetInput(itkImageToImageFilterICVF42IF2 self) -> itkImageCVF42
        GetInput(itkImageToImageFilterICVF42IF2 self, unsigned int idx) -> itkImageCVF42
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF42IF2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageCVF42') -> "void":
        """
        PushBackInput(itkImageToImageFilterICVF42IF2 self, itkImageCVF42 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF42IF2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterICVF42IF2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF42IF2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageCVF42') -> "void":
        """PushFrontInput(itkImageToImageFilterICVF42IF2 self, itkImageCVF42 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF42IF2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterICVF42IF2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF42IF2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterICVF42IF2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF42IF2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterICVF42IF2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF42IF2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterICVF42IF2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF42IF2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterICVF42IF2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF42IF2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterICVF42IF2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF42IF2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterICVF42IF2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF42IF2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterICVF42IF2

        Create a new object of the class itkImageToImageFilterICVF42IF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterICVF42IF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterICVF42IF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterICVF42IF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterICVF42IF2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF42IF2_SetInput, None, itkImageToImageFilterICVF42IF2)
itkImageToImageFilterICVF42IF2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF42IF2_GetInput, None, itkImageToImageFilterICVF42IF2)
itkImageToImageFilterICVF42IF2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF42IF2_PushBackInput, None, itkImageToImageFilterICVF42IF2)
itkImageToImageFilterICVF42IF2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF42IF2_PopBackInput, None, itkImageToImageFilterICVF42IF2)
itkImageToImageFilterICVF42IF2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF42IF2_PushFrontInput, None, itkImageToImageFilterICVF42IF2)
itkImageToImageFilterICVF42IF2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF42IF2_PopFrontInput, None, itkImageToImageFilterICVF42IF2)
itkImageToImageFilterICVF42IF2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF42IF2_SetCoordinateTolerance, None, itkImageToImageFilterICVF42IF2)
itkImageToImageFilterICVF42IF2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF42IF2_GetCoordinateTolerance, None, itkImageToImageFilterICVF42IF2)
itkImageToImageFilterICVF42IF2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF42IF2_SetDirectionTolerance, None, itkImageToImageFilterICVF42IF2)
itkImageToImageFilterICVF42IF2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF42IF2_GetDirectionTolerance, None, itkImageToImageFilterICVF42IF2)
itkImageToImageFilterICVF42IF2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterICVF42IF2_swigregister
itkImageToImageFilterICVF42IF2_swigregister(itkImageToImageFilterICVF42IF2)

def itkImageToImageFilterICVF42IF2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF42IF2 *":
    """itkImageToImageFilterICVF42IF2_cast(itkLightObject obj) -> itkImageToImageFilterICVF42IF2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterICVF42IF2_cast(obj)

class itkImageToImageFilterICVF42ISS2(itkImageSourcePython.itkImageSourceISS2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterICVF42ISS2 self, itkImageCVF42 image)
        SetInput(itkImageToImageFilterICVF42ISS2 self, unsigned int arg0, itkImageCVF42 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF42ISS2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageCVF42 const *":
        """
        GetInput(itkImageToImageFilterICVF42ISS2 self) -> itkImageCVF42
        GetInput(itkImageToImageFilterICVF42ISS2 self, unsigned int idx) -> itkImageCVF42
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF42ISS2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageCVF42') -> "void":
        """
        PushBackInput(itkImageToImageFilterICVF42ISS2 self, itkImageCVF42 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF42ISS2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterICVF42ISS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF42ISS2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageCVF42') -> "void":
        """PushFrontInput(itkImageToImageFilterICVF42ISS2 self, itkImageCVF42 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF42ISS2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterICVF42ISS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF42ISS2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterICVF42ISS2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF42ISS2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterICVF42ISS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF42ISS2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterICVF42ISS2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF42ISS2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterICVF42ISS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF42ISS2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterICVF42ISS2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF42ISS2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterICVF42ISS2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF42ISS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterICVF42ISS2

        Create a new object of the class itkImageToImageFilterICVF42ISS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterICVF42ISS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterICVF42ISS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterICVF42ISS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterICVF42ISS2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF42ISS2_SetInput, None, itkImageToImageFilterICVF42ISS2)
itkImageToImageFilterICVF42ISS2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF42ISS2_GetInput, None, itkImageToImageFilterICVF42ISS2)
itkImageToImageFilterICVF42ISS2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF42ISS2_PushBackInput, None, itkImageToImageFilterICVF42ISS2)
itkImageToImageFilterICVF42ISS2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF42ISS2_PopBackInput, None, itkImageToImageFilterICVF42ISS2)
itkImageToImageFilterICVF42ISS2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF42ISS2_PushFrontInput, None, itkImageToImageFilterICVF42ISS2)
itkImageToImageFilterICVF42ISS2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF42ISS2_PopFrontInput, None, itkImageToImageFilterICVF42ISS2)
itkImageToImageFilterICVF42ISS2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF42ISS2_SetCoordinateTolerance, None, itkImageToImageFilterICVF42ISS2)
itkImageToImageFilterICVF42ISS2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF42ISS2_GetCoordinateTolerance, None, itkImageToImageFilterICVF42ISS2)
itkImageToImageFilterICVF42ISS2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF42ISS2_SetDirectionTolerance, None, itkImageToImageFilterICVF42ISS2)
itkImageToImageFilterICVF42ISS2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF42ISS2_GetDirectionTolerance, None, itkImageToImageFilterICVF42ISS2)
itkImageToImageFilterICVF42ISS2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterICVF42ISS2_swigregister
itkImageToImageFilterICVF42ISS2_swigregister(itkImageToImageFilterICVF42ISS2)

def itkImageToImageFilterICVF42ISS2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF42ISS2 *":
    """itkImageToImageFilterICVF42ISS2_cast(itkLightObject obj) -> itkImageToImageFilterICVF42ISS2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterICVF42ISS2_cast(obj)

class itkImageToImageFilterICVF42IUC2(itkImageSourcePython.itkImageSourceIUC2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterICVF42IUC2 self, itkImageCVF42 image)
        SetInput(itkImageToImageFilterICVF42IUC2 self, unsigned int arg0, itkImageCVF42 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF42IUC2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageCVF42 const *":
        """
        GetInput(itkImageToImageFilterICVF42IUC2 self) -> itkImageCVF42
        GetInput(itkImageToImageFilterICVF42IUC2 self, unsigned int idx) -> itkImageCVF42
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF42IUC2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageCVF42') -> "void":
        """
        PushBackInput(itkImageToImageFilterICVF42IUC2 self, itkImageCVF42 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF42IUC2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterICVF42IUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF42IUC2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageCVF42') -> "void":
        """PushFrontInput(itkImageToImageFilterICVF42IUC2 self, itkImageCVF42 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF42IUC2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterICVF42IUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF42IUC2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterICVF42IUC2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF42IUC2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterICVF42IUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF42IUC2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterICVF42IUC2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF42IUC2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterICVF42IUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF42IUC2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterICVF42IUC2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF42IUC2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterICVF42IUC2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF42IUC2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterICVF42IUC2

        Create a new object of the class itkImageToImageFilterICVF42IUC2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterICVF42IUC2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterICVF42IUC2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterICVF42IUC2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterICVF42IUC2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF42IUC2_SetInput, None, itkImageToImageFilterICVF42IUC2)
itkImageToImageFilterICVF42IUC2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF42IUC2_GetInput, None, itkImageToImageFilterICVF42IUC2)
itkImageToImageFilterICVF42IUC2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF42IUC2_PushBackInput, None, itkImageToImageFilterICVF42IUC2)
itkImageToImageFilterICVF42IUC2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF42IUC2_PopBackInput, None, itkImageToImageFilterICVF42IUC2)
itkImageToImageFilterICVF42IUC2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF42IUC2_PushFrontInput, None, itkImageToImageFilterICVF42IUC2)
itkImageToImageFilterICVF42IUC2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF42IUC2_PopFrontInput, None, itkImageToImageFilterICVF42IUC2)
itkImageToImageFilterICVF42IUC2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF42IUC2_SetCoordinateTolerance, None, itkImageToImageFilterICVF42IUC2)
itkImageToImageFilterICVF42IUC2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF42IUC2_GetCoordinateTolerance, None, itkImageToImageFilterICVF42IUC2)
itkImageToImageFilterICVF42IUC2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF42IUC2_SetDirectionTolerance, None, itkImageToImageFilterICVF42IUC2)
itkImageToImageFilterICVF42IUC2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF42IUC2_GetDirectionTolerance, None, itkImageToImageFilterICVF42IUC2)
itkImageToImageFilterICVF42IUC2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterICVF42IUC2_swigregister
itkImageToImageFilterICVF42IUC2_swigregister(itkImageToImageFilterICVF42IUC2)

def itkImageToImageFilterICVF42IUC2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF42IUC2 *":
    """itkImageToImageFilterICVF42IUC2_cast(itkLightObject obj) -> itkImageToImageFilterICVF42IUC2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterICVF42IUC2_cast(obj)

class itkImageToImageFilterICVF42IUS2(itkImageSourcePython.itkImageSourceIUS2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterICVF42IUS2 self, itkImageCVF42 image)
        SetInput(itkImageToImageFilterICVF42IUS2 self, unsigned int arg0, itkImageCVF42 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF42IUS2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageCVF42 const *":
        """
        GetInput(itkImageToImageFilterICVF42IUS2 self) -> itkImageCVF42
        GetInput(itkImageToImageFilterICVF42IUS2 self, unsigned int idx) -> itkImageCVF42
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF42IUS2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageCVF42') -> "void":
        """
        PushBackInput(itkImageToImageFilterICVF42IUS2 self, itkImageCVF42 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF42IUS2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterICVF42IUS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF42IUS2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageCVF42') -> "void":
        """PushFrontInput(itkImageToImageFilterICVF42IUS2 self, itkImageCVF42 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF42IUS2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterICVF42IUS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF42IUS2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterICVF42IUS2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF42IUS2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterICVF42IUS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF42IUS2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterICVF42IUS2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF42IUS2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterICVF42IUS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF42IUS2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterICVF42IUS2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF42IUS2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterICVF42IUS2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF42IUS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterICVF42IUS2

        Create a new object of the class itkImageToImageFilterICVF42IUS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterICVF42IUS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterICVF42IUS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterICVF42IUS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterICVF42IUS2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF42IUS2_SetInput, None, itkImageToImageFilterICVF42IUS2)
itkImageToImageFilterICVF42IUS2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF42IUS2_GetInput, None, itkImageToImageFilterICVF42IUS2)
itkImageToImageFilterICVF42IUS2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF42IUS2_PushBackInput, None, itkImageToImageFilterICVF42IUS2)
itkImageToImageFilterICVF42IUS2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF42IUS2_PopBackInput, None, itkImageToImageFilterICVF42IUS2)
itkImageToImageFilterICVF42IUS2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF42IUS2_PushFrontInput, None, itkImageToImageFilterICVF42IUS2)
itkImageToImageFilterICVF42IUS2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF42IUS2_PopFrontInput, None, itkImageToImageFilterICVF42IUS2)
itkImageToImageFilterICVF42IUS2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF42IUS2_SetCoordinateTolerance, None, itkImageToImageFilterICVF42IUS2)
itkImageToImageFilterICVF42IUS2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF42IUS2_GetCoordinateTolerance, None, itkImageToImageFilterICVF42IUS2)
itkImageToImageFilterICVF42IUS2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF42IUS2_SetDirectionTolerance, None, itkImageToImageFilterICVF42IUS2)
itkImageToImageFilterICVF42IUS2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF42IUS2_GetDirectionTolerance, None, itkImageToImageFilterICVF42IUS2)
itkImageToImageFilterICVF42IUS2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterICVF42IUS2_swigregister
itkImageToImageFilterICVF42IUS2_swigregister(itkImageToImageFilterICVF42IUS2)

def itkImageToImageFilterICVF42IUS2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF42IUS2 *":
    """itkImageToImageFilterICVF42IUS2_cast(itkLightObject obj) -> itkImageToImageFilterICVF42IUS2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterICVF42IUS2_cast(obj)

class itkImageToImageFilterICVF43ID3(itkImageSourcePython.itkImageSourceID3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterICVF43ID3 self, itkImageCVF43 image)
        SetInput(itkImageToImageFilterICVF43ID3 self, unsigned int arg0, itkImageCVF43 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF43ID3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageCVF43 const *":
        """
        GetInput(itkImageToImageFilterICVF43ID3 self) -> itkImageCVF43
        GetInput(itkImageToImageFilterICVF43ID3 self, unsigned int idx) -> itkImageCVF43
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF43ID3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageCVF43') -> "void":
        """
        PushBackInput(itkImageToImageFilterICVF43ID3 self, itkImageCVF43 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF43ID3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterICVF43ID3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF43ID3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageCVF43') -> "void":
        """PushFrontInput(itkImageToImageFilterICVF43ID3 self, itkImageCVF43 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF43ID3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterICVF43ID3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF43ID3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterICVF43ID3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF43ID3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterICVF43ID3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF43ID3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterICVF43ID3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF43ID3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterICVF43ID3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF43ID3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterICVF43ID3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF43ID3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterICVF43ID3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF43ID3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterICVF43ID3

        Create a new object of the class itkImageToImageFilterICVF43ID3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterICVF43ID3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterICVF43ID3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterICVF43ID3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterICVF43ID3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF43ID3_SetInput, None, itkImageToImageFilterICVF43ID3)
itkImageToImageFilterICVF43ID3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF43ID3_GetInput, None, itkImageToImageFilterICVF43ID3)
itkImageToImageFilterICVF43ID3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF43ID3_PushBackInput, None, itkImageToImageFilterICVF43ID3)
itkImageToImageFilterICVF43ID3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF43ID3_PopBackInput, None, itkImageToImageFilterICVF43ID3)
itkImageToImageFilterICVF43ID3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF43ID3_PushFrontInput, None, itkImageToImageFilterICVF43ID3)
itkImageToImageFilterICVF43ID3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF43ID3_PopFrontInput, None, itkImageToImageFilterICVF43ID3)
itkImageToImageFilterICVF43ID3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF43ID3_SetCoordinateTolerance, None, itkImageToImageFilterICVF43ID3)
itkImageToImageFilterICVF43ID3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF43ID3_GetCoordinateTolerance, None, itkImageToImageFilterICVF43ID3)
itkImageToImageFilterICVF43ID3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF43ID3_SetDirectionTolerance, None, itkImageToImageFilterICVF43ID3)
itkImageToImageFilterICVF43ID3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF43ID3_GetDirectionTolerance, None, itkImageToImageFilterICVF43ID3)
itkImageToImageFilterICVF43ID3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterICVF43ID3_swigregister
itkImageToImageFilterICVF43ID3_swigregister(itkImageToImageFilterICVF43ID3)

def itkImageToImageFilterICVF43ID3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF43ID3 *":
    """itkImageToImageFilterICVF43ID3_cast(itkLightObject obj) -> itkImageToImageFilterICVF43ID3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterICVF43ID3_cast(obj)

class itkImageToImageFilterICVF43IF3(itkImageSourcePython.itkImageSourceIF3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterICVF43IF3 self, itkImageCVF43 image)
        SetInput(itkImageToImageFilterICVF43IF3 self, unsigned int arg0, itkImageCVF43 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF43IF3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageCVF43 const *":
        """
        GetInput(itkImageToImageFilterICVF43IF3 self) -> itkImageCVF43
        GetInput(itkImageToImageFilterICVF43IF3 self, unsigned int idx) -> itkImageCVF43
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF43IF3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageCVF43') -> "void":
        """
        PushBackInput(itkImageToImageFilterICVF43IF3 self, itkImageCVF43 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF43IF3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterICVF43IF3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF43IF3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageCVF43') -> "void":
        """PushFrontInput(itkImageToImageFilterICVF43IF3 self, itkImageCVF43 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF43IF3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterICVF43IF3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF43IF3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterICVF43IF3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF43IF3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterICVF43IF3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF43IF3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterICVF43IF3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF43IF3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterICVF43IF3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF43IF3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterICVF43IF3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF43IF3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterICVF43IF3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF43IF3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterICVF43IF3

        Create a new object of the class itkImageToImageFilterICVF43IF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterICVF43IF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterICVF43IF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterICVF43IF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterICVF43IF3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF43IF3_SetInput, None, itkImageToImageFilterICVF43IF3)
itkImageToImageFilterICVF43IF3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF43IF3_GetInput, None, itkImageToImageFilterICVF43IF3)
itkImageToImageFilterICVF43IF3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF43IF3_PushBackInput, None, itkImageToImageFilterICVF43IF3)
itkImageToImageFilterICVF43IF3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF43IF3_PopBackInput, None, itkImageToImageFilterICVF43IF3)
itkImageToImageFilterICVF43IF3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF43IF3_PushFrontInput, None, itkImageToImageFilterICVF43IF3)
itkImageToImageFilterICVF43IF3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF43IF3_PopFrontInput, None, itkImageToImageFilterICVF43IF3)
itkImageToImageFilterICVF43IF3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF43IF3_SetCoordinateTolerance, None, itkImageToImageFilterICVF43IF3)
itkImageToImageFilterICVF43IF3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF43IF3_GetCoordinateTolerance, None, itkImageToImageFilterICVF43IF3)
itkImageToImageFilterICVF43IF3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF43IF3_SetDirectionTolerance, None, itkImageToImageFilterICVF43IF3)
itkImageToImageFilterICVF43IF3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF43IF3_GetDirectionTolerance, None, itkImageToImageFilterICVF43IF3)
itkImageToImageFilterICVF43IF3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterICVF43IF3_swigregister
itkImageToImageFilterICVF43IF3_swigregister(itkImageToImageFilterICVF43IF3)

def itkImageToImageFilterICVF43IF3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF43IF3 *":
    """itkImageToImageFilterICVF43IF3_cast(itkLightObject obj) -> itkImageToImageFilterICVF43IF3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterICVF43IF3_cast(obj)

class itkImageToImageFilterICVF43ISS3(itkImageSourcePython.itkImageSourceISS3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterICVF43ISS3 self, itkImageCVF43 image)
        SetInput(itkImageToImageFilterICVF43ISS3 self, unsigned int arg0, itkImageCVF43 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF43ISS3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageCVF43 const *":
        """
        GetInput(itkImageToImageFilterICVF43ISS3 self) -> itkImageCVF43
        GetInput(itkImageToImageFilterICVF43ISS3 self, unsigned int idx) -> itkImageCVF43
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF43ISS3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageCVF43') -> "void":
        """
        PushBackInput(itkImageToImageFilterICVF43ISS3 self, itkImageCVF43 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF43ISS3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterICVF43ISS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF43ISS3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageCVF43') -> "void":
        """PushFrontInput(itkImageToImageFilterICVF43ISS3 self, itkImageCVF43 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF43ISS3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterICVF43ISS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF43ISS3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterICVF43ISS3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF43ISS3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterICVF43ISS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF43ISS3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterICVF43ISS3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF43ISS3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterICVF43ISS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF43ISS3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterICVF43ISS3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF43ISS3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterICVF43ISS3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF43ISS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterICVF43ISS3

        Create a new object of the class itkImageToImageFilterICVF43ISS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterICVF43ISS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterICVF43ISS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterICVF43ISS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterICVF43ISS3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF43ISS3_SetInput, None, itkImageToImageFilterICVF43ISS3)
itkImageToImageFilterICVF43ISS3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF43ISS3_GetInput, None, itkImageToImageFilterICVF43ISS3)
itkImageToImageFilterICVF43ISS3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF43ISS3_PushBackInput, None, itkImageToImageFilterICVF43ISS3)
itkImageToImageFilterICVF43ISS3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF43ISS3_PopBackInput, None, itkImageToImageFilterICVF43ISS3)
itkImageToImageFilterICVF43ISS3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF43ISS3_PushFrontInput, None, itkImageToImageFilterICVF43ISS3)
itkImageToImageFilterICVF43ISS3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF43ISS3_PopFrontInput, None, itkImageToImageFilterICVF43ISS3)
itkImageToImageFilterICVF43ISS3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF43ISS3_SetCoordinateTolerance, None, itkImageToImageFilterICVF43ISS3)
itkImageToImageFilterICVF43ISS3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF43ISS3_GetCoordinateTolerance, None, itkImageToImageFilterICVF43ISS3)
itkImageToImageFilterICVF43ISS3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF43ISS3_SetDirectionTolerance, None, itkImageToImageFilterICVF43ISS3)
itkImageToImageFilterICVF43ISS3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF43ISS3_GetDirectionTolerance, None, itkImageToImageFilterICVF43ISS3)
itkImageToImageFilterICVF43ISS3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterICVF43ISS3_swigregister
itkImageToImageFilterICVF43ISS3_swigregister(itkImageToImageFilterICVF43ISS3)

def itkImageToImageFilterICVF43ISS3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF43ISS3 *":
    """itkImageToImageFilterICVF43ISS3_cast(itkLightObject obj) -> itkImageToImageFilterICVF43ISS3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterICVF43ISS3_cast(obj)

class itkImageToImageFilterICVF43IUC3(itkImageSourcePython.itkImageSourceIUC3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterICVF43IUC3 self, itkImageCVF43 image)
        SetInput(itkImageToImageFilterICVF43IUC3 self, unsigned int arg0, itkImageCVF43 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF43IUC3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageCVF43 const *":
        """
        GetInput(itkImageToImageFilterICVF43IUC3 self) -> itkImageCVF43
        GetInput(itkImageToImageFilterICVF43IUC3 self, unsigned int idx) -> itkImageCVF43
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF43IUC3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageCVF43') -> "void":
        """
        PushBackInput(itkImageToImageFilterICVF43IUC3 self, itkImageCVF43 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF43IUC3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterICVF43IUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF43IUC3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageCVF43') -> "void":
        """PushFrontInput(itkImageToImageFilterICVF43IUC3 self, itkImageCVF43 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF43IUC3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterICVF43IUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF43IUC3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterICVF43IUC3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF43IUC3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterICVF43IUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF43IUC3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterICVF43IUC3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF43IUC3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterICVF43IUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF43IUC3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterICVF43IUC3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF43IUC3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterICVF43IUC3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF43IUC3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterICVF43IUC3

        Create a new object of the class itkImageToImageFilterICVF43IUC3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterICVF43IUC3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterICVF43IUC3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterICVF43IUC3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterICVF43IUC3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF43IUC3_SetInput, None, itkImageToImageFilterICVF43IUC3)
itkImageToImageFilterICVF43IUC3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF43IUC3_GetInput, None, itkImageToImageFilterICVF43IUC3)
itkImageToImageFilterICVF43IUC3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF43IUC3_PushBackInput, None, itkImageToImageFilterICVF43IUC3)
itkImageToImageFilterICVF43IUC3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF43IUC3_PopBackInput, None, itkImageToImageFilterICVF43IUC3)
itkImageToImageFilterICVF43IUC3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF43IUC3_PushFrontInput, None, itkImageToImageFilterICVF43IUC3)
itkImageToImageFilterICVF43IUC3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF43IUC3_PopFrontInput, None, itkImageToImageFilterICVF43IUC3)
itkImageToImageFilterICVF43IUC3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF43IUC3_SetCoordinateTolerance, None, itkImageToImageFilterICVF43IUC3)
itkImageToImageFilterICVF43IUC3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF43IUC3_GetCoordinateTolerance, None, itkImageToImageFilterICVF43IUC3)
itkImageToImageFilterICVF43IUC3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF43IUC3_SetDirectionTolerance, None, itkImageToImageFilterICVF43IUC3)
itkImageToImageFilterICVF43IUC3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF43IUC3_GetDirectionTolerance, None, itkImageToImageFilterICVF43IUC3)
itkImageToImageFilterICVF43IUC3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterICVF43IUC3_swigregister
itkImageToImageFilterICVF43IUC3_swigregister(itkImageToImageFilterICVF43IUC3)

def itkImageToImageFilterICVF43IUC3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF43IUC3 *":
    """itkImageToImageFilterICVF43IUC3_cast(itkLightObject obj) -> itkImageToImageFilterICVF43IUC3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterICVF43IUC3_cast(obj)

class itkImageToImageFilterICVF43IUS3(itkImageSourcePython.itkImageSourceIUS3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterICVF43IUS3 self, itkImageCVF43 image)
        SetInput(itkImageToImageFilterICVF43IUS3 self, unsigned int arg0, itkImageCVF43 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF43IUS3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageCVF43 const *":
        """
        GetInput(itkImageToImageFilterICVF43IUS3 self) -> itkImageCVF43
        GetInput(itkImageToImageFilterICVF43IUS3 self, unsigned int idx) -> itkImageCVF43
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF43IUS3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageCVF43') -> "void":
        """
        PushBackInput(itkImageToImageFilterICVF43IUS3 self, itkImageCVF43 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF43IUS3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterICVF43IUS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF43IUS3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageCVF43') -> "void":
        """PushFrontInput(itkImageToImageFilterICVF43IUS3 self, itkImageCVF43 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF43IUS3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterICVF43IUS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF43IUS3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterICVF43IUS3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF43IUS3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterICVF43IUS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF43IUS3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterICVF43IUS3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF43IUS3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterICVF43IUS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF43IUS3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterICVF43IUS3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF43IUS3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterICVF43IUS3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterICVF43IUS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterICVF43IUS3

        Create a new object of the class itkImageToImageFilterICVF43IUS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterICVF43IUS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterICVF43IUS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterICVF43IUS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterICVF43IUS3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF43IUS3_SetInput, None, itkImageToImageFilterICVF43IUS3)
itkImageToImageFilterICVF43IUS3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF43IUS3_GetInput, None, itkImageToImageFilterICVF43IUS3)
itkImageToImageFilterICVF43IUS3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF43IUS3_PushBackInput, None, itkImageToImageFilterICVF43IUS3)
itkImageToImageFilterICVF43IUS3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF43IUS3_PopBackInput, None, itkImageToImageFilterICVF43IUS3)
itkImageToImageFilterICVF43IUS3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF43IUS3_PushFrontInput, None, itkImageToImageFilterICVF43IUS3)
itkImageToImageFilterICVF43IUS3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF43IUS3_PopFrontInput, None, itkImageToImageFilterICVF43IUS3)
itkImageToImageFilterICVF43IUS3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF43IUS3_SetCoordinateTolerance, None, itkImageToImageFilterICVF43IUS3)
itkImageToImageFilterICVF43IUS3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF43IUS3_GetCoordinateTolerance, None, itkImageToImageFilterICVF43IUS3)
itkImageToImageFilterICVF43IUS3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF43IUS3_SetDirectionTolerance, None, itkImageToImageFilterICVF43IUS3)
itkImageToImageFilterICVF43IUS3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterICVF43IUS3_GetDirectionTolerance, None, itkImageToImageFilterICVF43IUS3)
itkImageToImageFilterICVF43IUS3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterICVF43IUS3_swigregister
itkImageToImageFilterICVF43IUS3_swigregister(itkImageToImageFilterICVF43IUS3)

def itkImageToImageFilterICVF43IUS3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterICVF43IUS3 *":
    """itkImageToImageFilterICVF43IUS3_cast(itkLightObject obj) -> itkImageToImageFilterICVF43IUS3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterICVF43IUS3_cast(obj)

class itkImageToImageFilterID2ICF2(itkImageSourcePython.itkImageSourceICF2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterID2ICF2 self, itkImageD2 image)
        SetInput(itkImageToImageFilterID2ICF2 self, unsigned int arg0, itkImageD2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ICF2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageD2 const *":
        """
        GetInput(itkImageToImageFilterID2ICF2 self) -> itkImageD2
        GetInput(itkImageToImageFilterID2ICF2 self, unsigned int idx) -> itkImageD2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ICF2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageD2') -> "void":
        """
        PushBackInput(itkImageToImageFilterID2ICF2 self, itkImageD2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ICF2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterID2ICF2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ICF2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageD2') -> "void":
        """PushFrontInput(itkImageToImageFilterID2ICF2 self, itkImageD2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ICF2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterID2ICF2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ICF2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterID2ICF2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ICF2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterID2ICF2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ICF2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterID2ICF2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ICF2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterID2ICF2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ICF2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterID2ICF2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterID2ICF2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterID2ICF2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ICF2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterID2ICF2

        Create a new object of the class itkImageToImageFilterID2ICF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterID2ICF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterID2ICF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterID2ICF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterID2ICF2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ICF2_SetInput, None, itkImageToImageFilterID2ICF2)
itkImageToImageFilterID2ICF2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ICF2_GetInput, None, itkImageToImageFilterID2ICF2)
itkImageToImageFilterID2ICF2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ICF2_PushBackInput, None, itkImageToImageFilterID2ICF2)
itkImageToImageFilterID2ICF2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ICF2_PopBackInput, None, itkImageToImageFilterID2ICF2)
itkImageToImageFilterID2ICF2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ICF2_PushFrontInput, None, itkImageToImageFilterID2ICF2)
itkImageToImageFilterID2ICF2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ICF2_PopFrontInput, None, itkImageToImageFilterID2ICF2)
itkImageToImageFilterID2ICF2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ICF2_SetCoordinateTolerance, None, itkImageToImageFilterID2ICF2)
itkImageToImageFilterID2ICF2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ICF2_GetCoordinateTolerance, None, itkImageToImageFilterID2ICF2)
itkImageToImageFilterID2ICF2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ICF2_SetDirectionTolerance, None, itkImageToImageFilterID2ICF2)
itkImageToImageFilterID2ICF2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ICF2_GetDirectionTolerance, None, itkImageToImageFilterID2ICF2)
itkImageToImageFilterID2ICF2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterID2ICF2_swigregister
itkImageToImageFilterID2ICF2_swigregister(itkImageToImageFilterID2ICF2)

def itkImageToImageFilterID2ICF2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterID2ICF2 *":
    """itkImageToImageFilterID2ICF2_cast(itkLightObject obj) -> itkImageToImageFilterID2ICF2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterID2ICF2_cast(obj)

class itkImageToImageFilterID2ICVD22(itkImageSourcePython.itkImageSourceICVD22):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterID2ICVD22 self, itkImageD2 image)
        SetInput(itkImageToImageFilterID2ICVD22 self, unsigned int arg0, itkImageD2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ICVD22_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageD2 const *":
        """
        GetInput(itkImageToImageFilterID2ICVD22 self) -> itkImageD2
        GetInput(itkImageToImageFilterID2ICVD22 self, unsigned int idx) -> itkImageD2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ICVD22_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageD2') -> "void":
        """
        PushBackInput(itkImageToImageFilterID2ICVD22 self, itkImageD2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ICVD22_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterID2ICVD22 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ICVD22_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageD2') -> "void":
        """PushFrontInput(itkImageToImageFilterID2ICVD22 self, itkImageD2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ICVD22_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterID2ICVD22 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ICVD22_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterID2ICVD22 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ICVD22_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterID2ICVD22 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ICVD22_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterID2ICVD22 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ICVD22_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterID2ICVD22 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ICVD22_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterID2ICVD22

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterID2ICVD22 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterID2ICVD22"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ICVD22_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterID2ICVD22

        Create a new object of the class itkImageToImageFilterID2ICVD22 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterID2ICVD22.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterID2ICVD22.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterID2ICVD22.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterID2ICVD22.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ICVD22_SetInput, None, itkImageToImageFilterID2ICVD22)
itkImageToImageFilterID2ICVD22.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ICVD22_GetInput, None, itkImageToImageFilterID2ICVD22)
itkImageToImageFilterID2ICVD22.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ICVD22_PushBackInput, None, itkImageToImageFilterID2ICVD22)
itkImageToImageFilterID2ICVD22.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ICVD22_PopBackInput, None, itkImageToImageFilterID2ICVD22)
itkImageToImageFilterID2ICVD22.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ICVD22_PushFrontInput, None, itkImageToImageFilterID2ICVD22)
itkImageToImageFilterID2ICVD22.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ICVD22_PopFrontInput, None, itkImageToImageFilterID2ICVD22)
itkImageToImageFilterID2ICVD22.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ICVD22_SetCoordinateTolerance, None, itkImageToImageFilterID2ICVD22)
itkImageToImageFilterID2ICVD22.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ICVD22_GetCoordinateTolerance, None, itkImageToImageFilterID2ICVD22)
itkImageToImageFilterID2ICVD22.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ICVD22_SetDirectionTolerance, None, itkImageToImageFilterID2ICVD22)
itkImageToImageFilterID2ICVD22.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ICVD22_GetDirectionTolerance, None, itkImageToImageFilterID2ICVD22)
itkImageToImageFilterID2ICVD22_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterID2ICVD22_swigregister
itkImageToImageFilterID2ICVD22_swigregister(itkImageToImageFilterID2ICVD22)

def itkImageToImageFilterID2ICVD22_cast(obj: 'itkLightObject') -> "itkImageToImageFilterID2ICVD22 *":
    """itkImageToImageFilterID2ICVD22_cast(itkLightObject obj) -> itkImageToImageFilterID2ICVD22"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterID2ICVD22_cast(obj)

class itkImageToImageFilterID2ICVF22(itkImageSourcePython.itkImageSourceICVF22):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterID2ICVF22 self, itkImageD2 image)
        SetInput(itkImageToImageFilterID2ICVF22 self, unsigned int arg0, itkImageD2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF22_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageD2 const *":
        """
        GetInput(itkImageToImageFilterID2ICVF22 self) -> itkImageD2
        GetInput(itkImageToImageFilterID2ICVF22 self, unsigned int idx) -> itkImageD2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF22_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageD2') -> "void":
        """
        PushBackInput(itkImageToImageFilterID2ICVF22 self, itkImageD2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF22_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterID2ICVF22 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF22_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageD2') -> "void":
        """PushFrontInput(itkImageToImageFilterID2ICVF22 self, itkImageD2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF22_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterID2ICVF22 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF22_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterID2ICVF22 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF22_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterID2ICVF22 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF22_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterID2ICVF22 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF22_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterID2ICVF22 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF22_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterID2ICVF22

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterID2ICVF22 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterID2ICVF22"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF22_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterID2ICVF22

        Create a new object of the class itkImageToImageFilterID2ICVF22 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterID2ICVF22.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterID2ICVF22.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterID2ICVF22.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterID2ICVF22.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF22_SetInput, None, itkImageToImageFilterID2ICVF22)
itkImageToImageFilterID2ICVF22.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF22_GetInput, None, itkImageToImageFilterID2ICVF22)
itkImageToImageFilterID2ICVF22.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF22_PushBackInput, None, itkImageToImageFilterID2ICVF22)
itkImageToImageFilterID2ICVF22.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF22_PopBackInput, None, itkImageToImageFilterID2ICVF22)
itkImageToImageFilterID2ICVF22.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF22_PushFrontInput, None, itkImageToImageFilterID2ICVF22)
itkImageToImageFilterID2ICVF22.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF22_PopFrontInput, None, itkImageToImageFilterID2ICVF22)
itkImageToImageFilterID2ICVF22.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF22_SetCoordinateTolerance, None, itkImageToImageFilterID2ICVF22)
itkImageToImageFilterID2ICVF22.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF22_GetCoordinateTolerance, None, itkImageToImageFilterID2ICVF22)
itkImageToImageFilterID2ICVF22.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF22_SetDirectionTolerance, None, itkImageToImageFilterID2ICVF22)
itkImageToImageFilterID2ICVF22.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF22_GetDirectionTolerance, None, itkImageToImageFilterID2ICVF22)
itkImageToImageFilterID2ICVF22_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF22_swigregister
itkImageToImageFilterID2ICVF22_swigregister(itkImageToImageFilterID2ICVF22)

def itkImageToImageFilterID2ICVF22_cast(obj: 'itkLightObject') -> "itkImageToImageFilterID2ICVF22 *":
    """itkImageToImageFilterID2ICVF22_cast(itkLightObject obj) -> itkImageToImageFilterID2ICVF22"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF22_cast(obj)

class itkImageToImageFilterID2ICVF32(itkImageSourcePython.itkImageSourceICVF32):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterID2ICVF32 self, itkImageD2 image)
        SetInput(itkImageToImageFilterID2ICVF32 self, unsigned int arg0, itkImageD2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF32_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageD2 const *":
        """
        GetInput(itkImageToImageFilterID2ICVF32 self) -> itkImageD2
        GetInput(itkImageToImageFilterID2ICVF32 self, unsigned int idx) -> itkImageD2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF32_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageD2') -> "void":
        """
        PushBackInput(itkImageToImageFilterID2ICVF32 self, itkImageD2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF32_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterID2ICVF32 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF32_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageD2') -> "void":
        """PushFrontInput(itkImageToImageFilterID2ICVF32 self, itkImageD2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF32_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterID2ICVF32 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF32_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterID2ICVF32 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF32_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterID2ICVF32 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF32_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterID2ICVF32 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF32_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterID2ICVF32 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF32_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterID2ICVF32

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterID2ICVF32 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterID2ICVF32"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF32_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterID2ICVF32

        Create a new object of the class itkImageToImageFilterID2ICVF32 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterID2ICVF32.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterID2ICVF32.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterID2ICVF32.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterID2ICVF32.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF32_SetInput, None, itkImageToImageFilterID2ICVF32)
itkImageToImageFilterID2ICVF32.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF32_GetInput, None, itkImageToImageFilterID2ICVF32)
itkImageToImageFilterID2ICVF32.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF32_PushBackInput, None, itkImageToImageFilterID2ICVF32)
itkImageToImageFilterID2ICVF32.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF32_PopBackInput, None, itkImageToImageFilterID2ICVF32)
itkImageToImageFilterID2ICVF32.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF32_PushFrontInput, None, itkImageToImageFilterID2ICVF32)
itkImageToImageFilterID2ICVF32.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF32_PopFrontInput, None, itkImageToImageFilterID2ICVF32)
itkImageToImageFilterID2ICVF32.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF32_SetCoordinateTolerance, None, itkImageToImageFilterID2ICVF32)
itkImageToImageFilterID2ICVF32.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF32_GetCoordinateTolerance, None, itkImageToImageFilterID2ICVF32)
itkImageToImageFilterID2ICVF32.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF32_SetDirectionTolerance, None, itkImageToImageFilterID2ICVF32)
itkImageToImageFilterID2ICVF32.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF32_GetDirectionTolerance, None, itkImageToImageFilterID2ICVF32)
itkImageToImageFilterID2ICVF32_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF32_swigregister
itkImageToImageFilterID2ICVF32_swigregister(itkImageToImageFilterID2ICVF32)

def itkImageToImageFilterID2ICVF32_cast(obj: 'itkLightObject') -> "itkImageToImageFilterID2ICVF32 *":
    """itkImageToImageFilterID2ICVF32_cast(itkLightObject obj) -> itkImageToImageFilterID2ICVF32"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF32_cast(obj)

class itkImageToImageFilterID2ICVF42(itkImageSourcePython.itkImageSourceICVF42):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterID2ICVF42 self, itkImageD2 image)
        SetInput(itkImageToImageFilterID2ICVF42 self, unsigned int arg0, itkImageD2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF42_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageD2 const *":
        """
        GetInput(itkImageToImageFilterID2ICVF42 self) -> itkImageD2
        GetInput(itkImageToImageFilterID2ICVF42 self, unsigned int idx) -> itkImageD2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF42_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageD2') -> "void":
        """
        PushBackInput(itkImageToImageFilterID2ICVF42 self, itkImageD2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF42_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterID2ICVF42 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF42_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageD2') -> "void":
        """PushFrontInput(itkImageToImageFilterID2ICVF42 self, itkImageD2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF42_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterID2ICVF42 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF42_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterID2ICVF42 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF42_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterID2ICVF42 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF42_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterID2ICVF42 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF42_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterID2ICVF42 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF42_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterID2ICVF42

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterID2ICVF42 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterID2ICVF42"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF42_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterID2ICVF42

        Create a new object of the class itkImageToImageFilterID2ICVF42 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterID2ICVF42.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterID2ICVF42.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterID2ICVF42.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterID2ICVF42.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF42_SetInput, None, itkImageToImageFilterID2ICVF42)
itkImageToImageFilterID2ICVF42.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF42_GetInput, None, itkImageToImageFilterID2ICVF42)
itkImageToImageFilterID2ICVF42.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF42_PushBackInput, None, itkImageToImageFilterID2ICVF42)
itkImageToImageFilterID2ICVF42.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF42_PopBackInput, None, itkImageToImageFilterID2ICVF42)
itkImageToImageFilterID2ICVF42.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF42_PushFrontInput, None, itkImageToImageFilterID2ICVF42)
itkImageToImageFilterID2ICVF42.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF42_PopFrontInput, None, itkImageToImageFilterID2ICVF42)
itkImageToImageFilterID2ICVF42.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF42_SetCoordinateTolerance, None, itkImageToImageFilterID2ICVF42)
itkImageToImageFilterID2ICVF42.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF42_GetCoordinateTolerance, None, itkImageToImageFilterID2ICVF42)
itkImageToImageFilterID2ICVF42.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF42_SetDirectionTolerance, None, itkImageToImageFilterID2ICVF42)
itkImageToImageFilterID2ICVF42.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF42_GetDirectionTolerance, None, itkImageToImageFilterID2ICVF42)
itkImageToImageFilterID2ICVF42_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF42_swigregister
itkImageToImageFilterID2ICVF42_swigregister(itkImageToImageFilterID2ICVF42)

def itkImageToImageFilterID2ICVF42_cast(obj: 'itkLightObject') -> "itkImageToImageFilterID2ICVF42 *":
    """itkImageToImageFilterID2ICVF42_cast(itkLightObject obj) -> itkImageToImageFilterID2ICVF42"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterID2ICVF42_cast(obj)

class itkImageToImageFilterID2ID3(itkImageSourcePython.itkImageSourceID3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterID2ID3 self, itkImageD2 image)
        SetInput(itkImageToImageFilterID2ID3 self, unsigned int arg0, itkImageD2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ID3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageD2 const *":
        """
        GetInput(itkImageToImageFilterID2ID3 self) -> itkImageD2
        GetInput(itkImageToImageFilterID2ID3 self, unsigned int idx) -> itkImageD2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ID3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageD2') -> "void":
        """
        PushBackInput(itkImageToImageFilterID2ID3 self, itkImageD2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ID3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterID2ID3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ID3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageD2') -> "void":
        """PushFrontInput(itkImageToImageFilterID2ID3 self, itkImageD2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ID3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterID2ID3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ID3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterID2ID3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ID3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterID2ID3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ID3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterID2ID3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ID3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterID2ID3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ID3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterID2ID3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterID2ID3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterID2ID3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ID3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterID2ID3

        Create a new object of the class itkImageToImageFilterID2ID3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterID2ID3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterID2ID3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterID2ID3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterID2ID3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ID3_SetInput, None, itkImageToImageFilterID2ID3)
itkImageToImageFilterID2ID3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ID3_GetInput, None, itkImageToImageFilterID2ID3)
itkImageToImageFilterID2ID3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ID3_PushBackInput, None, itkImageToImageFilterID2ID3)
itkImageToImageFilterID2ID3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ID3_PopBackInput, None, itkImageToImageFilterID2ID3)
itkImageToImageFilterID2ID3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ID3_PushFrontInput, None, itkImageToImageFilterID2ID3)
itkImageToImageFilterID2ID3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ID3_PopFrontInput, None, itkImageToImageFilterID2ID3)
itkImageToImageFilterID2ID3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ID3_SetCoordinateTolerance, None, itkImageToImageFilterID2ID3)
itkImageToImageFilterID2ID3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ID3_GetCoordinateTolerance, None, itkImageToImageFilterID2ID3)
itkImageToImageFilterID2ID3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ID3_SetDirectionTolerance, None, itkImageToImageFilterID2ID3)
itkImageToImageFilterID2ID3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ID3_GetDirectionTolerance, None, itkImageToImageFilterID2ID3)
itkImageToImageFilterID2ID3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterID2ID3_swigregister
itkImageToImageFilterID2ID3_swigregister(itkImageToImageFilterID2ID3)

def itkImageToImageFilterID2ID3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterID2ID3 *":
    """itkImageToImageFilterID2ID3_cast(itkLightObject obj) -> itkImageToImageFilterID2ID3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterID2ID3_cast(obj)

class itkImageToImageFilterID2IRGBAUC2(itkImageSourcePython.itkImageSourceIRGBAUC2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterID2IRGBAUC2 self, itkImageD2 image)
        SetInput(itkImageToImageFilterID2IRGBAUC2 self, unsigned int arg0, itkImageD2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2IRGBAUC2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageD2 const *":
        """
        GetInput(itkImageToImageFilterID2IRGBAUC2 self) -> itkImageD2
        GetInput(itkImageToImageFilterID2IRGBAUC2 self, unsigned int idx) -> itkImageD2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2IRGBAUC2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageD2') -> "void":
        """
        PushBackInput(itkImageToImageFilterID2IRGBAUC2 self, itkImageD2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2IRGBAUC2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterID2IRGBAUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2IRGBAUC2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageD2') -> "void":
        """PushFrontInput(itkImageToImageFilterID2IRGBAUC2 self, itkImageD2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2IRGBAUC2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterID2IRGBAUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2IRGBAUC2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterID2IRGBAUC2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2IRGBAUC2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterID2IRGBAUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2IRGBAUC2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterID2IRGBAUC2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2IRGBAUC2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterID2IRGBAUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2IRGBAUC2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterID2IRGBAUC2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterID2IRGBAUC2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterID2IRGBAUC2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2IRGBAUC2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterID2IRGBAUC2

        Create a new object of the class itkImageToImageFilterID2IRGBAUC2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterID2IRGBAUC2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterID2IRGBAUC2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterID2IRGBAUC2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterID2IRGBAUC2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2IRGBAUC2_SetInput, None, itkImageToImageFilterID2IRGBAUC2)
itkImageToImageFilterID2IRGBAUC2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2IRGBAUC2_GetInput, None, itkImageToImageFilterID2IRGBAUC2)
itkImageToImageFilterID2IRGBAUC2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2IRGBAUC2_PushBackInput, None, itkImageToImageFilterID2IRGBAUC2)
itkImageToImageFilterID2IRGBAUC2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2IRGBAUC2_PopBackInput, None, itkImageToImageFilterID2IRGBAUC2)
itkImageToImageFilterID2IRGBAUC2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2IRGBAUC2_PushFrontInput, None, itkImageToImageFilterID2IRGBAUC2)
itkImageToImageFilterID2IRGBAUC2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2IRGBAUC2_PopFrontInput, None, itkImageToImageFilterID2IRGBAUC2)
itkImageToImageFilterID2IRGBAUC2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2IRGBAUC2_SetCoordinateTolerance, None, itkImageToImageFilterID2IRGBAUC2)
itkImageToImageFilterID2IRGBAUC2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2IRGBAUC2_GetCoordinateTolerance, None, itkImageToImageFilterID2IRGBAUC2)
itkImageToImageFilterID2IRGBAUC2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2IRGBAUC2_SetDirectionTolerance, None, itkImageToImageFilterID2IRGBAUC2)
itkImageToImageFilterID2IRGBAUC2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2IRGBAUC2_GetDirectionTolerance, None, itkImageToImageFilterID2IRGBAUC2)
itkImageToImageFilterID2IRGBAUC2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterID2IRGBAUC2_swigregister
itkImageToImageFilterID2IRGBAUC2_swigregister(itkImageToImageFilterID2IRGBAUC2)

def itkImageToImageFilterID2IRGBAUC2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterID2IRGBAUC2 *":
    """itkImageToImageFilterID2IRGBAUC2_cast(itkLightObject obj) -> itkImageToImageFilterID2IRGBAUC2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterID2IRGBAUC2_cast(obj)

class itkImageToImageFilterID2IRGBUC2(itkImageSourcePython.itkImageSourceIRGBUC2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterID2IRGBUC2 self, itkImageD2 image)
        SetInput(itkImageToImageFilterID2IRGBUC2 self, unsigned int arg0, itkImageD2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2IRGBUC2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageD2 const *":
        """
        GetInput(itkImageToImageFilterID2IRGBUC2 self) -> itkImageD2
        GetInput(itkImageToImageFilterID2IRGBUC2 self, unsigned int idx) -> itkImageD2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2IRGBUC2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageD2') -> "void":
        """
        PushBackInput(itkImageToImageFilterID2IRGBUC2 self, itkImageD2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2IRGBUC2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterID2IRGBUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2IRGBUC2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageD2') -> "void":
        """PushFrontInput(itkImageToImageFilterID2IRGBUC2 self, itkImageD2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2IRGBUC2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterID2IRGBUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2IRGBUC2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterID2IRGBUC2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2IRGBUC2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterID2IRGBUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2IRGBUC2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterID2IRGBUC2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2IRGBUC2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterID2IRGBUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2IRGBUC2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterID2IRGBUC2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterID2IRGBUC2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterID2IRGBUC2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2IRGBUC2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterID2IRGBUC2

        Create a new object of the class itkImageToImageFilterID2IRGBUC2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterID2IRGBUC2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterID2IRGBUC2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterID2IRGBUC2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterID2IRGBUC2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2IRGBUC2_SetInput, None, itkImageToImageFilterID2IRGBUC2)
itkImageToImageFilterID2IRGBUC2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2IRGBUC2_GetInput, None, itkImageToImageFilterID2IRGBUC2)
itkImageToImageFilterID2IRGBUC2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2IRGBUC2_PushBackInput, None, itkImageToImageFilterID2IRGBUC2)
itkImageToImageFilterID2IRGBUC2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2IRGBUC2_PopBackInput, None, itkImageToImageFilterID2IRGBUC2)
itkImageToImageFilterID2IRGBUC2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2IRGBUC2_PushFrontInput, None, itkImageToImageFilterID2IRGBUC2)
itkImageToImageFilterID2IRGBUC2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2IRGBUC2_PopFrontInput, None, itkImageToImageFilterID2IRGBUC2)
itkImageToImageFilterID2IRGBUC2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2IRGBUC2_SetCoordinateTolerance, None, itkImageToImageFilterID2IRGBUC2)
itkImageToImageFilterID2IRGBUC2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2IRGBUC2_GetCoordinateTolerance, None, itkImageToImageFilterID2IRGBUC2)
itkImageToImageFilterID2IRGBUC2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2IRGBUC2_SetDirectionTolerance, None, itkImageToImageFilterID2IRGBUC2)
itkImageToImageFilterID2IRGBUC2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2IRGBUC2_GetDirectionTolerance, None, itkImageToImageFilterID2IRGBUC2)
itkImageToImageFilterID2IRGBUC2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterID2IRGBUC2_swigregister
itkImageToImageFilterID2IRGBUC2_swigregister(itkImageToImageFilterID2IRGBUC2)

def itkImageToImageFilterID2IRGBUC2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterID2IRGBUC2 *":
    """itkImageToImageFilterID2IRGBUC2_cast(itkLightObject obj) -> itkImageToImageFilterID2IRGBUC2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterID2IRGBUC2_cast(obj)

class itkImageToImageFilterID2ISSRTD22(itkImageSourcePython.itkImageSourceISSRTD22):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterID2ISSRTD22 self, itkImageD2 image)
        SetInput(itkImageToImageFilterID2ISSRTD22 self, unsigned int arg0, itkImageD2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ISSRTD22_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageD2 const *":
        """
        GetInput(itkImageToImageFilterID2ISSRTD22 self) -> itkImageD2
        GetInput(itkImageToImageFilterID2ISSRTD22 self, unsigned int idx) -> itkImageD2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ISSRTD22_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageD2') -> "void":
        """
        PushBackInput(itkImageToImageFilterID2ISSRTD22 self, itkImageD2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ISSRTD22_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterID2ISSRTD22 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ISSRTD22_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageD2') -> "void":
        """PushFrontInput(itkImageToImageFilterID2ISSRTD22 self, itkImageD2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ISSRTD22_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterID2ISSRTD22 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ISSRTD22_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterID2ISSRTD22 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ISSRTD22_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterID2ISSRTD22 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ISSRTD22_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterID2ISSRTD22 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ISSRTD22_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterID2ISSRTD22 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ISSRTD22_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterID2ISSRTD22

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterID2ISSRTD22 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterID2ISSRTD22"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2ISSRTD22_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterID2ISSRTD22

        Create a new object of the class itkImageToImageFilterID2ISSRTD22 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterID2ISSRTD22.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterID2ISSRTD22.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterID2ISSRTD22.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterID2ISSRTD22.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ISSRTD22_SetInput, None, itkImageToImageFilterID2ISSRTD22)
itkImageToImageFilterID2ISSRTD22.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ISSRTD22_GetInput, None, itkImageToImageFilterID2ISSRTD22)
itkImageToImageFilterID2ISSRTD22.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ISSRTD22_PushBackInput, None, itkImageToImageFilterID2ISSRTD22)
itkImageToImageFilterID2ISSRTD22.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ISSRTD22_PopBackInput, None, itkImageToImageFilterID2ISSRTD22)
itkImageToImageFilterID2ISSRTD22.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ISSRTD22_PushFrontInput, None, itkImageToImageFilterID2ISSRTD22)
itkImageToImageFilterID2ISSRTD22.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ISSRTD22_PopFrontInput, None, itkImageToImageFilterID2ISSRTD22)
itkImageToImageFilterID2ISSRTD22.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ISSRTD22_SetCoordinateTolerance, None, itkImageToImageFilterID2ISSRTD22)
itkImageToImageFilterID2ISSRTD22.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ISSRTD22_GetCoordinateTolerance, None, itkImageToImageFilterID2ISSRTD22)
itkImageToImageFilterID2ISSRTD22.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ISSRTD22_SetDirectionTolerance, None, itkImageToImageFilterID2ISSRTD22)
itkImageToImageFilterID2ISSRTD22.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2ISSRTD22_GetDirectionTolerance, None, itkImageToImageFilterID2ISSRTD22)
itkImageToImageFilterID2ISSRTD22_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterID2ISSRTD22_swigregister
itkImageToImageFilterID2ISSRTD22_swigregister(itkImageToImageFilterID2ISSRTD22)

def itkImageToImageFilterID2ISSRTD22_cast(obj: 'itkLightObject') -> "itkImageToImageFilterID2ISSRTD22 *":
    """itkImageToImageFilterID2ISSRTD22_cast(itkLightObject obj) -> itkImageToImageFilterID2ISSRTD22"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterID2ISSRTD22_cast(obj)

class itkImageToImageFilterID2IVF22(itkImageSourcePython.itkImageSourceIVF22):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterID2IVF22 self, itkImageD2 image)
        SetInput(itkImageToImageFilterID2IVF22 self, unsigned int arg0, itkImageD2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2IVF22_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageD2 const *":
        """
        GetInput(itkImageToImageFilterID2IVF22 self) -> itkImageD2
        GetInput(itkImageToImageFilterID2IVF22 self, unsigned int idx) -> itkImageD2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2IVF22_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageD2') -> "void":
        """
        PushBackInput(itkImageToImageFilterID2IVF22 self, itkImageD2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2IVF22_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterID2IVF22 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2IVF22_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageD2') -> "void":
        """PushFrontInput(itkImageToImageFilterID2IVF22 self, itkImageD2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2IVF22_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterID2IVF22 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2IVF22_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterID2IVF22 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2IVF22_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterID2IVF22 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2IVF22_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterID2IVF22 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2IVF22_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterID2IVF22 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2IVF22_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterID2IVF22

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterID2IVF22 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterID2IVF22"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2IVF22_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterID2IVF22

        Create a new object of the class itkImageToImageFilterID2IVF22 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterID2IVF22.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterID2IVF22.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterID2IVF22.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterID2IVF22.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2IVF22_SetInput, None, itkImageToImageFilterID2IVF22)
itkImageToImageFilterID2IVF22.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2IVF22_GetInput, None, itkImageToImageFilterID2IVF22)
itkImageToImageFilterID2IVF22.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2IVF22_PushBackInput, None, itkImageToImageFilterID2IVF22)
itkImageToImageFilterID2IVF22.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2IVF22_PopBackInput, None, itkImageToImageFilterID2IVF22)
itkImageToImageFilterID2IVF22.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2IVF22_PushFrontInput, None, itkImageToImageFilterID2IVF22)
itkImageToImageFilterID2IVF22.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2IVF22_PopFrontInput, None, itkImageToImageFilterID2IVF22)
itkImageToImageFilterID2IVF22.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2IVF22_SetCoordinateTolerance, None, itkImageToImageFilterID2IVF22)
itkImageToImageFilterID2IVF22.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2IVF22_GetCoordinateTolerance, None, itkImageToImageFilterID2IVF22)
itkImageToImageFilterID2IVF22.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2IVF22_SetDirectionTolerance, None, itkImageToImageFilterID2IVF22)
itkImageToImageFilterID2IVF22.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2IVF22_GetDirectionTolerance, None, itkImageToImageFilterID2IVF22)
itkImageToImageFilterID2IVF22_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterID2IVF22_swigregister
itkImageToImageFilterID2IVF22_swigregister(itkImageToImageFilterID2IVF22)

def itkImageToImageFilterID2IVF22_cast(obj: 'itkLightObject') -> "itkImageToImageFilterID2IVF22 *":
    """itkImageToImageFilterID2IVF22_cast(itkLightObject obj) -> itkImageToImageFilterID2IVF22"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterID2IVF22_cast(obj)

class itkImageToImageFilterID2IVF32(itkImageSourcePython.itkImageSourceIVF32):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterID2IVF32 self, itkImageD2 image)
        SetInput(itkImageToImageFilterID2IVF32 self, unsigned int arg0, itkImageD2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2IVF32_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageD2 const *":
        """
        GetInput(itkImageToImageFilterID2IVF32 self) -> itkImageD2
        GetInput(itkImageToImageFilterID2IVF32 self, unsigned int idx) -> itkImageD2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2IVF32_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageD2') -> "void":
        """
        PushBackInput(itkImageToImageFilterID2IVF32 self, itkImageD2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2IVF32_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterID2IVF32 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2IVF32_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageD2') -> "void":
        """PushFrontInput(itkImageToImageFilterID2IVF32 self, itkImageD2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2IVF32_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterID2IVF32 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2IVF32_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterID2IVF32 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2IVF32_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterID2IVF32 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2IVF32_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterID2IVF32 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2IVF32_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterID2IVF32 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2IVF32_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterID2IVF32

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterID2IVF32 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterID2IVF32"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2IVF32_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterID2IVF32

        Create a new object of the class itkImageToImageFilterID2IVF32 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterID2IVF32.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterID2IVF32.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterID2IVF32.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterID2IVF32.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2IVF32_SetInput, None, itkImageToImageFilterID2IVF32)
itkImageToImageFilterID2IVF32.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2IVF32_GetInput, None, itkImageToImageFilterID2IVF32)
itkImageToImageFilterID2IVF32.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2IVF32_PushBackInput, None, itkImageToImageFilterID2IVF32)
itkImageToImageFilterID2IVF32.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2IVF32_PopBackInput, None, itkImageToImageFilterID2IVF32)
itkImageToImageFilterID2IVF32.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2IVF32_PushFrontInput, None, itkImageToImageFilterID2IVF32)
itkImageToImageFilterID2IVF32.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2IVF32_PopFrontInput, None, itkImageToImageFilterID2IVF32)
itkImageToImageFilterID2IVF32.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2IVF32_SetCoordinateTolerance, None, itkImageToImageFilterID2IVF32)
itkImageToImageFilterID2IVF32.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2IVF32_GetCoordinateTolerance, None, itkImageToImageFilterID2IVF32)
itkImageToImageFilterID2IVF32.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2IVF32_SetDirectionTolerance, None, itkImageToImageFilterID2IVF32)
itkImageToImageFilterID2IVF32.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2IVF32_GetDirectionTolerance, None, itkImageToImageFilterID2IVF32)
itkImageToImageFilterID2IVF32_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterID2IVF32_swigregister
itkImageToImageFilterID2IVF32_swigregister(itkImageToImageFilterID2IVF32)

def itkImageToImageFilterID2IVF32_cast(obj: 'itkLightObject') -> "itkImageToImageFilterID2IVF32 *":
    """itkImageToImageFilterID2IVF32_cast(itkLightObject obj) -> itkImageToImageFilterID2IVF32"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterID2IVF32_cast(obj)

class itkImageToImageFilterID2IVF42(itkImageSourcePython.itkImageSourceIVF42):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterID2IVF42 self, itkImageD2 image)
        SetInput(itkImageToImageFilterID2IVF42 self, unsigned int arg0, itkImageD2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2IVF42_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageD2 const *":
        """
        GetInput(itkImageToImageFilterID2IVF42 self) -> itkImageD2
        GetInput(itkImageToImageFilterID2IVF42 self, unsigned int idx) -> itkImageD2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2IVF42_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageD2') -> "void":
        """
        PushBackInput(itkImageToImageFilterID2IVF42 self, itkImageD2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2IVF42_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterID2IVF42 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2IVF42_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageD2') -> "void":
        """PushFrontInput(itkImageToImageFilterID2IVF42 self, itkImageD2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2IVF42_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterID2IVF42 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2IVF42_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterID2IVF42 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2IVF42_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterID2IVF42 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2IVF42_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterID2IVF42 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2IVF42_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterID2IVF42 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2IVF42_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterID2IVF42

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterID2IVF42 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterID2IVF42"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2IVF42_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterID2IVF42

        Create a new object of the class itkImageToImageFilterID2IVF42 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterID2IVF42.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterID2IVF42.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterID2IVF42.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterID2IVF42.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2IVF42_SetInput, None, itkImageToImageFilterID2IVF42)
itkImageToImageFilterID2IVF42.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2IVF42_GetInput, None, itkImageToImageFilterID2IVF42)
itkImageToImageFilterID2IVF42.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2IVF42_PushBackInput, None, itkImageToImageFilterID2IVF42)
itkImageToImageFilterID2IVF42.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2IVF42_PopBackInput, None, itkImageToImageFilterID2IVF42)
itkImageToImageFilterID2IVF42.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2IVF42_PushFrontInput, None, itkImageToImageFilterID2IVF42)
itkImageToImageFilterID2IVF42.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2IVF42_PopFrontInput, None, itkImageToImageFilterID2IVF42)
itkImageToImageFilterID2IVF42.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2IVF42_SetCoordinateTolerance, None, itkImageToImageFilterID2IVF42)
itkImageToImageFilterID2IVF42.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2IVF42_GetCoordinateTolerance, None, itkImageToImageFilterID2IVF42)
itkImageToImageFilterID2IVF42.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2IVF42_SetDirectionTolerance, None, itkImageToImageFilterID2IVF42)
itkImageToImageFilterID2IVF42.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2IVF42_GetDirectionTolerance, None, itkImageToImageFilterID2IVF42)
itkImageToImageFilterID2IVF42_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterID2IVF42_swigregister
itkImageToImageFilterID2IVF42_swigregister(itkImageToImageFilterID2IVF42)

def itkImageToImageFilterID2IVF42_cast(obj: 'itkLightObject') -> "itkImageToImageFilterID2IVF42 *":
    """itkImageToImageFilterID2IVF42_cast(itkLightObject obj) -> itkImageToImageFilterID2IVF42"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterID2IVF42_cast(obj)

class itkImageToImageFilterID2VID2(itkImageSourcePython.itkImageSourceVID2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterID2VID2 self, itkImageD2 image)
        SetInput(itkImageToImageFilterID2VID2 self, unsigned int arg0, itkImageD2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2VID2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageD2 const *":
        """
        GetInput(itkImageToImageFilterID2VID2 self) -> itkImageD2
        GetInput(itkImageToImageFilterID2VID2 self, unsigned int idx) -> itkImageD2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2VID2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageD2') -> "void":
        """
        PushBackInput(itkImageToImageFilterID2VID2 self, itkImageD2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2VID2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterID2VID2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2VID2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageD2') -> "void":
        """PushFrontInput(itkImageToImageFilterID2VID2 self, itkImageD2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2VID2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterID2VID2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2VID2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterID2VID2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2VID2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterID2VID2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2VID2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterID2VID2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2VID2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterID2VID2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2VID2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterID2VID2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterID2VID2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterID2VID2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2VID2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterID2VID2

        Create a new object of the class itkImageToImageFilterID2VID2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterID2VID2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterID2VID2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterID2VID2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterID2VID2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2VID2_SetInput, None, itkImageToImageFilterID2VID2)
itkImageToImageFilterID2VID2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2VID2_GetInput, None, itkImageToImageFilterID2VID2)
itkImageToImageFilterID2VID2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2VID2_PushBackInput, None, itkImageToImageFilterID2VID2)
itkImageToImageFilterID2VID2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2VID2_PopBackInput, None, itkImageToImageFilterID2VID2)
itkImageToImageFilterID2VID2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2VID2_PushFrontInput, None, itkImageToImageFilterID2VID2)
itkImageToImageFilterID2VID2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2VID2_PopFrontInput, None, itkImageToImageFilterID2VID2)
itkImageToImageFilterID2VID2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2VID2_SetCoordinateTolerance, None, itkImageToImageFilterID2VID2)
itkImageToImageFilterID2VID2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2VID2_GetCoordinateTolerance, None, itkImageToImageFilterID2VID2)
itkImageToImageFilterID2VID2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2VID2_SetDirectionTolerance, None, itkImageToImageFilterID2VID2)
itkImageToImageFilterID2VID2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2VID2_GetDirectionTolerance, None, itkImageToImageFilterID2VID2)
itkImageToImageFilterID2VID2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterID2VID2_swigregister
itkImageToImageFilterID2VID2_swigregister(itkImageToImageFilterID2VID2)

def itkImageToImageFilterID2VID2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterID2VID2 *":
    """itkImageToImageFilterID2VID2_cast(itkLightObject obj) -> itkImageToImageFilterID2VID2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterID2VID2_cast(obj)

class itkImageToImageFilterID2VIF2(itkImageSourcePython.itkImageSourceVIF2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterID2VIF2 self, itkImageD2 image)
        SetInput(itkImageToImageFilterID2VIF2 self, unsigned int arg0, itkImageD2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2VIF2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageD2 const *":
        """
        GetInput(itkImageToImageFilterID2VIF2 self) -> itkImageD2
        GetInput(itkImageToImageFilterID2VIF2 self, unsigned int idx) -> itkImageD2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2VIF2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageD2') -> "void":
        """
        PushBackInput(itkImageToImageFilterID2VIF2 self, itkImageD2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2VIF2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterID2VIF2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2VIF2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageD2') -> "void":
        """PushFrontInput(itkImageToImageFilterID2VIF2 self, itkImageD2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2VIF2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterID2VIF2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2VIF2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterID2VIF2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2VIF2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterID2VIF2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2VIF2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterID2VIF2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2VIF2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterID2VIF2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2VIF2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterID2VIF2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterID2VIF2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterID2VIF2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2VIF2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterID2VIF2

        Create a new object of the class itkImageToImageFilterID2VIF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterID2VIF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterID2VIF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterID2VIF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterID2VIF2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2VIF2_SetInput, None, itkImageToImageFilterID2VIF2)
itkImageToImageFilterID2VIF2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2VIF2_GetInput, None, itkImageToImageFilterID2VIF2)
itkImageToImageFilterID2VIF2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2VIF2_PushBackInput, None, itkImageToImageFilterID2VIF2)
itkImageToImageFilterID2VIF2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2VIF2_PopBackInput, None, itkImageToImageFilterID2VIF2)
itkImageToImageFilterID2VIF2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2VIF2_PushFrontInput, None, itkImageToImageFilterID2VIF2)
itkImageToImageFilterID2VIF2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2VIF2_PopFrontInput, None, itkImageToImageFilterID2VIF2)
itkImageToImageFilterID2VIF2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2VIF2_SetCoordinateTolerance, None, itkImageToImageFilterID2VIF2)
itkImageToImageFilterID2VIF2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2VIF2_GetCoordinateTolerance, None, itkImageToImageFilterID2VIF2)
itkImageToImageFilterID2VIF2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2VIF2_SetDirectionTolerance, None, itkImageToImageFilterID2VIF2)
itkImageToImageFilterID2VIF2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2VIF2_GetDirectionTolerance, None, itkImageToImageFilterID2VIF2)
itkImageToImageFilterID2VIF2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterID2VIF2_swigregister
itkImageToImageFilterID2VIF2_swigregister(itkImageToImageFilterID2VIF2)

def itkImageToImageFilterID2VIF2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterID2VIF2 *":
    """itkImageToImageFilterID2VIF2_cast(itkLightObject obj) -> itkImageToImageFilterID2VIF2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterID2VIF2_cast(obj)

class itkImageToImageFilterID2VISS2(itkImageSourcePython.itkImageSourceVISS2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterID2VISS2 self, itkImageD2 image)
        SetInput(itkImageToImageFilterID2VISS2 self, unsigned int arg0, itkImageD2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2VISS2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageD2 const *":
        """
        GetInput(itkImageToImageFilterID2VISS2 self) -> itkImageD2
        GetInput(itkImageToImageFilterID2VISS2 self, unsigned int idx) -> itkImageD2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2VISS2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageD2') -> "void":
        """
        PushBackInput(itkImageToImageFilterID2VISS2 self, itkImageD2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2VISS2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterID2VISS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2VISS2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageD2') -> "void":
        """PushFrontInput(itkImageToImageFilterID2VISS2 self, itkImageD2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2VISS2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterID2VISS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2VISS2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterID2VISS2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2VISS2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterID2VISS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2VISS2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterID2VISS2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2VISS2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterID2VISS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2VISS2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterID2VISS2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterID2VISS2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterID2VISS2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2VISS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterID2VISS2

        Create a new object of the class itkImageToImageFilterID2VISS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterID2VISS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterID2VISS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterID2VISS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterID2VISS2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2VISS2_SetInput, None, itkImageToImageFilterID2VISS2)
itkImageToImageFilterID2VISS2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2VISS2_GetInput, None, itkImageToImageFilterID2VISS2)
itkImageToImageFilterID2VISS2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2VISS2_PushBackInput, None, itkImageToImageFilterID2VISS2)
itkImageToImageFilterID2VISS2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2VISS2_PopBackInput, None, itkImageToImageFilterID2VISS2)
itkImageToImageFilterID2VISS2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2VISS2_PushFrontInput, None, itkImageToImageFilterID2VISS2)
itkImageToImageFilterID2VISS2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2VISS2_PopFrontInput, None, itkImageToImageFilterID2VISS2)
itkImageToImageFilterID2VISS2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2VISS2_SetCoordinateTolerance, None, itkImageToImageFilterID2VISS2)
itkImageToImageFilterID2VISS2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2VISS2_GetCoordinateTolerance, None, itkImageToImageFilterID2VISS2)
itkImageToImageFilterID2VISS2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2VISS2_SetDirectionTolerance, None, itkImageToImageFilterID2VISS2)
itkImageToImageFilterID2VISS2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2VISS2_GetDirectionTolerance, None, itkImageToImageFilterID2VISS2)
itkImageToImageFilterID2VISS2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterID2VISS2_swigregister
itkImageToImageFilterID2VISS2_swigregister(itkImageToImageFilterID2VISS2)

def itkImageToImageFilterID2VISS2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterID2VISS2 *":
    """itkImageToImageFilterID2VISS2_cast(itkLightObject obj) -> itkImageToImageFilterID2VISS2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterID2VISS2_cast(obj)

class itkImageToImageFilterID2VIUC2(itkImageSourcePython.itkImageSourceVIUC2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterID2VIUC2 self, itkImageD2 image)
        SetInput(itkImageToImageFilterID2VIUC2 self, unsigned int arg0, itkImageD2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2VIUC2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageD2 const *":
        """
        GetInput(itkImageToImageFilterID2VIUC2 self) -> itkImageD2
        GetInput(itkImageToImageFilterID2VIUC2 self, unsigned int idx) -> itkImageD2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2VIUC2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageD2') -> "void":
        """
        PushBackInput(itkImageToImageFilterID2VIUC2 self, itkImageD2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2VIUC2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterID2VIUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2VIUC2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageD2') -> "void":
        """PushFrontInput(itkImageToImageFilterID2VIUC2 self, itkImageD2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2VIUC2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterID2VIUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2VIUC2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterID2VIUC2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2VIUC2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterID2VIUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2VIUC2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterID2VIUC2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2VIUC2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterID2VIUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2VIUC2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterID2VIUC2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterID2VIUC2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterID2VIUC2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2VIUC2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterID2VIUC2

        Create a new object of the class itkImageToImageFilterID2VIUC2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterID2VIUC2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterID2VIUC2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterID2VIUC2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterID2VIUC2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2VIUC2_SetInput, None, itkImageToImageFilterID2VIUC2)
itkImageToImageFilterID2VIUC2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2VIUC2_GetInput, None, itkImageToImageFilterID2VIUC2)
itkImageToImageFilterID2VIUC2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2VIUC2_PushBackInput, None, itkImageToImageFilterID2VIUC2)
itkImageToImageFilterID2VIUC2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2VIUC2_PopBackInput, None, itkImageToImageFilterID2VIUC2)
itkImageToImageFilterID2VIUC2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2VIUC2_PushFrontInput, None, itkImageToImageFilterID2VIUC2)
itkImageToImageFilterID2VIUC2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2VIUC2_PopFrontInput, None, itkImageToImageFilterID2VIUC2)
itkImageToImageFilterID2VIUC2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2VIUC2_SetCoordinateTolerance, None, itkImageToImageFilterID2VIUC2)
itkImageToImageFilterID2VIUC2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2VIUC2_GetCoordinateTolerance, None, itkImageToImageFilterID2VIUC2)
itkImageToImageFilterID2VIUC2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2VIUC2_SetDirectionTolerance, None, itkImageToImageFilterID2VIUC2)
itkImageToImageFilterID2VIUC2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2VIUC2_GetDirectionTolerance, None, itkImageToImageFilterID2VIUC2)
itkImageToImageFilterID2VIUC2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterID2VIUC2_swigregister
itkImageToImageFilterID2VIUC2_swigregister(itkImageToImageFilterID2VIUC2)

def itkImageToImageFilterID2VIUC2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterID2VIUC2 *":
    """itkImageToImageFilterID2VIUC2_cast(itkLightObject obj) -> itkImageToImageFilterID2VIUC2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterID2VIUC2_cast(obj)

class itkImageToImageFilterID2VIUS2(itkImageSourcePython.itkImageSourceVIUS2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterID2VIUS2 self, itkImageD2 image)
        SetInput(itkImageToImageFilterID2VIUS2 self, unsigned int arg0, itkImageD2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2VIUS2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageD2 const *":
        """
        GetInput(itkImageToImageFilterID2VIUS2 self) -> itkImageD2
        GetInput(itkImageToImageFilterID2VIUS2 self, unsigned int idx) -> itkImageD2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2VIUS2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageD2') -> "void":
        """
        PushBackInput(itkImageToImageFilterID2VIUS2 self, itkImageD2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2VIUS2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterID2VIUS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2VIUS2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageD2') -> "void":
        """PushFrontInput(itkImageToImageFilterID2VIUS2 self, itkImageD2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2VIUS2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterID2VIUS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2VIUS2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterID2VIUS2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2VIUS2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterID2VIUS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2VIUS2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterID2VIUS2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2VIUS2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterID2VIUS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2VIUS2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterID2VIUS2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterID2VIUS2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterID2VIUS2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID2VIUS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterID2VIUS2

        Create a new object of the class itkImageToImageFilterID2VIUS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterID2VIUS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterID2VIUS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterID2VIUS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterID2VIUS2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2VIUS2_SetInput, None, itkImageToImageFilterID2VIUS2)
itkImageToImageFilterID2VIUS2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2VIUS2_GetInput, None, itkImageToImageFilterID2VIUS2)
itkImageToImageFilterID2VIUS2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2VIUS2_PushBackInput, None, itkImageToImageFilterID2VIUS2)
itkImageToImageFilterID2VIUS2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2VIUS2_PopBackInput, None, itkImageToImageFilterID2VIUS2)
itkImageToImageFilterID2VIUS2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2VIUS2_PushFrontInput, None, itkImageToImageFilterID2VIUS2)
itkImageToImageFilterID2VIUS2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2VIUS2_PopFrontInput, None, itkImageToImageFilterID2VIUS2)
itkImageToImageFilterID2VIUS2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2VIUS2_SetCoordinateTolerance, None, itkImageToImageFilterID2VIUS2)
itkImageToImageFilterID2VIUS2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2VIUS2_GetCoordinateTolerance, None, itkImageToImageFilterID2VIUS2)
itkImageToImageFilterID2VIUS2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2VIUS2_SetDirectionTolerance, None, itkImageToImageFilterID2VIUS2)
itkImageToImageFilterID2VIUS2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID2VIUS2_GetDirectionTolerance, None, itkImageToImageFilterID2VIUS2)
itkImageToImageFilterID2VIUS2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterID2VIUS2_swigregister
itkImageToImageFilterID2VIUS2_swigregister(itkImageToImageFilterID2VIUS2)

def itkImageToImageFilterID2VIUS2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterID2VIUS2 *":
    """itkImageToImageFilterID2VIUS2_cast(itkLightObject obj) -> itkImageToImageFilterID2VIUS2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterID2VIUS2_cast(obj)

class itkImageToImageFilterID3ICF3(itkImageSourcePython.itkImageSourceICF3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterID3ICF3 self, itkImageD3 image)
        SetInput(itkImageToImageFilterID3ICF3 self, unsigned int arg0, itkImageD3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ICF3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageD3 const *":
        """
        GetInput(itkImageToImageFilterID3ICF3 self) -> itkImageD3
        GetInput(itkImageToImageFilterID3ICF3 self, unsigned int idx) -> itkImageD3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ICF3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageD3') -> "void":
        """
        PushBackInput(itkImageToImageFilterID3ICF3 self, itkImageD3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ICF3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterID3ICF3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ICF3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageD3') -> "void":
        """PushFrontInput(itkImageToImageFilterID3ICF3 self, itkImageD3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ICF3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterID3ICF3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ICF3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterID3ICF3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ICF3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterID3ICF3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ICF3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterID3ICF3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ICF3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterID3ICF3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ICF3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterID3ICF3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterID3ICF3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterID3ICF3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ICF3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterID3ICF3

        Create a new object of the class itkImageToImageFilterID3ICF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterID3ICF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterID3ICF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterID3ICF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterID3ICF3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ICF3_SetInput, None, itkImageToImageFilterID3ICF3)
itkImageToImageFilterID3ICF3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ICF3_GetInput, None, itkImageToImageFilterID3ICF3)
itkImageToImageFilterID3ICF3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ICF3_PushBackInput, None, itkImageToImageFilterID3ICF3)
itkImageToImageFilterID3ICF3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ICF3_PopBackInput, None, itkImageToImageFilterID3ICF3)
itkImageToImageFilterID3ICF3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ICF3_PushFrontInput, None, itkImageToImageFilterID3ICF3)
itkImageToImageFilterID3ICF3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ICF3_PopFrontInput, None, itkImageToImageFilterID3ICF3)
itkImageToImageFilterID3ICF3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ICF3_SetCoordinateTolerance, None, itkImageToImageFilterID3ICF3)
itkImageToImageFilterID3ICF3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ICF3_GetCoordinateTolerance, None, itkImageToImageFilterID3ICF3)
itkImageToImageFilterID3ICF3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ICF3_SetDirectionTolerance, None, itkImageToImageFilterID3ICF3)
itkImageToImageFilterID3ICF3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ICF3_GetDirectionTolerance, None, itkImageToImageFilterID3ICF3)
itkImageToImageFilterID3ICF3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterID3ICF3_swigregister
itkImageToImageFilterID3ICF3_swigregister(itkImageToImageFilterID3ICF3)

def itkImageToImageFilterID3ICF3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterID3ICF3 *":
    """itkImageToImageFilterID3ICF3_cast(itkLightObject obj) -> itkImageToImageFilterID3ICF3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterID3ICF3_cast(obj)

class itkImageToImageFilterID3ICVD33(itkImageSourcePython.itkImageSourceICVD33):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterID3ICVD33 self, itkImageD3 image)
        SetInput(itkImageToImageFilterID3ICVD33 self, unsigned int arg0, itkImageD3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ICVD33_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageD3 const *":
        """
        GetInput(itkImageToImageFilterID3ICVD33 self) -> itkImageD3
        GetInput(itkImageToImageFilterID3ICVD33 self, unsigned int idx) -> itkImageD3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ICVD33_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageD3') -> "void":
        """
        PushBackInput(itkImageToImageFilterID3ICVD33 self, itkImageD3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ICVD33_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterID3ICVD33 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ICVD33_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageD3') -> "void":
        """PushFrontInput(itkImageToImageFilterID3ICVD33 self, itkImageD3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ICVD33_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterID3ICVD33 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ICVD33_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterID3ICVD33 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ICVD33_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterID3ICVD33 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ICVD33_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterID3ICVD33 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ICVD33_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterID3ICVD33 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ICVD33_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterID3ICVD33

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterID3ICVD33 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterID3ICVD33"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ICVD33_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterID3ICVD33

        Create a new object of the class itkImageToImageFilterID3ICVD33 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterID3ICVD33.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterID3ICVD33.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterID3ICVD33.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterID3ICVD33.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ICVD33_SetInput, None, itkImageToImageFilterID3ICVD33)
itkImageToImageFilterID3ICVD33.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ICVD33_GetInput, None, itkImageToImageFilterID3ICVD33)
itkImageToImageFilterID3ICVD33.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ICVD33_PushBackInput, None, itkImageToImageFilterID3ICVD33)
itkImageToImageFilterID3ICVD33.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ICVD33_PopBackInput, None, itkImageToImageFilterID3ICVD33)
itkImageToImageFilterID3ICVD33.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ICVD33_PushFrontInput, None, itkImageToImageFilterID3ICVD33)
itkImageToImageFilterID3ICVD33.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ICVD33_PopFrontInput, None, itkImageToImageFilterID3ICVD33)
itkImageToImageFilterID3ICVD33.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ICVD33_SetCoordinateTolerance, None, itkImageToImageFilterID3ICVD33)
itkImageToImageFilterID3ICVD33.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ICVD33_GetCoordinateTolerance, None, itkImageToImageFilterID3ICVD33)
itkImageToImageFilterID3ICVD33.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ICVD33_SetDirectionTolerance, None, itkImageToImageFilterID3ICVD33)
itkImageToImageFilterID3ICVD33.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ICVD33_GetDirectionTolerance, None, itkImageToImageFilterID3ICVD33)
itkImageToImageFilterID3ICVD33_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterID3ICVD33_swigregister
itkImageToImageFilterID3ICVD33_swigregister(itkImageToImageFilterID3ICVD33)

def itkImageToImageFilterID3ICVD33_cast(obj: 'itkLightObject') -> "itkImageToImageFilterID3ICVD33 *":
    """itkImageToImageFilterID3ICVD33_cast(itkLightObject obj) -> itkImageToImageFilterID3ICVD33"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterID3ICVD33_cast(obj)

class itkImageToImageFilterID3ICVF23(itkImageSourcePython.itkImageSourceICVF23):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterID3ICVF23 self, itkImageD3 image)
        SetInput(itkImageToImageFilterID3ICVF23 self, unsigned int arg0, itkImageD3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF23_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageD3 const *":
        """
        GetInput(itkImageToImageFilterID3ICVF23 self) -> itkImageD3
        GetInput(itkImageToImageFilterID3ICVF23 self, unsigned int idx) -> itkImageD3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF23_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageD3') -> "void":
        """
        PushBackInput(itkImageToImageFilterID3ICVF23 self, itkImageD3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF23_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterID3ICVF23 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF23_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageD3') -> "void":
        """PushFrontInput(itkImageToImageFilterID3ICVF23 self, itkImageD3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF23_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterID3ICVF23 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF23_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterID3ICVF23 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF23_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterID3ICVF23 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF23_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterID3ICVF23 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF23_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterID3ICVF23 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF23_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterID3ICVF23

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterID3ICVF23 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterID3ICVF23"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF23_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterID3ICVF23

        Create a new object of the class itkImageToImageFilterID3ICVF23 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterID3ICVF23.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterID3ICVF23.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterID3ICVF23.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterID3ICVF23.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF23_SetInput, None, itkImageToImageFilterID3ICVF23)
itkImageToImageFilterID3ICVF23.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF23_GetInput, None, itkImageToImageFilterID3ICVF23)
itkImageToImageFilterID3ICVF23.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF23_PushBackInput, None, itkImageToImageFilterID3ICVF23)
itkImageToImageFilterID3ICVF23.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF23_PopBackInput, None, itkImageToImageFilterID3ICVF23)
itkImageToImageFilterID3ICVF23.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF23_PushFrontInput, None, itkImageToImageFilterID3ICVF23)
itkImageToImageFilterID3ICVF23.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF23_PopFrontInput, None, itkImageToImageFilterID3ICVF23)
itkImageToImageFilterID3ICVF23.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF23_SetCoordinateTolerance, None, itkImageToImageFilterID3ICVF23)
itkImageToImageFilterID3ICVF23.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF23_GetCoordinateTolerance, None, itkImageToImageFilterID3ICVF23)
itkImageToImageFilterID3ICVF23.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF23_SetDirectionTolerance, None, itkImageToImageFilterID3ICVF23)
itkImageToImageFilterID3ICVF23.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF23_GetDirectionTolerance, None, itkImageToImageFilterID3ICVF23)
itkImageToImageFilterID3ICVF23_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF23_swigregister
itkImageToImageFilterID3ICVF23_swigregister(itkImageToImageFilterID3ICVF23)

def itkImageToImageFilterID3ICVF23_cast(obj: 'itkLightObject') -> "itkImageToImageFilterID3ICVF23 *":
    """itkImageToImageFilterID3ICVF23_cast(itkLightObject obj) -> itkImageToImageFilterID3ICVF23"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF23_cast(obj)

class itkImageToImageFilterID3ICVF33(itkImageSourcePython.itkImageSourceICVF33):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterID3ICVF33 self, itkImageD3 image)
        SetInput(itkImageToImageFilterID3ICVF33 self, unsigned int arg0, itkImageD3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF33_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageD3 const *":
        """
        GetInput(itkImageToImageFilterID3ICVF33 self) -> itkImageD3
        GetInput(itkImageToImageFilterID3ICVF33 self, unsigned int idx) -> itkImageD3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF33_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageD3') -> "void":
        """
        PushBackInput(itkImageToImageFilterID3ICVF33 self, itkImageD3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF33_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterID3ICVF33 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF33_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageD3') -> "void":
        """PushFrontInput(itkImageToImageFilterID3ICVF33 self, itkImageD3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF33_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterID3ICVF33 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF33_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterID3ICVF33 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF33_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterID3ICVF33 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF33_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterID3ICVF33 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF33_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterID3ICVF33 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF33_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterID3ICVF33

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterID3ICVF33 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterID3ICVF33"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF33_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterID3ICVF33

        Create a new object of the class itkImageToImageFilterID3ICVF33 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterID3ICVF33.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterID3ICVF33.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterID3ICVF33.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterID3ICVF33.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF33_SetInput, None, itkImageToImageFilterID3ICVF33)
itkImageToImageFilterID3ICVF33.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF33_GetInput, None, itkImageToImageFilterID3ICVF33)
itkImageToImageFilterID3ICVF33.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF33_PushBackInput, None, itkImageToImageFilterID3ICVF33)
itkImageToImageFilterID3ICVF33.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF33_PopBackInput, None, itkImageToImageFilterID3ICVF33)
itkImageToImageFilterID3ICVF33.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF33_PushFrontInput, None, itkImageToImageFilterID3ICVF33)
itkImageToImageFilterID3ICVF33.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF33_PopFrontInput, None, itkImageToImageFilterID3ICVF33)
itkImageToImageFilterID3ICVF33.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF33_SetCoordinateTolerance, None, itkImageToImageFilterID3ICVF33)
itkImageToImageFilterID3ICVF33.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF33_GetCoordinateTolerance, None, itkImageToImageFilterID3ICVF33)
itkImageToImageFilterID3ICVF33.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF33_SetDirectionTolerance, None, itkImageToImageFilterID3ICVF33)
itkImageToImageFilterID3ICVF33.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF33_GetDirectionTolerance, None, itkImageToImageFilterID3ICVF33)
itkImageToImageFilterID3ICVF33_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF33_swigregister
itkImageToImageFilterID3ICVF33_swigregister(itkImageToImageFilterID3ICVF33)

def itkImageToImageFilterID3ICVF33_cast(obj: 'itkLightObject') -> "itkImageToImageFilterID3ICVF33 *":
    """itkImageToImageFilterID3ICVF33_cast(itkLightObject obj) -> itkImageToImageFilterID3ICVF33"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF33_cast(obj)

class itkImageToImageFilterID3ICVF43(itkImageSourcePython.itkImageSourceICVF43):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterID3ICVF43 self, itkImageD3 image)
        SetInput(itkImageToImageFilterID3ICVF43 self, unsigned int arg0, itkImageD3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF43_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageD3 const *":
        """
        GetInput(itkImageToImageFilterID3ICVF43 self) -> itkImageD3
        GetInput(itkImageToImageFilterID3ICVF43 self, unsigned int idx) -> itkImageD3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF43_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageD3') -> "void":
        """
        PushBackInput(itkImageToImageFilterID3ICVF43 self, itkImageD3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF43_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterID3ICVF43 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF43_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageD3') -> "void":
        """PushFrontInput(itkImageToImageFilterID3ICVF43 self, itkImageD3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF43_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterID3ICVF43 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF43_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterID3ICVF43 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF43_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterID3ICVF43 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF43_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterID3ICVF43 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF43_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterID3ICVF43 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF43_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterID3ICVF43

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterID3ICVF43 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterID3ICVF43"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF43_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterID3ICVF43

        Create a new object of the class itkImageToImageFilterID3ICVF43 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterID3ICVF43.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterID3ICVF43.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterID3ICVF43.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterID3ICVF43.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF43_SetInput, None, itkImageToImageFilterID3ICVF43)
itkImageToImageFilterID3ICVF43.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF43_GetInput, None, itkImageToImageFilterID3ICVF43)
itkImageToImageFilterID3ICVF43.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF43_PushBackInput, None, itkImageToImageFilterID3ICVF43)
itkImageToImageFilterID3ICVF43.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF43_PopBackInput, None, itkImageToImageFilterID3ICVF43)
itkImageToImageFilterID3ICVF43.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF43_PushFrontInput, None, itkImageToImageFilterID3ICVF43)
itkImageToImageFilterID3ICVF43.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF43_PopFrontInput, None, itkImageToImageFilterID3ICVF43)
itkImageToImageFilterID3ICVF43.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF43_SetCoordinateTolerance, None, itkImageToImageFilterID3ICVF43)
itkImageToImageFilterID3ICVF43.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF43_GetCoordinateTolerance, None, itkImageToImageFilterID3ICVF43)
itkImageToImageFilterID3ICVF43.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF43_SetDirectionTolerance, None, itkImageToImageFilterID3ICVF43)
itkImageToImageFilterID3ICVF43.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF43_GetDirectionTolerance, None, itkImageToImageFilterID3ICVF43)
itkImageToImageFilterID3ICVF43_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF43_swigregister
itkImageToImageFilterID3ICVF43_swigregister(itkImageToImageFilterID3ICVF43)

def itkImageToImageFilterID3ICVF43_cast(obj: 'itkLightObject') -> "itkImageToImageFilterID3ICVF43 *":
    """itkImageToImageFilterID3ICVF43_cast(itkLightObject obj) -> itkImageToImageFilterID3ICVF43"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterID3ICVF43_cast(obj)

class itkImageToImageFilterID3ID2(itkImageSourcePython.itkImageSourceID2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterID3ID2 self, itkImageD3 image)
        SetInput(itkImageToImageFilterID3ID2 self, unsigned int arg0, itkImageD3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ID2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageD3 const *":
        """
        GetInput(itkImageToImageFilterID3ID2 self) -> itkImageD3
        GetInput(itkImageToImageFilterID3ID2 self, unsigned int idx) -> itkImageD3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ID2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageD3') -> "void":
        """
        PushBackInput(itkImageToImageFilterID3ID2 self, itkImageD3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ID2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterID3ID2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ID2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageD3') -> "void":
        """PushFrontInput(itkImageToImageFilterID3ID2 self, itkImageD3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ID2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterID3ID2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ID2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterID3ID2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ID2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterID3ID2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ID2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterID3ID2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ID2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterID3ID2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ID2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterID3ID2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterID3ID2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterID3ID2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ID2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterID3ID2

        Create a new object of the class itkImageToImageFilterID3ID2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterID3ID2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterID3ID2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterID3ID2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterID3ID2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ID2_SetInput, None, itkImageToImageFilterID3ID2)
itkImageToImageFilterID3ID2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ID2_GetInput, None, itkImageToImageFilterID3ID2)
itkImageToImageFilterID3ID2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ID2_PushBackInput, None, itkImageToImageFilterID3ID2)
itkImageToImageFilterID3ID2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ID2_PopBackInput, None, itkImageToImageFilterID3ID2)
itkImageToImageFilterID3ID2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ID2_PushFrontInput, None, itkImageToImageFilterID3ID2)
itkImageToImageFilterID3ID2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ID2_PopFrontInput, None, itkImageToImageFilterID3ID2)
itkImageToImageFilterID3ID2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ID2_SetCoordinateTolerance, None, itkImageToImageFilterID3ID2)
itkImageToImageFilterID3ID2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ID2_GetCoordinateTolerance, None, itkImageToImageFilterID3ID2)
itkImageToImageFilterID3ID2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ID2_SetDirectionTolerance, None, itkImageToImageFilterID3ID2)
itkImageToImageFilterID3ID2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ID2_GetDirectionTolerance, None, itkImageToImageFilterID3ID2)
itkImageToImageFilterID3ID2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterID3ID2_swigregister
itkImageToImageFilterID3ID2_swigregister(itkImageToImageFilterID3ID2)

def itkImageToImageFilterID3ID2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterID3ID2 *":
    """itkImageToImageFilterID3ID2_cast(itkLightObject obj) -> itkImageToImageFilterID3ID2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterID3ID2_cast(obj)

class itkImageToImageFilterID3IRGBAUC3(itkImageSourcePython.itkImageSourceIRGBAUC3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterID3IRGBAUC3 self, itkImageD3 image)
        SetInput(itkImageToImageFilterID3IRGBAUC3 self, unsigned int arg0, itkImageD3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3IRGBAUC3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageD3 const *":
        """
        GetInput(itkImageToImageFilterID3IRGBAUC3 self) -> itkImageD3
        GetInput(itkImageToImageFilterID3IRGBAUC3 self, unsigned int idx) -> itkImageD3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3IRGBAUC3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageD3') -> "void":
        """
        PushBackInput(itkImageToImageFilterID3IRGBAUC3 self, itkImageD3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3IRGBAUC3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterID3IRGBAUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3IRGBAUC3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageD3') -> "void":
        """PushFrontInput(itkImageToImageFilterID3IRGBAUC3 self, itkImageD3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3IRGBAUC3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterID3IRGBAUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3IRGBAUC3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterID3IRGBAUC3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3IRGBAUC3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterID3IRGBAUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3IRGBAUC3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterID3IRGBAUC3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3IRGBAUC3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterID3IRGBAUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3IRGBAUC3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterID3IRGBAUC3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterID3IRGBAUC3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterID3IRGBAUC3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3IRGBAUC3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterID3IRGBAUC3

        Create a new object of the class itkImageToImageFilterID3IRGBAUC3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterID3IRGBAUC3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterID3IRGBAUC3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterID3IRGBAUC3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterID3IRGBAUC3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3IRGBAUC3_SetInput, None, itkImageToImageFilterID3IRGBAUC3)
itkImageToImageFilterID3IRGBAUC3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3IRGBAUC3_GetInput, None, itkImageToImageFilterID3IRGBAUC3)
itkImageToImageFilterID3IRGBAUC3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3IRGBAUC3_PushBackInput, None, itkImageToImageFilterID3IRGBAUC3)
itkImageToImageFilterID3IRGBAUC3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3IRGBAUC3_PopBackInput, None, itkImageToImageFilterID3IRGBAUC3)
itkImageToImageFilterID3IRGBAUC3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3IRGBAUC3_PushFrontInput, None, itkImageToImageFilterID3IRGBAUC3)
itkImageToImageFilterID3IRGBAUC3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3IRGBAUC3_PopFrontInput, None, itkImageToImageFilterID3IRGBAUC3)
itkImageToImageFilterID3IRGBAUC3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3IRGBAUC3_SetCoordinateTolerance, None, itkImageToImageFilterID3IRGBAUC3)
itkImageToImageFilterID3IRGBAUC3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3IRGBAUC3_GetCoordinateTolerance, None, itkImageToImageFilterID3IRGBAUC3)
itkImageToImageFilterID3IRGBAUC3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3IRGBAUC3_SetDirectionTolerance, None, itkImageToImageFilterID3IRGBAUC3)
itkImageToImageFilterID3IRGBAUC3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3IRGBAUC3_GetDirectionTolerance, None, itkImageToImageFilterID3IRGBAUC3)
itkImageToImageFilterID3IRGBAUC3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterID3IRGBAUC3_swigregister
itkImageToImageFilterID3IRGBAUC3_swigregister(itkImageToImageFilterID3IRGBAUC3)

def itkImageToImageFilterID3IRGBAUC3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterID3IRGBAUC3 *":
    """itkImageToImageFilterID3IRGBAUC3_cast(itkLightObject obj) -> itkImageToImageFilterID3IRGBAUC3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterID3IRGBAUC3_cast(obj)

class itkImageToImageFilterID3IRGBUC3(itkImageSourcePython.itkImageSourceIRGBUC3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterID3IRGBUC3 self, itkImageD3 image)
        SetInput(itkImageToImageFilterID3IRGBUC3 self, unsigned int arg0, itkImageD3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3IRGBUC3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageD3 const *":
        """
        GetInput(itkImageToImageFilterID3IRGBUC3 self) -> itkImageD3
        GetInput(itkImageToImageFilterID3IRGBUC3 self, unsigned int idx) -> itkImageD3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3IRGBUC3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageD3') -> "void":
        """
        PushBackInput(itkImageToImageFilterID3IRGBUC3 self, itkImageD3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3IRGBUC3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterID3IRGBUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3IRGBUC3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageD3') -> "void":
        """PushFrontInput(itkImageToImageFilterID3IRGBUC3 self, itkImageD3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3IRGBUC3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterID3IRGBUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3IRGBUC3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterID3IRGBUC3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3IRGBUC3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterID3IRGBUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3IRGBUC3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterID3IRGBUC3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3IRGBUC3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterID3IRGBUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3IRGBUC3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterID3IRGBUC3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterID3IRGBUC3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterID3IRGBUC3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3IRGBUC3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterID3IRGBUC3

        Create a new object of the class itkImageToImageFilterID3IRGBUC3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterID3IRGBUC3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterID3IRGBUC3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterID3IRGBUC3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterID3IRGBUC3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3IRGBUC3_SetInput, None, itkImageToImageFilterID3IRGBUC3)
itkImageToImageFilterID3IRGBUC3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3IRGBUC3_GetInput, None, itkImageToImageFilterID3IRGBUC3)
itkImageToImageFilterID3IRGBUC3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3IRGBUC3_PushBackInput, None, itkImageToImageFilterID3IRGBUC3)
itkImageToImageFilterID3IRGBUC3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3IRGBUC3_PopBackInput, None, itkImageToImageFilterID3IRGBUC3)
itkImageToImageFilterID3IRGBUC3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3IRGBUC3_PushFrontInput, None, itkImageToImageFilterID3IRGBUC3)
itkImageToImageFilterID3IRGBUC3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3IRGBUC3_PopFrontInput, None, itkImageToImageFilterID3IRGBUC3)
itkImageToImageFilterID3IRGBUC3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3IRGBUC3_SetCoordinateTolerance, None, itkImageToImageFilterID3IRGBUC3)
itkImageToImageFilterID3IRGBUC3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3IRGBUC3_GetCoordinateTolerance, None, itkImageToImageFilterID3IRGBUC3)
itkImageToImageFilterID3IRGBUC3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3IRGBUC3_SetDirectionTolerance, None, itkImageToImageFilterID3IRGBUC3)
itkImageToImageFilterID3IRGBUC3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3IRGBUC3_GetDirectionTolerance, None, itkImageToImageFilterID3IRGBUC3)
itkImageToImageFilterID3IRGBUC3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterID3IRGBUC3_swigregister
itkImageToImageFilterID3IRGBUC3_swigregister(itkImageToImageFilterID3IRGBUC3)

def itkImageToImageFilterID3IRGBUC3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterID3IRGBUC3 *":
    """itkImageToImageFilterID3IRGBUC3_cast(itkLightObject obj) -> itkImageToImageFilterID3IRGBUC3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterID3IRGBUC3_cast(obj)

class itkImageToImageFilterID3ISSRTD33(itkImageSourcePython.itkImageSourceISSRTD33):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterID3ISSRTD33 self, itkImageD3 image)
        SetInput(itkImageToImageFilterID3ISSRTD33 self, unsigned int arg0, itkImageD3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ISSRTD33_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageD3 const *":
        """
        GetInput(itkImageToImageFilterID3ISSRTD33 self) -> itkImageD3
        GetInput(itkImageToImageFilterID3ISSRTD33 self, unsigned int idx) -> itkImageD3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ISSRTD33_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageD3') -> "void":
        """
        PushBackInput(itkImageToImageFilterID3ISSRTD33 self, itkImageD3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ISSRTD33_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterID3ISSRTD33 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ISSRTD33_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageD3') -> "void":
        """PushFrontInput(itkImageToImageFilterID3ISSRTD33 self, itkImageD3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ISSRTD33_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterID3ISSRTD33 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ISSRTD33_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterID3ISSRTD33 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ISSRTD33_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterID3ISSRTD33 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ISSRTD33_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterID3ISSRTD33 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ISSRTD33_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterID3ISSRTD33 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ISSRTD33_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterID3ISSRTD33

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterID3ISSRTD33 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterID3ISSRTD33"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3ISSRTD33_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterID3ISSRTD33

        Create a new object of the class itkImageToImageFilterID3ISSRTD33 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterID3ISSRTD33.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterID3ISSRTD33.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterID3ISSRTD33.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterID3ISSRTD33.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ISSRTD33_SetInput, None, itkImageToImageFilterID3ISSRTD33)
itkImageToImageFilterID3ISSRTD33.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ISSRTD33_GetInput, None, itkImageToImageFilterID3ISSRTD33)
itkImageToImageFilterID3ISSRTD33.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ISSRTD33_PushBackInput, None, itkImageToImageFilterID3ISSRTD33)
itkImageToImageFilterID3ISSRTD33.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ISSRTD33_PopBackInput, None, itkImageToImageFilterID3ISSRTD33)
itkImageToImageFilterID3ISSRTD33.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ISSRTD33_PushFrontInput, None, itkImageToImageFilterID3ISSRTD33)
itkImageToImageFilterID3ISSRTD33.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ISSRTD33_PopFrontInput, None, itkImageToImageFilterID3ISSRTD33)
itkImageToImageFilterID3ISSRTD33.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ISSRTD33_SetCoordinateTolerance, None, itkImageToImageFilterID3ISSRTD33)
itkImageToImageFilterID3ISSRTD33.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ISSRTD33_GetCoordinateTolerance, None, itkImageToImageFilterID3ISSRTD33)
itkImageToImageFilterID3ISSRTD33.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ISSRTD33_SetDirectionTolerance, None, itkImageToImageFilterID3ISSRTD33)
itkImageToImageFilterID3ISSRTD33.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3ISSRTD33_GetDirectionTolerance, None, itkImageToImageFilterID3ISSRTD33)
itkImageToImageFilterID3ISSRTD33_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterID3ISSRTD33_swigregister
itkImageToImageFilterID3ISSRTD33_swigregister(itkImageToImageFilterID3ISSRTD33)

def itkImageToImageFilterID3ISSRTD33_cast(obj: 'itkLightObject') -> "itkImageToImageFilterID3ISSRTD33 *":
    """itkImageToImageFilterID3ISSRTD33_cast(itkLightObject obj) -> itkImageToImageFilterID3ISSRTD33"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterID3ISSRTD33_cast(obj)

class itkImageToImageFilterID3IVF23(itkImageSourcePython.itkImageSourceIVF23):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterID3IVF23 self, itkImageD3 image)
        SetInput(itkImageToImageFilterID3IVF23 self, unsigned int arg0, itkImageD3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3IVF23_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageD3 const *":
        """
        GetInput(itkImageToImageFilterID3IVF23 self) -> itkImageD3
        GetInput(itkImageToImageFilterID3IVF23 self, unsigned int idx) -> itkImageD3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3IVF23_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageD3') -> "void":
        """
        PushBackInput(itkImageToImageFilterID3IVF23 self, itkImageD3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3IVF23_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterID3IVF23 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3IVF23_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageD3') -> "void":
        """PushFrontInput(itkImageToImageFilterID3IVF23 self, itkImageD3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3IVF23_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterID3IVF23 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3IVF23_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterID3IVF23 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3IVF23_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterID3IVF23 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3IVF23_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterID3IVF23 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3IVF23_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterID3IVF23 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3IVF23_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterID3IVF23

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterID3IVF23 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterID3IVF23"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3IVF23_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterID3IVF23

        Create a new object of the class itkImageToImageFilterID3IVF23 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterID3IVF23.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterID3IVF23.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterID3IVF23.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterID3IVF23.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3IVF23_SetInput, None, itkImageToImageFilterID3IVF23)
itkImageToImageFilterID3IVF23.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3IVF23_GetInput, None, itkImageToImageFilterID3IVF23)
itkImageToImageFilterID3IVF23.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3IVF23_PushBackInput, None, itkImageToImageFilterID3IVF23)
itkImageToImageFilterID3IVF23.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3IVF23_PopBackInput, None, itkImageToImageFilterID3IVF23)
itkImageToImageFilterID3IVF23.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3IVF23_PushFrontInput, None, itkImageToImageFilterID3IVF23)
itkImageToImageFilterID3IVF23.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3IVF23_PopFrontInput, None, itkImageToImageFilterID3IVF23)
itkImageToImageFilterID3IVF23.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3IVF23_SetCoordinateTolerance, None, itkImageToImageFilterID3IVF23)
itkImageToImageFilterID3IVF23.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3IVF23_GetCoordinateTolerance, None, itkImageToImageFilterID3IVF23)
itkImageToImageFilterID3IVF23.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3IVF23_SetDirectionTolerance, None, itkImageToImageFilterID3IVF23)
itkImageToImageFilterID3IVF23.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3IVF23_GetDirectionTolerance, None, itkImageToImageFilterID3IVF23)
itkImageToImageFilterID3IVF23_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterID3IVF23_swigregister
itkImageToImageFilterID3IVF23_swigregister(itkImageToImageFilterID3IVF23)

def itkImageToImageFilterID3IVF23_cast(obj: 'itkLightObject') -> "itkImageToImageFilterID3IVF23 *":
    """itkImageToImageFilterID3IVF23_cast(itkLightObject obj) -> itkImageToImageFilterID3IVF23"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterID3IVF23_cast(obj)

class itkImageToImageFilterID3IVF33(itkImageSourcePython.itkImageSourceIVF33):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterID3IVF33 self, itkImageD3 image)
        SetInput(itkImageToImageFilterID3IVF33 self, unsigned int arg0, itkImageD3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3IVF33_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageD3 const *":
        """
        GetInput(itkImageToImageFilterID3IVF33 self) -> itkImageD3
        GetInput(itkImageToImageFilterID3IVF33 self, unsigned int idx) -> itkImageD3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3IVF33_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageD3') -> "void":
        """
        PushBackInput(itkImageToImageFilterID3IVF33 self, itkImageD3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3IVF33_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterID3IVF33 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3IVF33_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageD3') -> "void":
        """PushFrontInput(itkImageToImageFilterID3IVF33 self, itkImageD3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3IVF33_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterID3IVF33 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3IVF33_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterID3IVF33 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3IVF33_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterID3IVF33 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3IVF33_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterID3IVF33 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3IVF33_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterID3IVF33 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3IVF33_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterID3IVF33

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterID3IVF33 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterID3IVF33"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3IVF33_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterID3IVF33

        Create a new object of the class itkImageToImageFilterID3IVF33 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterID3IVF33.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterID3IVF33.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterID3IVF33.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterID3IVF33.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3IVF33_SetInput, None, itkImageToImageFilterID3IVF33)
itkImageToImageFilterID3IVF33.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3IVF33_GetInput, None, itkImageToImageFilterID3IVF33)
itkImageToImageFilterID3IVF33.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3IVF33_PushBackInput, None, itkImageToImageFilterID3IVF33)
itkImageToImageFilterID3IVF33.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3IVF33_PopBackInput, None, itkImageToImageFilterID3IVF33)
itkImageToImageFilterID3IVF33.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3IVF33_PushFrontInput, None, itkImageToImageFilterID3IVF33)
itkImageToImageFilterID3IVF33.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3IVF33_PopFrontInput, None, itkImageToImageFilterID3IVF33)
itkImageToImageFilterID3IVF33.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3IVF33_SetCoordinateTolerance, None, itkImageToImageFilterID3IVF33)
itkImageToImageFilterID3IVF33.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3IVF33_GetCoordinateTolerance, None, itkImageToImageFilterID3IVF33)
itkImageToImageFilterID3IVF33.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3IVF33_SetDirectionTolerance, None, itkImageToImageFilterID3IVF33)
itkImageToImageFilterID3IVF33.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3IVF33_GetDirectionTolerance, None, itkImageToImageFilterID3IVF33)
itkImageToImageFilterID3IVF33_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterID3IVF33_swigregister
itkImageToImageFilterID3IVF33_swigregister(itkImageToImageFilterID3IVF33)

def itkImageToImageFilterID3IVF33_cast(obj: 'itkLightObject') -> "itkImageToImageFilterID3IVF33 *":
    """itkImageToImageFilterID3IVF33_cast(itkLightObject obj) -> itkImageToImageFilterID3IVF33"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterID3IVF33_cast(obj)

class itkImageToImageFilterID3IVF43(itkImageSourcePython.itkImageSourceIVF43):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterID3IVF43 self, itkImageD3 image)
        SetInput(itkImageToImageFilterID3IVF43 self, unsigned int arg0, itkImageD3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3IVF43_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageD3 const *":
        """
        GetInput(itkImageToImageFilterID3IVF43 self) -> itkImageD3
        GetInput(itkImageToImageFilterID3IVF43 self, unsigned int idx) -> itkImageD3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3IVF43_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageD3') -> "void":
        """
        PushBackInput(itkImageToImageFilterID3IVF43 self, itkImageD3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3IVF43_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterID3IVF43 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3IVF43_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageD3') -> "void":
        """PushFrontInput(itkImageToImageFilterID3IVF43 self, itkImageD3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3IVF43_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterID3IVF43 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3IVF43_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterID3IVF43 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3IVF43_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterID3IVF43 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3IVF43_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterID3IVF43 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3IVF43_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterID3IVF43 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3IVF43_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterID3IVF43

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterID3IVF43 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterID3IVF43"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3IVF43_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterID3IVF43

        Create a new object of the class itkImageToImageFilterID3IVF43 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterID3IVF43.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterID3IVF43.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterID3IVF43.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterID3IVF43.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3IVF43_SetInput, None, itkImageToImageFilterID3IVF43)
itkImageToImageFilterID3IVF43.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3IVF43_GetInput, None, itkImageToImageFilterID3IVF43)
itkImageToImageFilterID3IVF43.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3IVF43_PushBackInput, None, itkImageToImageFilterID3IVF43)
itkImageToImageFilterID3IVF43.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3IVF43_PopBackInput, None, itkImageToImageFilterID3IVF43)
itkImageToImageFilterID3IVF43.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3IVF43_PushFrontInput, None, itkImageToImageFilterID3IVF43)
itkImageToImageFilterID3IVF43.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3IVF43_PopFrontInput, None, itkImageToImageFilterID3IVF43)
itkImageToImageFilterID3IVF43.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3IVF43_SetCoordinateTolerance, None, itkImageToImageFilterID3IVF43)
itkImageToImageFilterID3IVF43.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3IVF43_GetCoordinateTolerance, None, itkImageToImageFilterID3IVF43)
itkImageToImageFilterID3IVF43.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3IVF43_SetDirectionTolerance, None, itkImageToImageFilterID3IVF43)
itkImageToImageFilterID3IVF43.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3IVF43_GetDirectionTolerance, None, itkImageToImageFilterID3IVF43)
itkImageToImageFilterID3IVF43_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterID3IVF43_swigregister
itkImageToImageFilterID3IVF43_swigregister(itkImageToImageFilterID3IVF43)

def itkImageToImageFilterID3IVF43_cast(obj: 'itkLightObject') -> "itkImageToImageFilterID3IVF43 *":
    """itkImageToImageFilterID3IVF43_cast(itkLightObject obj) -> itkImageToImageFilterID3IVF43"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterID3IVF43_cast(obj)

class itkImageToImageFilterID3VID3(itkImageSourcePython.itkImageSourceVID3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterID3VID3 self, itkImageD3 image)
        SetInput(itkImageToImageFilterID3VID3 self, unsigned int arg0, itkImageD3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3VID3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageD3 const *":
        """
        GetInput(itkImageToImageFilterID3VID3 self) -> itkImageD3
        GetInput(itkImageToImageFilterID3VID3 self, unsigned int idx) -> itkImageD3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3VID3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageD3') -> "void":
        """
        PushBackInput(itkImageToImageFilterID3VID3 self, itkImageD3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3VID3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterID3VID3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3VID3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageD3') -> "void":
        """PushFrontInput(itkImageToImageFilterID3VID3 self, itkImageD3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3VID3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterID3VID3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3VID3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterID3VID3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3VID3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterID3VID3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3VID3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterID3VID3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3VID3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterID3VID3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3VID3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterID3VID3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterID3VID3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterID3VID3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3VID3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterID3VID3

        Create a new object of the class itkImageToImageFilterID3VID3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterID3VID3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterID3VID3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterID3VID3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterID3VID3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3VID3_SetInput, None, itkImageToImageFilterID3VID3)
itkImageToImageFilterID3VID3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3VID3_GetInput, None, itkImageToImageFilterID3VID3)
itkImageToImageFilterID3VID3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3VID3_PushBackInput, None, itkImageToImageFilterID3VID3)
itkImageToImageFilterID3VID3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3VID3_PopBackInput, None, itkImageToImageFilterID3VID3)
itkImageToImageFilterID3VID3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3VID3_PushFrontInput, None, itkImageToImageFilterID3VID3)
itkImageToImageFilterID3VID3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3VID3_PopFrontInput, None, itkImageToImageFilterID3VID3)
itkImageToImageFilterID3VID3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3VID3_SetCoordinateTolerance, None, itkImageToImageFilterID3VID3)
itkImageToImageFilterID3VID3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3VID3_GetCoordinateTolerance, None, itkImageToImageFilterID3VID3)
itkImageToImageFilterID3VID3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3VID3_SetDirectionTolerance, None, itkImageToImageFilterID3VID3)
itkImageToImageFilterID3VID3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3VID3_GetDirectionTolerance, None, itkImageToImageFilterID3VID3)
itkImageToImageFilterID3VID3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterID3VID3_swigregister
itkImageToImageFilterID3VID3_swigregister(itkImageToImageFilterID3VID3)

def itkImageToImageFilterID3VID3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterID3VID3 *":
    """itkImageToImageFilterID3VID3_cast(itkLightObject obj) -> itkImageToImageFilterID3VID3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterID3VID3_cast(obj)

class itkImageToImageFilterID3VIF3(itkImageSourcePython.itkImageSourceVIF3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterID3VIF3 self, itkImageD3 image)
        SetInput(itkImageToImageFilterID3VIF3 self, unsigned int arg0, itkImageD3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3VIF3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageD3 const *":
        """
        GetInput(itkImageToImageFilterID3VIF3 self) -> itkImageD3
        GetInput(itkImageToImageFilterID3VIF3 self, unsigned int idx) -> itkImageD3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3VIF3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageD3') -> "void":
        """
        PushBackInput(itkImageToImageFilterID3VIF3 self, itkImageD3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3VIF3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterID3VIF3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3VIF3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageD3') -> "void":
        """PushFrontInput(itkImageToImageFilterID3VIF3 self, itkImageD3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3VIF3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterID3VIF3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3VIF3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterID3VIF3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3VIF3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterID3VIF3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3VIF3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterID3VIF3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3VIF3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterID3VIF3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3VIF3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterID3VIF3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterID3VIF3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterID3VIF3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3VIF3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterID3VIF3

        Create a new object of the class itkImageToImageFilterID3VIF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterID3VIF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterID3VIF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterID3VIF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterID3VIF3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3VIF3_SetInput, None, itkImageToImageFilterID3VIF3)
itkImageToImageFilterID3VIF3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3VIF3_GetInput, None, itkImageToImageFilterID3VIF3)
itkImageToImageFilterID3VIF3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3VIF3_PushBackInput, None, itkImageToImageFilterID3VIF3)
itkImageToImageFilterID3VIF3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3VIF3_PopBackInput, None, itkImageToImageFilterID3VIF3)
itkImageToImageFilterID3VIF3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3VIF3_PushFrontInput, None, itkImageToImageFilterID3VIF3)
itkImageToImageFilterID3VIF3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3VIF3_PopFrontInput, None, itkImageToImageFilterID3VIF3)
itkImageToImageFilterID3VIF3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3VIF3_SetCoordinateTolerance, None, itkImageToImageFilterID3VIF3)
itkImageToImageFilterID3VIF3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3VIF3_GetCoordinateTolerance, None, itkImageToImageFilterID3VIF3)
itkImageToImageFilterID3VIF3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3VIF3_SetDirectionTolerance, None, itkImageToImageFilterID3VIF3)
itkImageToImageFilterID3VIF3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3VIF3_GetDirectionTolerance, None, itkImageToImageFilterID3VIF3)
itkImageToImageFilterID3VIF3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterID3VIF3_swigregister
itkImageToImageFilterID3VIF3_swigregister(itkImageToImageFilterID3VIF3)

def itkImageToImageFilterID3VIF3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterID3VIF3 *":
    """itkImageToImageFilterID3VIF3_cast(itkLightObject obj) -> itkImageToImageFilterID3VIF3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterID3VIF3_cast(obj)

class itkImageToImageFilterID3VISS3(itkImageSourcePython.itkImageSourceVISS3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterID3VISS3 self, itkImageD3 image)
        SetInput(itkImageToImageFilterID3VISS3 self, unsigned int arg0, itkImageD3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3VISS3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageD3 const *":
        """
        GetInput(itkImageToImageFilterID3VISS3 self) -> itkImageD3
        GetInput(itkImageToImageFilterID3VISS3 self, unsigned int idx) -> itkImageD3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3VISS3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageD3') -> "void":
        """
        PushBackInput(itkImageToImageFilterID3VISS3 self, itkImageD3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3VISS3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterID3VISS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3VISS3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageD3') -> "void":
        """PushFrontInput(itkImageToImageFilterID3VISS3 self, itkImageD3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3VISS3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterID3VISS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3VISS3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterID3VISS3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3VISS3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterID3VISS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3VISS3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterID3VISS3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3VISS3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterID3VISS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3VISS3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterID3VISS3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterID3VISS3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterID3VISS3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3VISS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterID3VISS3

        Create a new object of the class itkImageToImageFilterID3VISS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterID3VISS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterID3VISS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterID3VISS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterID3VISS3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3VISS3_SetInput, None, itkImageToImageFilterID3VISS3)
itkImageToImageFilterID3VISS3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3VISS3_GetInput, None, itkImageToImageFilterID3VISS3)
itkImageToImageFilterID3VISS3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3VISS3_PushBackInput, None, itkImageToImageFilterID3VISS3)
itkImageToImageFilterID3VISS3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3VISS3_PopBackInput, None, itkImageToImageFilterID3VISS3)
itkImageToImageFilterID3VISS3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3VISS3_PushFrontInput, None, itkImageToImageFilterID3VISS3)
itkImageToImageFilterID3VISS3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3VISS3_PopFrontInput, None, itkImageToImageFilterID3VISS3)
itkImageToImageFilterID3VISS3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3VISS3_SetCoordinateTolerance, None, itkImageToImageFilterID3VISS3)
itkImageToImageFilterID3VISS3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3VISS3_GetCoordinateTolerance, None, itkImageToImageFilterID3VISS3)
itkImageToImageFilterID3VISS3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3VISS3_SetDirectionTolerance, None, itkImageToImageFilterID3VISS3)
itkImageToImageFilterID3VISS3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3VISS3_GetDirectionTolerance, None, itkImageToImageFilterID3VISS3)
itkImageToImageFilterID3VISS3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterID3VISS3_swigregister
itkImageToImageFilterID3VISS3_swigregister(itkImageToImageFilterID3VISS3)

def itkImageToImageFilterID3VISS3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterID3VISS3 *":
    """itkImageToImageFilterID3VISS3_cast(itkLightObject obj) -> itkImageToImageFilterID3VISS3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterID3VISS3_cast(obj)

class itkImageToImageFilterID3VIUC3(itkImageSourcePython.itkImageSourceVIUC3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterID3VIUC3 self, itkImageD3 image)
        SetInput(itkImageToImageFilterID3VIUC3 self, unsigned int arg0, itkImageD3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3VIUC3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageD3 const *":
        """
        GetInput(itkImageToImageFilterID3VIUC3 self) -> itkImageD3
        GetInput(itkImageToImageFilterID3VIUC3 self, unsigned int idx) -> itkImageD3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3VIUC3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageD3') -> "void":
        """
        PushBackInput(itkImageToImageFilterID3VIUC3 self, itkImageD3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3VIUC3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterID3VIUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3VIUC3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageD3') -> "void":
        """PushFrontInput(itkImageToImageFilterID3VIUC3 self, itkImageD3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3VIUC3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterID3VIUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3VIUC3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterID3VIUC3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3VIUC3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterID3VIUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3VIUC3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterID3VIUC3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3VIUC3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterID3VIUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3VIUC3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterID3VIUC3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterID3VIUC3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterID3VIUC3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3VIUC3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterID3VIUC3

        Create a new object of the class itkImageToImageFilterID3VIUC3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterID3VIUC3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterID3VIUC3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterID3VIUC3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterID3VIUC3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3VIUC3_SetInput, None, itkImageToImageFilterID3VIUC3)
itkImageToImageFilterID3VIUC3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3VIUC3_GetInput, None, itkImageToImageFilterID3VIUC3)
itkImageToImageFilterID3VIUC3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3VIUC3_PushBackInput, None, itkImageToImageFilterID3VIUC3)
itkImageToImageFilterID3VIUC3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3VIUC3_PopBackInput, None, itkImageToImageFilterID3VIUC3)
itkImageToImageFilterID3VIUC3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3VIUC3_PushFrontInput, None, itkImageToImageFilterID3VIUC3)
itkImageToImageFilterID3VIUC3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3VIUC3_PopFrontInput, None, itkImageToImageFilterID3VIUC3)
itkImageToImageFilterID3VIUC3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3VIUC3_SetCoordinateTolerance, None, itkImageToImageFilterID3VIUC3)
itkImageToImageFilterID3VIUC3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3VIUC3_GetCoordinateTolerance, None, itkImageToImageFilterID3VIUC3)
itkImageToImageFilterID3VIUC3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3VIUC3_SetDirectionTolerance, None, itkImageToImageFilterID3VIUC3)
itkImageToImageFilterID3VIUC3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3VIUC3_GetDirectionTolerance, None, itkImageToImageFilterID3VIUC3)
itkImageToImageFilterID3VIUC3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterID3VIUC3_swigregister
itkImageToImageFilterID3VIUC3_swigregister(itkImageToImageFilterID3VIUC3)

def itkImageToImageFilterID3VIUC3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterID3VIUC3 *":
    """itkImageToImageFilterID3VIUC3_cast(itkLightObject obj) -> itkImageToImageFilterID3VIUC3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterID3VIUC3_cast(obj)

class itkImageToImageFilterID3VIUS3(itkImageSourcePython.itkImageSourceVIUS3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterID3VIUS3 self, itkImageD3 image)
        SetInput(itkImageToImageFilterID3VIUS3 self, unsigned int arg0, itkImageD3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3VIUS3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageD3 const *":
        """
        GetInput(itkImageToImageFilterID3VIUS3 self) -> itkImageD3
        GetInput(itkImageToImageFilterID3VIUS3 self, unsigned int idx) -> itkImageD3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3VIUS3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageD3') -> "void":
        """
        PushBackInput(itkImageToImageFilterID3VIUS3 self, itkImageD3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3VIUS3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterID3VIUS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3VIUS3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageD3') -> "void":
        """PushFrontInput(itkImageToImageFilterID3VIUS3 self, itkImageD3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3VIUS3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterID3VIUS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3VIUS3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterID3VIUS3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3VIUS3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterID3VIUS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3VIUS3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterID3VIUS3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3VIUS3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterID3VIUS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3VIUS3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterID3VIUS3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterID3VIUS3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterID3VIUS3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterID3VIUS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterID3VIUS3

        Create a new object of the class itkImageToImageFilterID3VIUS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterID3VIUS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterID3VIUS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterID3VIUS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterID3VIUS3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3VIUS3_SetInput, None, itkImageToImageFilterID3VIUS3)
itkImageToImageFilterID3VIUS3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3VIUS3_GetInput, None, itkImageToImageFilterID3VIUS3)
itkImageToImageFilterID3VIUS3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3VIUS3_PushBackInput, None, itkImageToImageFilterID3VIUS3)
itkImageToImageFilterID3VIUS3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3VIUS3_PopBackInput, None, itkImageToImageFilterID3VIUS3)
itkImageToImageFilterID3VIUS3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3VIUS3_PushFrontInput, None, itkImageToImageFilterID3VIUS3)
itkImageToImageFilterID3VIUS3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3VIUS3_PopFrontInput, None, itkImageToImageFilterID3VIUS3)
itkImageToImageFilterID3VIUS3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3VIUS3_SetCoordinateTolerance, None, itkImageToImageFilterID3VIUS3)
itkImageToImageFilterID3VIUS3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3VIUS3_GetCoordinateTolerance, None, itkImageToImageFilterID3VIUS3)
itkImageToImageFilterID3VIUS3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3VIUS3_SetDirectionTolerance, None, itkImageToImageFilterID3VIUS3)
itkImageToImageFilterID3VIUS3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterID3VIUS3_GetDirectionTolerance, None, itkImageToImageFilterID3VIUS3)
itkImageToImageFilterID3VIUS3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterID3VIUS3_swigregister
itkImageToImageFilterID3VIUS3_swigregister(itkImageToImageFilterID3VIUS3)

def itkImageToImageFilterID3VIUS3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterID3VIUS3 *":
    """itkImageToImageFilterID3VIUS3_cast(itkLightObject obj) -> itkImageToImageFilterID3VIUS3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterID3VIUS3_cast(obj)

class itkImageToImageFilterIF2ICF2(itkImageSourcePython.itkImageSourceICF2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIF2ICF2 self, itkImageF2 image)
        SetInput(itkImageToImageFilterIF2ICF2 self, unsigned int arg0, itkImageF2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICF2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageF2 const *":
        """
        GetInput(itkImageToImageFilterIF2ICF2 self) -> itkImageF2
        GetInput(itkImageToImageFilterIF2ICF2 self, unsigned int idx) -> itkImageF2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICF2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageF2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIF2ICF2 self, itkImageF2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICF2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIF2ICF2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICF2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageF2') -> "void":
        """PushFrontInput(itkImageToImageFilterIF2ICF2 self, itkImageF2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICF2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIF2ICF2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICF2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIF2ICF2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICF2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIF2ICF2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICF2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIF2ICF2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICF2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIF2ICF2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICF2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIF2ICF2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF2ICF2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIF2ICF2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICF2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIF2ICF2

        Create a new object of the class itkImageToImageFilterIF2ICF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIF2ICF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIF2ICF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIF2ICF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIF2ICF2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2ICF2_SetInput, None, itkImageToImageFilterIF2ICF2)
itkImageToImageFilterIF2ICF2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2ICF2_GetInput, None, itkImageToImageFilterIF2ICF2)
itkImageToImageFilterIF2ICF2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2ICF2_PushBackInput, None, itkImageToImageFilterIF2ICF2)
itkImageToImageFilterIF2ICF2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2ICF2_PopBackInput, None, itkImageToImageFilterIF2ICF2)
itkImageToImageFilterIF2ICF2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2ICF2_PushFrontInput, None, itkImageToImageFilterIF2ICF2)
itkImageToImageFilterIF2ICF2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2ICF2_PopFrontInput, None, itkImageToImageFilterIF2ICF2)
itkImageToImageFilterIF2ICF2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2ICF2_SetCoordinateTolerance, None, itkImageToImageFilterIF2ICF2)
itkImageToImageFilterIF2ICF2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2ICF2_GetCoordinateTolerance, None, itkImageToImageFilterIF2ICF2)
itkImageToImageFilterIF2ICF2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2ICF2_SetDirectionTolerance, None, itkImageToImageFilterIF2ICF2)
itkImageToImageFilterIF2ICF2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2ICF2_GetDirectionTolerance, None, itkImageToImageFilterIF2ICF2)
itkImageToImageFilterIF2ICF2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICF2_swigregister
itkImageToImageFilterIF2ICF2_swigregister(itkImageToImageFilterIF2ICF2)

def itkImageToImageFilterIF2ICF2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF2ICF2 *":
    """itkImageToImageFilterIF2ICF2_cast(itkLightObject obj) -> itkImageToImageFilterIF2ICF2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICF2_cast(obj)

class itkImageToImageFilterIF2ICVD22(itkImageSourcePython.itkImageSourceICVD22):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIF2ICVD22 self, itkImageF2 image)
        SetInput(itkImageToImageFilterIF2ICVD22 self, unsigned int arg0, itkImageF2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVD22_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageF2 const *":
        """
        GetInput(itkImageToImageFilterIF2ICVD22 self) -> itkImageF2
        GetInput(itkImageToImageFilterIF2ICVD22 self, unsigned int idx) -> itkImageF2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVD22_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageF2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIF2ICVD22 self, itkImageF2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVD22_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIF2ICVD22 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVD22_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageF2') -> "void":
        """PushFrontInput(itkImageToImageFilterIF2ICVD22 self, itkImageF2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVD22_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIF2ICVD22 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVD22_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIF2ICVD22 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVD22_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIF2ICVD22 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVD22_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIF2ICVD22 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVD22_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIF2ICVD22 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVD22_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIF2ICVD22

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF2ICVD22 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIF2ICVD22"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVD22_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIF2ICVD22

        Create a new object of the class itkImageToImageFilterIF2ICVD22 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIF2ICVD22.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIF2ICVD22.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIF2ICVD22.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIF2ICVD22.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVD22_SetInput, None, itkImageToImageFilterIF2ICVD22)
itkImageToImageFilterIF2ICVD22.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVD22_GetInput, None, itkImageToImageFilterIF2ICVD22)
itkImageToImageFilterIF2ICVD22.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVD22_PushBackInput, None, itkImageToImageFilterIF2ICVD22)
itkImageToImageFilterIF2ICVD22.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVD22_PopBackInput, None, itkImageToImageFilterIF2ICVD22)
itkImageToImageFilterIF2ICVD22.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVD22_PushFrontInput, None, itkImageToImageFilterIF2ICVD22)
itkImageToImageFilterIF2ICVD22.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVD22_PopFrontInput, None, itkImageToImageFilterIF2ICVD22)
itkImageToImageFilterIF2ICVD22.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVD22_SetCoordinateTolerance, None, itkImageToImageFilterIF2ICVD22)
itkImageToImageFilterIF2ICVD22.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVD22_GetCoordinateTolerance, None, itkImageToImageFilterIF2ICVD22)
itkImageToImageFilterIF2ICVD22.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVD22_SetDirectionTolerance, None, itkImageToImageFilterIF2ICVD22)
itkImageToImageFilterIF2ICVD22.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVD22_GetDirectionTolerance, None, itkImageToImageFilterIF2ICVD22)
itkImageToImageFilterIF2ICVD22_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVD22_swigregister
itkImageToImageFilterIF2ICVD22_swigregister(itkImageToImageFilterIF2ICVD22)

def itkImageToImageFilterIF2ICVD22_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF2ICVD22 *":
    """itkImageToImageFilterIF2ICVD22_cast(itkLightObject obj) -> itkImageToImageFilterIF2ICVD22"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVD22_cast(obj)

class itkImageToImageFilterIF2ICVF22(itkImageSourcePython.itkImageSourceICVF22):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIF2ICVF22 self, itkImageF2 image)
        SetInput(itkImageToImageFilterIF2ICVF22 self, unsigned int arg0, itkImageF2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF22_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageF2 const *":
        """
        GetInput(itkImageToImageFilterIF2ICVF22 self) -> itkImageF2
        GetInput(itkImageToImageFilterIF2ICVF22 self, unsigned int idx) -> itkImageF2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF22_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageF2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIF2ICVF22 self, itkImageF2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF22_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIF2ICVF22 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF22_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageF2') -> "void":
        """PushFrontInput(itkImageToImageFilterIF2ICVF22 self, itkImageF2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF22_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIF2ICVF22 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF22_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIF2ICVF22 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF22_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIF2ICVF22 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF22_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIF2ICVF22 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF22_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIF2ICVF22 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF22_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIF2ICVF22

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF2ICVF22 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIF2ICVF22"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF22_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIF2ICVF22

        Create a new object of the class itkImageToImageFilterIF2ICVF22 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIF2ICVF22.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIF2ICVF22.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIF2ICVF22.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIF2ICVF22.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF22_SetInput, None, itkImageToImageFilterIF2ICVF22)
itkImageToImageFilterIF2ICVF22.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF22_GetInput, None, itkImageToImageFilterIF2ICVF22)
itkImageToImageFilterIF2ICVF22.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF22_PushBackInput, None, itkImageToImageFilterIF2ICVF22)
itkImageToImageFilterIF2ICVF22.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF22_PopBackInput, None, itkImageToImageFilterIF2ICVF22)
itkImageToImageFilterIF2ICVF22.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF22_PushFrontInput, None, itkImageToImageFilterIF2ICVF22)
itkImageToImageFilterIF2ICVF22.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF22_PopFrontInput, None, itkImageToImageFilterIF2ICVF22)
itkImageToImageFilterIF2ICVF22.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF22_SetCoordinateTolerance, None, itkImageToImageFilterIF2ICVF22)
itkImageToImageFilterIF2ICVF22.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF22_GetCoordinateTolerance, None, itkImageToImageFilterIF2ICVF22)
itkImageToImageFilterIF2ICVF22.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF22_SetDirectionTolerance, None, itkImageToImageFilterIF2ICVF22)
itkImageToImageFilterIF2ICVF22.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF22_GetDirectionTolerance, None, itkImageToImageFilterIF2ICVF22)
itkImageToImageFilterIF2ICVF22_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF22_swigregister
itkImageToImageFilterIF2ICVF22_swigregister(itkImageToImageFilterIF2ICVF22)

def itkImageToImageFilterIF2ICVF22_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF2ICVF22 *":
    """itkImageToImageFilterIF2ICVF22_cast(itkLightObject obj) -> itkImageToImageFilterIF2ICVF22"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF22_cast(obj)

class itkImageToImageFilterIF2ICVF32(itkImageSourcePython.itkImageSourceICVF32):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIF2ICVF32 self, itkImageF2 image)
        SetInput(itkImageToImageFilterIF2ICVF32 self, unsigned int arg0, itkImageF2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF32_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageF2 const *":
        """
        GetInput(itkImageToImageFilterIF2ICVF32 self) -> itkImageF2
        GetInput(itkImageToImageFilterIF2ICVF32 self, unsigned int idx) -> itkImageF2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF32_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageF2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIF2ICVF32 self, itkImageF2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF32_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIF2ICVF32 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF32_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageF2') -> "void":
        """PushFrontInput(itkImageToImageFilterIF2ICVF32 self, itkImageF2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF32_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIF2ICVF32 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF32_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIF2ICVF32 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF32_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIF2ICVF32 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF32_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIF2ICVF32 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF32_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIF2ICVF32 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF32_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIF2ICVF32

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF2ICVF32 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIF2ICVF32"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF32_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIF2ICVF32

        Create a new object of the class itkImageToImageFilterIF2ICVF32 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIF2ICVF32.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIF2ICVF32.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIF2ICVF32.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIF2ICVF32.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF32_SetInput, None, itkImageToImageFilterIF2ICVF32)
itkImageToImageFilterIF2ICVF32.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF32_GetInput, None, itkImageToImageFilterIF2ICVF32)
itkImageToImageFilterIF2ICVF32.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF32_PushBackInput, None, itkImageToImageFilterIF2ICVF32)
itkImageToImageFilterIF2ICVF32.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF32_PopBackInput, None, itkImageToImageFilterIF2ICVF32)
itkImageToImageFilterIF2ICVF32.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF32_PushFrontInput, None, itkImageToImageFilterIF2ICVF32)
itkImageToImageFilterIF2ICVF32.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF32_PopFrontInput, None, itkImageToImageFilterIF2ICVF32)
itkImageToImageFilterIF2ICVF32.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF32_SetCoordinateTolerance, None, itkImageToImageFilterIF2ICVF32)
itkImageToImageFilterIF2ICVF32.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF32_GetCoordinateTolerance, None, itkImageToImageFilterIF2ICVF32)
itkImageToImageFilterIF2ICVF32.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF32_SetDirectionTolerance, None, itkImageToImageFilterIF2ICVF32)
itkImageToImageFilterIF2ICVF32.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF32_GetDirectionTolerance, None, itkImageToImageFilterIF2ICVF32)
itkImageToImageFilterIF2ICVF32_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF32_swigregister
itkImageToImageFilterIF2ICVF32_swigregister(itkImageToImageFilterIF2ICVF32)

def itkImageToImageFilterIF2ICVF32_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF2ICVF32 *":
    """itkImageToImageFilterIF2ICVF32_cast(itkLightObject obj) -> itkImageToImageFilterIF2ICVF32"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF32_cast(obj)

class itkImageToImageFilterIF2ICVF42(itkImageSourcePython.itkImageSourceICVF42):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIF2ICVF42 self, itkImageF2 image)
        SetInput(itkImageToImageFilterIF2ICVF42 self, unsigned int arg0, itkImageF2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF42_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageF2 const *":
        """
        GetInput(itkImageToImageFilterIF2ICVF42 self) -> itkImageF2
        GetInput(itkImageToImageFilterIF2ICVF42 self, unsigned int idx) -> itkImageF2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF42_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageF2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIF2ICVF42 self, itkImageF2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF42_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIF2ICVF42 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF42_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageF2') -> "void":
        """PushFrontInput(itkImageToImageFilterIF2ICVF42 self, itkImageF2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF42_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIF2ICVF42 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF42_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIF2ICVF42 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF42_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIF2ICVF42 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF42_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIF2ICVF42 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF42_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIF2ICVF42 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF42_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIF2ICVF42

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF2ICVF42 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIF2ICVF42"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF42_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIF2ICVF42

        Create a new object of the class itkImageToImageFilterIF2ICVF42 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIF2ICVF42.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIF2ICVF42.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIF2ICVF42.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIF2ICVF42.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF42_SetInput, None, itkImageToImageFilterIF2ICVF42)
itkImageToImageFilterIF2ICVF42.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF42_GetInput, None, itkImageToImageFilterIF2ICVF42)
itkImageToImageFilterIF2ICVF42.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF42_PushBackInput, None, itkImageToImageFilterIF2ICVF42)
itkImageToImageFilterIF2ICVF42.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF42_PopBackInput, None, itkImageToImageFilterIF2ICVF42)
itkImageToImageFilterIF2ICVF42.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF42_PushFrontInput, None, itkImageToImageFilterIF2ICVF42)
itkImageToImageFilterIF2ICVF42.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF42_PopFrontInput, None, itkImageToImageFilterIF2ICVF42)
itkImageToImageFilterIF2ICVF42.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF42_SetCoordinateTolerance, None, itkImageToImageFilterIF2ICVF42)
itkImageToImageFilterIF2ICVF42.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF42_GetCoordinateTolerance, None, itkImageToImageFilterIF2ICVF42)
itkImageToImageFilterIF2ICVF42.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF42_SetDirectionTolerance, None, itkImageToImageFilterIF2ICVF42)
itkImageToImageFilterIF2ICVF42.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF42_GetDirectionTolerance, None, itkImageToImageFilterIF2ICVF42)
itkImageToImageFilterIF2ICVF42_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF42_swigregister
itkImageToImageFilterIF2ICVF42_swigregister(itkImageToImageFilterIF2ICVF42)

def itkImageToImageFilterIF2ICVF42_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF2ICVF42 *":
    """itkImageToImageFilterIF2ICVF42_cast(itkLightObject obj) -> itkImageToImageFilterIF2ICVF42"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ICVF42_cast(obj)

class itkImageToImageFilterIF2IF3(itkImageSourcePython.itkImageSourceIF3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIF2IF3 self, itkImageF2 image)
        SetInput(itkImageToImageFilterIF2IF3 self, unsigned int arg0, itkImageF2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IF3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageF2 const *":
        """
        GetInput(itkImageToImageFilterIF2IF3 self) -> itkImageF2
        GetInput(itkImageToImageFilterIF2IF3 self, unsigned int idx) -> itkImageF2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IF3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageF2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIF2IF3 self, itkImageF2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IF3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIF2IF3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IF3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageF2') -> "void":
        """PushFrontInput(itkImageToImageFilterIF2IF3 self, itkImageF2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IF3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIF2IF3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IF3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIF2IF3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IF3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIF2IF3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IF3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIF2IF3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IF3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIF2IF3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IF3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIF2IF3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF2IF3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIF2IF3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IF3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIF2IF3

        Create a new object of the class itkImageToImageFilterIF2IF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIF2IF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIF2IF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIF2IF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIF2IF3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2IF3_SetInput, None, itkImageToImageFilterIF2IF3)
itkImageToImageFilterIF2IF3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2IF3_GetInput, None, itkImageToImageFilterIF2IF3)
itkImageToImageFilterIF2IF3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2IF3_PushBackInput, None, itkImageToImageFilterIF2IF3)
itkImageToImageFilterIF2IF3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2IF3_PopBackInput, None, itkImageToImageFilterIF2IF3)
itkImageToImageFilterIF2IF3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2IF3_PushFrontInput, None, itkImageToImageFilterIF2IF3)
itkImageToImageFilterIF2IF3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2IF3_PopFrontInput, None, itkImageToImageFilterIF2IF3)
itkImageToImageFilterIF2IF3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2IF3_SetCoordinateTolerance, None, itkImageToImageFilterIF2IF3)
itkImageToImageFilterIF2IF3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2IF3_GetCoordinateTolerance, None, itkImageToImageFilterIF2IF3)
itkImageToImageFilterIF2IF3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2IF3_SetDirectionTolerance, None, itkImageToImageFilterIF2IF3)
itkImageToImageFilterIF2IF3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2IF3_GetDirectionTolerance, None, itkImageToImageFilterIF2IF3)
itkImageToImageFilterIF2IF3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIF2IF3_swigregister
itkImageToImageFilterIF2IF3_swigregister(itkImageToImageFilterIF2IF3)

def itkImageToImageFilterIF2IF3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF2IF3 *":
    """itkImageToImageFilterIF2IF3_cast(itkLightObject obj) -> itkImageToImageFilterIF2IF3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IF3_cast(obj)

class itkImageToImageFilterIF2IRGBAUC2(itkImageSourcePython.itkImageSourceIRGBAUC2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIF2IRGBAUC2 self, itkImageF2 image)
        SetInput(itkImageToImageFilterIF2IRGBAUC2 self, unsigned int arg0, itkImageF2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IRGBAUC2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageF2 const *":
        """
        GetInput(itkImageToImageFilterIF2IRGBAUC2 self) -> itkImageF2
        GetInput(itkImageToImageFilterIF2IRGBAUC2 self, unsigned int idx) -> itkImageF2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IRGBAUC2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageF2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIF2IRGBAUC2 self, itkImageF2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IRGBAUC2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIF2IRGBAUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IRGBAUC2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageF2') -> "void":
        """PushFrontInput(itkImageToImageFilterIF2IRGBAUC2 self, itkImageF2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IRGBAUC2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIF2IRGBAUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IRGBAUC2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIF2IRGBAUC2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IRGBAUC2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIF2IRGBAUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IRGBAUC2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIF2IRGBAUC2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IRGBAUC2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIF2IRGBAUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IRGBAUC2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIF2IRGBAUC2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF2IRGBAUC2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIF2IRGBAUC2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IRGBAUC2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIF2IRGBAUC2

        Create a new object of the class itkImageToImageFilterIF2IRGBAUC2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIF2IRGBAUC2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIF2IRGBAUC2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIF2IRGBAUC2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIF2IRGBAUC2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2IRGBAUC2_SetInput, None, itkImageToImageFilterIF2IRGBAUC2)
itkImageToImageFilterIF2IRGBAUC2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2IRGBAUC2_GetInput, None, itkImageToImageFilterIF2IRGBAUC2)
itkImageToImageFilterIF2IRGBAUC2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2IRGBAUC2_PushBackInput, None, itkImageToImageFilterIF2IRGBAUC2)
itkImageToImageFilterIF2IRGBAUC2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2IRGBAUC2_PopBackInput, None, itkImageToImageFilterIF2IRGBAUC2)
itkImageToImageFilterIF2IRGBAUC2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2IRGBAUC2_PushFrontInput, None, itkImageToImageFilterIF2IRGBAUC2)
itkImageToImageFilterIF2IRGBAUC2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2IRGBAUC2_PopFrontInput, None, itkImageToImageFilterIF2IRGBAUC2)
itkImageToImageFilterIF2IRGBAUC2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2IRGBAUC2_SetCoordinateTolerance, None, itkImageToImageFilterIF2IRGBAUC2)
itkImageToImageFilterIF2IRGBAUC2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2IRGBAUC2_GetCoordinateTolerance, None, itkImageToImageFilterIF2IRGBAUC2)
itkImageToImageFilterIF2IRGBAUC2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2IRGBAUC2_SetDirectionTolerance, None, itkImageToImageFilterIF2IRGBAUC2)
itkImageToImageFilterIF2IRGBAUC2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2IRGBAUC2_GetDirectionTolerance, None, itkImageToImageFilterIF2IRGBAUC2)
itkImageToImageFilterIF2IRGBAUC2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIF2IRGBAUC2_swigregister
itkImageToImageFilterIF2IRGBAUC2_swigregister(itkImageToImageFilterIF2IRGBAUC2)

def itkImageToImageFilterIF2IRGBAUC2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF2IRGBAUC2 *":
    """itkImageToImageFilterIF2IRGBAUC2_cast(itkLightObject obj) -> itkImageToImageFilterIF2IRGBAUC2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IRGBAUC2_cast(obj)

class itkImageToImageFilterIF2IRGBUC2(itkImageSourcePython.itkImageSourceIRGBUC2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIF2IRGBUC2 self, itkImageF2 image)
        SetInput(itkImageToImageFilterIF2IRGBUC2 self, unsigned int arg0, itkImageF2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IRGBUC2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageF2 const *":
        """
        GetInput(itkImageToImageFilterIF2IRGBUC2 self) -> itkImageF2
        GetInput(itkImageToImageFilterIF2IRGBUC2 self, unsigned int idx) -> itkImageF2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IRGBUC2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageF2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIF2IRGBUC2 self, itkImageF2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IRGBUC2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIF2IRGBUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IRGBUC2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageF2') -> "void":
        """PushFrontInput(itkImageToImageFilterIF2IRGBUC2 self, itkImageF2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IRGBUC2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIF2IRGBUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IRGBUC2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIF2IRGBUC2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IRGBUC2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIF2IRGBUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IRGBUC2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIF2IRGBUC2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IRGBUC2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIF2IRGBUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IRGBUC2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIF2IRGBUC2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF2IRGBUC2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIF2IRGBUC2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IRGBUC2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIF2IRGBUC2

        Create a new object of the class itkImageToImageFilterIF2IRGBUC2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIF2IRGBUC2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIF2IRGBUC2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIF2IRGBUC2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIF2IRGBUC2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2IRGBUC2_SetInput, None, itkImageToImageFilterIF2IRGBUC2)
itkImageToImageFilterIF2IRGBUC2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2IRGBUC2_GetInput, None, itkImageToImageFilterIF2IRGBUC2)
itkImageToImageFilterIF2IRGBUC2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2IRGBUC2_PushBackInput, None, itkImageToImageFilterIF2IRGBUC2)
itkImageToImageFilterIF2IRGBUC2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2IRGBUC2_PopBackInput, None, itkImageToImageFilterIF2IRGBUC2)
itkImageToImageFilterIF2IRGBUC2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2IRGBUC2_PushFrontInput, None, itkImageToImageFilterIF2IRGBUC2)
itkImageToImageFilterIF2IRGBUC2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2IRGBUC2_PopFrontInput, None, itkImageToImageFilterIF2IRGBUC2)
itkImageToImageFilterIF2IRGBUC2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2IRGBUC2_SetCoordinateTolerance, None, itkImageToImageFilterIF2IRGBUC2)
itkImageToImageFilterIF2IRGBUC2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2IRGBUC2_GetCoordinateTolerance, None, itkImageToImageFilterIF2IRGBUC2)
itkImageToImageFilterIF2IRGBUC2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2IRGBUC2_SetDirectionTolerance, None, itkImageToImageFilterIF2IRGBUC2)
itkImageToImageFilterIF2IRGBUC2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2IRGBUC2_GetDirectionTolerance, None, itkImageToImageFilterIF2IRGBUC2)
itkImageToImageFilterIF2IRGBUC2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIF2IRGBUC2_swigregister
itkImageToImageFilterIF2IRGBUC2_swigregister(itkImageToImageFilterIF2IRGBUC2)

def itkImageToImageFilterIF2IRGBUC2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF2IRGBUC2 *":
    """itkImageToImageFilterIF2IRGBUC2_cast(itkLightObject obj) -> itkImageToImageFilterIF2IRGBUC2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IRGBUC2_cast(obj)

class itkImageToImageFilterIF2ISSRTD22(itkImageSourcePython.itkImageSourceISSRTD22):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIF2ISSRTD22 self, itkImageF2 image)
        SetInput(itkImageToImageFilterIF2ISSRTD22 self, unsigned int arg0, itkImageF2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ISSRTD22_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageF2 const *":
        """
        GetInput(itkImageToImageFilterIF2ISSRTD22 self) -> itkImageF2
        GetInput(itkImageToImageFilterIF2ISSRTD22 self, unsigned int idx) -> itkImageF2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ISSRTD22_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageF2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIF2ISSRTD22 self, itkImageF2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ISSRTD22_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIF2ISSRTD22 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ISSRTD22_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageF2') -> "void":
        """PushFrontInput(itkImageToImageFilterIF2ISSRTD22 self, itkImageF2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ISSRTD22_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIF2ISSRTD22 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ISSRTD22_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIF2ISSRTD22 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ISSRTD22_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIF2ISSRTD22 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ISSRTD22_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIF2ISSRTD22 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ISSRTD22_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIF2ISSRTD22 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ISSRTD22_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIF2ISSRTD22

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF2ISSRTD22 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIF2ISSRTD22"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ISSRTD22_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIF2ISSRTD22

        Create a new object of the class itkImageToImageFilterIF2ISSRTD22 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIF2ISSRTD22.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIF2ISSRTD22.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIF2ISSRTD22.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIF2ISSRTD22.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2ISSRTD22_SetInput, None, itkImageToImageFilterIF2ISSRTD22)
itkImageToImageFilterIF2ISSRTD22.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2ISSRTD22_GetInput, None, itkImageToImageFilterIF2ISSRTD22)
itkImageToImageFilterIF2ISSRTD22.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2ISSRTD22_PushBackInput, None, itkImageToImageFilterIF2ISSRTD22)
itkImageToImageFilterIF2ISSRTD22.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2ISSRTD22_PopBackInput, None, itkImageToImageFilterIF2ISSRTD22)
itkImageToImageFilterIF2ISSRTD22.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2ISSRTD22_PushFrontInput, None, itkImageToImageFilterIF2ISSRTD22)
itkImageToImageFilterIF2ISSRTD22.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2ISSRTD22_PopFrontInput, None, itkImageToImageFilterIF2ISSRTD22)
itkImageToImageFilterIF2ISSRTD22.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2ISSRTD22_SetCoordinateTolerance, None, itkImageToImageFilterIF2ISSRTD22)
itkImageToImageFilterIF2ISSRTD22.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2ISSRTD22_GetCoordinateTolerance, None, itkImageToImageFilterIF2ISSRTD22)
itkImageToImageFilterIF2ISSRTD22.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2ISSRTD22_SetDirectionTolerance, None, itkImageToImageFilterIF2ISSRTD22)
itkImageToImageFilterIF2ISSRTD22.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2ISSRTD22_GetDirectionTolerance, None, itkImageToImageFilterIF2ISSRTD22)
itkImageToImageFilterIF2ISSRTD22_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIF2ISSRTD22_swigregister
itkImageToImageFilterIF2ISSRTD22_swigregister(itkImageToImageFilterIF2ISSRTD22)

def itkImageToImageFilterIF2ISSRTD22_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF2ISSRTD22 *":
    """itkImageToImageFilterIF2ISSRTD22_cast(itkLightObject obj) -> itkImageToImageFilterIF2ISSRTD22"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIF2ISSRTD22_cast(obj)

class itkImageToImageFilterIF2IVF22(itkImageSourcePython.itkImageSourceIVF22):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIF2IVF22 self, itkImageF2 image)
        SetInput(itkImageToImageFilterIF2IVF22 self, unsigned int arg0, itkImageF2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF22_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageF2 const *":
        """
        GetInput(itkImageToImageFilterIF2IVF22 self) -> itkImageF2
        GetInput(itkImageToImageFilterIF2IVF22 self, unsigned int idx) -> itkImageF2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF22_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageF2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIF2IVF22 self, itkImageF2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF22_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIF2IVF22 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF22_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageF2') -> "void":
        """PushFrontInput(itkImageToImageFilterIF2IVF22 self, itkImageF2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF22_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIF2IVF22 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF22_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIF2IVF22 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF22_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIF2IVF22 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF22_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIF2IVF22 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF22_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIF2IVF22 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF22_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIF2IVF22

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF2IVF22 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIF2IVF22"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF22_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIF2IVF22

        Create a new object of the class itkImageToImageFilterIF2IVF22 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIF2IVF22.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIF2IVF22.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIF2IVF22.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIF2IVF22.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF22_SetInput, None, itkImageToImageFilterIF2IVF22)
itkImageToImageFilterIF2IVF22.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF22_GetInput, None, itkImageToImageFilterIF2IVF22)
itkImageToImageFilterIF2IVF22.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF22_PushBackInput, None, itkImageToImageFilterIF2IVF22)
itkImageToImageFilterIF2IVF22.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF22_PopBackInput, None, itkImageToImageFilterIF2IVF22)
itkImageToImageFilterIF2IVF22.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF22_PushFrontInput, None, itkImageToImageFilterIF2IVF22)
itkImageToImageFilterIF2IVF22.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF22_PopFrontInput, None, itkImageToImageFilterIF2IVF22)
itkImageToImageFilterIF2IVF22.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF22_SetCoordinateTolerance, None, itkImageToImageFilterIF2IVF22)
itkImageToImageFilterIF2IVF22.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF22_GetCoordinateTolerance, None, itkImageToImageFilterIF2IVF22)
itkImageToImageFilterIF2IVF22.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF22_SetDirectionTolerance, None, itkImageToImageFilterIF2IVF22)
itkImageToImageFilterIF2IVF22.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF22_GetDirectionTolerance, None, itkImageToImageFilterIF2IVF22)
itkImageToImageFilterIF2IVF22_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF22_swigregister
itkImageToImageFilterIF2IVF22_swigregister(itkImageToImageFilterIF2IVF22)

def itkImageToImageFilterIF2IVF22_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF2IVF22 *":
    """itkImageToImageFilterIF2IVF22_cast(itkLightObject obj) -> itkImageToImageFilterIF2IVF22"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF22_cast(obj)

class itkImageToImageFilterIF2IVF32(itkImageSourcePython.itkImageSourceIVF32):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIF2IVF32 self, itkImageF2 image)
        SetInput(itkImageToImageFilterIF2IVF32 self, unsigned int arg0, itkImageF2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF32_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageF2 const *":
        """
        GetInput(itkImageToImageFilterIF2IVF32 self) -> itkImageF2
        GetInput(itkImageToImageFilterIF2IVF32 self, unsigned int idx) -> itkImageF2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF32_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageF2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIF2IVF32 self, itkImageF2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF32_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIF2IVF32 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF32_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageF2') -> "void":
        """PushFrontInput(itkImageToImageFilterIF2IVF32 self, itkImageF2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF32_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIF2IVF32 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF32_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIF2IVF32 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF32_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIF2IVF32 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF32_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIF2IVF32 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF32_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIF2IVF32 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF32_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIF2IVF32

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF2IVF32 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIF2IVF32"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF32_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIF2IVF32

        Create a new object of the class itkImageToImageFilterIF2IVF32 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIF2IVF32.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIF2IVF32.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIF2IVF32.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIF2IVF32.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF32_SetInput, None, itkImageToImageFilterIF2IVF32)
itkImageToImageFilterIF2IVF32.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF32_GetInput, None, itkImageToImageFilterIF2IVF32)
itkImageToImageFilterIF2IVF32.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF32_PushBackInput, None, itkImageToImageFilterIF2IVF32)
itkImageToImageFilterIF2IVF32.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF32_PopBackInput, None, itkImageToImageFilterIF2IVF32)
itkImageToImageFilterIF2IVF32.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF32_PushFrontInput, None, itkImageToImageFilterIF2IVF32)
itkImageToImageFilterIF2IVF32.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF32_PopFrontInput, None, itkImageToImageFilterIF2IVF32)
itkImageToImageFilterIF2IVF32.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF32_SetCoordinateTolerance, None, itkImageToImageFilterIF2IVF32)
itkImageToImageFilterIF2IVF32.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF32_GetCoordinateTolerance, None, itkImageToImageFilterIF2IVF32)
itkImageToImageFilterIF2IVF32.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF32_SetDirectionTolerance, None, itkImageToImageFilterIF2IVF32)
itkImageToImageFilterIF2IVF32.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF32_GetDirectionTolerance, None, itkImageToImageFilterIF2IVF32)
itkImageToImageFilterIF2IVF32_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF32_swigregister
itkImageToImageFilterIF2IVF32_swigregister(itkImageToImageFilterIF2IVF32)

def itkImageToImageFilterIF2IVF32_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF2IVF32 *":
    """itkImageToImageFilterIF2IVF32_cast(itkLightObject obj) -> itkImageToImageFilterIF2IVF32"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF32_cast(obj)

class itkImageToImageFilterIF2IVF42(itkImageSourcePython.itkImageSourceIVF42):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIF2IVF42 self, itkImageF2 image)
        SetInput(itkImageToImageFilterIF2IVF42 self, unsigned int arg0, itkImageF2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF42_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageF2 const *":
        """
        GetInput(itkImageToImageFilterIF2IVF42 self) -> itkImageF2
        GetInput(itkImageToImageFilterIF2IVF42 self, unsigned int idx) -> itkImageF2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF42_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageF2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIF2IVF42 self, itkImageF2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF42_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIF2IVF42 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF42_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageF2') -> "void":
        """PushFrontInput(itkImageToImageFilterIF2IVF42 self, itkImageF2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF42_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIF2IVF42 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF42_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIF2IVF42 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF42_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIF2IVF42 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF42_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIF2IVF42 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF42_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIF2IVF42 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF42_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIF2IVF42

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF2IVF42 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIF2IVF42"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF42_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIF2IVF42

        Create a new object of the class itkImageToImageFilterIF2IVF42 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIF2IVF42.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIF2IVF42.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIF2IVF42.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIF2IVF42.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF42_SetInput, None, itkImageToImageFilterIF2IVF42)
itkImageToImageFilterIF2IVF42.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF42_GetInput, None, itkImageToImageFilterIF2IVF42)
itkImageToImageFilterIF2IVF42.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF42_PushBackInput, None, itkImageToImageFilterIF2IVF42)
itkImageToImageFilterIF2IVF42.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF42_PopBackInput, None, itkImageToImageFilterIF2IVF42)
itkImageToImageFilterIF2IVF42.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF42_PushFrontInput, None, itkImageToImageFilterIF2IVF42)
itkImageToImageFilterIF2IVF42.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF42_PopFrontInput, None, itkImageToImageFilterIF2IVF42)
itkImageToImageFilterIF2IVF42.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF42_SetCoordinateTolerance, None, itkImageToImageFilterIF2IVF42)
itkImageToImageFilterIF2IVF42.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF42_GetCoordinateTolerance, None, itkImageToImageFilterIF2IVF42)
itkImageToImageFilterIF2IVF42.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF42_SetDirectionTolerance, None, itkImageToImageFilterIF2IVF42)
itkImageToImageFilterIF2IVF42.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF42_GetDirectionTolerance, None, itkImageToImageFilterIF2IVF42)
itkImageToImageFilterIF2IVF42_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF42_swigregister
itkImageToImageFilterIF2IVF42_swigregister(itkImageToImageFilterIF2IVF42)

def itkImageToImageFilterIF2IVF42_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF2IVF42 *":
    """itkImageToImageFilterIF2IVF42_cast(itkLightObject obj) -> itkImageToImageFilterIF2IVF42"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIF2IVF42_cast(obj)

class itkImageToImageFilterIF2VID2(itkImageSourcePython.itkImageSourceVID2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIF2VID2 self, itkImageF2 image)
        SetInput(itkImageToImageFilterIF2VID2 self, unsigned int arg0, itkImageF2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2VID2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageF2 const *":
        """
        GetInput(itkImageToImageFilterIF2VID2 self) -> itkImageF2
        GetInput(itkImageToImageFilterIF2VID2 self, unsigned int idx) -> itkImageF2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2VID2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageF2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIF2VID2 self, itkImageF2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2VID2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIF2VID2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2VID2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageF2') -> "void":
        """PushFrontInput(itkImageToImageFilterIF2VID2 self, itkImageF2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2VID2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIF2VID2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2VID2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIF2VID2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2VID2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIF2VID2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2VID2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIF2VID2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2VID2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIF2VID2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2VID2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIF2VID2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF2VID2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIF2VID2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2VID2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIF2VID2

        Create a new object of the class itkImageToImageFilterIF2VID2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIF2VID2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIF2VID2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIF2VID2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIF2VID2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2VID2_SetInput, None, itkImageToImageFilterIF2VID2)
itkImageToImageFilterIF2VID2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2VID2_GetInput, None, itkImageToImageFilterIF2VID2)
itkImageToImageFilterIF2VID2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2VID2_PushBackInput, None, itkImageToImageFilterIF2VID2)
itkImageToImageFilterIF2VID2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2VID2_PopBackInput, None, itkImageToImageFilterIF2VID2)
itkImageToImageFilterIF2VID2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2VID2_PushFrontInput, None, itkImageToImageFilterIF2VID2)
itkImageToImageFilterIF2VID2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2VID2_PopFrontInput, None, itkImageToImageFilterIF2VID2)
itkImageToImageFilterIF2VID2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2VID2_SetCoordinateTolerance, None, itkImageToImageFilterIF2VID2)
itkImageToImageFilterIF2VID2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2VID2_GetCoordinateTolerance, None, itkImageToImageFilterIF2VID2)
itkImageToImageFilterIF2VID2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2VID2_SetDirectionTolerance, None, itkImageToImageFilterIF2VID2)
itkImageToImageFilterIF2VID2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2VID2_GetDirectionTolerance, None, itkImageToImageFilterIF2VID2)
itkImageToImageFilterIF2VID2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIF2VID2_swigregister
itkImageToImageFilterIF2VID2_swigregister(itkImageToImageFilterIF2VID2)

def itkImageToImageFilterIF2VID2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF2VID2 *":
    """itkImageToImageFilterIF2VID2_cast(itkLightObject obj) -> itkImageToImageFilterIF2VID2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIF2VID2_cast(obj)

class itkImageToImageFilterIF2VIF2(itkImageSourcePython.itkImageSourceVIF2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIF2VIF2 self, itkImageF2 image)
        SetInput(itkImageToImageFilterIF2VIF2 self, unsigned int arg0, itkImageF2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2VIF2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageF2 const *":
        """
        GetInput(itkImageToImageFilterIF2VIF2 self) -> itkImageF2
        GetInput(itkImageToImageFilterIF2VIF2 self, unsigned int idx) -> itkImageF2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2VIF2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageF2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIF2VIF2 self, itkImageF2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2VIF2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIF2VIF2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2VIF2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageF2') -> "void":
        """PushFrontInput(itkImageToImageFilterIF2VIF2 self, itkImageF2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2VIF2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIF2VIF2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2VIF2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIF2VIF2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2VIF2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIF2VIF2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2VIF2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIF2VIF2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2VIF2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIF2VIF2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2VIF2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIF2VIF2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF2VIF2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIF2VIF2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2VIF2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIF2VIF2

        Create a new object of the class itkImageToImageFilterIF2VIF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIF2VIF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIF2VIF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIF2VIF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIF2VIF2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2VIF2_SetInput, None, itkImageToImageFilterIF2VIF2)
itkImageToImageFilterIF2VIF2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2VIF2_GetInput, None, itkImageToImageFilterIF2VIF2)
itkImageToImageFilterIF2VIF2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2VIF2_PushBackInput, None, itkImageToImageFilterIF2VIF2)
itkImageToImageFilterIF2VIF2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2VIF2_PopBackInput, None, itkImageToImageFilterIF2VIF2)
itkImageToImageFilterIF2VIF2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2VIF2_PushFrontInput, None, itkImageToImageFilterIF2VIF2)
itkImageToImageFilterIF2VIF2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2VIF2_PopFrontInput, None, itkImageToImageFilterIF2VIF2)
itkImageToImageFilterIF2VIF2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2VIF2_SetCoordinateTolerance, None, itkImageToImageFilterIF2VIF2)
itkImageToImageFilterIF2VIF2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2VIF2_GetCoordinateTolerance, None, itkImageToImageFilterIF2VIF2)
itkImageToImageFilterIF2VIF2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2VIF2_SetDirectionTolerance, None, itkImageToImageFilterIF2VIF2)
itkImageToImageFilterIF2VIF2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2VIF2_GetDirectionTolerance, None, itkImageToImageFilterIF2VIF2)
itkImageToImageFilterIF2VIF2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIF2VIF2_swigregister
itkImageToImageFilterIF2VIF2_swigregister(itkImageToImageFilterIF2VIF2)

def itkImageToImageFilterIF2VIF2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF2VIF2 *":
    """itkImageToImageFilterIF2VIF2_cast(itkLightObject obj) -> itkImageToImageFilterIF2VIF2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIF2VIF2_cast(obj)

class itkImageToImageFilterIF2VISS2(itkImageSourcePython.itkImageSourceVISS2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIF2VISS2 self, itkImageF2 image)
        SetInput(itkImageToImageFilterIF2VISS2 self, unsigned int arg0, itkImageF2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2VISS2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageF2 const *":
        """
        GetInput(itkImageToImageFilterIF2VISS2 self) -> itkImageF2
        GetInput(itkImageToImageFilterIF2VISS2 self, unsigned int idx) -> itkImageF2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2VISS2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageF2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIF2VISS2 self, itkImageF2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2VISS2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIF2VISS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2VISS2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageF2') -> "void":
        """PushFrontInput(itkImageToImageFilterIF2VISS2 self, itkImageF2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2VISS2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIF2VISS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2VISS2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIF2VISS2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2VISS2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIF2VISS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2VISS2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIF2VISS2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2VISS2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIF2VISS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2VISS2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIF2VISS2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF2VISS2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIF2VISS2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2VISS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIF2VISS2

        Create a new object of the class itkImageToImageFilterIF2VISS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIF2VISS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIF2VISS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIF2VISS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIF2VISS2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2VISS2_SetInput, None, itkImageToImageFilterIF2VISS2)
itkImageToImageFilterIF2VISS2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2VISS2_GetInput, None, itkImageToImageFilterIF2VISS2)
itkImageToImageFilterIF2VISS2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2VISS2_PushBackInput, None, itkImageToImageFilterIF2VISS2)
itkImageToImageFilterIF2VISS2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2VISS2_PopBackInput, None, itkImageToImageFilterIF2VISS2)
itkImageToImageFilterIF2VISS2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2VISS2_PushFrontInput, None, itkImageToImageFilterIF2VISS2)
itkImageToImageFilterIF2VISS2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2VISS2_PopFrontInput, None, itkImageToImageFilterIF2VISS2)
itkImageToImageFilterIF2VISS2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2VISS2_SetCoordinateTolerance, None, itkImageToImageFilterIF2VISS2)
itkImageToImageFilterIF2VISS2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2VISS2_GetCoordinateTolerance, None, itkImageToImageFilterIF2VISS2)
itkImageToImageFilterIF2VISS2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2VISS2_SetDirectionTolerance, None, itkImageToImageFilterIF2VISS2)
itkImageToImageFilterIF2VISS2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2VISS2_GetDirectionTolerance, None, itkImageToImageFilterIF2VISS2)
itkImageToImageFilterIF2VISS2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIF2VISS2_swigregister
itkImageToImageFilterIF2VISS2_swigregister(itkImageToImageFilterIF2VISS2)

def itkImageToImageFilterIF2VISS2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF2VISS2 *":
    """itkImageToImageFilterIF2VISS2_cast(itkLightObject obj) -> itkImageToImageFilterIF2VISS2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIF2VISS2_cast(obj)

class itkImageToImageFilterIF2VIUC2(itkImageSourcePython.itkImageSourceVIUC2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIF2VIUC2 self, itkImageF2 image)
        SetInput(itkImageToImageFilterIF2VIUC2 self, unsigned int arg0, itkImageF2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2VIUC2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageF2 const *":
        """
        GetInput(itkImageToImageFilterIF2VIUC2 self) -> itkImageF2
        GetInput(itkImageToImageFilterIF2VIUC2 self, unsigned int idx) -> itkImageF2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2VIUC2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageF2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIF2VIUC2 self, itkImageF2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2VIUC2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIF2VIUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2VIUC2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageF2') -> "void":
        """PushFrontInput(itkImageToImageFilterIF2VIUC2 self, itkImageF2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2VIUC2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIF2VIUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2VIUC2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIF2VIUC2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2VIUC2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIF2VIUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2VIUC2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIF2VIUC2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2VIUC2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIF2VIUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2VIUC2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIF2VIUC2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF2VIUC2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIF2VIUC2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2VIUC2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIF2VIUC2

        Create a new object of the class itkImageToImageFilterIF2VIUC2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIF2VIUC2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIF2VIUC2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIF2VIUC2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIF2VIUC2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2VIUC2_SetInput, None, itkImageToImageFilterIF2VIUC2)
itkImageToImageFilterIF2VIUC2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2VIUC2_GetInput, None, itkImageToImageFilterIF2VIUC2)
itkImageToImageFilterIF2VIUC2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2VIUC2_PushBackInput, None, itkImageToImageFilterIF2VIUC2)
itkImageToImageFilterIF2VIUC2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2VIUC2_PopBackInput, None, itkImageToImageFilterIF2VIUC2)
itkImageToImageFilterIF2VIUC2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2VIUC2_PushFrontInput, None, itkImageToImageFilterIF2VIUC2)
itkImageToImageFilterIF2VIUC2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2VIUC2_PopFrontInput, None, itkImageToImageFilterIF2VIUC2)
itkImageToImageFilterIF2VIUC2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2VIUC2_SetCoordinateTolerance, None, itkImageToImageFilterIF2VIUC2)
itkImageToImageFilterIF2VIUC2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2VIUC2_GetCoordinateTolerance, None, itkImageToImageFilterIF2VIUC2)
itkImageToImageFilterIF2VIUC2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2VIUC2_SetDirectionTolerance, None, itkImageToImageFilterIF2VIUC2)
itkImageToImageFilterIF2VIUC2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2VIUC2_GetDirectionTolerance, None, itkImageToImageFilterIF2VIUC2)
itkImageToImageFilterIF2VIUC2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIF2VIUC2_swigregister
itkImageToImageFilterIF2VIUC2_swigregister(itkImageToImageFilterIF2VIUC2)

def itkImageToImageFilterIF2VIUC2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF2VIUC2 *":
    """itkImageToImageFilterIF2VIUC2_cast(itkLightObject obj) -> itkImageToImageFilterIF2VIUC2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIF2VIUC2_cast(obj)

class itkImageToImageFilterIF2VIUS2(itkImageSourcePython.itkImageSourceVIUS2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIF2VIUS2 self, itkImageF2 image)
        SetInput(itkImageToImageFilterIF2VIUS2 self, unsigned int arg0, itkImageF2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2VIUS2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageF2 const *":
        """
        GetInput(itkImageToImageFilterIF2VIUS2 self) -> itkImageF2
        GetInput(itkImageToImageFilterIF2VIUS2 self, unsigned int idx) -> itkImageF2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2VIUS2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageF2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIF2VIUS2 self, itkImageF2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2VIUS2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIF2VIUS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2VIUS2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageF2') -> "void":
        """PushFrontInput(itkImageToImageFilterIF2VIUS2 self, itkImageF2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2VIUS2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIF2VIUS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2VIUS2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIF2VIUS2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2VIUS2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIF2VIUS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2VIUS2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIF2VIUS2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2VIUS2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIF2VIUS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2VIUS2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIF2VIUS2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF2VIUS2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIF2VIUS2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF2VIUS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIF2VIUS2

        Create a new object of the class itkImageToImageFilterIF2VIUS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIF2VIUS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIF2VIUS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIF2VIUS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIF2VIUS2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2VIUS2_SetInput, None, itkImageToImageFilterIF2VIUS2)
itkImageToImageFilterIF2VIUS2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2VIUS2_GetInput, None, itkImageToImageFilterIF2VIUS2)
itkImageToImageFilterIF2VIUS2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2VIUS2_PushBackInput, None, itkImageToImageFilterIF2VIUS2)
itkImageToImageFilterIF2VIUS2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2VIUS2_PopBackInput, None, itkImageToImageFilterIF2VIUS2)
itkImageToImageFilterIF2VIUS2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2VIUS2_PushFrontInput, None, itkImageToImageFilterIF2VIUS2)
itkImageToImageFilterIF2VIUS2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2VIUS2_PopFrontInput, None, itkImageToImageFilterIF2VIUS2)
itkImageToImageFilterIF2VIUS2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2VIUS2_SetCoordinateTolerance, None, itkImageToImageFilterIF2VIUS2)
itkImageToImageFilterIF2VIUS2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2VIUS2_GetCoordinateTolerance, None, itkImageToImageFilterIF2VIUS2)
itkImageToImageFilterIF2VIUS2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2VIUS2_SetDirectionTolerance, None, itkImageToImageFilterIF2VIUS2)
itkImageToImageFilterIF2VIUS2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF2VIUS2_GetDirectionTolerance, None, itkImageToImageFilterIF2VIUS2)
itkImageToImageFilterIF2VIUS2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIF2VIUS2_swigregister
itkImageToImageFilterIF2VIUS2_swigregister(itkImageToImageFilterIF2VIUS2)

def itkImageToImageFilterIF2VIUS2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF2VIUS2 *":
    """itkImageToImageFilterIF2VIUS2_cast(itkLightObject obj) -> itkImageToImageFilterIF2VIUS2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIF2VIUS2_cast(obj)

class itkImageToImageFilterIF3ICF3(itkImageSourcePython.itkImageSourceICF3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIF3ICF3 self, itkImageF3 image)
        SetInput(itkImageToImageFilterIF3ICF3 self, unsigned int arg0, itkImageF3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICF3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageF3 const *":
        """
        GetInput(itkImageToImageFilterIF3ICF3 self) -> itkImageF3
        GetInput(itkImageToImageFilterIF3ICF3 self, unsigned int idx) -> itkImageF3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICF3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageF3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIF3ICF3 self, itkImageF3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICF3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIF3ICF3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICF3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageF3') -> "void":
        """PushFrontInput(itkImageToImageFilterIF3ICF3 self, itkImageF3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICF3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIF3ICF3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICF3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIF3ICF3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICF3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIF3ICF3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICF3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIF3ICF3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICF3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIF3ICF3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICF3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIF3ICF3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF3ICF3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIF3ICF3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICF3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIF3ICF3

        Create a new object of the class itkImageToImageFilterIF3ICF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIF3ICF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIF3ICF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIF3ICF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIF3ICF3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3ICF3_SetInput, None, itkImageToImageFilterIF3ICF3)
itkImageToImageFilterIF3ICF3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3ICF3_GetInput, None, itkImageToImageFilterIF3ICF3)
itkImageToImageFilterIF3ICF3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3ICF3_PushBackInput, None, itkImageToImageFilterIF3ICF3)
itkImageToImageFilterIF3ICF3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3ICF3_PopBackInput, None, itkImageToImageFilterIF3ICF3)
itkImageToImageFilterIF3ICF3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3ICF3_PushFrontInput, None, itkImageToImageFilterIF3ICF3)
itkImageToImageFilterIF3ICF3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3ICF3_PopFrontInput, None, itkImageToImageFilterIF3ICF3)
itkImageToImageFilterIF3ICF3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3ICF3_SetCoordinateTolerance, None, itkImageToImageFilterIF3ICF3)
itkImageToImageFilterIF3ICF3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3ICF3_GetCoordinateTolerance, None, itkImageToImageFilterIF3ICF3)
itkImageToImageFilterIF3ICF3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3ICF3_SetDirectionTolerance, None, itkImageToImageFilterIF3ICF3)
itkImageToImageFilterIF3ICF3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3ICF3_GetDirectionTolerance, None, itkImageToImageFilterIF3ICF3)
itkImageToImageFilterIF3ICF3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICF3_swigregister
itkImageToImageFilterIF3ICF3_swigregister(itkImageToImageFilterIF3ICF3)

def itkImageToImageFilterIF3ICF3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF3ICF3 *":
    """itkImageToImageFilterIF3ICF3_cast(itkLightObject obj) -> itkImageToImageFilterIF3ICF3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICF3_cast(obj)

class itkImageToImageFilterIF3ICVD33(itkImageSourcePython.itkImageSourceICVD33):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIF3ICVD33 self, itkImageF3 image)
        SetInput(itkImageToImageFilterIF3ICVD33 self, unsigned int arg0, itkImageF3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVD33_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageF3 const *":
        """
        GetInput(itkImageToImageFilterIF3ICVD33 self) -> itkImageF3
        GetInput(itkImageToImageFilterIF3ICVD33 self, unsigned int idx) -> itkImageF3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVD33_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageF3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIF3ICVD33 self, itkImageF3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVD33_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIF3ICVD33 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVD33_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageF3') -> "void":
        """PushFrontInput(itkImageToImageFilterIF3ICVD33 self, itkImageF3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVD33_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIF3ICVD33 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVD33_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIF3ICVD33 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVD33_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIF3ICVD33 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVD33_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIF3ICVD33 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVD33_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIF3ICVD33 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVD33_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIF3ICVD33

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF3ICVD33 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIF3ICVD33"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVD33_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIF3ICVD33

        Create a new object of the class itkImageToImageFilterIF3ICVD33 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIF3ICVD33.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIF3ICVD33.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIF3ICVD33.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIF3ICVD33.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVD33_SetInput, None, itkImageToImageFilterIF3ICVD33)
itkImageToImageFilterIF3ICVD33.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVD33_GetInput, None, itkImageToImageFilterIF3ICVD33)
itkImageToImageFilterIF3ICVD33.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVD33_PushBackInput, None, itkImageToImageFilterIF3ICVD33)
itkImageToImageFilterIF3ICVD33.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVD33_PopBackInput, None, itkImageToImageFilterIF3ICVD33)
itkImageToImageFilterIF3ICVD33.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVD33_PushFrontInput, None, itkImageToImageFilterIF3ICVD33)
itkImageToImageFilterIF3ICVD33.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVD33_PopFrontInput, None, itkImageToImageFilterIF3ICVD33)
itkImageToImageFilterIF3ICVD33.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVD33_SetCoordinateTolerance, None, itkImageToImageFilterIF3ICVD33)
itkImageToImageFilterIF3ICVD33.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVD33_GetCoordinateTolerance, None, itkImageToImageFilterIF3ICVD33)
itkImageToImageFilterIF3ICVD33.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVD33_SetDirectionTolerance, None, itkImageToImageFilterIF3ICVD33)
itkImageToImageFilterIF3ICVD33.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVD33_GetDirectionTolerance, None, itkImageToImageFilterIF3ICVD33)
itkImageToImageFilterIF3ICVD33_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVD33_swigregister
itkImageToImageFilterIF3ICVD33_swigregister(itkImageToImageFilterIF3ICVD33)

def itkImageToImageFilterIF3ICVD33_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF3ICVD33 *":
    """itkImageToImageFilterIF3ICVD33_cast(itkLightObject obj) -> itkImageToImageFilterIF3ICVD33"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVD33_cast(obj)

class itkImageToImageFilterIF3ICVF23(itkImageSourcePython.itkImageSourceICVF23):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIF3ICVF23 self, itkImageF3 image)
        SetInput(itkImageToImageFilterIF3ICVF23 self, unsigned int arg0, itkImageF3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF23_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageF3 const *":
        """
        GetInput(itkImageToImageFilterIF3ICVF23 self) -> itkImageF3
        GetInput(itkImageToImageFilterIF3ICVF23 self, unsigned int idx) -> itkImageF3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF23_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageF3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIF3ICVF23 self, itkImageF3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF23_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIF3ICVF23 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF23_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageF3') -> "void":
        """PushFrontInput(itkImageToImageFilterIF3ICVF23 self, itkImageF3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF23_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIF3ICVF23 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF23_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIF3ICVF23 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF23_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIF3ICVF23 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF23_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIF3ICVF23 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF23_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIF3ICVF23 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF23_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIF3ICVF23

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF3ICVF23 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIF3ICVF23"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF23_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIF3ICVF23

        Create a new object of the class itkImageToImageFilterIF3ICVF23 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIF3ICVF23.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIF3ICVF23.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIF3ICVF23.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIF3ICVF23.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF23_SetInput, None, itkImageToImageFilterIF3ICVF23)
itkImageToImageFilterIF3ICVF23.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF23_GetInput, None, itkImageToImageFilterIF3ICVF23)
itkImageToImageFilterIF3ICVF23.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF23_PushBackInput, None, itkImageToImageFilterIF3ICVF23)
itkImageToImageFilterIF3ICVF23.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF23_PopBackInput, None, itkImageToImageFilterIF3ICVF23)
itkImageToImageFilterIF3ICVF23.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF23_PushFrontInput, None, itkImageToImageFilterIF3ICVF23)
itkImageToImageFilterIF3ICVF23.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF23_PopFrontInput, None, itkImageToImageFilterIF3ICVF23)
itkImageToImageFilterIF3ICVF23.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF23_SetCoordinateTolerance, None, itkImageToImageFilterIF3ICVF23)
itkImageToImageFilterIF3ICVF23.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF23_GetCoordinateTolerance, None, itkImageToImageFilterIF3ICVF23)
itkImageToImageFilterIF3ICVF23.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF23_SetDirectionTolerance, None, itkImageToImageFilterIF3ICVF23)
itkImageToImageFilterIF3ICVF23.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF23_GetDirectionTolerance, None, itkImageToImageFilterIF3ICVF23)
itkImageToImageFilterIF3ICVF23_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF23_swigregister
itkImageToImageFilterIF3ICVF23_swigregister(itkImageToImageFilterIF3ICVF23)

def itkImageToImageFilterIF3ICVF23_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF3ICVF23 *":
    """itkImageToImageFilterIF3ICVF23_cast(itkLightObject obj) -> itkImageToImageFilterIF3ICVF23"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF23_cast(obj)

class itkImageToImageFilterIF3ICVF33(itkImageSourcePython.itkImageSourceICVF33):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIF3ICVF33 self, itkImageF3 image)
        SetInput(itkImageToImageFilterIF3ICVF33 self, unsigned int arg0, itkImageF3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF33_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageF3 const *":
        """
        GetInput(itkImageToImageFilterIF3ICVF33 self) -> itkImageF3
        GetInput(itkImageToImageFilterIF3ICVF33 self, unsigned int idx) -> itkImageF3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF33_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageF3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIF3ICVF33 self, itkImageF3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF33_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIF3ICVF33 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF33_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageF3') -> "void":
        """PushFrontInput(itkImageToImageFilterIF3ICVF33 self, itkImageF3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF33_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIF3ICVF33 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF33_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIF3ICVF33 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF33_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIF3ICVF33 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF33_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIF3ICVF33 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF33_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIF3ICVF33 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF33_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIF3ICVF33

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF3ICVF33 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIF3ICVF33"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF33_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIF3ICVF33

        Create a new object of the class itkImageToImageFilterIF3ICVF33 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIF3ICVF33.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIF3ICVF33.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIF3ICVF33.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIF3ICVF33.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF33_SetInput, None, itkImageToImageFilterIF3ICVF33)
itkImageToImageFilterIF3ICVF33.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF33_GetInput, None, itkImageToImageFilterIF3ICVF33)
itkImageToImageFilterIF3ICVF33.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF33_PushBackInput, None, itkImageToImageFilterIF3ICVF33)
itkImageToImageFilterIF3ICVF33.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF33_PopBackInput, None, itkImageToImageFilterIF3ICVF33)
itkImageToImageFilterIF3ICVF33.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF33_PushFrontInput, None, itkImageToImageFilterIF3ICVF33)
itkImageToImageFilterIF3ICVF33.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF33_PopFrontInput, None, itkImageToImageFilterIF3ICVF33)
itkImageToImageFilterIF3ICVF33.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF33_SetCoordinateTolerance, None, itkImageToImageFilterIF3ICVF33)
itkImageToImageFilterIF3ICVF33.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF33_GetCoordinateTolerance, None, itkImageToImageFilterIF3ICVF33)
itkImageToImageFilterIF3ICVF33.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF33_SetDirectionTolerance, None, itkImageToImageFilterIF3ICVF33)
itkImageToImageFilterIF3ICVF33.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF33_GetDirectionTolerance, None, itkImageToImageFilterIF3ICVF33)
itkImageToImageFilterIF3ICVF33_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF33_swigregister
itkImageToImageFilterIF3ICVF33_swigregister(itkImageToImageFilterIF3ICVF33)

def itkImageToImageFilterIF3ICVF33_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF3ICVF33 *":
    """itkImageToImageFilterIF3ICVF33_cast(itkLightObject obj) -> itkImageToImageFilterIF3ICVF33"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF33_cast(obj)

class itkImageToImageFilterIF3ICVF43(itkImageSourcePython.itkImageSourceICVF43):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIF3ICVF43 self, itkImageF3 image)
        SetInput(itkImageToImageFilterIF3ICVF43 self, unsigned int arg0, itkImageF3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF43_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageF3 const *":
        """
        GetInput(itkImageToImageFilterIF3ICVF43 self) -> itkImageF3
        GetInput(itkImageToImageFilterIF3ICVF43 self, unsigned int idx) -> itkImageF3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF43_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageF3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIF3ICVF43 self, itkImageF3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF43_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIF3ICVF43 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF43_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageF3') -> "void":
        """PushFrontInput(itkImageToImageFilterIF3ICVF43 self, itkImageF3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF43_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIF3ICVF43 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF43_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIF3ICVF43 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF43_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIF3ICVF43 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF43_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIF3ICVF43 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF43_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIF3ICVF43 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF43_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIF3ICVF43

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF3ICVF43 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIF3ICVF43"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF43_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIF3ICVF43

        Create a new object of the class itkImageToImageFilterIF3ICVF43 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIF3ICVF43.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIF3ICVF43.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIF3ICVF43.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIF3ICVF43.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF43_SetInput, None, itkImageToImageFilterIF3ICVF43)
itkImageToImageFilterIF3ICVF43.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF43_GetInput, None, itkImageToImageFilterIF3ICVF43)
itkImageToImageFilterIF3ICVF43.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF43_PushBackInput, None, itkImageToImageFilterIF3ICVF43)
itkImageToImageFilterIF3ICVF43.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF43_PopBackInput, None, itkImageToImageFilterIF3ICVF43)
itkImageToImageFilterIF3ICVF43.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF43_PushFrontInput, None, itkImageToImageFilterIF3ICVF43)
itkImageToImageFilterIF3ICVF43.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF43_PopFrontInput, None, itkImageToImageFilterIF3ICVF43)
itkImageToImageFilterIF3ICVF43.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF43_SetCoordinateTolerance, None, itkImageToImageFilterIF3ICVF43)
itkImageToImageFilterIF3ICVF43.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF43_GetCoordinateTolerance, None, itkImageToImageFilterIF3ICVF43)
itkImageToImageFilterIF3ICVF43.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF43_SetDirectionTolerance, None, itkImageToImageFilterIF3ICVF43)
itkImageToImageFilterIF3ICVF43.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF43_GetDirectionTolerance, None, itkImageToImageFilterIF3ICVF43)
itkImageToImageFilterIF3ICVF43_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF43_swigregister
itkImageToImageFilterIF3ICVF43_swigregister(itkImageToImageFilterIF3ICVF43)

def itkImageToImageFilterIF3ICVF43_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF3ICVF43 *":
    """itkImageToImageFilterIF3ICVF43_cast(itkLightObject obj) -> itkImageToImageFilterIF3ICVF43"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ICVF43_cast(obj)

class itkImageToImageFilterIF3IF2(itkImageSourcePython.itkImageSourceIF2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIF3IF2 self, itkImageF3 image)
        SetInput(itkImageToImageFilterIF3IF2 self, unsigned int arg0, itkImageF3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IF2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageF3 const *":
        """
        GetInput(itkImageToImageFilterIF3IF2 self) -> itkImageF3
        GetInput(itkImageToImageFilterIF3IF2 self, unsigned int idx) -> itkImageF3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IF2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageF3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIF3IF2 self, itkImageF3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IF2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIF3IF2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IF2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageF3') -> "void":
        """PushFrontInput(itkImageToImageFilterIF3IF2 self, itkImageF3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IF2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIF3IF2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IF2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIF3IF2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IF2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIF3IF2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IF2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIF3IF2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IF2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIF3IF2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IF2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIF3IF2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF3IF2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIF3IF2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IF2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIF3IF2

        Create a new object of the class itkImageToImageFilterIF3IF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIF3IF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIF3IF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIF3IF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIF3IF2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3IF2_SetInput, None, itkImageToImageFilterIF3IF2)
itkImageToImageFilterIF3IF2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3IF2_GetInput, None, itkImageToImageFilterIF3IF2)
itkImageToImageFilterIF3IF2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3IF2_PushBackInput, None, itkImageToImageFilterIF3IF2)
itkImageToImageFilterIF3IF2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3IF2_PopBackInput, None, itkImageToImageFilterIF3IF2)
itkImageToImageFilterIF3IF2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3IF2_PushFrontInput, None, itkImageToImageFilterIF3IF2)
itkImageToImageFilterIF3IF2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3IF2_PopFrontInput, None, itkImageToImageFilterIF3IF2)
itkImageToImageFilterIF3IF2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3IF2_SetCoordinateTolerance, None, itkImageToImageFilterIF3IF2)
itkImageToImageFilterIF3IF2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3IF2_GetCoordinateTolerance, None, itkImageToImageFilterIF3IF2)
itkImageToImageFilterIF3IF2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3IF2_SetDirectionTolerance, None, itkImageToImageFilterIF3IF2)
itkImageToImageFilterIF3IF2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3IF2_GetDirectionTolerance, None, itkImageToImageFilterIF3IF2)
itkImageToImageFilterIF3IF2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIF3IF2_swigregister
itkImageToImageFilterIF3IF2_swigregister(itkImageToImageFilterIF3IF2)

def itkImageToImageFilterIF3IF2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF3IF2 *":
    """itkImageToImageFilterIF3IF2_cast(itkLightObject obj) -> itkImageToImageFilterIF3IF2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IF2_cast(obj)

class itkImageToImageFilterIF3IRGBAUC3(itkImageSourcePython.itkImageSourceIRGBAUC3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIF3IRGBAUC3 self, itkImageF3 image)
        SetInput(itkImageToImageFilterIF3IRGBAUC3 self, unsigned int arg0, itkImageF3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IRGBAUC3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageF3 const *":
        """
        GetInput(itkImageToImageFilterIF3IRGBAUC3 self) -> itkImageF3
        GetInput(itkImageToImageFilterIF3IRGBAUC3 self, unsigned int idx) -> itkImageF3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IRGBAUC3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageF3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIF3IRGBAUC3 self, itkImageF3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IRGBAUC3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIF3IRGBAUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IRGBAUC3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageF3') -> "void":
        """PushFrontInput(itkImageToImageFilterIF3IRGBAUC3 self, itkImageF3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IRGBAUC3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIF3IRGBAUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IRGBAUC3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIF3IRGBAUC3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IRGBAUC3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIF3IRGBAUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IRGBAUC3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIF3IRGBAUC3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IRGBAUC3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIF3IRGBAUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IRGBAUC3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIF3IRGBAUC3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF3IRGBAUC3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIF3IRGBAUC3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IRGBAUC3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIF3IRGBAUC3

        Create a new object of the class itkImageToImageFilterIF3IRGBAUC3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIF3IRGBAUC3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIF3IRGBAUC3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIF3IRGBAUC3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIF3IRGBAUC3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3IRGBAUC3_SetInput, None, itkImageToImageFilterIF3IRGBAUC3)
itkImageToImageFilterIF3IRGBAUC3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3IRGBAUC3_GetInput, None, itkImageToImageFilterIF3IRGBAUC3)
itkImageToImageFilterIF3IRGBAUC3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3IRGBAUC3_PushBackInput, None, itkImageToImageFilterIF3IRGBAUC3)
itkImageToImageFilterIF3IRGBAUC3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3IRGBAUC3_PopBackInput, None, itkImageToImageFilterIF3IRGBAUC3)
itkImageToImageFilterIF3IRGBAUC3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3IRGBAUC3_PushFrontInput, None, itkImageToImageFilterIF3IRGBAUC3)
itkImageToImageFilterIF3IRGBAUC3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3IRGBAUC3_PopFrontInput, None, itkImageToImageFilterIF3IRGBAUC3)
itkImageToImageFilterIF3IRGBAUC3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3IRGBAUC3_SetCoordinateTolerance, None, itkImageToImageFilterIF3IRGBAUC3)
itkImageToImageFilterIF3IRGBAUC3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3IRGBAUC3_GetCoordinateTolerance, None, itkImageToImageFilterIF3IRGBAUC3)
itkImageToImageFilterIF3IRGBAUC3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3IRGBAUC3_SetDirectionTolerance, None, itkImageToImageFilterIF3IRGBAUC3)
itkImageToImageFilterIF3IRGBAUC3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3IRGBAUC3_GetDirectionTolerance, None, itkImageToImageFilterIF3IRGBAUC3)
itkImageToImageFilterIF3IRGBAUC3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIF3IRGBAUC3_swigregister
itkImageToImageFilterIF3IRGBAUC3_swigregister(itkImageToImageFilterIF3IRGBAUC3)

def itkImageToImageFilterIF3IRGBAUC3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF3IRGBAUC3 *":
    """itkImageToImageFilterIF3IRGBAUC3_cast(itkLightObject obj) -> itkImageToImageFilterIF3IRGBAUC3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IRGBAUC3_cast(obj)

class itkImageToImageFilterIF3IRGBUC3(itkImageSourcePython.itkImageSourceIRGBUC3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIF3IRGBUC3 self, itkImageF3 image)
        SetInput(itkImageToImageFilterIF3IRGBUC3 self, unsigned int arg0, itkImageF3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IRGBUC3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageF3 const *":
        """
        GetInput(itkImageToImageFilterIF3IRGBUC3 self) -> itkImageF3
        GetInput(itkImageToImageFilterIF3IRGBUC3 self, unsigned int idx) -> itkImageF3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IRGBUC3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageF3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIF3IRGBUC3 self, itkImageF3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IRGBUC3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIF3IRGBUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IRGBUC3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageF3') -> "void":
        """PushFrontInput(itkImageToImageFilterIF3IRGBUC3 self, itkImageF3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IRGBUC3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIF3IRGBUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IRGBUC3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIF3IRGBUC3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IRGBUC3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIF3IRGBUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IRGBUC3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIF3IRGBUC3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IRGBUC3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIF3IRGBUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IRGBUC3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIF3IRGBUC3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF3IRGBUC3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIF3IRGBUC3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IRGBUC3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIF3IRGBUC3

        Create a new object of the class itkImageToImageFilterIF3IRGBUC3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIF3IRGBUC3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIF3IRGBUC3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIF3IRGBUC3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIF3IRGBUC3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3IRGBUC3_SetInput, None, itkImageToImageFilterIF3IRGBUC3)
itkImageToImageFilterIF3IRGBUC3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3IRGBUC3_GetInput, None, itkImageToImageFilterIF3IRGBUC3)
itkImageToImageFilterIF3IRGBUC3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3IRGBUC3_PushBackInput, None, itkImageToImageFilterIF3IRGBUC3)
itkImageToImageFilterIF3IRGBUC3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3IRGBUC3_PopBackInput, None, itkImageToImageFilterIF3IRGBUC3)
itkImageToImageFilterIF3IRGBUC3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3IRGBUC3_PushFrontInput, None, itkImageToImageFilterIF3IRGBUC3)
itkImageToImageFilterIF3IRGBUC3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3IRGBUC3_PopFrontInput, None, itkImageToImageFilterIF3IRGBUC3)
itkImageToImageFilterIF3IRGBUC3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3IRGBUC3_SetCoordinateTolerance, None, itkImageToImageFilterIF3IRGBUC3)
itkImageToImageFilterIF3IRGBUC3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3IRGBUC3_GetCoordinateTolerance, None, itkImageToImageFilterIF3IRGBUC3)
itkImageToImageFilterIF3IRGBUC3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3IRGBUC3_SetDirectionTolerance, None, itkImageToImageFilterIF3IRGBUC3)
itkImageToImageFilterIF3IRGBUC3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3IRGBUC3_GetDirectionTolerance, None, itkImageToImageFilterIF3IRGBUC3)
itkImageToImageFilterIF3IRGBUC3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIF3IRGBUC3_swigregister
itkImageToImageFilterIF3IRGBUC3_swigregister(itkImageToImageFilterIF3IRGBUC3)

def itkImageToImageFilterIF3IRGBUC3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF3IRGBUC3 *":
    """itkImageToImageFilterIF3IRGBUC3_cast(itkLightObject obj) -> itkImageToImageFilterIF3IRGBUC3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IRGBUC3_cast(obj)

class itkImageToImageFilterIF3ISSRTD33(itkImageSourcePython.itkImageSourceISSRTD33):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIF3ISSRTD33 self, itkImageF3 image)
        SetInput(itkImageToImageFilterIF3ISSRTD33 self, unsigned int arg0, itkImageF3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ISSRTD33_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageF3 const *":
        """
        GetInput(itkImageToImageFilterIF3ISSRTD33 self) -> itkImageF3
        GetInput(itkImageToImageFilterIF3ISSRTD33 self, unsigned int idx) -> itkImageF3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ISSRTD33_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageF3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIF3ISSRTD33 self, itkImageF3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ISSRTD33_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIF3ISSRTD33 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ISSRTD33_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageF3') -> "void":
        """PushFrontInput(itkImageToImageFilterIF3ISSRTD33 self, itkImageF3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ISSRTD33_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIF3ISSRTD33 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ISSRTD33_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIF3ISSRTD33 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ISSRTD33_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIF3ISSRTD33 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ISSRTD33_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIF3ISSRTD33 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ISSRTD33_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIF3ISSRTD33 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ISSRTD33_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIF3ISSRTD33

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF3ISSRTD33 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIF3ISSRTD33"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ISSRTD33_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIF3ISSRTD33

        Create a new object of the class itkImageToImageFilterIF3ISSRTD33 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIF3ISSRTD33.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIF3ISSRTD33.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIF3ISSRTD33.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIF3ISSRTD33.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3ISSRTD33_SetInput, None, itkImageToImageFilterIF3ISSRTD33)
itkImageToImageFilterIF3ISSRTD33.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3ISSRTD33_GetInput, None, itkImageToImageFilterIF3ISSRTD33)
itkImageToImageFilterIF3ISSRTD33.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3ISSRTD33_PushBackInput, None, itkImageToImageFilterIF3ISSRTD33)
itkImageToImageFilterIF3ISSRTD33.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3ISSRTD33_PopBackInput, None, itkImageToImageFilterIF3ISSRTD33)
itkImageToImageFilterIF3ISSRTD33.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3ISSRTD33_PushFrontInput, None, itkImageToImageFilterIF3ISSRTD33)
itkImageToImageFilterIF3ISSRTD33.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3ISSRTD33_PopFrontInput, None, itkImageToImageFilterIF3ISSRTD33)
itkImageToImageFilterIF3ISSRTD33.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3ISSRTD33_SetCoordinateTolerance, None, itkImageToImageFilterIF3ISSRTD33)
itkImageToImageFilterIF3ISSRTD33.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3ISSRTD33_GetCoordinateTolerance, None, itkImageToImageFilterIF3ISSRTD33)
itkImageToImageFilterIF3ISSRTD33.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3ISSRTD33_SetDirectionTolerance, None, itkImageToImageFilterIF3ISSRTD33)
itkImageToImageFilterIF3ISSRTD33.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3ISSRTD33_GetDirectionTolerance, None, itkImageToImageFilterIF3ISSRTD33)
itkImageToImageFilterIF3ISSRTD33_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIF3ISSRTD33_swigregister
itkImageToImageFilterIF3ISSRTD33_swigregister(itkImageToImageFilterIF3ISSRTD33)

def itkImageToImageFilterIF3ISSRTD33_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF3ISSRTD33 *":
    """itkImageToImageFilterIF3ISSRTD33_cast(itkLightObject obj) -> itkImageToImageFilterIF3ISSRTD33"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIF3ISSRTD33_cast(obj)

class itkImageToImageFilterIF3IVF23(itkImageSourcePython.itkImageSourceIVF23):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIF3IVF23 self, itkImageF3 image)
        SetInput(itkImageToImageFilterIF3IVF23 self, unsigned int arg0, itkImageF3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF23_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageF3 const *":
        """
        GetInput(itkImageToImageFilterIF3IVF23 self) -> itkImageF3
        GetInput(itkImageToImageFilterIF3IVF23 self, unsigned int idx) -> itkImageF3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF23_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageF3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIF3IVF23 self, itkImageF3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF23_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIF3IVF23 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF23_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageF3') -> "void":
        """PushFrontInput(itkImageToImageFilterIF3IVF23 self, itkImageF3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF23_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIF3IVF23 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF23_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIF3IVF23 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF23_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIF3IVF23 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF23_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIF3IVF23 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF23_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIF3IVF23 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF23_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIF3IVF23

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF3IVF23 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIF3IVF23"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF23_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIF3IVF23

        Create a new object of the class itkImageToImageFilterIF3IVF23 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIF3IVF23.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIF3IVF23.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIF3IVF23.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIF3IVF23.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF23_SetInput, None, itkImageToImageFilterIF3IVF23)
itkImageToImageFilterIF3IVF23.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF23_GetInput, None, itkImageToImageFilterIF3IVF23)
itkImageToImageFilterIF3IVF23.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF23_PushBackInput, None, itkImageToImageFilterIF3IVF23)
itkImageToImageFilterIF3IVF23.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF23_PopBackInput, None, itkImageToImageFilterIF3IVF23)
itkImageToImageFilterIF3IVF23.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF23_PushFrontInput, None, itkImageToImageFilterIF3IVF23)
itkImageToImageFilterIF3IVF23.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF23_PopFrontInput, None, itkImageToImageFilterIF3IVF23)
itkImageToImageFilterIF3IVF23.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF23_SetCoordinateTolerance, None, itkImageToImageFilterIF3IVF23)
itkImageToImageFilterIF3IVF23.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF23_GetCoordinateTolerance, None, itkImageToImageFilterIF3IVF23)
itkImageToImageFilterIF3IVF23.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF23_SetDirectionTolerance, None, itkImageToImageFilterIF3IVF23)
itkImageToImageFilterIF3IVF23.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF23_GetDirectionTolerance, None, itkImageToImageFilterIF3IVF23)
itkImageToImageFilterIF3IVF23_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF23_swigregister
itkImageToImageFilterIF3IVF23_swigregister(itkImageToImageFilterIF3IVF23)

def itkImageToImageFilterIF3IVF23_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF3IVF23 *":
    """itkImageToImageFilterIF3IVF23_cast(itkLightObject obj) -> itkImageToImageFilterIF3IVF23"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF23_cast(obj)

class itkImageToImageFilterIF3IVF33(itkImageSourcePython.itkImageSourceIVF33):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIF3IVF33 self, itkImageF3 image)
        SetInput(itkImageToImageFilterIF3IVF33 self, unsigned int arg0, itkImageF3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF33_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageF3 const *":
        """
        GetInput(itkImageToImageFilterIF3IVF33 self) -> itkImageF3
        GetInput(itkImageToImageFilterIF3IVF33 self, unsigned int idx) -> itkImageF3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF33_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageF3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIF3IVF33 self, itkImageF3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF33_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIF3IVF33 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF33_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageF3') -> "void":
        """PushFrontInput(itkImageToImageFilterIF3IVF33 self, itkImageF3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF33_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIF3IVF33 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF33_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIF3IVF33 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF33_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIF3IVF33 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF33_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIF3IVF33 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF33_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIF3IVF33 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF33_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIF3IVF33

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF3IVF33 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIF3IVF33"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF33_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIF3IVF33

        Create a new object of the class itkImageToImageFilterIF3IVF33 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIF3IVF33.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIF3IVF33.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIF3IVF33.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIF3IVF33.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF33_SetInput, None, itkImageToImageFilterIF3IVF33)
itkImageToImageFilterIF3IVF33.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF33_GetInput, None, itkImageToImageFilterIF3IVF33)
itkImageToImageFilterIF3IVF33.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF33_PushBackInput, None, itkImageToImageFilterIF3IVF33)
itkImageToImageFilterIF3IVF33.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF33_PopBackInput, None, itkImageToImageFilterIF3IVF33)
itkImageToImageFilterIF3IVF33.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF33_PushFrontInput, None, itkImageToImageFilterIF3IVF33)
itkImageToImageFilterIF3IVF33.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF33_PopFrontInput, None, itkImageToImageFilterIF3IVF33)
itkImageToImageFilterIF3IVF33.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF33_SetCoordinateTolerance, None, itkImageToImageFilterIF3IVF33)
itkImageToImageFilterIF3IVF33.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF33_GetCoordinateTolerance, None, itkImageToImageFilterIF3IVF33)
itkImageToImageFilterIF3IVF33.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF33_SetDirectionTolerance, None, itkImageToImageFilterIF3IVF33)
itkImageToImageFilterIF3IVF33.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF33_GetDirectionTolerance, None, itkImageToImageFilterIF3IVF33)
itkImageToImageFilterIF3IVF33_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF33_swigregister
itkImageToImageFilterIF3IVF33_swigregister(itkImageToImageFilterIF3IVF33)

def itkImageToImageFilterIF3IVF33_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF3IVF33 *":
    """itkImageToImageFilterIF3IVF33_cast(itkLightObject obj) -> itkImageToImageFilterIF3IVF33"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF33_cast(obj)

class itkImageToImageFilterIF3IVF43(itkImageSourcePython.itkImageSourceIVF43):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIF3IVF43 self, itkImageF3 image)
        SetInput(itkImageToImageFilterIF3IVF43 self, unsigned int arg0, itkImageF3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF43_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageF3 const *":
        """
        GetInput(itkImageToImageFilterIF3IVF43 self) -> itkImageF3
        GetInput(itkImageToImageFilterIF3IVF43 self, unsigned int idx) -> itkImageF3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF43_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageF3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIF3IVF43 self, itkImageF3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF43_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIF3IVF43 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF43_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageF3') -> "void":
        """PushFrontInput(itkImageToImageFilterIF3IVF43 self, itkImageF3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF43_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIF3IVF43 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF43_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIF3IVF43 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF43_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIF3IVF43 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF43_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIF3IVF43 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF43_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIF3IVF43 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF43_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIF3IVF43

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF3IVF43 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIF3IVF43"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF43_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIF3IVF43

        Create a new object of the class itkImageToImageFilterIF3IVF43 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIF3IVF43.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIF3IVF43.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIF3IVF43.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIF3IVF43.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF43_SetInput, None, itkImageToImageFilterIF3IVF43)
itkImageToImageFilterIF3IVF43.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF43_GetInput, None, itkImageToImageFilterIF3IVF43)
itkImageToImageFilterIF3IVF43.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF43_PushBackInput, None, itkImageToImageFilterIF3IVF43)
itkImageToImageFilterIF3IVF43.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF43_PopBackInput, None, itkImageToImageFilterIF3IVF43)
itkImageToImageFilterIF3IVF43.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF43_PushFrontInput, None, itkImageToImageFilterIF3IVF43)
itkImageToImageFilterIF3IVF43.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF43_PopFrontInput, None, itkImageToImageFilterIF3IVF43)
itkImageToImageFilterIF3IVF43.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF43_SetCoordinateTolerance, None, itkImageToImageFilterIF3IVF43)
itkImageToImageFilterIF3IVF43.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF43_GetCoordinateTolerance, None, itkImageToImageFilterIF3IVF43)
itkImageToImageFilterIF3IVF43.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF43_SetDirectionTolerance, None, itkImageToImageFilterIF3IVF43)
itkImageToImageFilterIF3IVF43.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF43_GetDirectionTolerance, None, itkImageToImageFilterIF3IVF43)
itkImageToImageFilterIF3IVF43_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF43_swigregister
itkImageToImageFilterIF3IVF43_swigregister(itkImageToImageFilterIF3IVF43)

def itkImageToImageFilterIF3IVF43_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF3IVF43 *":
    """itkImageToImageFilterIF3IVF43_cast(itkLightObject obj) -> itkImageToImageFilterIF3IVF43"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIF3IVF43_cast(obj)

class itkImageToImageFilterIF3VID3(itkImageSourcePython.itkImageSourceVID3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIF3VID3 self, itkImageF3 image)
        SetInput(itkImageToImageFilterIF3VID3 self, unsigned int arg0, itkImageF3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3VID3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageF3 const *":
        """
        GetInput(itkImageToImageFilterIF3VID3 self) -> itkImageF3
        GetInput(itkImageToImageFilterIF3VID3 self, unsigned int idx) -> itkImageF3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3VID3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageF3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIF3VID3 self, itkImageF3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3VID3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIF3VID3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3VID3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageF3') -> "void":
        """PushFrontInput(itkImageToImageFilterIF3VID3 self, itkImageF3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3VID3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIF3VID3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3VID3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIF3VID3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3VID3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIF3VID3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3VID3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIF3VID3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3VID3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIF3VID3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3VID3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIF3VID3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF3VID3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIF3VID3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3VID3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIF3VID3

        Create a new object of the class itkImageToImageFilterIF3VID3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIF3VID3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIF3VID3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIF3VID3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIF3VID3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3VID3_SetInput, None, itkImageToImageFilterIF3VID3)
itkImageToImageFilterIF3VID3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3VID3_GetInput, None, itkImageToImageFilterIF3VID3)
itkImageToImageFilterIF3VID3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3VID3_PushBackInput, None, itkImageToImageFilterIF3VID3)
itkImageToImageFilterIF3VID3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3VID3_PopBackInput, None, itkImageToImageFilterIF3VID3)
itkImageToImageFilterIF3VID3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3VID3_PushFrontInput, None, itkImageToImageFilterIF3VID3)
itkImageToImageFilterIF3VID3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3VID3_PopFrontInput, None, itkImageToImageFilterIF3VID3)
itkImageToImageFilterIF3VID3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3VID3_SetCoordinateTolerance, None, itkImageToImageFilterIF3VID3)
itkImageToImageFilterIF3VID3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3VID3_GetCoordinateTolerance, None, itkImageToImageFilterIF3VID3)
itkImageToImageFilterIF3VID3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3VID3_SetDirectionTolerance, None, itkImageToImageFilterIF3VID3)
itkImageToImageFilterIF3VID3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3VID3_GetDirectionTolerance, None, itkImageToImageFilterIF3VID3)
itkImageToImageFilterIF3VID3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIF3VID3_swigregister
itkImageToImageFilterIF3VID3_swigregister(itkImageToImageFilterIF3VID3)

def itkImageToImageFilterIF3VID3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF3VID3 *":
    """itkImageToImageFilterIF3VID3_cast(itkLightObject obj) -> itkImageToImageFilterIF3VID3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIF3VID3_cast(obj)

class itkImageToImageFilterIF3VIF3(itkImageSourcePython.itkImageSourceVIF3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIF3VIF3 self, itkImageF3 image)
        SetInput(itkImageToImageFilterIF3VIF3 self, unsigned int arg0, itkImageF3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3VIF3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageF3 const *":
        """
        GetInput(itkImageToImageFilterIF3VIF3 self) -> itkImageF3
        GetInput(itkImageToImageFilterIF3VIF3 self, unsigned int idx) -> itkImageF3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3VIF3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageF3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIF3VIF3 self, itkImageF3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3VIF3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIF3VIF3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3VIF3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageF3') -> "void":
        """PushFrontInput(itkImageToImageFilterIF3VIF3 self, itkImageF3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3VIF3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIF3VIF3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3VIF3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIF3VIF3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3VIF3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIF3VIF3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3VIF3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIF3VIF3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3VIF3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIF3VIF3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3VIF3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIF3VIF3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF3VIF3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIF3VIF3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3VIF3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIF3VIF3

        Create a new object of the class itkImageToImageFilterIF3VIF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIF3VIF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIF3VIF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIF3VIF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIF3VIF3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3VIF3_SetInput, None, itkImageToImageFilterIF3VIF3)
itkImageToImageFilterIF3VIF3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3VIF3_GetInput, None, itkImageToImageFilterIF3VIF3)
itkImageToImageFilterIF3VIF3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3VIF3_PushBackInput, None, itkImageToImageFilterIF3VIF3)
itkImageToImageFilterIF3VIF3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3VIF3_PopBackInput, None, itkImageToImageFilterIF3VIF3)
itkImageToImageFilterIF3VIF3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3VIF3_PushFrontInput, None, itkImageToImageFilterIF3VIF3)
itkImageToImageFilterIF3VIF3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3VIF3_PopFrontInput, None, itkImageToImageFilterIF3VIF3)
itkImageToImageFilterIF3VIF3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3VIF3_SetCoordinateTolerance, None, itkImageToImageFilterIF3VIF3)
itkImageToImageFilterIF3VIF3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3VIF3_GetCoordinateTolerance, None, itkImageToImageFilterIF3VIF3)
itkImageToImageFilterIF3VIF3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3VIF3_SetDirectionTolerance, None, itkImageToImageFilterIF3VIF3)
itkImageToImageFilterIF3VIF3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3VIF3_GetDirectionTolerance, None, itkImageToImageFilterIF3VIF3)
itkImageToImageFilterIF3VIF3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIF3VIF3_swigregister
itkImageToImageFilterIF3VIF3_swigregister(itkImageToImageFilterIF3VIF3)

def itkImageToImageFilterIF3VIF3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF3VIF3 *":
    """itkImageToImageFilterIF3VIF3_cast(itkLightObject obj) -> itkImageToImageFilterIF3VIF3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIF3VIF3_cast(obj)

class itkImageToImageFilterIF3VISS3(itkImageSourcePython.itkImageSourceVISS3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIF3VISS3 self, itkImageF3 image)
        SetInput(itkImageToImageFilterIF3VISS3 self, unsigned int arg0, itkImageF3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3VISS3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageF3 const *":
        """
        GetInput(itkImageToImageFilterIF3VISS3 self) -> itkImageF3
        GetInput(itkImageToImageFilterIF3VISS3 self, unsigned int idx) -> itkImageF3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3VISS3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageF3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIF3VISS3 self, itkImageF3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3VISS3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIF3VISS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3VISS3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageF3') -> "void":
        """PushFrontInput(itkImageToImageFilterIF3VISS3 self, itkImageF3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3VISS3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIF3VISS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3VISS3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIF3VISS3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3VISS3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIF3VISS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3VISS3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIF3VISS3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3VISS3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIF3VISS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3VISS3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIF3VISS3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF3VISS3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIF3VISS3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3VISS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIF3VISS3

        Create a new object of the class itkImageToImageFilterIF3VISS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIF3VISS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIF3VISS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIF3VISS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIF3VISS3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3VISS3_SetInput, None, itkImageToImageFilterIF3VISS3)
itkImageToImageFilterIF3VISS3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3VISS3_GetInput, None, itkImageToImageFilterIF3VISS3)
itkImageToImageFilterIF3VISS3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3VISS3_PushBackInput, None, itkImageToImageFilterIF3VISS3)
itkImageToImageFilterIF3VISS3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3VISS3_PopBackInput, None, itkImageToImageFilterIF3VISS3)
itkImageToImageFilterIF3VISS3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3VISS3_PushFrontInput, None, itkImageToImageFilterIF3VISS3)
itkImageToImageFilterIF3VISS3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3VISS3_PopFrontInput, None, itkImageToImageFilterIF3VISS3)
itkImageToImageFilterIF3VISS3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3VISS3_SetCoordinateTolerance, None, itkImageToImageFilterIF3VISS3)
itkImageToImageFilterIF3VISS3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3VISS3_GetCoordinateTolerance, None, itkImageToImageFilterIF3VISS3)
itkImageToImageFilterIF3VISS3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3VISS3_SetDirectionTolerance, None, itkImageToImageFilterIF3VISS3)
itkImageToImageFilterIF3VISS3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3VISS3_GetDirectionTolerance, None, itkImageToImageFilterIF3VISS3)
itkImageToImageFilterIF3VISS3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIF3VISS3_swigregister
itkImageToImageFilterIF3VISS3_swigregister(itkImageToImageFilterIF3VISS3)

def itkImageToImageFilterIF3VISS3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF3VISS3 *":
    """itkImageToImageFilterIF3VISS3_cast(itkLightObject obj) -> itkImageToImageFilterIF3VISS3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIF3VISS3_cast(obj)

class itkImageToImageFilterIF3VIUC3(itkImageSourcePython.itkImageSourceVIUC3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIF3VIUC3 self, itkImageF3 image)
        SetInput(itkImageToImageFilterIF3VIUC3 self, unsigned int arg0, itkImageF3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3VIUC3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageF3 const *":
        """
        GetInput(itkImageToImageFilterIF3VIUC3 self) -> itkImageF3
        GetInput(itkImageToImageFilterIF3VIUC3 self, unsigned int idx) -> itkImageF3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3VIUC3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageF3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIF3VIUC3 self, itkImageF3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3VIUC3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIF3VIUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3VIUC3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageF3') -> "void":
        """PushFrontInput(itkImageToImageFilterIF3VIUC3 self, itkImageF3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3VIUC3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIF3VIUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3VIUC3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIF3VIUC3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3VIUC3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIF3VIUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3VIUC3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIF3VIUC3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3VIUC3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIF3VIUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3VIUC3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIF3VIUC3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF3VIUC3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIF3VIUC3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3VIUC3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIF3VIUC3

        Create a new object of the class itkImageToImageFilterIF3VIUC3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIF3VIUC3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIF3VIUC3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIF3VIUC3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIF3VIUC3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3VIUC3_SetInput, None, itkImageToImageFilterIF3VIUC3)
itkImageToImageFilterIF3VIUC3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3VIUC3_GetInput, None, itkImageToImageFilterIF3VIUC3)
itkImageToImageFilterIF3VIUC3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3VIUC3_PushBackInput, None, itkImageToImageFilterIF3VIUC3)
itkImageToImageFilterIF3VIUC3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3VIUC3_PopBackInput, None, itkImageToImageFilterIF3VIUC3)
itkImageToImageFilterIF3VIUC3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3VIUC3_PushFrontInput, None, itkImageToImageFilterIF3VIUC3)
itkImageToImageFilterIF3VIUC3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3VIUC3_PopFrontInput, None, itkImageToImageFilterIF3VIUC3)
itkImageToImageFilterIF3VIUC3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3VIUC3_SetCoordinateTolerance, None, itkImageToImageFilterIF3VIUC3)
itkImageToImageFilterIF3VIUC3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3VIUC3_GetCoordinateTolerance, None, itkImageToImageFilterIF3VIUC3)
itkImageToImageFilterIF3VIUC3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3VIUC3_SetDirectionTolerance, None, itkImageToImageFilterIF3VIUC3)
itkImageToImageFilterIF3VIUC3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3VIUC3_GetDirectionTolerance, None, itkImageToImageFilterIF3VIUC3)
itkImageToImageFilterIF3VIUC3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIF3VIUC3_swigregister
itkImageToImageFilterIF3VIUC3_swigregister(itkImageToImageFilterIF3VIUC3)

def itkImageToImageFilterIF3VIUC3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF3VIUC3 *":
    """itkImageToImageFilterIF3VIUC3_cast(itkLightObject obj) -> itkImageToImageFilterIF3VIUC3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIF3VIUC3_cast(obj)

class itkImageToImageFilterIF3VIUS3(itkImageSourcePython.itkImageSourceVIUS3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIF3VIUS3 self, itkImageF3 image)
        SetInput(itkImageToImageFilterIF3VIUS3 self, unsigned int arg0, itkImageF3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3VIUS3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageF3 const *":
        """
        GetInput(itkImageToImageFilterIF3VIUS3 self) -> itkImageF3
        GetInput(itkImageToImageFilterIF3VIUS3 self, unsigned int idx) -> itkImageF3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3VIUS3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageF3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIF3VIUS3 self, itkImageF3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3VIUS3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIF3VIUS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3VIUS3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageF3') -> "void":
        """PushFrontInput(itkImageToImageFilterIF3VIUS3 self, itkImageF3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3VIUS3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIF3VIUS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3VIUS3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIF3VIUS3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3VIUS3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIF3VIUS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3VIUS3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIF3VIUS3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3VIUS3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIF3VIUS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3VIUS3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIF3VIUS3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF3VIUS3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIF3VIUS3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIF3VIUS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIF3VIUS3

        Create a new object of the class itkImageToImageFilterIF3VIUS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIF3VIUS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIF3VIUS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIF3VIUS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIF3VIUS3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3VIUS3_SetInput, None, itkImageToImageFilterIF3VIUS3)
itkImageToImageFilterIF3VIUS3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3VIUS3_GetInput, None, itkImageToImageFilterIF3VIUS3)
itkImageToImageFilterIF3VIUS3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3VIUS3_PushBackInput, None, itkImageToImageFilterIF3VIUS3)
itkImageToImageFilterIF3VIUS3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3VIUS3_PopBackInput, None, itkImageToImageFilterIF3VIUS3)
itkImageToImageFilterIF3VIUS3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3VIUS3_PushFrontInput, None, itkImageToImageFilterIF3VIUS3)
itkImageToImageFilterIF3VIUS3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3VIUS3_PopFrontInput, None, itkImageToImageFilterIF3VIUS3)
itkImageToImageFilterIF3VIUS3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3VIUS3_SetCoordinateTolerance, None, itkImageToImageFilterIF3VIUS3)
itkImageToImageFilterIF3VIUS3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3VIUS3_GetCoordinateTolerance, None, itkImageToImageFilterIF3VIUS3)
itkImageToImageFilterIF3VIUS3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3VIUS3_SetDirectionTolerance, None, itkImageToImageFilterIF3VIUS3)
itkImageToImageFilterIF3VIUS3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIF3VIUS3_GetDirectionTolerance, None, itkImageToImageFilterIF3VIUS3)
itkImageToImageFilterIF3VIUS3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIF3VIUS3_swigregister
itkImageToImageFilterIF3VIUS3_swigregister(itkImageToImageFilterIF3VIUS3)

def itkImageToImageFilterIF3VIUS3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF3VIUS3 *":
    """itkImageToImageFilterIF3VIUS3_cast(itkLightObject obj) -> itkImageToImageFilterIF3VIUS3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIF3VIUS3_cast(obj)

class itkImageToImageFilterIRGBAUC2ID2(itkImageSourcePython.itkImageSourceID2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIRGBAUC2ID2 self, itkImageRGBAUC2 image)
        SetInput(itkImageToImageFilterIRGBAUC2ID2 self, unsigned int arg0, itkImageRGBAUC2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2ID2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageRGBAUC2 const *":
        """
        GetInput(itkImageToImageFilterIRGBAUC2ID2 self) -> itkImageRGBAUC2
        GetInput(itkImageToImageFilterIRGBAUC2ID2 self, unsigned int idx) -> itkImageRGBAUC2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2ID2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageRGBAUC2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIRGBAUC2ID2 self, itkImageRGBAUC2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2ID2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIRGBAUC2ID2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2ID2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageRGBAUC2') -> "void":
        """PushFrontInput(itkImageToImageFilterIRGBAUC2ID2 self, itkImageRGBAUC2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2ID2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIRGBAUC2ID2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2ID2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIRGBAUC2ID2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2ID2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIRGBAUC2ID2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2ID2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIRGBAUC2ID2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2ID2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIRGBAUC2ID2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2ID2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIRGBAUC2ID2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIRGBAUC2ID2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIRGBAUC2ID2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2ID2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIRGBAUC2ID2

        Create a new object of the class itkImageToImageFilterIRGBAUC2ID2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIRGBAUC2ID2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIRGBAUC2ID2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIRGBAUC2ID2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIRGBAUC2ID2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2ID2_SetInput, None, itkImageToImageFilterIRGBAUC2ID2)
itkImageToImageFilterIRGBAUC2ID2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2ID2_GetInput, None, itkImageToImageFilterIRGBAUC2ID2)
itkImageToImageFilterIRGBAUC2ID2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2ID2_PushBackInput, None, itkImageToImageFilterIRGBAUC2ID2)
itkImageToImageFilterIRGBAUC2ID2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2ID2_PopBackInput, None, itkImageToImageFilterIRGBAUC2ID2)
itkImageToImageFilterIRGBAUC2ID2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2ID2_PushFrontInput, None, itkImageToImageFilterIRGBAUC2ID2)
itkImageToImageFilterIRGBAUC2ID2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2ID2_PopFrontInput, None, itkImageToImageFilterIRGBAUC2ID2)
itkImageToImageFilterIRGBAUC2ID2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2ID2_SetCoordinateTolerance, None, itkImageToImageFilterIRGBAUC2ID2)
itkImageToImageFilterIRGBAUC2ID2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2ID2_GetCoordinateTolerance, None, itkImageToImageFilterIRGBAUC2ID2)
itkImageToImageFilterIRGBAUC2ID2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2ID2_SetDirectionTolerance, None, itkImageToImageFilterIRGBAUC2ID2)
itkImageToImageFilterIRGBAUC2ID2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2ID2_GetDirectionTolerance, None, itkImageToImageFilterIRGBAUC2ID2)
itkImageToImageFilterIRGBAUC2ID2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2ID2_swigregister
itkImageToImageFilterIRGBAUC2ID2_swigregister(itkImageToImageFilterIRGBAUC2ID2)

def itkImageToImageFilterIRGBAUC2ID2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIRGBAUC2ID2 *":
    """itkImageToImageFilterIRGBAUC2ID2_cast(itkLightObject obj) -> itkImageToImageFilterIRGBAUC2ID2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2ID2_cast(obj)

class itkImageToImageFilterIRGBAUC2IF2(itkImageSourcePython.itkImageSourceIF2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIRGBAUC2IF2 self, itkImageRGBAUC2 image)
        SetInput(itkImageToImageFilterIRGBAUC2IF2 self, unsigned int arg0, itkImageRGBAUC2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IF2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageRGBAUC2 const *":
        """
        GetInput(itkImageToImageFilterIRGBAUC2IF2 self) -> itkImageRGBAUC2
        GetInput(itkImageToImageFilterIRGBAUC2IF2 self, unsigned int idx) -> itkImageRGBAUC2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IF2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageRGBAUC2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIRGBAUC2IF2 self, itkImageRGBAUC2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IF2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIRGBAUC2IF2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IF2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageRGBAUC2') -> "void":
        """PushFrontInput(itkImageToImageFilterIRGBAUC2IF2 self, itkImageRGBAUC2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IF2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIRGBAUC2IF2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IF2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIRGBAUC2IF2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IF2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIRGBAUC2IF2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IF2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIRGBAUC2IF2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IF2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIRGBAUC2IF2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IF2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIRGBAUC2IF2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIRGBAUC2IF2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIRGBAUC2IF2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IF2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIRGBAUC2IF2

        Create a new object of the class itkImageToImageFilterIRGBAUC2IF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIRGBAUC2IF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIRGBAUC2IF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIRGBAUC2IF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIRGBAUC2IF2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IF2_SetInput, None, itkImageToImageFilterIRGBAUC2IF2)
itkImageToImageFilterIRGBAUC2IF2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IF2_GetInput, None, itkImageToImageFilterIRGBAUC2IF2)
itkImageToImageFilterIRGBAUC2IF2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IF2_PushBackInput, None, itkImageToImageFilterIRGBAUC2IF2)
itkImageToImageFilterIRGBAUC2IF2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IF2_PopBackInput, None, itkImageToImageFilterIRGBAUC2IF2)
itkImageToImageFilterIRGBAUC2IF2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IF2_PushFrontInput, None, itkImageToImageFilterIRGBAUC2IF2)
itkImageToImageFilterIRGBAUC2IF2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IF2_PopFrontInput, None, itkImageToImageFilterIRGBAUC2IF2)
itkImageToImageFilterIRGBAUC2IF2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IF2_SetCoordinateTolerance, None, itkImageToImageFilterIRGBAUC2IF2)
itkImageToImageFilterIRGBAUC2IF2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IF2_GetCoordinateTolerance, None, itkImageToImageFilterIRGBAUC2IF2)
itkImageToImageFilterIRGBAUC2IF2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IF2_SetDirectionTolerance, None, itkImageToImageFilterIRGBAUC2IF2)
itkImageToImageFilterIRGBAUC2IF2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IF2_GetDirectionTolerance, None, itkImageToImageFilterIRGBAUC2IF2)
itkImageToImageFilterIRGBAUC2IF2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IF2_swigregister
itkImageToImageFilterIRGBAUC2IF2_swigregister(itkImageToImageFilterIRGBAUC2IF2)

def itkImageToImageFilterIRGBAUC2IF2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIRGBAUC2IF2 *":
    """itkImageToImageFilterIRGBAUC2IF2_cast(itkLightObject obj) -> itkImageToImageFilterIRGBAUC2IF2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IF2_cast(obj)

class itkImageToImageFilterIRGBAUC2ISS2(itkImageSourcePython.itkImageSourceISS2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIRGBAUC2ISS2 self, itkImageRGBAUC2 image)
        SetInput(itkImageToImageFilterIRGBAUC2ISS2 self, unsigned int arg0, itkImageRGBAUC2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2ISS2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageRGBAUC2 const *":
        """
        GetInput(itkImageToImageFilterIRGBAUC2ISS2 self) -> itkImageRGBAUC2
        GetInput(itkImageToImageFilterIRGBAUC2ISS2 self, unsigned int idx) -> itkImageRGBAUC2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2ISS2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageRGBAUC2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIRGBAUC2ISS2 self, itkImageRGBAUC2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2ISS2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIRGBAUC2ISS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2ISS2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageRGBAUC2') -> "void":
        """PushFrontInput(itkImageToImageFilterIRGBAUC2ISS2 self, itkImageRGBAUC2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2ISS2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIRGBAUC2ISS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2ISS2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIRGBAUC2ISS2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2ISS2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIRGBAUC2ISS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2ISS2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIRGBAUC2ISS2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2ISS2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIRGBAUC2ISS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2ISS2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIRGBAUC2ISS2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIRGBAUC2ISS2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIRGBAUC2ISS2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2ISS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIRGBAUC2ISS2

        Create a new object of the class itkImageToImageFilterIRGBAUC2ISS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIRGBAUC2ISS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIRGBAUC2ISS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIRGBAUC2ISS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIRGBAUC2ISS2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2ISS2_SetInput, None, itkImageToImageFilterIRGBAUC2ISS2)
itkImageToImageFilterIRGBAUC2ISS2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2ISS2_GetInput, None, itkImageToImageFilterIRGBAUC2ISS2)
itkImageToImageFilterIRGBAUC2ISS2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2ISS2_PushBackInput, None, itkImageToImageFilterIRGBAUC2ISS2)
itkImageToImageFilterIRGBAUC2ISS2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2ISS2_PopBackInput, None, itkImageToImageFilterIRGBAUC2ISS2)
itkImageToImageFilterIRGBAUC2ISS2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2ISS2_PushFrontInput, None, itkImageToImageFilterIRGBAUC2ISS2)
itkImageToImageFilterIRGBAUC2ISS2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2ISS2_PopFrontInput, None, itkImageToImageFilterIRGBAUC2ISS2)
itkImageToImageFilterIRGBAUC2ISS2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2ISS2_SetCoordinateTolerance, None, itkImageToImageFilterIRGBAUC2ISS2)
itkImageToImageFilterIRGBAUC2ISS2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2ISS2_GetCoordinateTolerance, None, itkImageToImageFilterIRGBAUC2ISS2)
itkImageToImageFilterIRGBAUC2ISS2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2ISS2_SetDirectionTolerance, None, itkImageToImageFilterIRGBAUC2ISS2)
itkImageToImageFilterIRGBAUC2ISS2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2ISS2_GetDirectionTolerance, None, itkImageToImageFilterIRGBAUC2ISS2)
itkImageToImageFilterIRGBAUC2ISS2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2ISS2_swigregister
itkImageToImageFilterIRGBAUC2ISS2_swigregister(itkImageToImageFilterIRGBAUC2ISS2)

def itkImageToImageFilterIRGBAUC2ISS2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIRGBAUC2ISS2 *":
    """itkImageToImageFilterIRGBAUC2ISS2_cast(itkLightObject obj) -> itkImageToImageFilterIRGBAUC2ISS2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2ISS2_cast(obj)

class itkImageToImageFilterIRGBAUC2IUC2(itkImageSourcePython.itkImageSourceIUC2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIRGBAUC2IUC2 self, itkImageRGBAUC2 image)
        SetInput(itkImageToImageFilterIRGBAUC2IUC2 self, unsigned int arg0, itkImageRGBAUC2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUC2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageRGBAUC2 const *":
        """
        GetInput(itkImageToImageFilterIRGBAUC2IUC2 self) -> itkImageRGBAUC2
        GetInput(itkImageToImageFilterIRGBAUC2IUC2 self, unsigned int idx) -> itkImageRGBAUC2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUC2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageRGBAUC2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIRGBAUC2IUC2 self, itkImageRGBAUC2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUC2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIRGBAUC2IUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUC2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageRGBAUC2') -> "void":
        """PushFrontInput(itkImageToImageFilterIRGBAUC2IUC2 self, itkImageRGBAUC2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUC2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIRGBAUC2IUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUC2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIRGBAUC2IUC2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUC2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIRGBAUC2IUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUC2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIRGBAUC2IUC2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUC2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIRGBAUC2IUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUC2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIRGBAUC2IUC2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIRGBAUC2IUC2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIRGBAUC2IUC2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUC2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIRGBAUC2IUC2

        Create a new object of the class itkImageToImageFilterIRGBAUC2IUC2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIRGBAUC2IUC2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIRGBAUC2IUC2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIRGBAUC2IUC2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIRGBAUC2IUC2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUC2_SetInput, None, itkImageToImageFilterIRGBAUC2IUC2)
itkImageToImageFilterIRGBAUC2IUC2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUC2_GetInput, None, itkImageToImageFilterIRGBAUC2IUC2)
itkImageToImageFilterIRGBAUC2IUC2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUC2_PushBackInput, None, itkImageToImageFilterIRGBAUC2IUC2)
itkImageToImageFilterIRGBAUC2IUC2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUC2_PopBackInput, None, itkImageToImageFilterIRGBAUC2IUC2)
itkImageToImageFilterIRGBAUC2IUC2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUC2_PushFrontInput, None, itkImageToImageFilterIRGBAUC2IUC2)
itkImageToImageFilterIRGBAUC2IUC2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUC2_PopFrontInput, None, itkImageToImageFilterIRGBAUC2IUC2)
itkImageToImageFilterIRGBAUC2IUC2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUC2_SetCoordinateTolerance, None, itkImageToImageFilterIRGBAUC2IUC2)
itkImageToImageFilterIRGBAUC2IUC2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUC2_GetCoordinateTolerance, None, itkImageToImageFilterIRGBAUC2IUC2)
itkImageToImageFilterIRGBAUC2IUC2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUC2_SetDirectionTolerance, None, itkImageToImageFilterIRGBAUC2IUC2)
itkImageToImageFilterIRGBAUC2IUC2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUC2_GetDirectionTolerance, None, itkImageToImageFilterIRGBAUC2IUC2)
itkImageToImageFilterIRGBAUC2IUC2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUC2_swigregister
itkImageToImageFilterIRGBAUC2IUC2_swigregister(itkImageToImageFilterIRGBAUC2IUC2)

def itkImageToImageFilterIRGBAUC2IUC2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIRGBAUC2IUC2 *":
    """itkImageToImageFilterIRGBAUC2IUC2_cast(itkLightObject obj) -> itkImageToImageFilterIRGBAUC2IUC2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUC2_cast(obj)

class itkImageToImageFilterIRGBAUC2IUL2(itkImageSourcePython.itkImageSourceIUL2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIRGBAUC2IUL2 self, itkImageRGBAUC2 image)
        SetInput(itkImageToImageFilterIRGBAUC2IUL2 self, unsigned int arg0, itkImageRGBAUC2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUL2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageRGBAUC2 const *":
        """
        GetInput(itkImageToImageFilterIRGBAUC2IUL2 self) -> itkImageRGBAUC2
        GetInput(itkImageToImageFilterIRGBAUC2IUL2 self, unsigned int idx) -> itkImageRGBAUC2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUL2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageRGBAUC2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIRGBAUC2IUL2 self, itkImageRGBAUC2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUL2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIRGBAUC2IUL2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUL2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageRGBAUC2') -> "void":
        """PushFrontInput(itkImageToImageFilterIRGBAUC2IUL2 self, itkImageRGBAUC2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUL2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIRGBAUC2IUL2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUL2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIRGBAUC2IUL2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUL2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIRGBAUC2IUL2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUL2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIRGBAUC2IUL2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUL2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIRGBAUC2IUL2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUL2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIRGBAUC2IUL2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIRGBAUC2IUL2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIRGBAUC2IUL2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUL2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIRGBAUC2IUL2

        Create a new object of the class itkImageToImageFilterIRGBAUC2IUL2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIRGBAUC2IUL2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIRGBAUC2IUL2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIRGBAUC2IUL2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIRGBAUC2IUL2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUL2_SetInput, None, itkImageToImageFilterIRGBAUC2IUL2)
itkImageToImageFilterIRGBAUC2IUL2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUL2_GetInput, None, itkImageToImageFilterIRGBAUC2IUL2)
itkImageToImageFilterIRGBAUC2IUL2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUL2_PushBackInput, None, itkImageToImageFilterIRGBAUC2IUL2)
itkImageToImageFilterIRGBAUC2IUL2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUL2_PopBackInput, None, itkImageToImageFilterIRGBAUC2IUL2)
itkImageToImageFilterIRGBAUC2IUL2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUL2_PushFrontInput, None, itkImageToImageFilterIRGBAUC2IUL2)
itkImageToImageFilterIRGBAUC2IUL2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUL2_PopFrontInput, None, itkImageToImageFilterIRGBAUC2IUL2)
itkImageToImageFilterIRGBAUC2IUL2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUL2_SetCoordinateTolerance, None, itkImageToImageFilterIRGBAUC2IUL2)
itkImageToImageFilterIRGBAUC2IUL2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUL2_GetCoordinateTolerance, None, itkImageToImageFilterIRGBAUC2IUL2)
itkImageToImageFilterIRGBAUC2IUL2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUL2_SetDirectionTolerance, None, itkImageToImageFilterIRGBAUC2IUL2)
itkImageToImageFilterIRGBAUC2IUL2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUL2_GetDirectionTolerance, None, itkImageToImageFilterIRGBAUC2IUL2)
itkImageToImageFilterIRGBAUC2IUL2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUL2_swigregister
itkImageToImageFilterIRGBAUC2IUL2_swigregister(itkImageToImageFilterIRGBAUC2IUL2)

def itkImageToImageFilterIRGBAUC2IUL2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIRGBAUC2IUL2 *":
    """itkImageToImageFilterIRGBAUC2IUL2_cast(itkLightObject obj) -> itkImageToImageFilterIRGBAUC2IUL2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUL2_cast(obj)

class itkImageToImageFilterIRGBAUC2IUS2(itkImageSourcePython.itkImageSourceIUS2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIRGBAUC2IUS2 self, itkImageRGBAUC2 image)
        SetInput(itkImageToImageFilterIRGBAUC2IUS2 self, unsigned int arg0, itkImageRGBAUC2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUS2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageRGBAUC2 const *":
        """
        GetInput(itkImageToImageFilterIRGBAUC2IUS2 self) -> itkImageRGBAUC2
        GetInput(itkImageToImageFilterIRGBAUC2IUS2 self, unsigned int idx) -> itkImageRGBAUC2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUS2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageRGBAUC2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIRGBAUC2IUS2 self, itkImageRGBAUC2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUS2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIRGBAUC2IUS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUS2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageRGBAUC2') -> "void":
        """PushFrontInput(itkImageToImageFilterIRGBAUC2IUS2 self, itkImageRGBAUC2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUS2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIRGBAUC2IUS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUS2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIRGBAUC2IUS2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUS2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIRGBAUC2IUS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUS2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIRGBAUC2IUS2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUS2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIRGBAUC2IUS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUS2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIRGBAUC2IUS2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIRGBAUC2IUS2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIRGBAUC2IUS2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIRGBAUC2IUS2

        Create a new object of the class itkImageToImageFilterIRGBAUC2IUS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIRGBAUC2IUS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIRGBAUC2IUS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIRGBAUC2IUS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIRGBAUC2IUS2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUS2_SetInput, None, itkImageToImageFilterIRGBAUC2IUS2)
itkImageToImageFilterIRGBAUC2IUS2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUS2_GetInput, None, itkImageToImageFilterIRGBAUC2IUS2)
itkImageToImageFilterIRGBAUC2IUS2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUS2_PushBackInput, None, itkImageToImageFilterIRGBAUC2IUS2)
itkImageToImageFilterIRGBAUC2IUS2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUS2_PopBackInput, None, itkImageToImageFilterIRGBAUC2IUS2)
itkImageToImageFilterIRGBAUC2IUS2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUS2_PushFrontInput, None, itkImageToImageFilterIRGBAUC2IUS2)
itkImageToImageFilterIRGBAUC2IUS2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUS2_PopFrontInput, None, itkImageToImageFilterIRGBAUC2IUS2)
itkImageToImageFilterIRGBAUC2IUS2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUS2_SetCoordinateTolerance, None, itkImageToImageFilterIRGBAUC2IUS2)
itkImageToImageFilterIRGBAUC2IUS2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUS2_GetCoordinateTolerance, None, itkImageToImageFilterIRGBAUC2IUS2)
itkImageToImageFilterIRGBAUC2IUS2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUS2_SetDirectionTolerance, None, itkImageToImageFilterIRGBAUC2IUS2)
itkImageToImageFilterIRGBAUC2IUS2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUS2_GetDirectionTolerance, None, itkImageToImageFilterIRGBAUC2IUS2)
itkImageToImageFilterIRGBAUC2IUS2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUS2_swigregister
itkImageToImageFilterIRGBAUC2IUS2_swigregister(itkImageToImageFilterIRGBAUC2IUS2)

def itkImageToImageFilterIRGBAUC2IUS2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIRGBAUC2IUS2 *":
    """itkImageToImageFilterIRGBAUC2IUS2_cast(itkLightObject obj) -> itkImageToImageFilterIRGBAUC2IUS2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC2IUS2_cast(obj)

class itkImageToImageFilterIRGBAUC3ID3(itkImageSourcePython.itkImageSourceID3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIRGBAUC3ID3 self, itkImageRGBAUC3 image)
        SetInput(itkImageToImageFilterIRGBAUC3ID3 self, unsigned int arg0, itkImageRGBAUC3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3ID3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageRGBAUC3 const *":
        """
        GetInput(itkImageToImageFilterIRGBAUC3ID3 self) -> itkImageRGBAUC3
        GetInput(itkImageToImageFilterIRGBAUC3ID3 self, unsigned int idx) -> itkImageRGBAUC3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3ID3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageRGBAUC3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIRGBAUC3ID3 self, itkImageRGBAUC3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3ID3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIRGBAUC3ID3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3ID3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageRGBAUC3') -> "void":
        """PushFrontInput(itkImageToImageFilterIRGBAUC3ID3 self, itkImageRGBAUC3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3ID3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIRGBAUC3ID3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3ID3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIRGBAUC3ID3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3ID3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIRGBAUC3ID3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3ID3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIRGBAUC3ID3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3ID3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIRGBAUC3ID3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3ID3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIRGBAUC3ID3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIRGBAUC3ID3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIRGBAUC3ID3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3ID3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIRGBAUC3ID3

        Create a new object of the class itkImageToImageFilterIRGBAUC3ID3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIRGBAUC3ID3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIRGBAUC3ID3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIRGBAUC3ID3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIRGBAUC3ID3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3ID3_SetInput, None, itkImageToImageFilterIRGBAUC3ID3)
itkImageToImageFilterIRGBAUC3ID3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3ID3_GetInput, None, itkImageToImageFilterIRGBAUC3ID3)
itkImageToImageFilterIRGBAUC3ID3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3ID3_PushBackInput, None, itkImageToImageFilterIRGBAUC3ID3)
itkImageToImageFilterIRGBAUC3ID3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3ID3_PopBackInput, None, itkImageToImageFilterIRGBAUC3ID3)
itkImageToImageFilterIRGBAUC3ID3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3ID3_PushFrontInput, None, itkImageToImageFilterIRGBAUC3ID3)
itkImageToImageFilterIRGBAUC3ID3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3ID3_PopFrontInput, None, itkImageToImageFilterIRGBAUC3ID3)
itkImageToImageFilterIRGBAUC3ID3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3ID3_SetCoordinateTolerance, None, itkImageToImageFilterIRGBAUC3ID3)
itkImageToImageFilterIRGBAUC3ID3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3ID3_GetCoordinateTolerance, None, itkImageToImageFilterIRGBAUC3ID3)
itkImageToImageFilterIRGBAUC3ID3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3ID3_SetDirectionTolerance, None, itkImageToImageFilterIRGBAUC3ID3)
itkImageToImageFilterIRGBAUC3ID3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3ID3_GetDirectionTolerance, None, itkImageToImageFilterIRGBAUC3ID3)
itkImageToImageFilterIRGBAUC3ID3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3ID3_swigregister
itkImageToImageFilterIRGBAUC3ID3_swigregister(itkImageToImageFilterIRGBAUC3ID3)

def itkImageToImageFilterIRGBAUC3ID3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIRGBAUC3ID3 *":
    """itkImageToImageFilterIRGBAUC3ID3_cast(itkLightObject obj) -> itkImageToImageFilterIRGBAUC3ID3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3ID3_cast(obj)

class itkImageToImageFilterIRGBAUC3IF3(itkImageSourcePython.itkImageSourceIF3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIRGBAUC3IF3 self, itkImageRGBAUC3 image)
        SetInput(itkImageToImageFilterIRGBAUC3IF3 self, unsigned int arg0, itkImageRGBAUC3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IF3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageRGBAUC3 const *":
        """
        GetInput(itkImageToImageFilterIRGBAUC3IF3 self) -> itkImageRGBAUC3
        GetInput(itkImageToImageFilterIRGBAUC3IF3 self, unsigned int idx) -> itkImageRGBAUC3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IF3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageRGBAUC3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIRGBAUC3IF3 self, itkImageRGBAUC3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IF3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIRGBAUC3IF3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IF3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageRGBAUC3') -> "void":
        """PushFrontInput(itkImageToImageFilterIRGBAUC3IF3 self, itkImageRGBAUC3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IF3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIRGBAUC3IF3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IF3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIRGBAUC3IF3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IF3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIRGBAUC3IF3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IF3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIRGBAUC3IF3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IF3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIRGBAUC3IF3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IF3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIRGBAUC3IF3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIRGBAUC3IF3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIRGBAUC3IF3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IF3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIRGBAUC3IF3

        Create a new object of the class itkImageToImageFilterIRGBAUC3IF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIRGBAUC3IF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIRGBAUC3IF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIRGBAUC3IF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIRGBAUC3IF3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IF3_SetInput, None, itkImageToImageFilterIRGBAUC3IF3)
itkImageToImageFilterIRGBAUC3IF3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IF3_GetInput, None, itkImageToImageFilterIRGBAUC3IF3)
itkImageToImageFilterIRGBAUC3IF3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IF3_PushBackInput, None, itkImageToImageFilterIRGBAUC3IF3)
itkImageToImageFilterIRGBAUC3IF3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IF3_PopBackInput, None, itkImageToImageFilterIRGBAUC3IF3)
itkImageToImageFilterIRGBAUC3IF3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IF3_PushFrontInput, None, itkImageToImageFilterIRGBAUC3IF3)
itkImageToImageFilterIRGBAUC3IF3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IF3_PopFrontInput, None, itkImageToImageFilterIRGBAUC3IF3)
itkImageToImageFilterIRGBAUC3IF3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IF3_SetCoordinateTolerance, None, itkImageToImageFilterIRGBAUC3IF3)
itkImageToImageFilterIRGBAUC3IF3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IF3_GetCoordinateTolerance, None, itkImageToImageFilterIRGBAUC3IF3)
itkImageToImageFilterIRGBAUC3IF3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IF3_SetDirectionTolerance, None, itkImageToImageFilterIRGBAUC3IF3)
itkImageToImageFilterIRGBAUC3IF3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IF3_GetDirectionTolerance, None, itkImageToImageFilterIRGBAUC3IF3)
itkImageToImageFilterIRGBAUC3IF3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IF3_swigregister
itkImageToImageFilterIRGBAUC3IF3_swigregister(itkImageToImageFilterIRGBAUC3IF3)

def itkImageToImageFilterIRGBAUC3IF3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIRGBAUC3IF3 *":
    """itkImageToImageFilterIRGBAUC3IF3_cast(itkLightObject obj) -> itkImageToImageFilterIRGBAUC3IF3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IF3_cast(obj)

class itkImageToImageFilterIRGBAUC3ISS3(itkImageSourcePython.itkImageSourceISS3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIRGBAUC3ISS3 self, itkImageRGBAUC3 image)
        SetInput(itkImageToImageFilterIRGBAUC3ISS3 self, unsigned int arg0, itkImageRGBAUC3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3ISS3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageRGBAUC3 const *":
        """
        GetInput(itkImageToImageFilterIRGBAUC3ISS3 self) -> itkImageRGBAUC3
        GetInput(itkImageToImageFilterIRGBAUC3ISS3 self, unsigned int idx) -> itkImageRGBAUC3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3ISS3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageRGBAUC3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIRGBAUC3ISS3 self, itkImageRGBAUC3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3ISS3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIRGBAUC3ISS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3ISS3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageRGBAUC3') -> "void":
        """PushFrontInput(itkImageToImageFilterIRGBAUC3ISS3 self, itkImageRGBAUC3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3ISS3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIRGBAUC3ISS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3ISS3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIRGBAUC3ISS3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3ISS3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIRGBAUC3ISS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3ISS3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIRGBAUC3ISS3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3ISS3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIRGBAUC3ISS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3ISS3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIRGBAUC3ISS3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIRGBAUC3ISS3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIRGBAUC3ISS3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3ISS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIRGBAUC3ISS3

        Create a new object of the class itkImageToImageFilterIRGBAUC3ISS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIRGBAUC3ISS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIRGBAUC3ISS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIRGBAUC3ISS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIRGBAUC3ISS3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3ISS3_SetInput, None, itkImageToImageFilterIRGBAUC3ISS3)
itkImageToImageFilterIRGBAUC3ISS3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3ISS3_GetInput, None, itkImageToImageFilterIRGBAUC3ISS3)
itkImageToImageFilterIRGBAUC3ISS3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3ISS3_PushBackInput, None, itkImageToImageFilterIRGBAUC3ISS3)
itkImageToImageFilterIRGBAUC3ISS3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3ISS3_PopBackInput, None, itkImageToImageFilterIRGBAUC3ISS3)
itkImageToImageFilterIRGBAUC3ISS3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3ISS3_PushFrontInput, None, itkImageToImageFilterIRGBAUC3ISS3)
itkImageToImageFilterIRGBAUC3ISS3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3ISS3_PopFrontInput, None, itkImageToImageFilterIRGBAUC3ISS3)
itkImageToImageFilterIRGBAUC3ISS3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3ISS3_SetCoordinateTolerance, None, itkImageToImageFilterIRGBAUC3ISS3)
itkImageToImageFilterIRGBAUC3ISS3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3ISS3_GetCoordinateTolerance, None, itkImageToImageFilterIRGBAUC3ISS3)
itkImageToImageFilterIRGBAUC3ISS3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3ISS3_SetDirectionTolerance, None, itkImageToImageFilterIRGBAUC3ISS3)
itkImageToImageFilterIRGBAUC3ISS3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3ISS3_GetDirectionTolerance, None, itkImageToImageFilterIRGBAUC3ISS3)
itkImageToImageFilterIRGBAUC3ISS3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3ISS3_swigregister
itkImageToImageFilterIRGBAUC3ISS3_swigregister(itkImageToImageFilterIRGBAUC3ISS3)

def itkImageToImageFilterIRGBAUC3ISS3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIRGBAUC3ISS3 *":
    """itkImageToImageFilterIRGBAUC3ISS3_cast(itkLightObject obj) -> itkImageToImageFilterIRGBAUC3ISS3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3ISS3_cast(obj)

class itkImageToImageFilterIRGBAUC3IUC3(itkImageSourcePython.itkImageSourceIUC3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIRGBAUC3IUC3 self, itkImageRGBAUC3 image)
        SetInput(itkImageToImageFilterIRGBAUC3IUC3 self, unsigned int arg0, itkImageRGBAUC3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUC3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageRGBAUC3 const *":
        """
        GetInput(itkImageToImageFilterIRGBAUC3IUC3 self) -> itkImageRGBAUC3
        GetInput(itkImageToImageFilterIRGBAUC3IUC3 self, unsigned int idx) -> itkImageRGBAUC3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUC3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageRGBAUC3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIRGBAUC3IUC3 self, itkImageRGBAUC3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUC3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIRGBAUC3IUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUC3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageRGBAUC3') -> "void":
        """PushFrontInput(itkImageToImageFilterIRGBAUC3IUC3 self, itkImageRGBAUC3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUC3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIRGBAUC3IUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUC3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIRGBAUC3IUC3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUC3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIRGBAUC3IUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUC3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIRGBAUC3IUC3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUC3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIRGBAUC3IUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUC3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIRGBAUC3IUC3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIRGBAUC3IUC3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIRGBAUC3IUC3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUC3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIRGBAUC3IUC3

        Create a new object of the class itkImageToImageFilterIRGBAUC3IUC3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIRGBAUC3IUC3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIRGBAUC3IUC3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIRGBAUC3IUC3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIRGBAUC3IUC3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUC3_SetInput, None, itkImageToImageFilterIRGBAUC3IUC3)
itkImageToImageFilterIRGBAUC3IUC3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUC3_GetInput, None, itkImageToImageFilterIRGBAUC3IUC3)
itkImageToImageFilterIRGBAUC3IUC3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUC3_PushBackInput, None, itkImageToImageFilterIRGBAUC3IUC3)
itkImageToImageFilterIRGBAUC3IUC3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUC3_PopBackInput, None, itkImageToImageFilterIRGBAUC3IUC3)
itkImageToImageFilterIRGBAUC3IUC3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUC3_PushFrontInput, None, itkImageToImageFilterIRGBAUC3IUC3)
itkImageToImageFilterIRGBAUC3IUC3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUC3_PopFrontInput, None, itkImageToImageFilterIRGBAUC3IUC3)
itkImageToImageFilterIRGBAUC3IUC3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUC3_SetCoordinateTolerance, None, itkImageToImageFilterIRGBAUC3IUC3)
itkImageToImageFilterIRGBAUC3IUC3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUC3_GetCoordinateTolerance, None, itkImageToImageFilterIRGBAUC3IUC3)
itkImageToImageFilterIRGBAUC3IUC3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUC3_SetDirectionTolerance, None, itkImageToImageFilterIRGBAUC3IUC3)
itkImageToImageFilterIRGBAUC3IUC3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUC3_GetDirectionTolerance, None, itkImageToImageFilterIRGBAUC3IUC3)
itkImageToImageFilterIRGBAUC3IUC3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUC3_swigregister
itkImageToImageFilterIRGBAUC3IUC3_swigregister(itkImageToImageFilterIRGBAUC3IUC3)

def itkImageToImageFilterIRGBAUC3IUC3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIRGBAUC3IUC3 *":
    """itkImageToImageFilterIRGBAUC3IUC3_cast(itkLightObject obj) -> itkImageToImageFilterIRGBAUC3IUC3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUC3_cast(obj)

class itkImageToImageFilterIRGBAUC3IUL3(itkImageSourcePython.itkImageSourceIUL3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIRGBAUC3IUL3 self, itkImageRGBAUC3 image)
        SetInput(itkImageToImageFilterIRGBAUC3IUL3 self, unsigned int arg0, itkImageRGBAUC3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUL3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageRGBAUC3 const *":
        """
        GetInput(itkImageToImageFilterIRGBAUC3IUL3 self) -> itkImageRGBAUC3
        GetInput(itkImageToImageFilterIRGBAUC3IUL3 self, unsigned int idx) -> itkImageRGBAUC3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUL3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageRGBAUC3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIRGBAUC3IUL3 self, itkImageRGBAUC3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUL3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIRGBAUC3IUL3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUL3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageRGBAUC3') -> "void":
        """PushFrontInput(itkImageToImageFilterIRGBAUC3IUL3 self, itkImageRGBAUC3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUL3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIRGBAUC3IUL3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUL3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIRGBAUC3IUL3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUL3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIRGBAUC3IUL3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUL3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIRGBAUC3IUL3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUL3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIRGBAUC3IUL3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUL3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIRGBAUC3IUL3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIRGBAUC3IUL3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIRGBAUC3IUL3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUL3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIRGBAUC3IUL3

        Create a new object of the class itkImageToImageFilterIRGBAUC3IUL3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIRGBAUC3IUL3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIRGBAUC3IUL3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIRGBAUC3IUL3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIRGBAUC3IUL3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUL3_SetInput, None, itkImageToImageFilterIRGBAUC3IUL3)
itkImageToImageFilterIRGBAUC3IUL3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUL3_GetInput, None, itkImageToImageFilterIRGBAUC3IUL3)
itkImageToImageFilterIRGBAUC3IUL3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUL3_PushBackInput, None, itkImageToImageFilterIRGBAUC3IUL3)
itkImageToImageFilterIRGBAUC3IUL3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUL3_PopBackInput, None, itkImageToImageFilterIRGBAUC3IUL3)
itkImageToImageFilterIRGBAUC3IUL3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUL3_PushFrontInput, None, itkImageToImageFilterIRGBAUC3IUL3)
itkImageToImageFilterIRGBAUC3IUL3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUL3_PopFrontInput, None, itkImageToImageFilterIRGBAUC3IUL3)
itkImageToImageFilterIRGBAUC3IUL3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUL3_SetCoordinateTolerance, None, itkImageToImageFilterIRGBAUC3IUL3)
itkImageToImageFilterIRGBAUC3IUL3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUL3_GetCoordinateTolerance, None, itkImageToImageFilterIRGBAUC3IUL3)
itkImageToImageFilterIRGBAUC3IUL3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUL3_SetDirectionTolerance, None, itkImageToImageFilterIRGBAUC3IUL3)
itkImageToImageFilterIRGBAUC3IUL3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUL3_GetDirectionTolerance, None, itkImageToImageFilterIRGBAUC3IUL3)
itkImageToImageFilterIRGBAUC3IUL3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUL3_swigregister
itkImageToImageFilterIRGBAUC3IUL3_swigregister(itkImageToImageFilterIRGBAUC3IUL3)

def itkImageToImageFilterIRGBAUC3IUL3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIRGBAUC3IUL3 *":
    """itkImageToImageFilterIRGBAUC3IUL3_cast(itkLightObject obj) -> itkImageToImageFilterIRGBAUC3IUL3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUL3_cast(obj)

class itkImageToImageFilterIRGBAUC3IUS3(itkImageSourcePython.itkImageSourceIUS3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIRGBAUC3IUS3 self, itkImageRGBAUC3 image)
        SetInput(itkImageToImageFilterIRGBAUC3IUS3 self, unsigned int arg0, itkImageRGBAUC3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUS3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageRGBAUC3 const *":
        """
        GetInput(itkImageToImageFilterIRGBAUC3IUS3 self) -> itkImageRGBAUC3
        GetInput(itkImageToImageFilterIRGBAUC3IUS3 self, unsigned int idx) -> itkImageRGBAUC3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUS3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageRGBAUC3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIRGBAUC3IUS3 self, itkImageRGBAUC3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUS3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIRGBAUC3IUS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUS3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageRGBAUC3') -> "void":
        """PushFrontInput(itkImageToImageFilterIRGBAUC3IUS3 self, itkImageRGBAUC3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUS3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIRGBAUC3IUS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUS3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIRGBAUC3IUS3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUS3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIRGBAUC3IUS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUS3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIRGBAUC3IUS3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUS3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIRGBAUC3IUS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUS3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIRGBAUC3IUS3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIRGBAUC3IUS3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIRGBAUC3IUS3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIRGBAUC3IUS3

        Create a new object of the class itkImageToImageFilterIRGBAUC3IUS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIRGBAUC3IUS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIRGBAUC3IUS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIRGBAUC3IUS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIRGBAUC3IUS3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUS3_SetInput, None, itkImageToImageFilterIRGBAUC3IUS3)
itkImageToImageFilterIRGBAUC3IUS3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUS3_GetInput, None, itkImageToImageFilterIRGBAUC3IUS3)
itkImageToImageFilterIRGBAUC3IUS3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUS3_PushBackInput, None, itkImageToImageFilterIRGBAUC3IUS3)
itkImageToImageFilterIRGBAUC3IUS3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUS3_PopBackInput, None, itkImageToImageFilterIRGBAUC3IUS3)
itkImageToImageFilterIRGBAUC3IUS3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUS3_PushFrontInput, None, itkImageToImageFilterIRGBAUC3IUS3)
itkImageToImageFilterIRGBAUC3IUS3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUS3_PopFrontInput, None, itkImageToImageFilterIRGBAUC3IUS3)
itkImageToImageFilterIRGBAUC3IUS3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUS3_SetCoordinateTolerance, None, itkImageToImageFilterIRGBAUC3IUS3)
itkImageToImageFilterIRGBAUC3IUS3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUS3_GetCoordinateTolerance, None, itkImageToImageFilterIRGBAUC3IUS3)
itkImageToImageFilterIRGBAUC3IUS3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUS3_SetDirectionTolerance, None, itkImageToImageFilterIRGBAUC3IUS3)
itkImageToImageFilterIRGBAUC3IUS3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUS3_GetDirectionTolerance, None, itkImageToImageFilterIRGBAUC3IUS3)
itkImageToImageFilterIRGBAUC3IUS3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUS3_swigregister
itkImageToImageFilterIRGBAUC3IUS3_swigregister(itkImageToImageFilterIRGBAUC3IUS3)

def itkImageToImageFilterIRGBAUC3IUS3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIRGBAUC3IUS3 *":
    """itkImageToImageFilterIRGBAUC3IUS3_cast(itkLightObject obj) -> itkImageToImageFilterIRGBAUC3IUS3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBAUC3IUS3_cast(obj)

class itkImageToImageFilterIRGBUC2ID2(itkImageSourcePython.itkImageSourceID2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIRGBUC2ID2 self, itkImageRGBUC2 image)
        SetInput(itkImageToImageFilterIRGBUC2ID2 self, unsigned int arg0, itkImageRGBUC2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2ID2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageRGBUC2 const *":
        """
        GetInput(itkImageToImageFilterIRGBUC2ID2 self) -> itkImageRGBUC2
        GetInput(itkImageToImageFilterIRGBUC2ID2 self, unsigned int idx) -> itkImageRGBUC2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2ID2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageRGBUC2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIRGBUC2ID2 self, itkImageRGBUC2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2ID2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIRGBUC2ID2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2ID2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageRGBUC2') -> "void":
        """PushFrontInput(itkImageToImageFilterIRGBUC2ID2 self, itkImageRGBUC2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2ID2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIRGBUC2ID2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2ID2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIRGBUC2ID2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2ID2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIRGBUC2ID2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2ID2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIRGBUC2ID2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2ID2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIRGBUC2ID2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2ID2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIRGBUC2ID2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIRGBUC2ID2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIRGBUC2ID2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2ID2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIRGBUC2ID2

        Create a new object of the class itkImageToImageFilterIRGBUC2ID2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIRGBUC2ID2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIRGBUC2ID2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIRGBUC2ID2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIRGBUC2ID2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2ID2_SetInput, None, itkImageToImageFilterIRGBUC2ID2)
itkImageToImageFilterIRGBUC2ID2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2ID2_GetInput, None, itkImageToImageFilterIRGBUC2ID2)
itkImageToImageFilterIRGBUC2ID2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2ID2_PushBackInput, None, itkImageToImageFilterIRGBUC2ID2)
itkImageToImageFilterIRGBUC2ID2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2ID2_PopBackInput, None, itkImageToImageFilterIRGBUC2ID2)
itkImageToImageFilterIRGBUC2ID2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2ID2_PushFrontInput, None, itkImageToImageFilterIRGBUC2ID2)
itkImageToImageFilterIRGBUC2ID2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2ID2_PopFrontInput, None, itkImageToImageFilterIRGBUC2ID2)
itkImageToImageFilterIRGBUC2ID2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2ID2_SetCoordinateTolerance, None, itkImageToImageFilterIRGBUC2ID2)
itkImageToImageFilterIRGBUC2ID2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2ID2_GetCoordinateTolerance, None, itkImageToImageFilterIRGBUC2ID2)
itkImageToImageFilterIRGBUC2ID2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2ID2_SetDirectionTolerance, None, itkImageToImageFilterIRGBUC2ID2)
itkImageToImageFilterIRGBUC2ID2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2ID2_GetDirectionTolerance, None, itkImageToImageFilterIRGBUC2ID2)
itkImageToImageFilterIRGBUC2ID2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2ID2_swigregister
itkImageToImageFilterIRGBUC2ID2_swigregister(itkImageToImageFilterIRGBUC2ID2)

def itkImageToImageFilterIRGBUC2ID2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIRGBUC2ID2 *":
    """itkImageToImageFilterIRGBUC2ID2_cast(itkLightObject obj) -> itkImageToImageFilterIRGBUC2ID2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2ID2_cast(obj)

class itkImageToImageFilterIRGBUC2IF2(itkImageSourcePython.itkImageSourceIF2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIRGBUC2IF2 self, itkImageRGBUC2 image)
        SetInput(itkImageToImageFilterIRGBUC2IF2 self, unsigned int arg0, itkImageRGBUC2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IF2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageRGBUC2 const *":
        """
        GetInput(itkImageToImageFilterIRGBUC2IF2 self) -> itkImageRGBUC2
        GetInput(itkImageToImageFilterIRGBUC2IF2 self, unsigned int idx) -> itkImageRGBUC2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IF2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageRGBUC2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIRGBUC2IF2 self, itkImageRGBUC2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IF2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIRGBUC2IF2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IF2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageRGBUC2') -> "void":
        """PushFrontInput(itkImageToImageFilterIRGBUC2IF2 self, itkImageRGBUC2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IF2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIRGBUC2IF2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IF2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIRGBUC2IF2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IF2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIRGBUC2IF2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IF2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIRGBUC2IF2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IF2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIRGBUC2IF2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IF2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIRGBUC2IF2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIRGBUC2IF2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIRGBUC2IF2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IF2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIRGBUC2IF2

        Create a new object of the class itkImageToImageFilterIRGBUC2IF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIRGBUC2IF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIRGBUC2IF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIRGBUC2IF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIRGBUC2IF2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IF2_SetInput, None, itkImageToImageFilterIRGBUC2IF2)
itkImageToImageFilterIRGBUC2IF2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IF2_GetInput, None, itkImageToImageFilterIRGBUC2IF2)
itkImageToImageFilterIRGBUC2IF2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IF2_PushBackInput, None, itkImageToImageFilterIRGBUC2IF2)
itkImageToImageFilterIRGBUC2IF2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IF2_PopBackInput, None, itkImageToImageFilterIRGBUC2IF2)
itkImageToImageFilterIRGBUC2IF2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IF2_PushFrontInput, None, itkImageToImageFilterIRGBUC2IF2)
itkImageToImageFilterIRGBUC2IF2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IF2_PopFrontInput, None, itkImageToImageFilterIRGBUC2IF2)
itkImageToImageFilterIRGBUC2IF2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IF2_SetCoordinateTolerance, None, itkImageToImageFilterIRGBUC2IF2)
itkImageToImageFilterIRGBUC2IF2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IF2_GetCoordinateTolerance, None, itkImageToImageFilterIRGBUC2IF2)
itkImageToImageFilterIRGBUC2IF2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IF2_SetDirectionTolerance, None, itkImageToImageFilterIRGBUC2IF2)
itkImageToImageFilterIRGBUC2IF2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IF2_GetDirectionTolerance, None, itkImageToImageFilterIRGBUC2IF2)
itkImageToImageFilterIRGBUC2IF2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IF2_swigregister
itkImageToImageFilterIRGBUC2IF2_swigregister(itkImageToImageFilterIRGBUC2IF2)

def itkImageToImageFilterIRGBUC2IF2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIRGBUC2IF2 *":
    """itkImageToImageFilterIRGBUC2IF2_cast(itkLightObject obj) -> itkImageToImageFilterIRGBUC2IF2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IF2_cast(obj)

class itkImageToImageFilterIRGBUC2IRGBUC3(itkImageSourcePython.itkImageSourceIRGBUC3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIRGBUC2IRGBUC3 self, itkImageRGBUC2 image)
        SetInput(itkImageToImageFilterIRGBUC2IRGBUC3 self, unsigned int arg0, itkImageRGBUC2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IRGBUC3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageRGBUC2 const *":
        """
        GetInput(itkImageToImageFilterIRGBUC2IRGBUC3 self) -> itkImageRGBUC2
        GetInput(itkImageToImageFilterIRGBUC2IRGBUC3 self, unsigned int idx) -> itkImageRGBUC2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IRGBUC3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageRGBUC2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIRGBUC2IRGBUC3 self, itkImageRGBUC2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IRGBUC3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIRGBUC2IRGBUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IRGBUC3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageRGBUC2') -> "void":
        """PushFrontInput(itkImageToImageFilterIRGBUC2IRGBUC3 self, itkImageRGBUC2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IRGBUC3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIRGBUC2IRGBUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IRGBUC3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIRGBUC2IRGBUC3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IRGBUC3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIRGBUC2IRGBUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IRGBUC3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIRGBUC2IRGBUC3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IRGBUC3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIRGBUC2IRGBUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IRGBUC3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIRGBUC2IRGBUC3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIRGBUC2IRGBUC3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIRGBUC2IRGBUC3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IRGBUC3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIRGBUC2IRGBUC3

        Create a new object of the class itkImageToImageFilterIRGBUC2IRGBUC3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIRGBUC2IRGBUC3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIRGBUC2IRGBUC3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIRGBUC2IRGBUC3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIRGBUC2IRGBUC3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IRGBUC3_SetInput, None, itkImageToImageFilterIRGBUC2IRGBUC3)
itkImageToImageFilterIRGBUC2IRGBUC3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IRGBUC3_GetInput, None, itkImageToImageFilterIRGBUC2IRGBUC3)
itkImageToImageFilterIRGBUC2IRGBUC3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IRGBUC3_PushBackInput, None, itkImageToImageFilterIRGBUC2IRGBUC3)
itkImageToImageFilterIRGBUC2IRGBUC3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IRGBUC3_PopBackInput, None, itkImageToImageFilterIRGBUC2IRGBUC3)
itkImageToImageFilterIRGBUC2IRGBUC3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IRGBUC3_PushFrontInput, None, itkImageToImageFilterIRGBUC2IRGBUC3)
itkImageToImageFilterIRGBUC2IRGBUC3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IRGBUC3_PopFrontInput, None, itkImageToImageFilterIRGBUC2IRGBUC3)
itkImageToImageFilterIRGBUC2IRGBUC3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IRGBUC3_SetCoordinateTolerance, None, itkImageToImageFilterIRGBUC2IRGBUC3)
itkImageToImageFilterIRGBUC2IRGBUC3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IRGBUC3_GetCoordinateTolerance, None, itkImageToImageFilterIRGBUC2IRGBUC3)
itkImageToImageFilterIRGBUC2IRGBUC3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IRGBUC3_SetDirectionTolerance, None, itkImageToImageFilterIRGBUC2IRGBUC3)
itkImageToImageFilterIRGBUC2IRGBUC3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IRGBUC3_GetDirectionTolerance, None, itkImageToImageFilterIRGBUC2IRGBUC3)
itkImageToImageFilterIRGBUC2IRGBUC3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IRGBUC3_swigregister
itkImageToImageFilterIRGBUC2IRGBUC3_swigregister(itkImageToImageFilterIRGBUC2IRGBUC3)

def itkImageToImageFilterIRGBUC2IRGBUC3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIRGBUC2IRGBUC3 *":
    """itkImageToImageFilterIRGBUC2IRGBUC3_cast(itkLightObject obj) -> itkImageToImageFilterIRGBUC2IRGBUC3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IRGBUC3_cast(obj)

class itkImageToImageFilterIRGBUC2ISS2(itkImageSourcePython.itkImageSourceISS2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIRGBUC2ISS2 self, itkImageRGBUC2 image)
        SetInput(itkImageToImageFilterIRGBUC2ISS2 self, unsigned int arg0, itkImageRGBUC2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2ISS2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageRGBUC2 const *":
        """
        GetInput(itkImageToImageFilterIRGBUC2ISS2 self) -> itkImageRGBUC2
        GetInput(itkImageToImageFilterIRGBUC2ISS2 self, unsigned int idx) -> itkImageRGBUC2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2ISS2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageRGBUC2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIRGBUC2ISS2 self, itkImageRGBUC2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2ISS2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIRGBUC2ISS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2ISS2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageRGBUC2') -> "void":
        """PushFrontInput(itkImageToImageFilterIRGBUC2ISS2 self, itkImageRGBUC2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2ISS2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIRGBUC2ISS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2ISS2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIRGBUC2ISS2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2ISS2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIRGBUC2ISS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2ISS2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIRGBUC2ISS2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2ISS2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIRGBUC2ISS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2ISS2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIRGBUC2ISS2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIRGBUC2ISS2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIRGBUC2ISS2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2ISS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIRGBUC2ISS2

        Create a new object of the class itkImageToImageFilterIRGBUC2ISS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIRGBUC2ISS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIRGBUC2ISS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIRGBUC2ISS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIRGBUC2ISS2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2ISS2_SetInput, None, itkImageToImageFilterIRGBUC2ISS2)
itkImageToImageFilterIRGBUC2ISS2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2ISS2_GetInput, None, itkImageToImageFilterIRGBUC2ISS2)
itkImageToImageFilterIRGBUC2ISS2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2ISS2_PushBackInput, None, itkImageToImageFilterIRGBUC2ISS2)
itkImageToImageFilterIRGBUC2ISS2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2ISS2_PopBackInput, None, itkImageToImageFilterIRGBUC2ISS2)
itkImageToImageFilterIRGBUC2ISS2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2ISS2_PushFrontInput, None, itkImageToImageFilterIRGBUC2ISS2)
itkImageToImageFilterIRGBUC2ISS2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2ISS2_PopFrontInput, None, itkImageToImageFilterIRGBUC2ISS2)
itkImageToImageFilterIRGBUC2ISS2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2ISS2_SetCoordinateTolerance, None, itkImageToImageFilterIRGBUC2ISS2)
itkImageToImageFilterIRGBUC2ISS2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2ISS2_GetCoordinateTolerance, None, itkImageToImageFilterIRGBUC2ISS2)
itkImageToImageFilterIRGBUC2ISS2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2ISS2_SetDirectionTolerance, None, itkImageToImageFilterIRGBUC2ISS2)
itkImageToImageFilterIRGBUC2ISS2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2ISS2_GetDirectionTolerance, None, itkImageToImageFilterIRGBUC2ISS2)
itkImageToImageFilterIRGBUC2ISS2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2ISS2_swigregister
itkImageToImageFilterIRGBUC2ISS2_swigregister(itkImageToImageFilterIRGBUC2ISS2)

def itkImageToImageFilterIRGBUC2ISS2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIRGBUC2ISS2 *":
    """itkImageToImageFilterIRGBUC2ISS2_cast(itkLightObject obj) -> itkImageToImageFilterIRGBUC2ISS2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2ISS2_cast(obj)

class itkImageToImageFilterIRGBUC2IUC2(itkImageSourcePython.itkImageSourceIUC2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIRGBUC2IUC2 self, itkImageRGBUC2 image)
        SetInput(itkImageToImageFilterIRGBUC2IUC2 self, unsigned int arg0, itkImageRGBUC2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUC2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageRGBUC2 const *":
        """
        GetInput(itkImageToImageFilterIRGBUC2IUC2 self) -> itkImageRGBUC2
        GetInput(itkImageToImageFilterIRGBUC2IUC2 self, unsigned int idx) -> itkImageRGBUC2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUC2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageRGBUC2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIRGBUC2IUC2 self, itkImageRGBUC2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUC2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIRGBUC2IUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUC2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageRGBUC2') -> "void":
        """PushFrontInput(itkImageToImageFilterIRGBUC2IUC2 self, itkImageRGBUC2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUC2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIRGBUC2IUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUC2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIRGBUC2IUC2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUC2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIRGBUC2IUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUC2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIRGBUC2IUC2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUC2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIRGBUC2IUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUC2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIRGBUC2IUC2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIRGBUC2IUC2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIRGBUC2IUC2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUC2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIRGBUC2IUC2

        Create a new object of the class itkImageToImageFilterIRGBUC2IUC2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIRGBUC2IUC2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIRGBUC2IUC2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIRGBUC2IUC2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIRGBUC2IUC2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUC2_SetInput, None, itkImageToImageFilterIRGBUC2IUC2)
itkImageToImageFilterIRGBUC2IUC2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUC2_GetInput, None, itkImageToImageFilterIRGBUC2IUC2)
itkImageToImageFilterIRGBUC2IUC2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUC2_PushBackInput, None, itkImageToImageFilterIRGBUC2IUC2)
itkImageToImageFilterIRGBUC2IUC2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUC2_PopBackInput, None, itkImageToImageFilterIRGBUC2IUC2)
itkImageToImageFilterIRGBUC2IUC2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUC2_PushFrontInput, None, itkImageToImageFilterIRGBUC2IUC2)
itkImageToImageFilterIRGBUC2IUC2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUC2_PopFrontInput, None, itkImageToImageFilterIRGBUC2IUC2)
itkImageToImageFilterIRGBUC2IUC2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUC2_SetCoordinateTolerance, None, itkImageToImageFilterIRGBUC2IUC2)
itkImageToImageFilterIRGBUC2IUC2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUC2_GetCoordinateTolerance, None, itkImageToImageFilterIRGBUC2IUC2)
itkImageToImageFilterIRGBUC2IUC2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUC2_SetDirectionTolerance, None, itkImageToImageFilterIRGBUC2IUC2)
itkImageToImageFilterIRGBUC2IUC2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUC2_GetDirectionTolerance, None, itkImageToImageFilterIRGBUC2IUC2)
itkImageToImageFilterIRGBUC2IUC2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUC2_swigregister
itkImageToImageFilterIRGBUC2IUC2_swigregister(itkImageToImageFilterIRGBUC2IUC2)

def itkImageToImageFilterIRGBUC2IUC2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIRGBUC2IUC2 *":
    """itkImageToImageFilterIRGBUC2IUC2_cast(itkLightObject obj) -> itkImageToImageFilterIRGBUC2IUC2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUC2_cast(obj)

class itkImageToImageFilterIRGBUC2IUL2(itkImageSourcePython.itkImageSourceIUL2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIRGBUC2IUL2 self, itkImageRGBUC2 image)
        SetInput(itkImageToImageFilterIRGBUC2IUL2 self, unsigned int arg0, itkImageRGBUC2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUL2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageRGBUC2 const *":
        """
        GetInput(itkImageToImageFilterIRGBUC2IUL2 self) -> itkImageRGBUC2
        GetInput(itkImageToImageFilterIRGBUC2IUL2 self, unsigned int idx) -> itkImageRGBUC2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUL2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageRGBUC2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIRGBUC2IUL2 self, itkImageRGBUC2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUL2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIRGBUC2IUL2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUL2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageRGBUC2') -> "void":
        """PushFrontInput(itkImageToImageFilterIRGBUC2IUL2 self, itkImageRGBUC2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUL2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIRGBUC2IUL2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUL2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIRGBUC2IUL2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUL2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIRGBUC2IUL2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUL2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIRGBUC2IUL2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUL2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIRGBUC2IUL2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUL2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIRGBUC2IUL2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIRGBUC2IUL2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIRGBUC2IUL2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUL2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIRGBUC2IUL2

        Create a new object of the class itkImageToImageFilterIRGBUC2IUL2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIRGBUC2IUL2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIRGBUC2IUL2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIRGBUC2IUL2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIRGBUC2IUL2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUL2_SetInput, None, itkImageToImageFilterIRGBUC2IUL2)
itkImageToImageFilterIRGBUC2IUL2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUL2_GetInput, None, itkImageToImageFilterIRGBUC2IUL2)
itkImageToImageFilterIRGBUC2IUL2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUL2_PushBackInput, None, itkImageToImageFilterIRGBUC2IUL2)
itkImageToImageFilterIRGBUC2IUL2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUL2_PopBackInput, None, itkImageToImageFilterIRGBUC2IUL2)
itkImageToImageFilterIRGBUC2IUL2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUL2_PushFrontInput, None, itkImageToImageFilterIRGBUC2IUL2)
itkImageToImageFilterIRGBUC2IUL2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUL2_PopFrontInput, None, itkImageToImageFilterIRGBUC2IUL2)
itkImageToImageFilterIRGBUC2IUL2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUL2_SetCoordinateTolerance, None, itkImageToImageFilterIRGBUC2IUL2)
itkImageToImageFilterIRGBUC2IUL2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUL2_GetCoordinateTolerance, None, itkImageToImageFilterIRGBUC2IUL2)
itkImageToImageFilterIRGBUC2IUL2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUL2_SetDirectionTolerance, None, itkImageToImageFilterIRGBUC2IUL2)
itkImageToImageFilterIRGBUC2IUL2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUL2_GetDirectionTolerance, None, itkImageToImageFilterIRGBUC2IUL2)
itkImageToImageFilterIRGBUC2IUL2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUL2_swigregister
itkImageToImageFilterIRGBUC2IUL2_swigregister(itkImageToImageFilterIRGBUC2IUL2)

def itkImageToImageFilterIRGBUC2IUL2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIRGBUC2IUL2 *":
    """itkImageToImageFilterIRGBUC2IUL2_cast(itkLightObject obj) -> itkImageToImageFilterIRGBUC2IUL2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUL2_cast(obj)

class itkImageToImageFilterIRGBUC2IUS2(itkImageSourcePython.itkImageSourceIUS2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIRGBUC2IUS2 self, itkImageRGBUC2 image)
        SetInput(itkImageToImageFilterIRGBUC2IUS2 self, unsigned int arg0, itkImageRGBUC2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUS2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageRGBUC2 const *":
        """
        GetInput(itkImageToImageFilterIRGBUC2IUS2 self) -> itkImageRGBUC2
        GetInput(itkImageToImageFilterIRGBUC2IUS2 self, unsigned int idx) -> itkImageRGBUC2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUS2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageRGBUC2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIRGBUC2IUS2 self, itkImageRGBUC2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUS2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIRGBUC2IUS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUS2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageRGBUC2') -> "void":
        """PushFrontInput(itkImageToImageFilterIRGBUC2IUS2 self, itkImageRGBUC2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUS2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIRGBUC2IUS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUS2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIRGBUC2IUS2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUS2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIRGBUC2IUS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUS2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIRGBUC2IUS2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUS2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIRGBUC2IUS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUS2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIRGBUC2IUS2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIRGBUC2IUS2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIRGBUC2IUS2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIRGBUC2IUS2

        Create a new object of the class itkImageToImageFilterIRGBUC2IUS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIRGBUC2IUS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIRGBUC2IUS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIRGBUC2IUS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIRGBUC2IUS2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUS2_SetInput, None, itkImageToImageFilterIRGBUC2IUS2)
itkImageToImageFilterIRGBUC2IUS2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUS2_GetInput, None, itkImageToImageFilterIRGBUC2IUS2)
itkImageToImageFilterIRGBUC2IUS2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUS2_PushBackInput, None, itkImageToImageFilterIRGBUC2IUS2)
itkImageToImageFilterIRGBUC2IUS2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUS2_PopBackInput, None, itkImageToImageFilterIRGBUC2IUS2)
itkImageToImageFilterIRGBUC2IUS2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUS2_PushFrontInput, None, itkImageToImageFilterIRGBUC2IUS2)
itkImageToImageFilterIRGBUC2IUS2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUS2_PopFrontInput, None, itkImageToImageFilterIRGBUC2IUS2)
itkImageToImageFilterIRGBUC2IUS2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUS2_SetCoordinateTolerance, None, itkImageToImageFilterIRGBUC2IUS2)
itkImageToImageFilterIRGBUC2IUS2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUS2_GetCoordinateTolerance, None, itkImageToImageFilterIRGBUC2IUS2)
itkImageToImageFilterIRGBUC2IUS2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUS2_SetDirectionTolerance, None, itkImageToImageFilterIRGBUC2IUS2)
itkImageToImageFilterIRGBUC2IUS2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUS2_GetDirectionTolerance, None, itkImageToImageFilterIRGBUC2IUS2)
itkImageToImageFilterIRGBUC2IUS2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUS2_swigregister
itkImageToImageFilterIRGBUC2IUS2_swigregister(itkImageToImageFilterIRGBUC2IUS2)

def itkImageToImageFilterIRGBUC2IUS2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIRGBUC2IUS2 *":
    """itkImageToImageFilterIRGBUC2IUS2_cast(itkLightObject obj) -> itkImageToImageFilterIRGBUC2IUS2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC2IUS2_cast(obj)

class itkImageToImageFilterIRGBUC3ID3(itkImageSourcePython.itkImageSourceID3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIRGBUC3ID3 self, itkImageRGBUC3 image)
        SetInput(itkImageToImageFilterIRGBUC3ID3 self, unsigned int arg0, itkImageRGBUC3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3ID3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageRGBUC3 const *":
        """
        GetInput(itkImageToImageFilterIRGBUC3ID3 self) -> itkImageRGBUC3
        GetInput(itkImageToImageFilterIRGBUC3ID3 self, unsigned int idx) -> itkImageRGBUC3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3ID3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageRGBUC3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIRGBUC3ID3 self, itkImageRGBUC3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3ID3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIRGBUC3ID3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3ID3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageRGBUC3') -> "void":
        """PushFrontInput(itkImageToImageFilterIRGBUC3ID3 self, itkImageRGBUC3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3ID3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIRGBUC3ID3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3ID3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIRGBUC3ID3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3ID3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIRGBUC3ID3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3ID3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIRGBUC3ID3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3ID3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIRGBUC3ID3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3ID3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIRGBUC3ID3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIRGBUC3ID3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIRGBUC3ID3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3ID3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIRGBUC3ID3

        Create a new object of the class itkImageToImageFilterIRGBUC3ID3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIRGBUC3ID3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIRGBUC3ID3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIRGBUC3ID3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIRGBUC3ID3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3ID3_SetInput, None, itkImageToImageFilterIRGBUC3ID3)
itkImageToImageFilterIRGBUC3ID3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3ID3_GetInput, None, itkImageToImageFilterIRGBUC3ID3)
itkImageToImageFilterIRGBUC3ID3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3ID3_PushBackInput, None, itkImageToImageFilterIRGBUC3ID3)
itkImageToImageFilterIRGBUC3ID3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3ID3_PopBackInput, None, itkImageToImageFilterIRGBUC3ID3)
itkImageToImageFilterIRGBUC3ID3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3ID3_PushFrontInput, None, itkImageToImageFilterIRGBUC3ID3)
itkImageToImageFilterIRGBUC3ID3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3ID3_PopFrontInput, None, itkImageToImageFilterIRGBUC3ID3)
itkImageToImageFilterIRGBUC3ID3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3ID3_SetCoordinateTolerance, None, itkImageToImageFilterIRGBUC3ID3)
itkImageToImageFilterIRGBUC3ID3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3ID3_GetCoordinateTolerance, None, itkImageToImageFilterIRGBUC3ID3)
itkImageToImageFilterIRGBUC3ID3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3ID3_SetDirectionTolerance, None, itkImageToImageFilterIRGBUC3ID3)
itkImageToImageFilterIRGBUC3ID3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3ID3_GetDirectionTolerance, None, itkImageToImageFilterIRGBUC3ID3)
itkImageToImageFilterIRGBUC3ID3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3ID3_swigregister
itkImageToImageFilterIRGBUC3ID3_swigregister(itkImageToImageFilterIRGBUC3ID3)

def itkImageToImageFilterIRGBUC3ID3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIRGBUC3ID3 *":
    """itkImageToImageFilterIRGBUC3ID3_cast(itkLightObject obj) -> itkImageToImageFilterIRGBUC3ID3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3ID3_cast(obj)

class itkImageToImageFilterIRGBUC3IF3(itkImageSourcePython.itkImageSourceIF3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIRGBUC3IF3 self, itkImageRGBUC3 image)
        SetInput(itkImageToImageFilterIRGBUC3IF3 self, unsigned int arg0, itkImageRGBUC3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IF3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageRGBUC3 const *":
        """
        GetInput(itkImageToImageFilterIRGBUC3IF3 self) -> itkImageRGBUC3
        GetInput(itkImageToImageFilterIRGBUC3IF3 self, unsigned int idx) -> itkImageRGBUC3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IF3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageRGBUC3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIRGBUC3IF3 self, itkImageRGBUC3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IF3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIRGBUC3IF3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IF3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageRGBUC3') -> "void":
        """PushFrontInput(itkImageToImageFilterIRGBUC3IF3 self, itkImageRGBUC3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IF3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIRGBUC3IF3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IF3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIRGBUC3IF3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IF3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIRGBUC3IF3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IF3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIRGBUC3IF3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IF3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIRGBUC3IF3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IF3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIRGBUC3IF3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIRGBUC3IF3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIRGBUC3IF3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IF3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIRGBUC3IF3

        Create a new object of the class itkImageToImageFilterIRGBUC3IF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIRGBUC3IF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIRGBUC3IF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIRGBUC3IF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIRGBUC3IF3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IF3_SetInput, None, itkImageToImageFilterIRGBUC3IF3)
itkImageToImageFilterIRGBUC3IF3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IF3_GetInput, None, itkImageToImageFilterIRGBUC3IF3)
itkImageToImageFilterIRGBUC3IF3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IF3_PushBackInput, None, itkImageToImageFilterIRGBUC3IF3)
itkImageToImageFilterIRGBUC3IF3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IF3_PopBackInput, None, itkImageToImageFilterIRGBUC3IF3)
itkImageToImageFilterIRGBUC3IF3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IF3_PushFrontInput, None, itkImageToImageFilterIRGBUC3IF3)
itkImageToImageFilterIRGBUC3IF3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IF3_PopFrontInput, None, itkImageToImageFilterIRGBUC3IF3)
itkImageToImageFilterIRGBUC3IF3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IF3_SetCoordinateTolerance, None, itkImageToImageFilterIRGBUC3IF3)
itkImageToImageFilterIRGBUC3IF3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IF3_GetCoordinateTolerance, None, itkImageToImageFilterIRGBUC3IF3)
itkImageToImageFilterIRGBUC3IF3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IF3_SetDirectionTolerance, None, itkImageToImageFilterIRGBUC3IF3)
itkImageToImageFilterIRGBUC3IF3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IF3_GetDirectionTolerance, None, itkImageToImageFilterIRGBUC3IF3)
itkImageToImageFilterIRGBUC3IF3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IF3_swigregister
itkImageToImageFilterIRGBUC3IF3_swigregister(itkImageToImageFilterIRGBUC3IF3)

def itkImageToImageFilterIRGBUC3IF3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIRGBUC3IF3 *":
    """itkImageToImageFilterIRGBUC3IF3_cast(itkLightObject obj) -> itkImageToImageFilterIRGBUC3IF3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IF3_cast(obj)

class itkImageToImageFilterIRGBUC3IRGBUC2(itkImageSourcePython.itkImageSourceIRGBUC2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIRGBUC3IRGBUC2 self, itkImageRGBUC3 image)
        SetInput(itkImageToImageFilterIRGBUC3IRGBUC2 self, unsigned int arg0, itkImageRGBUC3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IRGBUC2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageRGBUC3 const *":
        """
        GetInput(itkImageToImageFilterIRGBUC3IRGBUC2 self) -> itkImageRGBUC3
        GetInput(itkImageToImageFilterIRGBUC3IRGBUC2 self, unsigned int idx) -> itkImageRGBUC3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IRGBUC2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageRGBUC3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIRGBUC3IRGBUC2 self, itkImageRGBUC3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IRGBUC2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIRGBUC3IRGBUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IRGBUC2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageRGBUC3') -> "void":
        """PushFrontInput(itkImageToImageFilterIRGBUC3IRGBUC2 self, itkImageRGBUC3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IRGBUC2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIRGBUC3IRGBUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IRGBUC2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIRGBUC3IRGBUC2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IRGBUC2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIRGBUC3IRGBUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IRGBUC2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIRGBUC3IRGBUC2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IRGBUC2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIRGBUC3IRGBUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IRGBUC2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIRGBUC3IRGBUC2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIRGBUC3IRGBUC2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIRGBUC3IRGBUC2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IRGBUC2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIRGBUC3IRGBUC2

        Create a new object of the class itkImageToImageFilterIRGBUC3IRGBUC2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIRGBUC3IRGBUC2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIRGBUC3IRGBUC2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIRGBUC3IRGBUC2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIRGBUC3IRGBUC2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IRGBUC2_SetInput, None, itkImageToImageFilterIRGBUC3IRGBUC2)
itkImageToImageFilterIRGBUC3IRGBUC2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IRGBUC2_GetInput, None, itkImageToImageFilterIRGBUC3IRGBUC2)
itkImageToImageFilterIRGBUC3IRGBUC2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IRGBUC2_PushBackInput, None, itkImageToImageFilterIRGBUC3IRGBUC2)
itkImageToImageFilterIRGBUC3IRGBUC2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IRGBUC2_PopBackInput, None, itkImageToImageFilterIRGBUC3IRGBUC2)
itkImageToImageFilterIRGBUC3IRGBUC2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IRGBUC2_PushFrontInput, None, itkImageToImageFilterIRGBUC3IRGBUC2)
itkImageToImageFilterIRGBUC3IRGBUC2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IRGBUC2_PopFrontInput, None, itkImageToImageFilterIRGBUC3IRGBUC2)
itkImageToImageFilterIRGBUC3IRGBUC2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IRGBUC2_SetCoordinateTolerance, None, itkImageToImageFilterIRGBUC3IRGBUC2)
itkImageToImageFilterIRGBUC3IRGBUC2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IRGBUC2_GetCoordinateTolerance, None, itkImageToImageFilterIRGBUC3IRGBUC2)
itkImageToImageFilterIRGBUC3IRGBUC2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IRGBUC2_SetDirectionTolerance, None, itkImageToImageFilterIRGBUC3IRGBUC2)
itkImageToImageFilterIRGBUC3IRGBUC2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IRGBUC2_GetDirectionTolerance, None, itkImageToImageFilterIRGBUC3IRGBUC2)
itkImageToImageFilterIRGBUC3IRGBUC2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IRGBUC2_swigregister
itkImageToImageFilterIRGBUC3IRGBUC2_swigregister(itkImageToImageFilterIRGBUC3IRGBUC2)

def itkImageToImageFilterIRGBUC3IRGBUC2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIRGBUC3IRGBUC2 *":
    """itkImageToImageFilterIRGBUC3IRGBUC2_cast(itkLightObject obj) -> itkImageToImageFilterIRGBUC3IRGBUC2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IRGBUC2_cast(obj)

class itkImageToImageFilterIRGBUC3ISS3(itkImageSourcePython.itkImageSourceISS3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIRGBUC3ISS3 self, itkImageRGBUC3 image)
        SetInput(itkImageToImageFilterIRGBUC3ISS3 self, unsigned int arg0, itkImageRGBUC3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3ISS3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageRGBUC3 const *":
        """
        GetInput(itkImageToImageFilterIRGBUC3ISS3 self) -> itkImageRGBUC3
        GetInput(itkImageToImageFilterIRGBUC3ISS3 self, unsigned int idx) -> itkImageRGBUC3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3ISS3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageRGBUC3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIRGBUC3ISS3 self, itkImageRGBUC3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3ISS3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIRGBUC3ISS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3ISS3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageRGBUC3') -> "void":
        """PushFrontInput(itkImageToImageFilterIRGBUC3ISS3 self, itkImageRGBUC3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3ISS3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIRGBUC3ISS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3ISS3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIRGBUC3ISS3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3ISS3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIRGBUC3ISS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3ISS3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIRGBUC3ISS3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3ISS3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIRGBUC3ISS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3ISS3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIRGBUC3ISS3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIRGBUC3ISS3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIRGBUC3ISS3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3ISS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIRGBUC3ISS3

        Create a new object of the class itkImageToImageFilterIRGBUC3ISS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIRGBUC3ISS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIRGBUC3ISS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIRGBUC3ISS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIRGBUC3ISS3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3ISS3_SetInput, None, itkImageToImageFilterIRGBUC3ISS3)
itkImageToImageFilterIRGBUC3ISS3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3ISS3_GetInput, None, itkImageToImageFilterIRGBUC3ISS3)
itkImageToImageFilterIRGBUC3ISS3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3ISS3_PushBackInput, None, itkImageToImageFilterIRGBUC3ISS3)
itkImageToImageFilterIRGBUC3ISS3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3ISS3_PopBackInput, None, itkImageToImageFilterIRGBUC3ISS3)
itkImageToImageFilterIRGBUC3ISS3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3ISS3_PushFrontInput, None, itkImageToImageFilterIRGBUC3ISS3)
itkImageToImageFilterIRGBUC3ISS3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3ISS3_PopFrontInput, None, itkImageToImageFilterIRGBUC3ISS3)
itkImageToImageFilterIRGBUC3ISS3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3ISS3_SetCoordinateTolerance, None, itkImageToImageFilterIRGBUC3ISS3)
itkImageToImageFilterIRGBUC3ISS3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3ISS3_GetCoordinateTolerance, None, itkImageToImageFilterIRGBUC3ISS3)
itkImageToImageFilterIRGBUC3ISS3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3ISS3_SetDirectionTolerance, None, itkImageToImageFilterIRGBUC3ISS3)
itkImageToImageFilterIRGBUC3ISS3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3ISS3_GetDirectionTolerance, None, itkImageToImageFilterIRGBUC3ISS3)
itkImageToImageFilterIRGBUC3ISS3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3ISS3_swigregister
itkImageToImageFilterIRGBUC3ISS3_swigregister(itkImageToImageFilterIRGBUC3ISS3)

def itkImageToImageFilterIRGBUC3ISS3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIRGBUC3ISS3 *":
    """itkImageToImageFilterIRGBUC3ISS3_cast(itkLightObject obj) -> itkImageToImageFilterIRGBUC3ISS3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3ISS3_cast(obj)

class itkImageToImageFilterIRGBUC3IUC3(itkImageSourcePython.itkImageSourceIUC3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIRGBUC3IUC3 self, itkImageRGBUC3 image)
        SetInput(itkImageToImageFilterIRGBUC3IUC3 self, unsigned int arg0, itkImageRGBUC3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUC3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageRGBUC3 const *":
        """
        GetInput(itkImageToImageFilterIRGBUC3IUC3 self) -> itkImageRGBUC3
        GetInput(itkImageToImageFilterIRGBUC3IUC3 self, unsigned int idx) -> itkImageRGBUC3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUC3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageRGBUC3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIRGBUC3IUC3 self, itkImageRGBUC3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUC3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIRGBUC3IUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUC3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageRGBUC3') -> "void":
        """PushFrontInput(itkImageToImageFilterIRGBUC3IUC3 self, itkImageRGBUC3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUC3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIRGBUC3IUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUC3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIRGBUC3IUC3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUC3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIRGBUC3IUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUC3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIRGBUC3IUC3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUC3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIRGBUC3IUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUC3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIRGBUC3IUC3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIRGBUC3IUC3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIRGBUC3IUC3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUC3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIRGBUC3IUC3

        Create a new object of the class itkImageToImageFilterIRGBUC3IUC3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIRGBUC3IUC3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIRGBUC3IUC3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIRGBUC3IUC3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIRGBUC3IUC3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUC3_SetInput, None, itkImageToImageFilterIRGBUC3IUC3)
itkImageToImageFilterIRGBUC3IUC3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUC3_GetInput, None, itkImageToImageFilterIRGBUC3IUC3)
itkImageToImageFilterIRGBUC3IUC3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUC3_PushBackInput, None, itkImageToImageFilterIRGBUC3IUC3)
itkImageToImageFilterIRGBUC3IUC3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUC3_PopBackInput, None, itkImageToImageFilterIRGBUC3IUC3)
itkImageToImageFilterIRGBUC3IUC3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUC3_PushFrontInput, None, itkImageToImageFilterIRGBUC3IUC3)
itkImageToImageFilterIRGBUC3IUC3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUC3_PopFrontInput, None, itkImageToImageFilterIRGBUC3IUC3)
itkImageToImageFilterIRGBUC3IUC3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUC3_SetCoordinateTolerance, None, itkImageToImageFilterIRGBUC3IUC3)
itkImageToImageFilterIRGBUC3IUC3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUC3_GetCoordinateTolerance, None, itkImageToImageFilterIRGBUC3IUC3)
itkImageToImageFilterIRGBUC3IUC3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUC3_SetDirectionTolerance, None, itkImageToImageFilterIRGBUC3IUC3)
itkImageToImageFilterIRGBUC3IUC3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUC3_GetDirectionTolerance, None, itkImageToImageFilterIRGBUC3IUC3)
itkImageToImageFilterIRGBUC3IUC3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUC3_swigregister
itkImageToImageFilterIRGBUC3IUC3_swigregister(itkImageToImageFilterIRGBUC3IUC3)

def itkImageToImageFilterIRGBUC3IUC3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIRGBUC3IUC3 *":
    """itkImageToImageFilterIRGBUC3IUC3_cast(itkLightObject obj) -> itkImageToImageFilterIRGBUC3IUC3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUC3_cast(obj)

class itkImageToImageFilterIRGBUC3IUL3(itkImageSourcePython.itkImageSourceIUL3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIRGBUC3IUL3 self, itkImageRGBUC3 image)
        SetInput(itkImageToImageFilterIRGBUC3IUL3 self, unsigned int arg0, itkImageRGBUC3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUL3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageRGBUC3 const *":
        """
        GetInput(itkImageToImageFilterIRGBUC3IUL3 self) -> itkImageRGBUC3
        GetInput(itkImageToImageFilterIRGBUC3IUL3 self, unsigned int idx) -> itkImageRGBUC3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUL3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageRGBUC3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIRGBUC3IUL3 self, itkImageRGBUC3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUL3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIRGBUC3IUL3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUL3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageRGBUC3') -> "void":
        """PushFrontInput(itkImageToImageFilterIRGBUC3IUL3 self, itkImageRGBUC3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUL3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIRGBUC3IUL3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUL3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIRGBUC3IUL3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUL3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIRGBUC3IUL3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUL3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIRGBUC3IUL3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUL3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIRGBUC3IUL3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUL3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIRGBUC3IUL3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIRGBUC3IUL3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIRGBUC3IUL3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUL3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIRGBUC3IUL3

        Create a new object of the class itkImageToImageFilterIRGBUC3IUL3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIRGBUC3IUL3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIRGBUC3IUL3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIRGBUC3IUL3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIRGBUC3IUL3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUL3_SetInput, None, itkImageToImageFilterIRGBUC3IUL3)
itkImageToImageFilterIRGBUC3IUL3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUL3_GetInput, None, itkImageToImageFilterIRGBUC3IUL3)
itkImageToImageFilterIRGBUC3IUL3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUL3_PushBackInput, None, itkImageToImageFilterIRGBUC3IUL3)
itkImageToImageFilterIRGBUC3IUL3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUL3_PopBackInput, None, itkImageToImageFilterIRGBUC3IUL3)
itkImageToImageFilterIRGBUC3IUL3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUL3_PushFrontInput, None, itkImageToImageFilterIRGBUC3IUL3)
itkImageToImageFilterIRGBUC3IUL3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUL3_PopFrontInput, None, itkImageToImageFilterIRGBUC3IUL3)
itkImageToImageFilterIRGBUC3IUL3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUL3_SetCoordinateTolerance, None, itkImageToImageFilterIRGBUC3IUL3)
itkImageToImageFilterIRGBUC3IUL3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUL3_GetCoordinateTolerance, None, itkImageToImageFilterIRGBUC3IUL3)
itkImageToImageFilterIRGBUC3IUL3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUL3_SetDirectionTolerance, None, itkImageToImageFilterIRGBUC3IUL3)
itkImageToImageFilterIRGBUC3IUL3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUL3_GetDirectionTolerance, None, itkImageToImageFilterIRGBUC3IUL3)
itkImageToImageFilterIRGBUC3IUL3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUL3_swigregister
itkImageToImageFilterIRGBUC3IUL3_swigregister(itkImageToImageFilterIRGBUC3IUL3)

def itkImageToImageFilterIRGBUC3IUL3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIRGBUC3IUL3 *":
    """itkImageToImageFilterIRGBUC3IUL3_cast(itkLightObject obj) -> itkImageToImageFilterIRGBUC3IUL3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUL3_cast(obj)

class itkImageToImageFilterIRGBUC3IUS3(itkImageSourcePython.itkImageSourceIUS3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIRGBUC3IUS3 self, itkImageRGBUC3 image)
        SetInput(itkImageToImageFilterIRGBUC3IUS3 self, unsigned int arg0, itkImageRGBUC3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUS3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageRGBUC3 const *":
        """
        GetInput(itkImageToImageFilterIRGBUC3IUS3 self) -> itkImageRGBUC3
        GetInput(itkImageToImageFilterIRGBUC3IUS3 self, unsigned int idx) -> itkImageRGBUC3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUS3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageRGBUC3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIRGBUC3IUS3 self, itkImageRGBUC3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUS3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIRGBUC3IUS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUS3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageRGBUC3') -> "void":
        """PushFrontInput(itkImageToImageFilterIRGBUC3IUS3 self, itkImageRGBUC3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUS3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIRGBUC3IUS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUS3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIRGBUC3IUS3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUS3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIRGBUC3IUS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUS3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIRGBUC3IUS3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUS3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIRGBUC3IUS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUS3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIRGBUC3IUS3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIRGBUC3IUS3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIRGBUC3IUS3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIRGBUC3IUS3

        Create a new object of the class itkImageToImageFilterIRGBUC3IUS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIRGBUC3IUS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIRGBUC3IUS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIRGBUC3IUS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIRGBUC3IUS3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUS3_SetInput, None, itkImageToImageFilterIRGBUC3IUS3)
itkImageToImageFilterIRGBUC3IUS3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUS3_GetInput, None, itkImageToImageFilterIRGBUC3IUS3)
itkImageToImageFilterIRGBUC3IUS3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUS3_PushBackInput, None, itkImageToImageFilterIRGBUC3IUS3)
itkImageToImageFilterIRGBUC3IUS3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUS3_PopBackInput, None, itkImageToImageFilterIRGBUC3IUS3)
itkImageToImageFilterIRGBUC3IUS3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUS3_PushFrontInput, None, itkImageToImageFilterIRGBUC3IUS3)
itkImageToImageFilterIRGBUC3IUS3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUS3_PopFrontInput, None, itkImageToImageFilterIRGBUC3IUS3)
itkImageToImageFilterIRGBUC3IUS3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUS3_SetCoordinateTolerance, None, itkImageToImageFilterIRGBUC3IUS3)
itkImageToImageFilterIRGBUC3IUS3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUS3_GetCoordinateTolerance, None, itkImageToImageFilterIRGBUC3IUS3)
itkImageToImageFilterIRGBUC3IUS3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUS3_SetDirectionTolerance, None, itkImageToImageFilterIRGBUC3IUS3)
itkImageToImageFilterIRGBUC3IUS3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUS3_GetDirectionTolerance, None, itkImageToImageFilterIRGBUC3IUS3)
itkImageToImageFilterIRGBUC3IUS3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUS3_swigregister
itkImageToImageFilterIRGBUC3IUS3_swigregister(itkImageToImageFilterIRGBUC3IUS3)

def itkImageToImageFilterIRGBUC3IUS3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIRGBUC3IUS3 *":
    """itkImageToImageFilterIRGBUC3IUS3_cast(itkLightObject obj) -> itkImageToImageFilterIRGBUC3IUS3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIRGBUC3IUS3_cast(obj)

class itkImageToImageFilterISS2ICF2(itkImageSourcePython.itkImageSourceICF2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterISS2ICF2 self, itkImageSS2 image)
        SetInput(itkImageToImageFilterISS2ICF2 self, unsigned int arg0, itkImageSS2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ICF2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageSS2 const *":
        """
        GetInput(itkImageToImageFilterISS2ICF2 self) -> itkImageSS2
        GetInput(itkImageToImageFilterISS2ICF2 self, unsigned int idx) -> itkImageSS2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ICF2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageSS2') -> "void":
        """
        PushBackInput(itkImageToImageFilterISS2ICF2 self, itkImageSS2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ICF2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterISS2ICF2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ICF2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageSS2') -> "void":
        """PushFrontInput(itkImageToImageFilterISS2ICF2 self, itkImageSS2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ICF2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterISS2ICF2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ICF2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterISS2ICF2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ICF2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterISS2ICF2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ICF2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterISS2ICF2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ICF2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterISS2ICF2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ICF2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterISS2ICF2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS2ICF2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterISS2ICF2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ICF2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterISS2ICF2

        Create a new object of the class itkImageToImageFilterISS2ICF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterISS2ICF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterISS2ICF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterISS2ICF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterISS2ICF2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2ICF2_SetInput, None, itkImageToImageFilterISS2ICF2)
itkImageToImageFilterISS2ICF2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2ICF2_GetInput, None, itkImageToImageFilterISS2ICF2)
itkImageToImageFilterISS2ICF2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2ICF2_PushBackInput, None, itkImageToImageFilterISS2ICF2)
itkImageToImageFilterISS2ICF2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2ICF2_PopBackInput, None, itkImageToImageFilterISS2ICF2)
itkImageToImageFilterISS2ICF2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2ICF2_PushFrontInput, None, itkImageToImageFilterISS2ICF2)
itkImageToImageFilterISS2ICF2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2ICF2_PopFrontInput, None, itkImageToImageFilterISS2ICF2)
itkImageToImageFilterISS2ICF2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2ICF2_SetCoordinateTolerance, None, itkImageToImageFilterISS2ICF2)
itkImageToImageFilterISS2ICF2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2ICF2_GetCoordinateTolerance, None, itkImageToImageFilterISS2ICF2)
itkImageToImageFilterISS2ICF2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2ICF2_SetDirectionTolerance, None, itkImageToImageFilterISS2ICF2)
itkImageToImageFilterISS2ICF2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2ICF2_GetDirectionTolerance, None, itkImageToImageFilterISS2ICF2)
itkImageToImageFilterISS2ICF2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterISS2ICF2_swigregister
itkImageToImageFilterISS2ICF2_swigregister(itkImageToImageFilterISS2ICF2)

def itkImageToImageFilterISS2ICF2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS2ICF2 *":
    """itkImageToImageFilterISS2ICF2_cast(itkLightObject obj) -> itkImageToImageFilterISS2ICF2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ICF2_cast(obj)

class itkImageToImageFilterISS2ICVF22(itkImageSourcePython.itkImageSourceICVF22):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterISS2ICVF22 self, itkImageSS2 image)
        SetInput(itkImageToImageFilterISS2ICVF22 self, unsigned int arg0, itkImageSS2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF22_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageSS2 const *":
        """
        GetInput(itkImageToImageFilterISS2ICVF22 self) -> itkImageSS2
        GetInput(itkImageToImageFilterISS2ICVF22 self, unsigned int idx) -> itkImageSS2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF22_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageSS2') -> "void":
        """
        PushBackInput(itkImageToImageFilterISS2ICVF22 self, itkImageSS2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF22_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterISS2ICVF22 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF22_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageSS2') -> "void":
        """PushFrontInput(itkImageToImageFilterISS2ICVF22 self, itkImageSS2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF22_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterISS2ICVF22 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF22_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterISS2ICVF22 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF22_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterISS2ICVF22 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF22_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterISS2ICVF22 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF22_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterISS2ICVF22 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF22_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterISS2ICVF22

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS2ICVF22 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterISS2ICVF22"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF22_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterISS2ICVF22

        Create a new object of the class itkImageToImageFilterISS2ICVF22 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterISS2ICVF22.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterISS2ICVF22.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterISS2ICVF22.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterISS2ICVF22.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF22_SetInput, None, itkImageToImageFilterISS2ICVF22)
itkImageToImageFilterISS2ICVF22.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF22_GetInput, None, itkImageToImageFilterISS2ICVF22)
itkImageToImageFilterISS2ICVF22.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF22_PushBackInput, None, itkImageToImageFilterISS2ICVF22)
itkImageToImageFilterISS2ICVF22.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF22_PopBackInput, None, itkImageToImageFilterISS2ICVF22)
itkImageToImageFilterISS2ICVF22.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF22_PushFrontInput, None, itkImageToImageFilterISS2ICVF22)
itkImageToImageFilterISS2ICVF22.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF22_PopFrontInput, None, itkImageToImageFilterISS2ICVF22)
itkImageToImageFilterISS2ICVF22.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF22_SetCoordinateTolerance, None, itkImageToImageFilterISS2ICVF22)
itkImageToImageFilterISS2ICVF22.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF22_GetCoordinateTolerance, None, itkImageToImageFilterISS2ICVF22)
itkImageToImageFilterISS2ICVF22.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF22_SetDirectionTolerance, None, itkImageToImageFilterISS2ICVF22)
itkImageToImageFilterISS2ICVF22.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF22_GetDirectionTolerance, None, itkImageToImageFilterISS2ICVF22)
itkImageToImageFilterISS2ICVF22_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF22_swigregister
itkImageToImageFilterISS2ICVF22_swigregister(itkImageToImageFilterISS2ICVF22)

def itkImageToImageFilterISS2ICVF22_cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS2ICVF22 *":
    """itkImageToImageFilterISS2ICVF22_cast(itkLightObject obj) -> itkImageToImageFilterISS2ICVF22"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF22_cast(obj)

class itkImageToImageFilterISS2ICVF32(itkImageSourcePython.itkImageSourceICVF32):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterISS2ICVF32 self, itkImageSS2 image)
        SetInput(itkImageToImageFilterISS2ICVF32 self, unsigned int arg0, itkImageSS2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF32_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageSS2 const *":
        """
        GetInput(itkImageToImageFilterISS2ICVF32 self) -> itkImageSS2
        GetInput(itkImageToImageFilterISS2ICVF32 self, unsigned int idx) -> itkImageSS2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF32_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageSS2') -> "void":
        """
        PushBackInput(itkImageToImageFilterISS2ICVF32 self, itkImageSS2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF32_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterISS2ICVF32 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF32_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageSS2') -> "void":
        """PushFrontInput(itkImageToImageFilterISS2ICVF32 self, itkImageSS2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF32_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterISS2ICVF32 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF32_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterISS2ICVF32 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF32_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterISS2ICVF32 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF32_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterISS2ICVF32 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF32_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterISS2ICVF32 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF32_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterISS2ICVF32

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS2ICVF32 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterISS2ICVF32"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF32_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterISS2ICVF32

        Create a new object of the class itkImageToImageFilterISS2ICVF32 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterISS2ICVF32.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterISS2ICVF32.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterISS2ICVF32.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterISS2ICVF32.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF32_SetInput, None, itkImageToImageFilterISS2ICVF32)
itkImageToImageFilterISS2ICVF32.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF32_GetInput, None, itkImageToImageFilterISS2ICVF32)
itkImageToImageFilterISS2ICVF32.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF32_PushBackInput, None, itkImageToImageFilterISS2ICVF32)
itkImageToImageFilterISS2ICVF32.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF32_PopBackInput, None, itkImageToImageFilterISS2ICVF32)
itkImageToImageFilterISS2ICVF32.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF32_PushFrontInput, None, itkImageToImageFilterISS2ICVF32)
itkImageToImageFilterISS2ICVF32.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF32_PopFrontInput, None, itkImageToImageFilterISS2ICVF32)
itkImageToImageFilterISS2ICVF32.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF32_SetCoordinateTolerance, None, itkImageToImageFilterISS2ICVF32)
itkImageToImageFilterISS2ICVF32.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF32_GetCoordinateTolerance, None, itkImageToImageFilterISS2ICVF32)
itkImageToImageFilterISS2ICVF32.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF32_SetDirectionTolerance, None, itkImageToImageFilterISS2ICVF32)
itkImageToImageFilterISS2ICVF32.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF32_GetDirectionTolerance, None, itkImageToImageFilterISS2ICVF32)
itkImageToImageFilterISS2ICVF32_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF32_swigregister
itkImageToImageFilterISS2ICVF32_swigregister(itkImageToImageFilterISS2ICVF32)

def itkImageToImageFilterISS2ICVF32_cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS2ICVF32 *":
    """itkImageToImageFilterISS2ICVF32_cast(itkLightObject obj) -> itkImageToImageFilterISS2ICVF32"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF32_cast(obj)

class itkImageToImageFilterISS2ICVF42(itkImageSourcePython.itkImageSourceICVF42):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterISS2ICVF42 self, itkImageSS2 image)
        SetInput(itkImageToImageFilterISS2ICVF42 self, unsigned int arg0, itkImageSS2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF42_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageSS2 const *":
        """
        GetInput(itkImageToImageFilterISS2ICVF42 self) -> itkImageSS2
        GetInput(itkImageToImageFilterISS2ICVF42 self, unsigned int idx) -> itkImageSS2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF42_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageSS2') -> "void":
        """
        PushBackInput(itkImageToImageFilterISS2ICVF42 self, itkImageSS2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF42_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterISS2ICVF42 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF42_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageSS2') -> "void":
        """PushFrontInput(itkImageToImageFilterISS2ICVF42 self, itkImageSS2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF42_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterISS2ICVF42 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF42_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterISS2ICVF42 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF42_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterISS2ICVF42 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF42_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterISS2ICVF42 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF42_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterISS2ICVF42 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF42_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterISS2ICVF42

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS2ICVF42 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterISS2ICVF42"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF42_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterISS2ICVF42

        Create a new object of the class itkImageToImageFilterISS2ICVF42 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterISS2ICVF42.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterISS2ICVF42.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterISS2ICVF42.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterISS2ICVF42.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF42_SetInput, None, itkImageToImageFilterISS2ICVF42)
itkImageToImageFilterISS2ICVF42.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF42_GetInput, None, itkImageToImageFilterISS2ICVF42)
itkImageToImageFilterISS2ICVF42.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF42_PushBackInput, None, itkImageToImageFilterISS2ICVF42)
itkImageToImageFilterISS2ICVF42.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF42_PopBackInput, None, itkImageToImageFilterISS2ICVF42)
itkImageToImageFilterISS2ICVF42.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF42_PushFrontInput, None, itkImageToImageFilterISS2ICVF42)
itkImageToImageFilterISS2ICVF42.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF42_PopFrontInput, None, itkImageToImageFilterISS2ICVF42)
itkImageToImageFilterISS2ICVF42.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF42_SetCoordinateTolerance, None, itkImageToImageFilterISS2ICVF42)
itkImageToImageFilterISS2ICVF42.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF42_GetCoordinateTolerance, None, itkImageToImageFilterISS2ICVF42)
itkImageToImageFilterISS2ICVF42.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF42_SetDirectionTolerance, None, itkImageToImageFilterISS2ICVF42)
itkImageToImageFilterISS2ICVF42.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF42_GetDirectionTolerance, None, itkImageToImageFilterISS2ICVF42)
itkImageToImageFilterISS2ICVF42_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF42_swigregister
itkImageToImageFilterISS2ICVF42_swigregister(itkImageToImageFilterISS2ICVF42)

def itkImageToImageFilterISS2ICVF42_cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS2ICVF42 *":
    """itkImageToImageFilterISS2ICVF42_cast(itkLightObject obj) -> itkImageToImageFilterISS2ICVF42"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ICVF42_cast(obj)

class itkImageToImageFilterISS2IRGBAUC2(itkImageSourcePython.itkImageSourceIRGBAUC2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterISS2IRGBAUC2 self, itkImageSS2 image)
        SetInput(itkImageToImageFilterISS2IRGBAUC2 self, unsigned int arg0, itkImageSS2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2IRGBAUC2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageSS2 const *":
        """
        GetInput(itkImageToImageFilterISS2IRGBAUC2 self) -> itkImageSS2
        GetInput(itkImageToImageFilterISS2IRGBAUC2 self, unsigned int idx) -> itkImageSS2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2IRGBAUC2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageSS2') -> "void":
        """
        PushBackInput(itkImageToImageFilterISS2IRGBAUC2 self, itkImageSS2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2IRGBAUC2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterISS2IRGBAUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2IRGBAUC2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageSS2') -> "void":
        """PushFrontInput(itkImageToImageFilterISS2IRGBAUC2 self, itkImageSS2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2IRGBAUC2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterISS2IRGBAUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2IRGBAUC2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterISS2IRGBAUC2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2IRGBAUC2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterISS2IRGBAUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2IRGBAUC2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterISS2IRGBAUC2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2IRGBAUC2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterISS2IRGBAUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2IRGBAUC2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterISS2IRGBAUC2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS2IRGBAUC2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterISS2IRGBAUC2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2IRGBAUC2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterISS2IRGBAUC2

        Create a new object of the class itkImageToImageFilterISS2IRGBAUC2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterISS2IRGBAUC2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterISS2IRGBAUC2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterISS2IRGBAUC2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterISS2IRGBAUC2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2IRGBAUC2_SetInput, None, itkImageToImageFilterISS2IRGBAUC2)
itkImageToImageFilterISS2IRGBAUC2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2IRGBAUC2_GetInput, None, itkImageToImageFilterISS2IRGBAUC2)
itkImageToImageFilterISS2IRGBAUC2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2IRGBAUC2_PushBackInput, None, itkImageToImageFilterISS2IRGBAUC2)
itkImageToImageFilterISS2IRGBAUC2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2IRGBAUC2_PopBackInput, None, itkImageToImageFilterISS2IRGBAUC2)
itkImageToImageFilterISS2IRGBAUC2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2IRGBAUC2_PushFrontInput, None, itkImageToImageFilterISS2IRGBAUC2)
itkImageToImageFilterISS2IRGBAUC2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2IRGBAUC2_PopFrontInput, None, itkImageToImageFilterISS2IRGBAUC2)
itkImageToImageFilterISS2IRGBAUC2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2IRGBAUC2_SetCoordinateTolerance, None, itkImageToImageFilterISS2IRGBAUC2)
itkImageToImageFilterISS2IRGBAUC2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2IRGBAUC2_GetCoordinateTolerance, None, itkImageToImageFilterISS2IRGBAUC2)
itkImageToImageFilterISS2IRGBAUC2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2IRGBAUC2_SetDirectionTolerance, None, itkImageToImageFilterISS2IRGBAUC2)
itkImageToImageFilterISS2IRGBAUC2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2IRGBAUC2_GetDirectionTolerance, None, itkImageToImageFilterISS2IRGBAUC2)
itkImageToImageFilterISS2IRGBAUC2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterISS2IRGBAUC2_swigregister
itkImageToImageFilterISS2IRGBAUC2_swigregister(itkImageToImageFilterISS2IRGBAUC2)

def itkImageToImageFilterISS2IRGBAUC2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS2IRGBAUC2 *":
    """itkImageToImageFilterISS2IRGBAUC2_cast(itkLightObject obj) -> itkImageToImageFilterISS2IRGBAUC2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterISS2IRGBAUC2_cast(obj)

class itkImageToImageFilterISS2IRGBUC2(itkImageSourcePython.itkImageSourceIRGBUC2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterISS2IRGBUC2 self, itkImageSS2 image)
        SetInput(itkImageToImageFilterISS2IRGBUC2 self, unsigned int arg0, itkImageSS2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2IRGBUC2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageSS2 const *":
        """
        GetInput(itkImageToImageFilterISS2IRGBUC2 self) -> itkImageSS2
        GetInput(itkImageToImageFilterISS2IRGBUC2 self, unsigned int idx) -> itkImageSS2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2IRGBUC2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageSS2') -> "void":
        """
        PushBackInput(itkImageToImageFilterISS2IRGBUC2 self, itkImageSS2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2IRGBUC2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterISS2IRGBUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2IRGBUC2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageSS2') -> "void":
        """PushFrontInput(itkImageToImageFilterISS2IRGBUC2 self, itkImageSS2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2IRGBUC2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterISS2IRGBUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2IRGBUC2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterISS2IRGBUC2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2IRGBUC2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterISS2IRGBUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2IRGBUC2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterISS2IRGBUC2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2IRGBUC2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterISS2IRGBUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2IRGBUC2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterISS2IRGBUC2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS2IRGBUC2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterISS2IRGBUC2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2IRGBUC2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterISS2IRGBUC2

        Create a new object of the class itkImageToImageFilterISS2IRGBUC2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterISS2IRGBUC2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterISS2IRGBUC2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterISS2IRGBUC2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterISS2IRGBUC2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2IRGBUC2_SetInput, None, itkImageToImageFilterISS2IRGBUC2)
itkImageToImageFilterISS2IRGBUC2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2IRGBUC2_GetInput, None, itkImageToImageFilterISS2IRGBUC2)
itkImageToImageFilterISS2IRGBUC2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2IRGBUC2_PushBackInput, None, itkImageToImageFilterISS2IRGBUC2)
itkImageToImageFilterISS2IRGBUC2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2IRGBUC2_PopBackInput, None, itkImageToImageFilterISS2IRGBUC2)
itkImageToImageFilterISS2IRGBUC2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2IRGBUC2_PushFrontInput, None, itkImageToImageFilterISS2IRGBUC2)
itkImageToImageFilterISS2IRGBUC2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2IRGBUC2_PopFrontInput, None, itkImageToImageFilterISS2IRGBUC2)
itkImageToImageFilterISS2IRGBUC2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2IRGBUC2_SetCoordinateTolerance, None, itkImageToImageFilterISS2IRGBUC2)
itkImageToImageFilterISS2IRGBUC2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2IRGBUC2_GetCoordinateTolerance, None, itkImageToImageFilterISS2IRGBUC2)
itkImageToImageFilterISS2IRGBUC2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2IRGBUC2_SetDirectionTolerance, None, itkImageToImageFilterISS2IRGBUC2)
itkImageToImageFilterISS2IRGBUC2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2IRGBUC2_GetDirectionTolerance, None, itkImageToImageFilterISS2IRGBUC2)
itkImageToImageFilterISS2IRGBUC2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterISS2IRGBUC2_swigregister
itkImageToImageFilterISS2IRGBUC2_swigregister(itkImageToImageFilterISS2IRGBUC2)

def itkImageToImageFilterISS2IRGBUC2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS2IRGBUC2 *":
    """itkImageToImageFilterISS2IRGBUC2_cast(itkLightObject obj) -> itkImageToImageFilterISS2IRGBUC2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterISS2IRGBUC2_cast(obj)

class itkImageToImageFilterISS2ISS3(itkImageSourcePython.itkImageSourceISS3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterISS2ISS3 self, itkImageSS2 image)
        SetInput(itkImageToImageFilterISS2ISS3 self, unsigned int arg0, itkImageSS2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ISS3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageSS2 const *":
        """
        GetInput(itkImageToImageFilterISS2ISS3 self) -> itkImageSS2
        GetInput(itkImageToImageFilterISS2ISS3 self, unsigned int idx) -> itkImageSS2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ISS3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageSS2') -> "void":
        """
        PushBackInput(itkImageToImageFilterISS2ISS3 self, itkImageSS2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ISS3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterISS2ISS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ISS3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageSS2') -> "void":
        """PushFrontInput(itkImageToImageFilterISS2ISS3 self, itkImageSS2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ISS3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterISS2ISS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ISS3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterISS2ISS3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ISS3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterISS2ISS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ISS3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterISS2ISS3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ISS3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterISS2ISS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ISS3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterISS2ISS3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS2ISS3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterISS2ISS3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ISS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterISS2ISS3

        Create a new object of the class itkImageToImageFilterISS2ISS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterISS2ISS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterISS2ISS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterISS2ISS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterISS2ISS3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2ISS3_SetInput, None, itkImageToImageFilterISS2ISS3)
itkImageToImageFilterISS2ISS3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2ISS3_GetInput, None, itkImageToImageFilterISS2ISS3)
itkImageToImageFilterISS2ISS3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2ISS3_PushBackInput, None, itkImageToImageFilterISS2ISS3)
itkImageToImageFilterISS2ISS3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2ISS3_PopBackInput, None, itkImageToImageFilterISS2ISS3)
itkImageToImageFilterISS2ISS3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2ISS3_PushFrontInput, None, itkImageToImageFilterISS2ISS3)
itkImageToImageFilterISS2ISS3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2ISS3_PopFrontInput, None, itkImageToImageFilterISS2ISS3)
itkImageToImageFilterISS2ISS3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2ISS3_SetCoordinateTolerance, None, itkImageToImageFilterISS2ISS3)
itkImageToImageFilterISS2ISS3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2ISS3_GetCoordinateTolerance, None, itkImageToImageFilterISS2ISS3)
itkImageToImageFilterISS2ISS3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2ISS3_SetDirectionTolerance, None, itkImageToImageFilterISS2ISS3)
itkImageToImageFilterISS2ISS3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2ISS3_GetDirectionTolerance, None, itkImageToImageFilterISS2ISS3)
itkImageToImageFilterISS2ISS3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterISS2ISS3_swigregister
itkImageToImageFilterISS2ISS3_swigregister(itkImageToImageFilterISS2ISS3)

def itkImageToImageFilterISS2ISS3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS2ISS3 *":
    """itkImageToImageFilterISS2ISS3_cast(itkLightObject obj) -> itkImageToImageFilterISS2ISS3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ISS3_cast(obj)

class itkImageToImageFilterISS2ISSRTD22(itkImageSourcePython.itkImageSourceISSRTD22):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterISS2ISSRTD22 self, itkImageSS2 image)
        SetInput(itkImageToImageFilterISS2ISSRTD22 self, unsigned int arg0, itkImageSS2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ISSRTD22_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageSS2 const *":
        """
        GetInput(itkImageToImageFilterISS2ISSRTD22 self) -> itkImageSS2
        GetInput(itkImageToImageFilterISS2ISSRTD22 self, unsigned int idx) -> itkImageSS2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ISSRTD22_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageSS2') -> "void":
        """
        PushBackInput(itkImageToImageFilterISS2ISSRTD22 self, itkImageSS2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ISSRTD22_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterISS2ISSRTD22 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ISSRTD22_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageSS2') -> "void":
        """PushFrontInput(itkImageToImageFilterISS2ISSRTD22 self, itkImageSS2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ISSRTD22_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterISS2ISSRTD22 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ISSRTD22_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterISS2ISSRTD22 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ISSRTD22_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterISS2ISSRTD22 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ISSRTD22_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterISS2ISSRTD22 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ISSRTD22_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterISS2ISSRTD22 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ISSRTD22_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterISS2ISSRTD22

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS2ISSRTD22 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterISS2ISSRTD22"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ISSRTD22_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterISS2ISSRTD22

        Create a new object of the class itkImageToImageFilterISS2ISSRTD22 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterISS2ISSRTD22.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterISS2ISSRTD22.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterISS2ISSRTD22.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterISS2ISSRTD22.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2ISSRTD22_SetInput, None, itkImageToImageFilterISS2ISSRTD22)
itkImageToImageFilterISS2ISSRTD22.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2ISSRTD22_GetInput, None, itkImageToImageFilterISS2ISSRTD22)
itkImageToImageFilterISS2ISSRTD22.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2ISSRTD22_PushBackInput, None, itkImageToImageFilterISS2ISSRTD22)
itkImageToImageFilterISS2ISSRTD22.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2ISSRTD22_PopBackInput, None, itkImageToImageFilterISS2ISSRTD22)
itkImageToImageFilterISS2ISSRTD22.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2ISSRTD22_PushFrontInput, None, itkImageToImageFilterISS2ISSRTD22)
itkImageToImageFilterISS2ISSRTD22.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2ISSRTD22_PopFrontInput, None, itkImageToImageFilterISS2ISSRTD22)
itkImageToImageFilterISS2ISSRTD22.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2ISSRTD22_SetCoordinateTolerance, None, itkImageToImageFilterISS2ISSRTD22)
itkImageToImageFilterISS2ISSRTD22.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2ISSRTD22_GetCoordinateTolerance, None, itkImageToImageFilterISS2ISSRTD22)
itkImageToImageFilterISS2ISSRTD22.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2ISSRTD22_SetDirectionTolerance, None, itkImageToImageFilterISS2ISSRTD22)
itkImageToImageFilterISS2ISSRTD22.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2ISSRTD22_GetDirectionTolerance, None, itkImageToImageFilterISS2ISSRTD22)
itkImageToImageFilterISS2ISSRTD22_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterISS2ISSRTD22_swigregister
itkImageToImageFilterISS2ISSRTD22_swigregister(itkImageToImageFilterISS2ISSRTD22)

def itkImageToImageFilterISS2ISSRTD22_cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS2ISSRTD22 *":
    """itkImageToImageFilterISS2ISSRTD22_cast(itkLightObject obj) -> itkImageToImageFilterISS2ISSRTD22"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterISS2ISSRTD22_cast(obj)

class itkImageToImageFilterISS2IVF22(itkImageSourcePython.itkImageSourceIVF22):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterISS2IVF22 self, itkImageSS2 image)
        SetInput(itkImageToImageFilterISS2IVF22 self, unsigned int arg0, itkImageSS2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF22_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageSS2 const *":
        """
        GetInput(itkImageToImageFilterISS2IVF22 self) -> itkImageSS2
        GetInput(itkImageToImageFilterISS2IVF22 self, unsigned int idx) -> itkImageSS2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF22_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageSS2') -> "void":
        """
        PushBackInput(itkImageToImageFilterISS2IVF22 self, itkImageSS2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF22_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterISS2IVF22 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF22_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageSS2') -> "void":
        """PushFrontInput(itkImageToImageFilterISS2IVF22 self, itkImageSS2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF22_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterISS2IVF22 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF22_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterISS2IVF22 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF22_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterISS2IVF22 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF22_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterISS2IVF22 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF22_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterISS2IVF22 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF22_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterISS2IVF22

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS2IVF22 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterISS2IVF22"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF22_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterISS2IVF22

        Create a new object of the class itkImageToImageFilterISS2IVF22 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterISS2IVF22.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterISS2IVF22.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterISS2IVF22.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterISS2IVF22.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF22_SetInput, None, itkImageToImageFilterISS2IVF22)
itkImageToImageFilterISS2IVF22.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF22_GetInput, None, itkImageToImageFilterISS2IVF22)
itkImageToImageFilterISS2IVF22.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF22_PushBackInput, None, itkImageToImageFilterISS2IVF22)
itkImageToImageFilterISS2IVF22.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF22_PopBackInput, None, itkImageToImageFilterISS2IVF22)
itkImageToImageFilterISS2IVF22.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF22_PushFrontInput, None, itkImageToImageFilterISS2IVF22)
itkImageToImageFilterISS2IVF22.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF22_PopFrontInput, None, itkImageToImageFilterISS2IVF22)
itkImageToImageFilterISS2IVF22.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF22_SetCoordinateTolerance, None, itkImageToImageFilterISS2IVF22)
itkImageToImageFilterISS2IVF22.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF22_GetCoordinateTolerance, None, itkImageToImageFilterISS2IVF22)
itkImageToImageFilterISS2IVF22.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF22_SetDirectionTolerance, None, itkImageToImageFilterISS2IVF22)
itkImageToImageFilterISS2IVF22.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF22_GetDirectionTolerance, None, itkImageToImageFilterISS2IVF22)
itkImageToImageFilterISS2IVF22_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF22_swigregister
itkImageToImageFilterISS2IVF22_swigregister(itkImageToImageFilterISS2IVF22)

def itkImageToImageFilterISS2IVF22_cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS2IVF22 *":
    """itkImageToImageFilterISS2IVF22_cast(itkLightObject obj) -> itkImageToImageFilterISS2IVF22"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF22_cast(obj)

class itkImageToImageFilterISS2IVF32(itkImageSourcePython.itkImageSourceIVF32):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterISS2IVF32 self, itkImageSS2 image)
        SetInput(itkImageToImageFilterISS2IVF32 self, unsigned int arg0, itkImageSS2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF32_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageSS2 const *":
        """
        GetInput(itkImageToImageFilterISS2IVF32 self) -> itkImageSS2
        GetInput(itkImageToImageFilterISS2IVF32 self, unsigned int idx) -> itkImageSS2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF32_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageSS2') -> "void":
        """
        PushBackInput(itkImageToImageFilterISS2IVF32 self, itkImageSS2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF32_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterISS2IVF32 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF32_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageSS2') -> "void":
        """PushFrontInput(itkImageToImageFilterISS2IVF32 self, itkImageSS2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF32_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterISS2IVF32 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF32_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterISS2IVF32 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF32_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterISS2IVF32 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF32_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterISS2IVF32 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF32_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterISS2IVF32 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF32_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterISS2IVF32

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS2IVF32 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterISS2IVF32"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF32_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterISS2IVF32

        Create a new object of the class itkImageToImageFilterISS2IVF32 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterISS2IVF32.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterISS2IVF32.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterISS2IVF32.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterISS2IVF32.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF32_SetInput, None, itkImageToImageFilterISS2IVF32)
itkImageToImageFilterISS2IVF32.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF32_GetInput, None, itkImageToImageFilterISS2IVF32)
itkImageToImageFilterISS2IVF32.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF32_PushBackInput, None, itkImageToImageFilterISS2IVF32)
itkImageToImageFilterISS2IVF32.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF32_PopBackInput, None, itkImageToImageFilterISS2IVF32)
itkImageToImageFilterISS2IVF32.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF32_PushFrontInput, None, itkImageToImageFilterISS2IVF32)
itkImageToImageFilterISS2IVF32.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF32_PopFrontInput, None, itkImageToImageFilterISS2IVF32)
itkImageToImageFilterISS2IVF32.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF32_SetCoordinateTolerance, None, itkImageToImageFilterISS2IVF32)
itkImageToImageFilterISS2IVF32.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF32_GetCoordinateTolerance, None, itkImageToImageFilterISS2IVF32)
itkImageToImageFilterISS2IVF32.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF32_SetDirectionTolerance, None, itkImageToImageFilterISS2IVF32)
itkImageToImageFilterISS2IVF32.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF32_GetDirectionTolerance, None, itkImageToImageFilterISS2IVF32)
itkImageToImageFilterISS2IVF32_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF32_swigregister
itkImageToImageFilterISS2IVF32_swigregister(itkImageToImageFilterISS2IVF32)

def itkImageToImageFilterISS2IVF32_cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS2IVF32 *":
    """itkImageToImageFilterISS2IVF32_cast(itkLightObject obj) -> itkImageToImageFilterISS2IVF32"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF32_cast(obj)

class itkImageToImageFilterISS2IVF42(itkImageSourcePython.itkImageSourceIVF42):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterISS2IVF42 self, itkImageSS2 image)
        SetInput(itkImageToImageFilterISS2IVF42 self, unsigned int arg0, itkImageSS2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF42_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageSS2 const *":
        """
        GetInput(itkImageToImageFilterISS2IVF42 self) -> itkImageSS2
        GetInput(itkImageToImageFilterISS2IVF42 self, unsigned int idx) -> itkImageSS2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF42_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageSS2') -> "void":
        """
        PushBackInput(itkImageToImageFilterISS2IVF42 self, itkImageSS2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF42_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterISS2IVF42 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF42_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageSS2') -> "void":
        """PushFrontInput(itkImageToImageFilterISS2IVF42 self, itkImageSS2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF42_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterISS2IVF42 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF42_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterISS2IVF42 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF42_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterISS2IVF42 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF42_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterISS2IVF42 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF42_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterISS2IVF42 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF42_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterISS2IVF42

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS2IVF42 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterISS2IVF42"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF42_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterISS2IVF42

        Create a new object of the class itkImageToImageFilterISS2IVF42 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterISS2IVF42.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterISS2IVF42.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterISS2IVF42.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterISS2IVF42.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF42_SetInput, None, itkImageToImageFilterISS2IVF42)
itkImageToImageFilterISS2IVF42.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF42_GetInput, None, itkImageToImageFilterISS2IVF42)
itkImageToImageFilterISS2IVF42.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF42_PushBackInput, None, itkImageToImageFilterISS2IVF42)
itkImageToImageFilterISS2IVF42.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF42_PopBackInput, None, itkImageToImageFilterISS2IVF42)
itkImageToImageFilterISS2IVF42.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF42_PushFrontInput, None, itkImageToImageFilterISS2IVF42)
itkImageToImageFilterISS2IVF42.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF42_PopFrontInput, None, itkImageToImageFilterISS2IVF42)
itkImageToImageFilterISS2IVF42.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF42_SetCoordinateTolerance, None, itkImageToImageFilterISS2IVF42)
itkImageToImageFilterISS2IVF42.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF42_GetCoordinateTolerance, None, itkImageToImageFilterISS2IVF42)
itkImageToImageFilterISS2IVF42.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF42_SetDirectionTolerance, None, itkImageToImageFilterISS2IVF42)
itkImageToImageFilterISS2IVF42.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF42_GetDirectionTolerance, None, itkImageToImageFilterISS2IVF42)
itkImageToImageFilterISS2IVF42_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF42_swigregister
itkImageToImageFilterISS2IVF42_swigregister(itkImageToImageFilterISS2IVF42)

def itkImageToImageFilterISS2IVF42_cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS2IVF42 *":
    """itkImageToImageFilterISS2IVF42_cast(itkLightObject obj) -> itkImageToImageFilterISS2IVF42"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterISS2IVF42_cast(obj)

class itkImageToImageFilterISS2VID2(itkImageSourcePython.itkImageSourceVID2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterISS2VID2 self, itkImageSS2 image)
        SetInput(itkImageToImageFilterISS2VID2 self, unsigned int arg0, itkImageSS2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2VID2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageSS2 const *":
        """
        GetInput(itkImageToImageFilterISS2VID2 self) -> itkImageSS2
        GetInput(itkImageToImageFilterISS2VID2 self, unsigned int idx) -> itkImageSS2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2VID2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageSS2') -> "void":
        """
        PushBackInput(itkImageToImageFilterISS2VID2 self, itkImageSS2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2VID2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterISS2VID2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2VID2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageSS2') -> "void":
        """PushFrontInput(itkImageToImageFilterISS2VID2 self, itkImageSS2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2VID2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterISS2VID2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2VID2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterISS2VID2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2VID2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterISS2VID2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2VID2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterISS2VID2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2VID2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterISS2VID2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2VID2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterISS2VID2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS2VID2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterISS2VID2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2VID2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterISS2VID2

        Create a new object of the class itkImageToImageFilterISS2VID2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterISS2VID2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterISS2VID2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterISS2VID2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterISS2VID2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2VID2_SetInput, None, itkImageToImageFilterISS2VID2)
itkImageToImageFilterISS2VID2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2VID2_GetInput, None, itkImageToImageFilterISS2VID2)
itkImageToImageFilterISS2VID2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2VID2_PushBackInput, None, itkImageToImageFilterISS2VID2)
itkImageToImageFilterISS2VID2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2VID2_PopBackInput, None, itkImageToImageFilterISS2VID2)
itkImageToImageFilterISS2VID2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2VID2_PushFrontInput, None, itkImageToImageFilterISS2VID2)
itkImageToImageFilterISS2VID2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2VID2_PopFrontInput, None, itkImageToImageFilterISS2VID2)
itkImageToImageFilterISS2VID2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2VID2_SetCoordinateTolerance, None, itkImageToImageFilterISS2VID2)
itkImageToImageFilterISS2VID2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2VID2_GetCoordinateTolerance, None, itkImageToImageFilterISS2VID2)
itkImageToImageFilterISS2VID2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2VID2_SetDirectionTolerance, None, itkImageToImageFilterISS2VID2)
itkImageToImageFilterISS2VID2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2VID2_GetDirectionTolerance, None, itkImageToImageFilterISS2VID2)
itkImageToImageFilterISS2VID2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterISS2VID2_swigregister
itkImageToImageFilterISS2VID2_swigregister(itkImageToImageFilterISS2VID2)

def itkImageToImageFilterISS2VID2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS2VID2 *":
    """itkImageToImageFilterISS2VID2_cast(itkLightObject obj) -> itkImageToImageFilterISS2VID2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterISS2VID2_cast(obj)

class itkImageToImageFilterISS2VIF2(itkImageSourcePython.itkImageSourceVIF2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterISS2VIF2 self, itkImageSS2 image)
        SetInput(itkImageToImageFilterISS2VIF2 self, unsigned int arg0, itkImageSS2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2VIF2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageSS2 const *":
        """
        GetInput(itkImageToImageFilterISS2VIF2 self) -> itkImageSS2
        GetInput(itkImageToImageFilterISS2VIF2 self, unsigned int idx) -> itkImageSS2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2VIF2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageSS2') -> "void":
        """
        PushBackInput(itkImageToImageFilterISS2VIF2 self, itkImageSS2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2VIF2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterISS2VIF2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2VIF2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageSS2') -> "void":
        """PushFrontInput(itkImageToImageFilterISS2VIF2 self, itkImageSS2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2VIF2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterISS2VIF2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2VIF2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterISS2VIF2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2VIF2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterISS2VIF2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2VIF2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterISS2VIF2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2VIF2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterISS2VIF2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2VIF2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterISS2VIF2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS2VIF2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterISS2VIF2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2VIF2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterISS2VIF2

        Create a new object of the class itkImageToImageFilterISS2VIF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterISS2VIF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterISS2VIF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterISS2VIF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterISS2VIF2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2VIF2_SetInput, None, itkImageToImageFilterISS2VIF2)
itkImageToImageFilterISS2VIF2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2VIF2_GetInput, None, itkImageToImageFilterISS2VIF2)
itkImageToImageFilterISS2VIF2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2VIF2_PushBackInput, None, itkImageToImageFilterISS2VIF2)
itkImageToImageFilterISS2VIF2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2VIF2_PopBackInput, None, itkImageToImageFilterISS2VIF2)
itkImageToImageFilterISS2VIF2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2VIF2_PushFrontInput, None, itkImageToImageFilterISS2VIF2)
itkImageToImageFilterISS2VIF2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2VIF2_PopFrontInput, None, itkImageToImageFilterISS2VIF2)
itkImageToImageFilterISS2VIF2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2VIF2_SetCoordinateTolerance, None, itkImageToImageFilterISS2VIF2)
itkImageToImageFilterISS2VIF2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2VIF2_GetCoordinateTolerance, None, itkImageToImageFilterISS2VIF2)
itkImageToImageFilterISS2VIF2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2VIF2_SetDirectionTolerance, None, itkImageToImageFilterISS2VIF2)
itkImageToImageFilterISS2VIF2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2VIF2_GetDirectionTolerance, None, itkImageToImageFilterISS2VIF2)
itkImageToImageFilterISS2VIF2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterISS2VIF2_swigregister
itkImageToImageFilterISS2VIF2_swigregister(itkImageToImageFilterISS2VIF2)

def itkImageToImageFilterISS2VIF2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS2VIF2 *":
    """itkImageToImageFilterISS2VIF2_cast(itkLightObject obj) -> itkImageToImageFilterISS2VIF2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterISS2VIF2_cast(obj)

class itkImageToImageFilterISS2VISS2(itkImageSourcePython.itkImageSourceVISS2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterISS2VISS2 self, itkImageSS2 image)
        SetInput(itkImageToImageFilterISS2VISS2 self, unsigned int arg0, itkImageSS2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2VISS2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageSS2 const *":
        """
        GetInput(itkImageToImageFilterISS2VISS2 self) -> itkImageSS2
        GetInput(itkImageToImageFilterISS2VISS2 self, unsigned int idx) -> itkImageSS2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2VISS2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageSS2') -> "void":
        """
        PushBackInput(itkImageToImageFilterISS2VISS2 self, itkImageSS2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2VISS2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterISS2VISS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2VISS2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageSS2') -> "void":
        """PushFrontInput(itkImageToImageFilterISS2VISS2 self, itkImageSS2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2VISS2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterISS2VISS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2VISS2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterISS2VISS2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2VISS2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterISS2VISS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2VISS2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterISS2VISS2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2VISS2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterISS2VISS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2VISS2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterISS2VISS2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS2VISS2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterISS2VISS2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2VISS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterISS2VISS2

        Create a new object of the class itkImageToImageFilterISS2VISS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterISS2VISS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterISS2VISS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterISS2VISS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterISS2VISS2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2VISS2_SetInput, None, itkImageToImageFilterISS2VISS2)
itkImageToImageFilterISS2VISS2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2VISS2_GetInput, None, itkImageToImageFilterISS2VISS2)
itkImageToImageFilterISS2VISS2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2VISS2_PushBackInput, None, itkImageToImageFilterISS2VISS2)
itkImageToImageFilterISS2VISS2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2VISS2_PopBackInput, None, itkImageToImageFilterISS2VISS2)
itkImageToImageFilterISS2VISS2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2VISS2_PushFrontInput, None, itkImageToImageFilterISS2VISS2)
itkImageToImageFilterISS2VISS2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2VISS2_PopFrontInput, None, itkImageToImageFilterISS2VISS2)
itkImageToImageFilterISS2VISS2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2VISS2_SetCoordinateTolerance, None, itkImageToImageFilterISS2VISS2)
itkImageToImageFilterISS2VISS2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2VISS2_GetCoordinateTolerance, None, itkImageToImageFilterISS2VISS2)
itkImageToImageFilterISS2VISS2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2VISS2_SetDirectionTolerance, None, itkImageToImageFilterISS2VISS2)
itkImageToImageFilterISS2VISS2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2VISS2_GetDirectionTolerance, None, itkImageToImageFilterISS2VISS2)
itkImageToImageFilterISS2VISS2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterISS2VISS2_swigregister
itkImageToImageFilterISS2VISS2_swigregister(itkImageToImageFilterISS2VISS2)

def itkImageToImageFilterISS2VISS2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS2VISS2 *":
    """itkImageToImageFilterISS2VISS2_cast(itkLightObject obj) -> itkImageToImageFilterISS2VISS2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterISS2VISS2_cast(obj)

class itkImageToImageFilterISS2VIUC2(itkImageSourcePython.itkImageSourceVIUC2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterISS2VIUC2 self, itkImageSS2 image)
        SetInput(itkImageToImageFilterISS2VIUC2 self, unsigned int arg0, itkImageSS2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2VIUC2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageSS2 const *":
        """
        GetInput(itkImageToImageFilterISS2VIUC2 self) -> itkImageSS2
        GetInput(itkImageToImageFilterISS2VIUC2 self, unsigned int idx) -> itkImageSS2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2VIUC2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageSS2') -> "void":
        """
        PushBackInput(itkImageToImageFilterISS2VIUC2 self, itkImageSS2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2VIUC2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterISS2VIUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2VIUC2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageSS2') -> "void":
        """PushFrontInput(itkImageToImageFilterISS2VIUC2 self, itkImageSS2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2VIUC2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterISS2VIUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2VIUC2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterISS2VIUC2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2VIUC2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterISS2VIUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2VIUC2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterISS2VIUC2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2VIUC2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterISS2VIUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2VIUC2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterISS2VIUC2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS2VIUC2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterISS2VIUC2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2VIUC2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterISS2VIUC2

        Create a new object of the class itkImageToImageFilterISS2VIUC2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterISS2VIUC2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterISS2VIUC2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterISS2VIUC2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterISS2VIUC2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2VIUC2_SetInput, None, itkImageToImageFilterISS2VIUC2)
itkImageToImageFilterISS2VIUC2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2VIUC2_GetInput, None, itkImageToImageFilterISS2VIUC2)
itkImageToImageFilterISS2VIUC2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2VIUC2_PushBackInput, None, itkImageToImageFilterISS2VIUC2)
itkImageToImageFilterISS2VIUC2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2VIUC2_PopBackInput, None, itkImageToImageFilterISS2VIUC2)
itkImageToImageFilterISS2VIUC2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2VIUC2_PushFrontInput, None, itkImageToImageFilterISS2VIUC2)
itkImageToImageFilterISS2VIUC2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2VIUC2_PopFrontInput, None, itkImageToImageFilterISS2VIUC2)
itkImageToImageFilterISS2VIUC2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2VIUC2_SetCoordinateTolerance, None, itkImageToImageFilterISS2VIUC2)
itkImageToImageFilterISS2VIUC2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2VIUC2_GetCoordinateTolerance, None, itkImageToImageFilterISS2VIUC2)
itkImageToImageFilterISS2VIUC2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2VIUC2_SetDirectionTolerance, None, itkImageToImageFilterISS2VIUC2)
itkImageToImageFilterISS2VIUC2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2VIUC2_GetDirectionTolerance, None, itkImageToImageFilterISS2VIUC2)
itkImageToImageFilterISS2VIUC2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterISS2VIUC2_swigregister
itkImageToImageFilterISS2VIUC2_swigregister(itkImageToImageFilterISS2VIUC2)

def itkImageToImageFilterISS2VIUC2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS2VIUC2 *":
    """itkImageToImageFilterISS2VIUC2_cast(itkLightObject obj) -> itkImageToImageFilterISS2VIUC2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterISS2VIUC2_cast(obj)

class itkImageToImageFilterISS2VIUS2(itkImageSourcePython.itkImageSourceVIUS2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterISS2VIUS2 self, itkImageSS2 image)
        SetInput(itkImageToImageFilterISS2VIUS2 self, unsigned int arg0, itkImageSS2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2VIUS2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageSS2 const *":
        """
        GetInput(itkImageToImageFilterISS2VIUS2 self) -> itkImageSS2
        GetInput(itkImageToImageFilterISS2VIUS2 self, unsigned int idx) -> itkImageSS2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2VIUS2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageSS2') -> "void":
        """
        PushBackInput(itkImageToImageFilterISS2VIUS2 self, itkImageSS2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2VIUS2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterISS2VIUS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2VIUS2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageSS2') -> "void":
        """PushFrontInput(itkImageToImageFilterISS2VIUS2 self, itkImageSS2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2VIUS2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterISS2VIUS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2VIUS2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterISS2VIUS2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2VIUS2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterISS2VIUS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2VIUS2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterISS2VIUS2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2VIUS2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterISS2VIUS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2VIUS2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterISS2VIUS2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS2VIUS2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterISS2VIUS2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS2VIUS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterISS2VIUS2

        Create a new object of the class itkImageToImageFilterISS2VIUS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterISS2VIUS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterISS2VIUS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterISS2VIUS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterISS2VIUS2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2VIUS2_SetInput, None, itkImageToImageFilterISS2VIUS2)
itkImageToImageFilterISS2VIUS2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2VIUS2_GetInput, None, itkImageToImageFilterISS2VIUS2)
itkImageToImageFilterISS2VIUS2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2VIUS2_PushBackInput, None, itkImageToImageFilterISS2VIUS2)
itkImageToImageFilterISS2VIUS2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2VIUS2_PopBackInput, None, itkImageToImageFilterISS2VIUS2)
itkImageToImageFilterISS2VIUS2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2VIUS2_PushFrontInput, None, itkImageToImageFilterISS2VIUS2)
itkImageToImageFilterISS2VIUS2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2VIUS2_PopFrontInput, None, itkImageToImageFilterISS2VIUS2)
itkImageToImageFilterISS2VIUS2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2VIUS2_SetCoordinateTolerance, None, itkImageToImageFilterISS2VIUS2)
itkImageToImageFilterISS2VIUS2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2VIUS2_GetCoordinateTolerance, None, itkImageToImageFilterISS2VIUS2)
itkImageToImageFilterISS2VIUS2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2VIUS2_SetDirectionTolerance, None, itkImageToImageFilterISS2VIUS2)
itkImageToImageFilterISS2VIUS2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS2VIUS2_GetDirectionTolerance, None, itkImageToImageFilterISS2VIUS2)
itkImageToImageFilterISS2VIUS2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterISS2VIUS2_swigregister
itkImageToImageFilterISS2VIUS2_swigregister(itkImageToImageFilterISS2VIUS2)

def itkImageToImageFilterISS2VIUS2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS2VIUS2 *":
    """itkImageToImageFilterISS2VIUS2_cast(itkLightObject obj) -> itkImageToImageFilterISS2VIUS2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterISS2VIUS2_cast(obj)

class itkImageToImageFilterISS3ICF3(itkImageSourcePython.itkImageSourceICF3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterISS3ICF3 self, itkImageSS3 image)
        SetInput(itkImageToImageFilterISS3ICF3 self, unsigned int arg0, itkImageSS3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ICF3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageSS3 const *":
        """
        GetInput(itkImageToImageFilterISS3ICF3 self) -> itkImageSS3
        GetInput(itkImageToImageFilterISS3ICF3 self, unsigned int idx) -> itkImageSS3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ICF3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageSS3') -> "void":
        """
        PushBackInput(itkImageToImageFilterISS3ICF3 self, itkImageSS3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ICF3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterISS3ICF3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ICF3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageSS3') -> "void":
        """PushFrontInput(itkImageToImageFilterISS3ICF3 self, itkImageSS3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ICF3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterISS3ICF3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ICF3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterISS3ICF3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ICF3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterISS3ICF3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ICF3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterISS3ICF3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ICF3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterISS3ICF3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ICF3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterISS3ICF3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS3ICF3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterISS3ICF3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ICF3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterISS3ICF3

        Create a new object of the class itkImageToImageFilterISS3ICF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterISS3ICF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterISS3ICF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterISS3ICF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterISS3ICF3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3ICF3_SetInput, None, itkImageToImageFilterISS3ICF3)
itkImageToImageFilterISS3ICF3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3ICF3_GetInput, None, itkImageToImageFilterISS3ICF3)
itkImageToImageFilterISS3ICF3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3ICF3_PushBackInput, None, itkImageToImageFilterISS3ICF3)
itkImageToImageFilterISS3ICF3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3ICF3_PopBackInput, None, itkImageToImageFilterISS3ICF3)
itkImageToImageFilterISS3ICF3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3ICF3_PushFrontInput, None, itkImageToImageFilterISS3ICF3)
itkImageToImageFilterISS3ICF3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3ICF3_PopFrontInput, None, itkImageToImageFilterISS3ICF3)
itkImageToImageFilterISS3ICF3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3ICF3_SetCoordinateTolerance, None, itkImageToImageFilterISS3ICF3)
itkImageToImageFilterISS3ICF3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3ICF3_GetCoordinateTolerance, None, itkImageToImageFilterISS3ICF3)
itkImageToImageFilterISS3ICF3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3ICF3_SetDirectionTolerance, None, itkImageToImageFilterISS3ICF3)
itkImageToImageFilterISS3ICF3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3ICF3_GetDirectionTolerance, None, itkImageToImageFilterISS3ICF3)
itkImageToImageFilterISS3ICF3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterISS3ICF3_swigregister
itkImageToImageFilterISS3ICF3_swigregister(itkImageToImageFilterISS3ICF3)

def itkImageToImageFilterISS3ICF3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS3ICF3 *":
    """itkImageToImageFilterISS3ICF3_cast(itkLightObject obj) -> itkImageToImageFilterISS3ICF3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ICF3_cast(obj)

class itkImageToImageFilterISS3ICVF23(itkImageSourcePython.itkImageSourceICVF23):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterISS3ICVF23 self, itkImageSS3 image)
        SetInput(itkImageToImageFilterISS3ICVF23 self, unsigned int arg0, itkImageSS3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF23_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageSS3 const *":
        """
        GetInput(itkImageToImageFilterISS3ICVF23 self) -> itkImageSS3
        GetInput(itkImageToImageFilterISS3ICVF23 self, unsigned int idx) -> itkImageSS3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF23_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageSS3') -> "void":
        """
        PushBackInput(itkImageToImageFilterISS3ICVF23 self, itkImageSS3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF23_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterISS3ICVF23 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF23_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageSS3') -> "void":
        """PushFrontInput(itkImageToImageFilterISS3ICVF23 self, itkImageSS3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF23_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterISS3ICVF23 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF23_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterISS3ICVF23 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF23_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterISS3ICVF23 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF23_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterISS3ICVF23 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF23_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterISS3ICVF23 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF23_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterISS3ICVF23

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS3ICVF23 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterISS3ICVF23"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF23_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterISS3ICVF23

        Create a new object of the class itkImageToImageFilterISS3ICVF23 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterISS3ICVF23.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterISS3ICVF23.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterISS3ICVF23.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterISS3ICVF23.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF23_SetInput, None, itkImageToImageFilterISS3ICVF23)
itkImageToImageFilterISS3ICVF23.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF23_GetInput, None, itkImageToImageFilterISS3ICVF23)
itkImageToImageFilterISS3ICVF23.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF23_PushBackInput, None, itkImageToImageFilterISS3ICVF23)
itkImageToImageFilterISS3ICVF23.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF23_PopBackInput, None, itkImageToImageFilterISS3ICVF23)
itkImageToImageFilterISS3ICVF23.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF23_PushFrontInput, None, itkImageToImageFilterISS3ICVF23)
itkImageToImageFilterISS3ICVF23.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF23_PopFrontInput, None, itkImageToImageFilterISS3ICVF23)
itkImageToImageFilterISS3ICVF23.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF23_SetCoordinateTolerance, None, itkImageToImageFilterISS3ICVF23)
itkImageToImageFilterISS3ICVF23.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF23_GetCoordinateTolerance, None, itkImageToImageFilterISS3ICVF23)
itkImageToImageFilterISS3ICVF23.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF23_SetDirectionTolerance, None, itkImageToImageFilterISS3ICVF23)
itkImageToImageFilterISS3ICVF23.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF23_GetDirectionTolerance, None, itkImageToImageFilterISS3ICVF23)
itkImageToImageFilterISS3ICVF23_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF23_swigregister
itkImageToImageFilterISS3ICVF23_swigregister(itkImageToImageFilterISS3ICVF23)

def itkImageToImageFilterISS3ICVF23_cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS3ICVF23 *":
    """itkImageToImageFilterISS3ICVF23_cast(itkLightObject obj) -> itkImageToImageFilterISS3ICVF23"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF23_cast(obj)

class itkImageToImageFilterISS3ICVF33(itkImageSourcePython.itkImageSourceICVF33):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterISS3ICVF33 self, itkImageSS3 image)
        SetInput(itkImageToImageFilterISS3ICVF33 self, unsigned int arg0, itkImageSS3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF33_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageSS3 const *":
        """
        GetInput(itkImageToImageFilterISS3ICVF33 self) -> itkImageSS3
        GetInput(itkImageToImageFilterISS3ICVF33 self, unsigned int idx) -> itkImageSS3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF33_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageSS3') -> "void":
        """
        PushBackInput(itkImageToImageFilterISS3ICVF33 self, itkImageSS3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF33_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterISS3ICVF33 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF33_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageSS3') -> "void":
        """PushFrontInput(itkImageToImageFilterISS3ICVF33 self, itkImageSS3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF33_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterISS3ICVF33 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF33_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterISS3ICVF33 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF33_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterISS3ICVF33 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF33_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterISS3ICVF33 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF33_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterISS3ICVF33 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF33_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterISS3ICVF33

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS3ICVF33 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterISS3ICVF33"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF33_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterISS3ICVF33

        Create a new object of the class itkImageToImageFilterISS3ICVF33 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterISS3ICVF33.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterISS3ICVF33.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterISS3ICVF33.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterISS3ICVF33.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF33_SetInput, None, itkImageToImageFilterISS3ICVF33)
itkImageToImageFilterISS3ICVF33.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF33_GetInput, None, itkImageToImageFilterISS3ICVF33)
itkImageToImageFilterISS3ICVF33.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF33_PushBackInput, None, itkImageToImageFilterISS3ICVF33)
itkImageToImageFilterISS3ICVF33.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF33_PopBackInput, None, itkImageToImageFilterISS3ICVF33)
itkImageToImageFilterISS3ICVF33.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF33_PushFrontInput, None, itkImageToImageFilterISS3ICVF33)
itkImageToImageFilterISS3ICVF33.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF33_PopFrontInput, None, itkImageToImageFilterISS3ICVF33)
itkImageToImageFilterISS3ICVF33.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF33_SetCoordinateTolerance, None, itkImageToImageFilterISS3ICVF33)
itkImageToImageFilterISS3ICVF33.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF33_GetCoordinateTolerance, None, itkImageToImageFilterISS3ICVF33)
itkImageToImageFilterISS3ICVF33.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF33_SetDirectionTolerance, None, itkImageToImageFilterISS3ICVF33)
itkImageToImageFilterISS3ICVF33.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF33_GetDirectionTolerance, None, itkImageToImageFilterISS3ICVF33)
itkImageToImageFilterISS3ICVF33_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF33_swigregister
itkImageToImageFilterISS3ICVF33_swigregister(itkImageToImageFilterISS3ICVF33)

def itkImageToImageFilterISS3ICVF33_cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS3ICVF33 *":
    """itkImageToImageFilterISS3ICVF33_cast(itkLightObject obj) -> itkImageToImageFilterISS3ICVF33"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF33_cast(obj)

class itkImageToImageFilterISS3ICVF43(itkImageSourcePython.itkImageSourceICVF43):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterISS3ICVF43 self, itkImageSS3 image)
        SetInput(itkImageToImageFilterISS3ICVF43 self, unsigned int arg0, itkImageSS3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF43_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageSS3 const *":
        """
        GetInput(itkImageToImageFilterISS3ICVF43 self) -> itkImageSS3
        GetInput(itkImageToImageFilterISS3ICVF43 self, unsigned int idx) -> itkImageSS3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF43_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageSS3') -> "void":
        """
        PushBackInput(itkImageToImageFilterISS3ICVF43 self, itkImageSS3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF43_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterISS3ICVF43 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF43_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageSS3') -> "void":
        """PushFrontInput(itkImageToImageFilterISS3ICVF43 self, itkImageSS3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF43_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterISS3ICVF43 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF43_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterISS3ICVF43 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF43_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterISS3ICVF43 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF43_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterISS3ICVF43 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF43_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterISS3ICVF43 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF43_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterISS3ICVF43

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS3ICVF43 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterISS3ICVF43"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF43_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterISS3ICVF43

        Create a new object of the class itkImageToImageFilterISS3ICVF43 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterISS3ICVF43.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterISS3ICVF43.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterISS3ICVF43.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterISS3ICVF43.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF43_SetInput, None, itkImageToImageFilterISS3ICVF43)
itkImageToImageFilterISS3ICVF43.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF43_GetInput, None, itkImageToImageFilterISS3ICVF43)
itkImageToImageFilterISS3ICVF43.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF43_PushBackInput, None, itkImageToImageFilterISS3ICVF43)
itkImageToImageFilterISS3ICVF43.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF43_PopBackInput, None, itkImageToImageFilterISS3ICVF43)
itkImageToImageFilterISS3ICVF43.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF43_PushFrontInput, None, itkImageToImageFilterISS3ICVF43)
itkImageToImageFilterISS3ICVF43.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF43_PopFrontInput, None, itkImageToImageFilterISS3ICVF43)
itkImageToImageFilterISS3ICVF43.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF43_SetCoordinateTolerance, None, itkImageToImageFilterISS3ICVF43)
itkImageToImageFilterISS3ICVF43.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF43_GetCoordinateTolerance, None, itkImageToImageFilterISS3ICVF43)
itkImageToImageFilterISS3ICVF43.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF43_SetDirectionTolerance, None, itkImageToImageFilterISS3ICVF43)
itkImageToImageFilterISS3ICVF43.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF43_GetDirectionTolerance, None, itkImageToImageFilterISS3ICVF43)
itkImageToImageFilterISS3ICVF43_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF43_swigregister
itkImageToImageFilterISS3ICVF43_swigregister(itkImageToImageFilterISS3ICVF43)

def itkImageToImageFilterISS3ICVF43_cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS3ICVF43 *":
    """itkImageToImageFilterISS3ICVF43_cast(itkLightObject obj) -> itkImageToImageFilterISS3ICVF43"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ICVF43_cast(obj)

class itkImageToImageFilterISS3IRGBAUC3(itkImageSourcePython.itkImageSourceIRGBAUC3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterISS3IRGBAUC3 self, itkImageSS3 image)
        SetInput(itkImageToImageFilterISS3IRGBAUC3 self, unsigned int arg0, itkImageSS3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3IRGBAUC3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageSS3 const *":
        """
        GetInput(itkImageToImageFilterISS3IRGBAUC3 self) -> itkImageSS3
        GetInput(itkImageToImageFilterISS3IRGBAUC3 self, unsigned int idx) -> itkImageSS3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3IRGBAUC3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageSS3') -> "void":
        """
        PushBackInput(itkImageToImageFilterISS3IRGBAUC3 self, itkImageSS3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3IRGBAUC3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterISS3IRGBAUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3IRGBAUC3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageSS3') -> "void":
        """PushFrontInput(itkImageToImageFilterISS3IRGBAUC3 self, itkImageSS3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3IRGBAUC3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterISS3IRGBAUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3IRGBAUC3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterISS3IRGBAUC3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3IRGBAUC3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterISS3IRGBAUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3IRGBAUC3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterISS3IRGBAUC3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3IRGBAUC3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterISS3IRGBAUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3IRGBAUC3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterISS3IRGBAUC3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS3IRGBAUC3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterISS3IRGBAUC3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3IRGBAUC3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterISS3IRGBAUC3

        Create a new object of the class itkImageToImageFilterISS3IRGBAUC3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterISS3IRGBAUC3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterISS3IRGBAUC3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterISS3IRGBAUC3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterISS3IRGBAUC3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3IRGBAUC3_SetInput, None, itkImageToImageFilterISS3IRGBAUC3)
itkImageToImageFilterISS3IRGBAUC3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3IRGBAUC3_GetInput, None, itkImageToImageFilterISS3IRGBAUC3)
itkImageToImageFilterISS3IRGBAUC3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3IRGBAUC3_PushBackInput, None, itkImageToImageFilterISS3IRGBAUC3)
itkImageToImageFilterISS3IRGBAUC3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3IRGBAUC3_PopBackInput, None, itkImageToImageFilterISS3IRGBAUC3)
itkImageToImageFilterISS3IRGBAUC3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3IRGBAUC3_PushFrontInput, None, itkImageToImageFilterISS3IRGBAUC3)
itkImageToImageFilterISS3IRGBAUC3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3IRGBAUC3_PopFrontInput, None, itkImageToImageFilterISS3IRGBAUC3)
itkImageToImageFilterISS3IRGBAUC3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3IRGBAUC3_SetCoordinateTolerance, None, itkImageToImageFilterISS3IRGBAUC3)
itkImageToImageFilterISS3IRGBAUC3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3IRGBAUC3_GetCoordinateTolerance, None, itkImageToImageFilterISS3IRGBAUC3)
itkImageToImageFilterISS3IRGBAUC3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3IRGBAUC3_SetDirectionTolerance, None, itkImageToImageFilterISS3IRGBAUC3)
itkImageToImageFilterISS3IRGBAUC3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3IRGBAUC3_GetDirectionTolerance, None, itkImageToImageFilterISS3IRGBAUC3)
itkImageToImageFilterISS3IRGBAUC3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterISS3IRGBAUC3_swigregister
itkImageToImageFilterISS3IRGBAUC3_swigregister(itkImageToImageFilterISS3IRGBAUC3)

def itkImageToImageFilterISS3IRGBAUC3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS3IRGBAUC3 *":
    """itkImageToImageFilterISS3IRGBAUC3_cast(itkLightObject obj) -> itkImageToImageFilterISS3IRGBAUC3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterISS3IRGBAUC3_cast(obj)

class itkImageToImageFilterISS3IRGBUC3(itkImageSourcePython.itkImageSourceIRGBUC3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterISS3IRGBUC3 self, itkImageSS3 image)
        SetInput(itkImageToImageFilterISS3IRGBUC3 self, unsigned int arg0, itkImageSS3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3IRGBUC3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageSS3 const *":
        """
        GetInput(itkImageToImageFilterISS3IRGBUC3 self) -> itkImageSS3
        GetInput(itkImageToImageFilterISS3IRGBUC3 self, unsigned int idx) -> itkImageSS3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3IRGBUC3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageSS3') -> "void":
        """
        PushBackInput(itkImageToImageFilterISS3IRGBUC3 self, itkImageSS3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3IRGBUC3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterISS3IRGBUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3IRGBUC3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageSS3') -> "void":
        """PushFrontInput(itkImageToImageFilterISS3IRGBUC3 self, itkImageSS3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3IRGBUC3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterISS3IRGBUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3IRGBUC3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterISS3IRGBUC3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3IRGBUC3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterISS3IRGBUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3IRGBUC3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterISS3IRGBUC3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3IRGBUC3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterISS3IRGBUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3IRGBUC3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterISS3IRGBUC3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS3IRGBUC3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterISS3IRGBUC3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3IRGBUC3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterISS3IRGBUC3

        Create a new object of the class itkImageToImageFilterISS3IRGBUC3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterISS3IRGBUC3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterISS3IRGBUC3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterISS3IRGBUC3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterISS3IRGBUC3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3IRGBUC3_SetInput, None, itkImageToImageFilterISS3IRGBUC3)
itkImageToImageFilterISS3IRGBUC3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3IRGBUC3_GetInput, None, itkImageToImageFilterISS3IRGBUC3)
itkImageToImageFilterISS3IRGBUC3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3IRGBUC3_PushBackInput, None, itkImageToImageFilterISS3IRGBUC3)
itkImageToImageFilterISS3IRGBUC3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3IRGBUC3_PopBackInput, None, itkImageToImageFilterISS3IRGBUC3)
itkImageToImageFilterISS3IRGBUC3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3IRGBUC3_PushFrontInput, None, itkImageToImageFilterISS3IRGBUC3)
itkImageToImageFilterISS3IRGBUC3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3IRGBUC3_PopFrontInput, None, itkImageToImageFilterISS3IRGBUC3)
itkImageToImageFilterISS3IRGBUC3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3IRGBUC3_SetCoordinateTolerance, None, itkImageToImageFilterISS3IRGBUC3)
itkImageToImageFilterISS3IRGBUC3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3IRGBUC3_GetCoordinateTolerance, None, itkImageToImageFilterISS3IRGBUC3)
itkImageToImageFilterISS3IRGBUC3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3IRGBUC3_SetDirectionTolerance, None, itkImageToImageFilterISS3IRGBUC3)
itkImageToImageFilterISS3IRGBUC3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3IRGBUC3_GetDirectionTolerance, None, itkImageToImageFilterISS3IRGBUC3)
itkImageToImageFilterISS3IRGBUC3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterISS3IRGBUC3_swigregister
itkImageToImageFilterISS3IRGBUC3_swigregister(itkImageToImageFilterISS3IRGBUC3)

def itkImageToImageFilterISS3IRGBUC3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS3IRGBUC3 *":
    """itkImageToImageFilterISS3IRGBUC3_cast(itkLightObject obj) -> itkImageToImageFilterISS3IRGBUC3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterISS3IRGBUC3_cast(obj)

class itkImageToImageFilterISS3ISS2(itkImageSourcePython.itkImageSourceISS2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterISS3ISS2 self, itkImageSS3 image)
        SetInput(itkImageToImageFilterISS3ISS2 self, unsigned int arg0, itkImageSS3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ISS2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageSS3 const *":
        """
        GetInput(itkImageToImageFilterISS3ISS2 self) -> itkImageSS3
        GetInput(itkImageToImageFilterISS3ISS2 self, unsigned int idx) -> itkImageSS3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ISS2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageSS3') -> "void":
        """
        PushBackInput(itkImageToImageFilterISS3ISS2 self, itkImageSS3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ISS2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterISS3ISS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ISS2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageSS3') -> "void":
        """PushFrontInput(itkImageToImageFilterISS3ISS2 self, itkImageSS3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ISS2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterISS3ISS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ISS2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterISS3ISS2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ISS2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterISS3ISS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ISS2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterISS3ISS2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ISS2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterISS3ISS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ISS2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterISS3ISS2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS3ISS2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterISS3ISS2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ISS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterISS3ISS2

        Create a new object of the class itkImageToImageFilterISS3ISS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterISS3ISS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterISS3ISS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterISS3ISS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterISS3ISS2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3ISS2_SetInput, None, itkImageToImageFilterISS3ISS2)
itkImageToImageFilterISS3ISS2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3ISS2_GetInput, None, itkImageToImageFilterISS3ISS2)
itkImageToImageFilterISS3ISS2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3ISS2_PushBackInput, None, itkImageToImageFilterISS3ISS2)
itkImageToImageFilterISS3ISS2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3ISS2_PopBackInput, None, itkImageToImageFilterISS3ISS2)
itkImageToImageFilterISS3ISS2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3ISS2_PushFrontInput, None, itkImageToImageFilterISS3ISS2)
itkImageToImageFilterISS3ISS2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3ISS2_PopFrontInput, None, itkImageToImageFilterISS3ISS2)
itkImageToImageFilterISS3ISS2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3ISS2_SetCoordinateTolerance, None, itkImageToImageFilterISS3ISS2)
itkImageToImageFilterISS3ISS2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3ISS2_GetCoordinateTolerance, None, itkImageToImageFilterISS3ISS2)
itkImageToImageFilterISS3ISS2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3ISS2_SetDirectionTolerance, None, itkImageToImageFilterISS3ISS2)
itkImageToImageFilterISS3ISS2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3ISS2_GetDirectionTolerance, None, itkImageToImageFilterISS3ISS2)
itkImageToImageFilterISS3ISS2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterISS3ISS2_swigregister
itkImageToImageFilterISS3ISS2_swigregister(itkImageToImageFilterISS3ISS2)

def itkImageToImageFilterISS3ISS2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS3ISS2 *":
    """itkImageToImageFilterISS3ISS2_cast(itkLightObject obj) -> itkImageToImageFilterISS3ISS2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ISS2_cast(obj)

class itkImageToImageFilterISS3ISSRTD33(itkImageSourcePython.itkImageSourceISSRTD33):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterISS3ISSRTD33 self, itkImageSS3 image)
        SetInput(itkImageToImageFilterISS3ISSRTD33 self, unsigned int arg0, itkImageSS3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ISSRTD33_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageSS3 const *":
        """
        GetInput(itkImageToImageFilterISS3ISSRTD33 self) -> itkImageSS3
        GetInput(itkImageToImageFilterISS3ISSRTD33 self, unsigned int idx) -> itkImageSS3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ISSRTD33_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageSS3') -> "void":
        """
        PushBackInput(itkImageToImageFilterISS3ISSRTD33 self, itkImageSS3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ISSRTD33_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterISS3ISSRTD33 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ISSRTD33_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageSS3') -> "void":
        """PushFrontInput(itkImageToImageFilterISS3ISSRTD33 self, itkImageSS3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ISSRTD33_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterISS3ISSRTD33 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ISSRTD33_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterISS3ISSRTD33 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ISSRTD33_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterISS3ISSRTD33 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ISSRTD33_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterISS3ISSRTD33 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ISSRTD33_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterISS3ISSRTD33 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ISSRTD33_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterISS3ISSRTD33

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS3ISSRTD33 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterISS3ISSRTD33"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ISSRTD33_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterISS3ISSRTD33

        Create a new object of the class itkImageToImageFilterISS3ISSRTD33 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterISS3ISSRTD33.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterISS3ISSRTD33.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterISS3ISSRTD33.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterISS3ISSRTD33.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3ISSRTD33_SetInput, None, itkImageToImageFilterISS3ISSRTD33)
itkImageToImageFilterISS3ISSRTD33.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3ISSRTD33_GetInput, None, itkImageToImageFilterISS3ISSRTD33)
itkImageToImageFilterISS3ISSRTD33.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3ISSRTD33_PushBackInput, None, itkImageToImageFilterISS3ISSRTD33)
itkImageToImageFilterISS3ISSRTD33.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3ISSRTD33_PopBackInput, None, itkImageToImageFilterISS3ISSRTD33)
itkImageToImageFilterISS3ISSRTD33.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3ISSRTD33_PushFrontInput, None, itkImageToImageFilterISS3ISSRTD33)
itkImageToImageFilterISS3ISSRTD33.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3ISSRTD33_PopFrontInput, None, itkImageToImageFilterISS3ISSRTD33)
itkImageToImageFilterISS3ISSRTD33.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3ISSRTD33_SetCoordinateTolerance, None, itkImageToImageFilterISS3ISSRTD33)
itkImageToImageFilterISS3ISSRTD33.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3ISSRTD33_GetCoordinateTolerance, None, itkImageToImageFilterISS3ISSRTD33)
itkImageToImageFilterISS3ISSRTD33.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3ISSRTD33_SetDirectionTolerance, None, itkImageToImageFilterISS3ISSRTD33)
itkImageToImageFilterISS3ISSRTD33.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3ISSRTD33_GetDirectionTolerance, None, itkImageToImageFilterISS3ISSRTD33)
itkImageToImageFilterISS3ISSRTD33_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterISS3ISSRTD33_swigregister
itkImageToImageFilterISS3ISSRTD33_swigregister(itkImageToImageFilterISS3ISSRTD33)

def itkImageToImageFilterISS3ISSRTD33_cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS3ISSRTD33 *":
    """itkImageToImageFilterISS3ISSRTD33_cast(itkLightObject obj) -> itkImageToImageFilterISS3ISSRTD33"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterISS3ISSRTD33_cast(obj)

class itkImageToImageFilterISS3IVF23(itkImageSourcePython.itkImageSourceIVF23):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterISS3IVF23 self, itkImageSS3 image)
        SetInput(itkImageToImageFilterISS3IVF23 self, unsigned int arg0, itkImageSS3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF23_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageSS3 const *":
        """
        GetInput(itkImageToImageFilterISS3IVF23 self) -> itkImageSS3
        GetInput(itkImageToImageFilterISS3IVF23 self, unsigned int idx) -> itkImageSS3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF23_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageSS3') -> "void":
        """
        PushBackInput(itkImageToImageFilterISS3IVF23 self, itkImageSS3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF23_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterISS3IVF23 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF23_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageSS3') -> "void":
        """PushFrontInput(itkImageToImageFilterISS3IVF23 self, itkImageSS3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF23_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterISS3IVF23 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF23_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterISS3IVF23 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF23_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterISS3IVF23 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF23_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterISS3IVF23 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF23_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterISS3IVF23 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF23_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterISS3IVF23

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS3IVF23 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterISS3IVF23"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF23_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterISS3IVF23

        Create a new object of the class itkImageToImageFilterISS3IVF23 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterISS3IVF23.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterISS3IVF23.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterISS3IVF23.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterISS3IVF23.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF23_SetInput, None, itkImageToImageFilterISS3IVF23)
itkImageToImageFilterISS3IVF23.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF23_GetInput, None, itkImageToImageFilterISS3IVF23)
itkImageToImageFilterISS3IVF23.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF23_PushBackInput, None, itkImageToImageFilterISS3IVF23)
itkImageToImageFilterISS3IVF23.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF23_PopBackInput, None, itkImageToImageFilterISS3IVF23)
itkImageToImageFilterISS3IVF23.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF23_PushFrontInput, None, itkImageToImageFilterISS3IVF23)
itkImageToImageFilterISS3IVF23.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF23_PopFrontInput, None, itkImageToImageFilterISS3IVF23)
itkImageToImageFilterISS3IVF23.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF23_SetCoordinateTolerance, None, itkImageToImageFilterISS3IVF23)
itkImageToImageFilterISS3IVF23.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF23_GetCoordinateTolerance, None, itkImageToImageFilterISS3IVF23)
itkImageToImageFilterISS3IVF23.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF23_SetDirectionTolerance, None, itkImageToImageFilterISS3IVF23)
itkImageToImageFilterISS3IVF23.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF23_GetDirectionTolerance, None, itkImageToImageFilterISS3IVF23)
itkImageToImageFilterISS3IVF23_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF23_swigregister
itkImageToImageFilterISS3IVF23_swigregister(itkImageToImageFilterISS3IVF23)

def itkImageToImageFilterISS3IVF23_cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS3IVF23 *":
    """itkImageToImageFilterISS3IVF23_cast(itkLightObject obj) -> itkImageToImageFilterISS3IVF23"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF23_cast(obj)

class itkImageToImageFilterISS3IVF33(itkImageSourcePython.itkImageSourceIVF33):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterISS3IVF33 self, itkImageSS3 image)
        SetInput(itkImageToImageFilterISS3IVF33 self, unsigned int arg0, itkImageSS3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF33_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageSS3 const *":
        """
        GetInput(itkImageToImageFilterISS3IVF33 self) -> itkImageSS3
        GetInput(itkImageToImageFilterISS3IVF33 self, unsigned int idx) -> itkImageSS3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF33_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageSS3') -> "void":
        """
        PushBackInput(itkImageToImageFilterISS3IVF33 self, itkImageSS3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF33_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterISS3IVF33 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF33_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageSS3') -> "void":
        """PushFrontInput(itkImageToImageFilterISS3IVF33 self, itkImageSS3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF33_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterISS3IVF33 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF33_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterISS3IVF33 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF33_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterISS3IVF33 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF33_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterISS3IVF33 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF33_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterISS3IVF33 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF33_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterISS3IVF33

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS3IVF33 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterISS3IVF33"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF33_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterISS3IVF33

        Create a new object of the class itkImageToImageFilterISS3IVF33 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterISS3IVF33.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterISS3IVF33.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterISS3IVF33.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterISS3IVF33.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF33_SetInput, None, itkImageToImageFilterISS3IVF33)
itkImageToImageFilterISS3IVF33.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF33_GetInput, None, itkImageToImageFilterISS3IVF33)
itkImageToImageFilterISS3IVF33.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF33_PushBackInput, None, itkImageToImageFilterISS3IVF33)
itkImageToImageFilterISS3IVF33.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF33_PopBackInput, None, itkImageToImageFilterISS3IVF33)
itkImageToImageFilterISS3IVF33.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF33_PushFrontInput, None, itkImageToImageFilterISS3IVF33)
itkImageToImageFilterISS3IVF33.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF33_PopFrontInput, None, itkImageToImageFilterISS3IVF33)
itkImageToImageFilterISS3IVF33.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF33_SetCoordinateTolerance, None, itkImageToImageFilterISS3IVF33)
itkImageToImageFilterISS3IVF33.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF33_GetCoordinateTolerance, None, itkImageToImageFilterISS3IVF33)
itkImageToImageFilterISS3IVF33.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF33_SetDirectionTolerance, None, itkImageToImageFilterISS3IVF33)
itkImageToImageFilterISS3IVF33.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF33_GetDirectionTolerance, None, itkImageToImageFilterISS3IVF33)
itkImageToImageFilterISS3IVF33_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF33_swigregister
itkImageToImageFilterISS3IVF33_swigregister(itkImageToImageFilterISS3IVF33)

def itkImageToImageFilterISS3IVF33_cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS3IVF33 *":
    """itkImageToImageFilterISS3IVF33_cast(itkLightObject obj) -> itkImageToImageFilterISS3IVF33"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF33_cast(obj)

class itkImageToImageFilterISS3IVF43(itkImageSourcePython.itkImageSourceIVF43):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterISS3IVF43 self, itkImageSS3 image)
        SetInput(itkImageToImageFilterISS3IVF43 self, unsigned int arg0, itkImageSS3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF43_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageSS3 const *":
        """
        GetInput(itkImageToImageFilterISS3IVF43 self) -> itkImageSS3
        GetInput(itkImageToImageFilterISS3IVF43 self, unsigned int idx) -> itkImageSS3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF43_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageSS3') -> "void":
        """
        PushBackInput(itkImageToImageFilterISS3IVF43 self, itkImageSS3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF43_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterISS3IVF43 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF43_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageSS3') -> "void":
        """PushFrontInput(itkImageToImageFilterISS3IVF43 self, itkImageSS3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF43_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterISS3IVF43 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF43_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterISS3IVF43 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF43_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterISS3IVF43 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF43_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterISS3IVF43 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF43_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterISS3IVF43 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF43_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterISS3IVF43

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS3IVF43 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterISS3IVF43"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF43_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterISS3IVF43

        Create a new object of the class itkImageToImageFilterISS3IVF43 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterISS3IVF43.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterISS3IVF43.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterISS3IVF43.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterISS3IVF43.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF43_SetInput, None, itkImageToImageFilterISS3IVF43)
itkImageToImageFilterISS3IVF43.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF43_GetInput, None, itkImageToImageFilterISS3IVF43)
itkImageToImageFilterISS3IVF43.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF43_PushBackInput, None, itkImageToImageFilterISS3IVF43)
itkImageToImageFilterISS3IVF43.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF43_PopBackInput, None, itkImageToImageFilterISS3IVF43)
itkImageToImageFilterISS3IVF43.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF43_PushFrontInput, None, itkImageToImageFilterISS3IVF43)
itkImageToImageFilterISS3IVF43.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF43_PopFrontInput, None, itkImageToImageFilterISS3IVF43)
itkImageToImageFilterISS3IVF43.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF43_SetCoordinateTolerance, None, itkImageToImageFilterISS3IVF43)
itkImageToImageFilterISS3IVF43.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF43_GetCoordinateTolerance, None, itkImageToImageFilterISS3IVF43)
itkImageToImageFilterISS3IVF43.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF43_SetDirectionTolerance, None, itkImageToImageFilterISS3IVF43)
itkImageToImageFilterISS3IVF43.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF43_GetDirectionTolerance, None, itkImageToImageFilterISS3IVF43)
itkImageToImageFilterISS3IVF43_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF43_swigregister
itkImageToImageFilterISS3IVF43_swigregister(itkImageToImageFilterISS3IVF43)

def itkImageToImageFilterISS3IVF43_cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS3IVF43 *":
    """itkImageToImageFilterISS3IVF43_cast(itkLightObject obj) -> itkImageToImageFilterISS3IVF43"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterISS3IVF43_cast(obj)

class itkImageToImageFilterISS3VID3(itkImageSourcePython.itkImageSourceVID3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterISS3VID3 self, itkImageSS3 image)
        SetInput(itkImageToImageFilterISS3VID3 self, unsigned int arg0, itkImageSS3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3VID3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageSS3 const *":
        """
        GetInput(itkImageToImageFilterISS3VID3 self) -> itkImageSS3
        GetInput(itkImageToImageFilterISS3VID3 self, unsigned int idx) -> itkImageSS3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3VID3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageSS3') -> "void":
        """
        PushBackInput(itkImageToImageFilterISS3VID3 self, itkImageSS3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3VID3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterISS3VID3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3VID3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageSS3') -> "void":
        """PushFrontInput(itkImageToImageFilterISS3VID3 self, itkImageSS3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3VID3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterISS3VID3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3VID3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterISS3VID3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3VID3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterISS3VID3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3VID3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterISS3VID3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3VID3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterISS3VID3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3VID3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterISS3VID3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS3VID3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterISS3VID3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3VID3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterISS3VID3

        Create a new object of the class itkImageToImageFilterISS3VID3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterISS3VID3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterISS3VID3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterISS3VID3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterISS3VID3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3VID3_SetInput, None, itkImageToImageFilterISS3VID3)
itkImageToImageFilterISS3VID3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3VID3_GetInput, None, itkImageToImageFilterISS3VID3)
itkImageToImageFilterISS3VID3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3VID3_PushBackInput, None, itkImageToImageFilterISS3VID3)
itkImageToImageFilterISS3VID3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3VID3_PopBackInput, None, itkImageToImageFilterISS3VID3)
itkImageToImageFilterISS3VID3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3VID3_PushFrontInput, None, itkImageToImageFilterISS3VID3)
itkImageToImageFilterISS3VID3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3VID3_PopFrontInput, None, itkImageToImageFilterISS3VID3)
itkImageToImageFilterISS3VID3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3VID3_SetCoordinateTolerance, None, itkImageToImageFilterISS3VID3)
itkImageToImageFilterISS3VID3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3VID3_GetCoordinateTolerance, None, itkImageToImageFilterISS3VID3)
itkImageToImageFilterISS3VID3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3VID3_SetDirectionTolerance, None, itkImageToImageFilterISS3VID3)
itkImageToImageFilterISS3VID3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3VID3_GetDirectionTolerance, None, itkImageToImageFilterISS3VID3)
itkImageToImageFilterISS3VID3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterISS3VID3_swigregister
itkImageToImageFilterISS3VID3_swigregister(itkImageToImageFilterISS3VID3)

def itkImageToImageFilterISS3VID3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS3VID3 *":
    """itkImageToImageFilterISS3VID3_cast(itkLightObject obj) -> itkImageToImageFilterISS3VID3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterISS3VID3_cast(obj)

class itkImageToImageFilterISS3VIF3(itkImageSourcePython.itkImageSourceVIF3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterISS3VIF3 self, itkImageSS3 image)
        SetInput(itkImageToImageFilterISS3VIF3 self, unsigned int arg0, itkImageSS3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3VIF3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageSS3 const *":
        """
        GetInput(itkImageToImageFilterISS3VIF3 self) -> itkImageSS3
        GetInput(itkImageToImageFilterISS3VIF3 self, unsigned int idx) -> itkImageSS3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3VIF3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageSS3') -> "void":
        """
        PushBackInput(itkImageToImageFilterISS3VIF3 self, itkImageSS3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3VIF3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterISS3VIF3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3VIF3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageSS3') -> "void":
        """PushFrontInput(itkImageToImageFilterISS3VIF3 self, itkImageSS3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3VIF3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterISS3VIF3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3VIF3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterISS3VIF3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3VIF3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterISS3VIF3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3VIF3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterISS3VIF3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3VIF3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterISS3VIF3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3VIF3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterISS3VIF3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS3VIF3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterISS3VIF3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3VIF3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterISS3VIF3

        Create a new object of the class itkImageToImageFilterISS3VIF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterISS3VIF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterISS3VIF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterISS3VIF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterISS3VIF3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3VIF3_SetInput, None, itkImageToImageFilterISS3VIF3)
itkImageToImageFilterISS3VIF3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3VIF3_GetInput, None, itkImageToImageFilterISS3VIF3)
itkImageToImageFilterISS3VIF3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3VIF3_PushBackInput, None, itkImageToImageFilterISS3VIF3)
itkImageToImageFilterISS3VIF3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3VIF3_PopBackInput, None, itkImageToImageFilterISS3VIF3)
itkImageToImageFilterISS3VIF3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3VIF3_PushFrontInput, None, itkImageToImageFilterISS3VIF3)
itkImageToImageFilterISS3VIF3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3VIF3_PopFrontInput, None, itkImageToImageFilterISS3VIF3)
itkImageToImageFilterISS3VIF3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3VIF3_SetCoordinateTolerance, None, itkImageToImageFilterISS3VIF3)
itkImageToImageFilterISS3VIF3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3VIF3_GetCoordinateTolerance, None, itkImageToImageFilterISS3VIF3)
itkImageToImageFilterISS3VIF3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3VIF3_SetDirectionTolerance, None, itkImageToImageFilterISS3VIF3)
itkImageToImageFilterISS3VIF3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3VIF3_GetDirectionTolerance, None, itkImageToImageFilterISS3VIF3)
itkImageToImageFilterISS3VIF3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterISS3VIF3_swigregister
itkImageToImageFilterISS3VIF3_swigregister(itkImageToImageFilterISS3VIF3)

def itkImageToImageFilterISS3VIF3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS3VIF3 *":
    """itkImageToImageFilterISS3VIF3_cast(itkLightObject obj) -> itkImageToImageFilterISS3VIF3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterISS3VIF3_cast(obj)

class itkImageToImageFilterISS3VISS3(itkImageSourcePython.itkImageSourceVISS3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterISS3VISS3 self, itkImageSS3 image)
        SetInput(itkImageToImageFilterISS3VISS3 self, unsigned int arg0, itkImageSS3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3VISS3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageSS3 const *":
        """
        GetInput(itkImageToImageFilterISS3VISS3 self) -> itkImageSS3
        GetInput(itkImageToImageFilterISS3VISS3 self, unsigned int idx) -> itkImageSS3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3VISS3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageSS3') -> "void":
        """
        PushBackInput(itkImageToImageFilterISS3VISS3 self, itkImageSS3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3VISS3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterISS3VISS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3VISS3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageSS3') -> "void":
        """PushFrontInput(itkImageToImageFilterISS3VISS3 self, itkImageSS3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3VISS3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterISS3VISS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3VISS3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterISS3VISS3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3VISS3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterISS3VISS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3VISS3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterISS3VISS3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3VISS3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterISS3VISS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3VISS3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterISS3VISS3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS3VISS3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterISS3VISS3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3VISS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterISS3VISS3

        Create a new object of the class itkImageToImageFilterISS3VISS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterISS3VISS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterISS3VISS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterISS3VISS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterISS3VISS3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3VISS3_SetInput, None, itkImageToImageFilterISS3VISS3)
itkImageToImageFilterISS3VISS3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3VISS3_GetInput, None, itkImageToImageFilterISS3VISS3)
itkImageToImageFilterISS3VISS3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3VISS3_PushBackInput, None, itkImageToImageFilterISS3VISS3)
itkImageToImageFilterISS3VISS3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3VISS3_PopBackInput, None, itkImageToImageFilterISS3VISS3)
itkImageToImageFilterISS3VISS3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3VISS3_PushFrontInput, None, itkImageToImageFilterISS3VISS3)
itkImageToImageFilterISS3VISS3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3VISS3_PopFrontInput, None, itkImageToImageFilterISS3VISS3)
itkImageToImageFilterISS3VISS3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3VISS3_SetCoordinateTolerance, None, itkImageToImageFilterISS3VISS3)
itkImageToImageFilterISS3VISS3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3VISS3_GetCoordinateTolerance, None, itkImageToImageFilterISS3VISS3)
itkImageToImageFilterISS3VISS3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3VISS3_SetDirectionTolerance, None, itkImageToImageFilterISS3VISS3)
itkImageToImageFilterISS3VISS3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3VISS3_GetDirectionTolerance, None, itkImageToImageFilterISS3VISS3)
itkImageToImageFilterISS3VISS3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterISS3VISS3_swigregister
itkImageToImageFilterISS3VISS3_swigregister(itkImageToImageFilterISS3VISS3)

def itkImageToImageFilterISS3VISS3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS3VISS3 *":
    """itkImageToImageFilterISS3VISS3_cast(itkLightObject obj) -> itkImageToImageFilterISS3VISS3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterISS3VISS3_cast(obj)

class itkImageToImageFilterISS3VIUC3(itkImageSourcePython.itkImageSourceVIUC3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterISS3VIUC3 self, itkImageSS3 image)
        SetInput(itkImageToImageFilterISS3VIUC3 self, unsigned int arg0, itkImageSS3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3VIUC3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageSS3 const *":
        """
        GetInput(itkImageToImageFilterISS3VIUC3 self) -> itkImageSS3
        GetInput(itkImageToImageFilterISS3VIUC3 self, unsigned int idx) -> itkImageSS3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3VIUC3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageSS3') -> "void":
        """
        PushBackInput(itkImageToImageFilterISS3VIUC3 self, itkImageSS3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3VIUC3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterISS3VIUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3VIUC3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageSS3') -> "void":
        """PushFrontInput(itkImageToImageFilterISS3VIUC3 self, itkImageSS3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3VIUC3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterISS3VIUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3VIUC3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterISS3VIUC3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3VIUC3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterISS3VIUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3VIUC3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterISS3VIUC3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3VIUC3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterISS3VIUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3VIUC3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterISS3VIUC3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS3VIUC3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterISS3VIUC3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3VIUC3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterISS3VIUC3

        Create a new object of the class itkImageToImageFilterISS3VIUC3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterISS3VIUC3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterISS3VIUC3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterISS3VIUC3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterISS3VIUC3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3VIUC3_SetInput, None, itkImageToImageFilterISS3VIUC3)
itkImageToImageFilterISS3VIUC3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3VIUC3_GetInput, None, itkImageToImageFilterISS3VIUC3)
itkImageToImageFilterISS3VIUC3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3VIUC3_PushBackInput, None, itkImageToImageFilterISS3VIUC3)
itkImageToImageFilterISS3VIUC3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3VIUC3_PopBackInput, None, itkImageToImageFilterISS3VIUC3)
itkImageToImageFilterISS3VIUC3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3VIUC3_PushFrontInput, None, itkImageToImageFilterISS3VIUC3)
itkImageToImageFilterISS3VIUC3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3VIUC3_PopFrontInput, None, itkImageToImageFilterISS3VIUC3)
itkImageToImageFilterISS3VIUC3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3VIUC3_SetCoordinateTolerance, None, itkImageToImageFilterISS3VIUC3)
itkImageToImageFilterISS3VIUC3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3VIUC3_GetCoordinateTolerance, None, itkImageToImageFilterISS3VIUC3)
itkImageToImageFilterISS3VIUC3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3VIUC3_SetDirectionTolerance, None, itkImageToImageFilterISS3VIUC3)
itkImageToImageFilterISS3VIUC3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3VIUC3_GetDirectionTolerance, None, itkImageToImageFilterISS3VIUC3)
itkImageToImageFilterISS3VIUC3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterISS3VIUC3_swigregister
itkImageToImageFilterISS3VIUC3_swigregister(itkImageToImageFilterISS3VIUC3)

def itkImageToImageFilterISS3VIUC3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS3VIUC3 *":
    """itkImageToImageFilterISS3VIUC3_cast(itkLightObject obj) -> itkImageToImageFilterISS3VIUC3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterISS3VIUC3_cast(obj)

class itkImageToImageFilterISS3VIUS3(itkImageSourcePython.itkImageSourceVIUS3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterISS3VIUS3 self, itkImageSS3 image)
        SetInput(itkImageToImageFilterISS3VIUS3 self, unsigned int arg0, itkImageSS3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3VIUS3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageSS3 const *":
        """
        GetInput(itkImageToImageFilterISS3VIUS3 self) -> itkImageSS3
        GetInput(itkImageToImageFilterISS3VIUS3 self, unsigned int idx) -> itkImageSS3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3VIUS3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageSS3') -> "void":
        """
        PushBackInput(itkImageToImageFilterISS3VIUS3 self, itkImageSS3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3VIUS3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterISS3VIUS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3VIUS3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageSS3') -> "void":
        """PushFrontInput(itkImageToImageFilterISS3VIUS3 self, itkImageSS3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3VIUS3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterISS3VIUS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3VIUS3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterISS3VIUS3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3VIUS3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterISS3VIUS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3VIUS3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterISS3VIUS3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3VIUS3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterISS3VIUS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3VIUS3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterISS3VIUS3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS3VIUS3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterISS3VIUS3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISS3VIUS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterISS3VIUS3

        Create a new object of the class itkImageToImageFilterISS3VIUS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterISS3VIUS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterISS3VIUS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterISS3VIUS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterISS3VIUS3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3VIUS3_SetInput, None, itkImageToImageFilterISS3VIUS3)
itkImageToImageFilterISS3VIUS3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3VIUS3_GetInput, None, itkImageToImageFilterISS3VIUS3)
itkImageToImageFilterISS3VIUS3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3VIUS3_PushBackInput, None, itkImageToImageFilterISS3VIUS3)
itkImageToImageFilterISS3VIUS3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3VIUS3_PopBackInput, None, itkImageToImageFilterISS3VIUS3)
itkImageToImageFilterISS3VIUS3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3VIUS3_PushFrontInput, None, itkImageToImageFilterISS3VIUS3)
itkImageToImageFilterISS3VIUS3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3VIUS3_PopFrontInput, None, itkImageToImageFilterISS3VIUS3)
itkImageToImageFilterISS3VIUS3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3VIUS3_SetCoordinateTolerance, None, itkImageToImageFilterISS3VIUS3)
itkImageToImageFilterISS3VIUS3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3VIUS3_GetCoordinateTolerance, None, itkImageToImageFilterISS3VIUS3)
itkImageToImageFilterISS3VIUS3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3VIUS3_SetDirectionTolerance, None, itkImageToImageFilterISS3VIUS3)
itkImageToImageFilterISS3VIUS3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISS3VIUS3_GetDirectionTolerance, None, itkImageToImageFilterISS3VIUS3)
itkImageToImageFilterISS3VIUS3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterISS3VIUS3_swigregister
itkImageToImageFilterISS3VIUS3_swigregister(itkImageToImageFilterISS3VIUS3)

def itkImageToImageFilterISS3VIUS3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS3VIUS3 *":
    """itkImageToImageFilterISS3VIUS3_cast(itkLightObject obj) -> itkImageToImageFilterISS3VIUS3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterISS3VIUS3_cast(obj)

class itkImageToImageFilterISSRTD22ID2(itkImageSourcePython.itkImageSourceID2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterISSRTD22ID2 self, itkImageSSRTD22 image)
        SetInput(itkImageToImageFilterISSRTD22ID2 self, unsigned int arg0, itkImageSSRTD22 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ID2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageSSRTD22 const *":
        """
        GetInput(itkImageToImageFilterISSRTD22ID2 self) -> itkImageSSRTD22
        GetInput(itkImageToImageFilterISSRTD22ID2 self, unsigned int idx) -> itkImageSSRTD22
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ID2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageSSRTD22') -> "void":
        """
        PushBackInput(itkImageToImageFilterISSRTD22ID2 self, itkImageSSRTD22 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ID2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterISSRTD22ID2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ID2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageSSRTD22') -> "void":
        """PushFrontInput(itkImageToImageFilterISSRTD22ID2 self, itkImageSSRTD22 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ID2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterISSRTD22ID2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ID2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterISSRTD22ID2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ID2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterISSRTD22ID2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ID2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterISSRTD22ID2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ID2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterISSRTD22ID2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ID2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterISSRTD22ID2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterISSRTD22ID2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterISSRTD22ID2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ID2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterISSRTD22ID2

        Create a new object of the class itkImageToImageFilterISSRTD22ID2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterISSRTD22ID2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterISSRTD22ID2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterISSRTD22ID2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterISSRTD22ID2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ID2_SetInput, None, itkImageToImageFilterISSRTD22ID2)
itkImageToImageFilterISSRTD22ID2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ID2_GetInput, None, itkImageToImageFilterISSRTD22ID2)
itkImageToImageFilterISSRTD22ID2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ID2_PushBackInput, None, itkImageToImageFilterISSRTD22ID2)
itkImageToImageFilterISSRTD22ID2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ID2_PopBackInput, None, itkImageToImageFilterISSRTD22ID2)
itkImageToImageFilterISSRTD22ID2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ID2_PushFrontInput, None, itkImageToImageFilterISSRTD22ID2)
itkImageToImageFilterISSRTD22ID2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ID2_PopFrontInput, None, itkImageToImageFilterISSRTD22ID2)
itkImageToImageFilterISSRTD22ID2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ID2_SetCoordinateTolerance, None, itkImageToImageFilterISSRTD22ID2)
itkImageToImageFilterISSRTD22ID2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ID2_GetCoordinateTolerance, None, itkImageToImageFilterISSRTD22ID2)
itkImageToImageFilterISSRTD22ID2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ID2_SetDirectionTolerance, None, itkImageToImageFilterISSRTD22ID2)
itkImageToImageFilterISSRTD22ID2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ID2_GetDirectionTolerance, None, itkImageToImageFilterISSRTD22ID2)
itkImageToImageFilterISSRTD22ID2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ID2_swigregister
itkImageToImageFilterISSRTD22ID2_swigregister(itkImageToImageFilterISSRTD22ID2)

def itkImageToImageFilterISSRTD22ID2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterISSRTD22ID2 *":
    """itkImageToImageFilterISSRTD22ID2_cast(itkLightObject obj) -> itkImageToImageFilterISSRTD22ID2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ID2_cast(obj)

class itkImageToImageFilterISSRTD22IF2(itkImageSourcePython.itkImageSourceIF2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterISSRTD22IF2 self, itkImageSSRTD22 image)
        SetInput(itkImageToImageFilterISSRTD22IF2 self, unsigned int arg0, itkImageSSRTD22 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IF2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageSSRTD22 const *":
        """
        GetInput(itkImageToImageFilterISSRTD22IF2 self) -> itkImageSSRTD22
        GetInput(itkImageToImageFilterISSRTD22IF2 self, unsigned int idx) -> itkImageSSRTD22
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IF2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageSSRTD22') -> "void":
        """
        PushBackInput(itkImageToImageFilterISSRTD22IF2 self, itkImageSSRTD22 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IF2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterISSRTD22IF2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IF2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageSSRTD22') -> "void":
        """PushFrontInput(itkImageToImageFilterISSRTD22IF2 self, itkImageSSRTD22 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IF2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterISSRTD22IF2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IF2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterISSRTD22IF2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IF2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterISSRTD22IF2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IF2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterISSRTD22IF2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IF2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterISSRTD22IF2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IF2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterISSRTD22IF2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterISSRTD22IF2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterISSRTD22IF2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IF2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterISSRTD22IF2

        Create a new object of the class itkImageToImageFilterISSRTD22IF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterISSRTD22IF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterISSRTD22IF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterISSRTD22IF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterISSRTD22IF2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IF2_SetInput, None, itkImageToImageFilterISSRTD22IF2)
itkImageToImageFilterISSRTD22IF2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IF2_GetInput, None, itkImageToImageFilterISSRTD22IF2)
itkImageToImageFilterISSRTD22IF2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IF2_PushBackInput, None, itkImageToImageFilterISSRTD22IF2)
itkImageToImageFilterISSRTD22IF2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IF2_PopBackInput, None, itkImageToImageFilterISSRTD22IF2)
itkImageToImageFilterISSRTD22IF2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IF2_PushFrontInput, None, itkImageToImageFilterISSRTD22IF2)
itkImageToImageFilterISSRTD22IF2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IF2_PopFrontInput, None, itkImageToImageFilterISSRTD22IF2)
itkImageToImageFilterISSRTD22IF2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IF2_SetCoordinateTolerance, None, itkImageToImageFilterISSRTD22IF2)
itkImageToImageFilterISSRTD22IF2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IF2_GetCoordinateTolerance, None, itkImageToImageFilterISSRTD22IF2)
itkImageToImageFilterISSRTD22IF2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IF2_SetDirectionTolerance, None, itkImageToImageFilterISSRTD22IF2)
itkImageToImageFilterISSRTD22IF2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IF2_GetDirectionTolerance, None, itkImageToImageFilterISSRTD22IF2)
itkImageToImageFilterISSRTD22IF2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IF2_swigregister
itkImageToImageFilterISSRTD22IF2_swigregister(itkImageToImageFilterISSRTD22IF2)

def itkImageToImageFilterISSRTD22IF2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterISSRTD22IF2 *":
    """itkImageToImageFilterISSRTD22IF2_cast(itkLightObject obj) -> itkImageToImageFilterISSRTD22IF2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IF2_cast(obj)

class itkImageToImageFilterISSRTD22ISS2(itkImageSourcePython.itkImageSourceISS2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterISSRTD22ISS2 self, itkImageSSRTD22 image)
        SetInput(itkImageToImageFilterISSRTD22ISS2 self, unsigned int arg0, itkImageSSRTD22 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ISS2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageSSRTD22 const *":
        """
        GetInput(itkImageToImageFilterISSRTD22ISS2 self) -> itkImageSSRTD22
        GetInput(itkImageToImageFilterISSRTD22ISS2 self, unsigned int idx) -> itkImageSSRTD22
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ISS2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageSSRTD22') -> "void":
        """
        PushBackInput(itkImageToImageFilterISSRTD22ISS2 self, itkImageSSRTD22 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ISS2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterISSRTD22ISS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ISS2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageSSRTD22') -> "void":
        """PushFrontInput(itkImageToImageFilterISSRTD22ISS2 self, itkImageSSRTD22 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ISS2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterISSRTD22ISS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ISS2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterISSRTD22ISS2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ISS2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterISSRTD22ISS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ISS2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterISSRTD22ISS2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ISS2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterISSRTD22ISS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ISS2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterISSRTD22ISS2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterISSRTD22ISS2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterISSRTD22ISS2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ISS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterISSRTD22ISS2

        Create a new object of the class itkImageToImageFilterISSRTD22ISS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterISSRTD22ISS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterISSRTD22ISS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterISSRTD22ISS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterISSRTD22ISS2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ISS2_SetInput, None, itkImageToImageFilterISSRTD22ISS2)
itkImageToImageFilterISSRTD22ISS2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ISS2_GetInput, None, itkImageToImageFilterISSRTD22ISS2)
itkImageToImageFilterISSRTD22ISS2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ISS2_PushBackInput, None, itkImageToImageFilterISSRTD22ISS2)
itkImageToImageFilterISSRTD22ISS2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ISS2_PopBackInput, None, itkImageToImageFilterISSRTD22ISS2)
itkImageToImageFilterISSRTD22ISS2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ISS2_PushFrontInput, None, itkImageToImageFilterISSRTD22ISS2)
itkImageToImageFilterISSRTD22ISS2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ISS2_PopFrontInput, None, itkImageToImageFilterISSRTD22ISS2)
itkImageToImageFilterISSRTD22ISS2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ISS2_SetCoordinateTolerance, None, itkImageToImageFilterISSRTD22ISS2)
itkImageToImageFilterISSRTD22ISS2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ISS2_GetCoordinateTolerance, None, itkImageToImageFilterISSRTD22ISS2)
itkImageToImageFilterISSRTD22ISS2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ISS2_SetDirectionTolerance, None, itkImageToImageFilterISSRTD22ISS2)
itkImageToImageFilterISSRTD22ISS2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ISS2_GetDirectionTolerance, None, itkImageToImageFilterISSRTD22ISS2)
itkImageToImageFilterISSRTD22ISS2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ISS2_swigregister
itkImageToImageFilterISSRTD22ISS2_swigregister(itkImageToImageFilterISSRTD22ISS2)

def itkImageToImageFilterISSRTD22ISS2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterISSRTD22ISS2 *":
    """itkImageToImageFilterISSRTD22ISS2_cast(itkLightObject obj) -> itkImageToImageFilterISSRTD22ISS2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ISS2_cast(obj)

class itkImageToImageFilterISSRTD22ISSRTD22(itkImageSourcePython.itkImageSourceISSRTD22):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterISSRTD22ISSRTD22 self, itkImageSSRTD22 image)
        SetInput(itkImageToImageFilterISSRTD22ISSRTD22 self, unsigned int arg0, itkImageSSRTD22 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ISSRTD22_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageSSRTD22 const *":
        """
        GetInput(itkImageToImageFilterISSRTD22ISSRTD22 self) -> itkImageSSRTD22
        GetInput(itkImageToImageFilterISSRTD22ISSRTD22 self, unsigned int idx) -> itkImageSSRTD22
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ISSRTD22_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageSSRTD22') -> "void":
        """
        PushBackInput(itkImageToImageFilterISSRTD22ISSRTD22 self, itkImageSSRTD22 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ISSRTD22_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterISSRTD22ISSRTD22 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ISSRTD22_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageSSRTD22') -> "void":
        """PushFrontInput(itkImageToImageFilterISSRTD22ISSRTD22 self, itkImageSSRTD22 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ISSRTD22_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterISSRTD22ISSRTD22 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ISSRTD22_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterISSRTD22ISSRTD22 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ISSRTD22_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterISSRTD22ISSRTD22 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ISSRTD22_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterISSRTD22ISSRTD22 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ISSRTD22_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterISSRTD22ISSRTD22 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ISSRTD22_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterISSRTD22ISSRTD22

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterISSRTD22ISSRTD22 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterISSRTD22ISSRTD22"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ISSRTD22_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterISSRTD22ISSRTD22

        Create a new object of the class itkImageToImageFilterISSRTD22ISSRTD22 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterISSRTD22ISSRTD22.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterISSRTD22ISSRTD22.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterISSRTD22ISSRTD22.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterISSRTD22ISSRTD22.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ISSRTD22_SetInput, None, itkImageToImageFilterISSRTD22ISSRTD22)
itkImageToImageFilterISSRTD22ISSRTD22.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ISSRTD22_GetInput, None, itkImageToImageFilterISSRTD22ISSRTD22)
itkImageToImageFilterISSRTD22ISSRTD22.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ISSRTD22_PushBackInput, None, itkImageToImageFilterISSRTD22ISSRTD22)
itkImageToImageFilterISSRTD22ISSRTD22.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ISSRTD22_PopBackInput, None, itkImageToImageFilterISSRTD22ISSRTD22)
itkImageToImageFilterISSRTD22ISSRTD22.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ISSRTD22_PushFrontInput, None, itkImageToImageFilterISSRTD22ISSRTD22)
itkImageToImageFilterISSRTD22ISSRTD22.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ISSRTD22_PopFrontInput, None, itkImageToImageFilterISSRTD22ISSRTD22)
itkImageToImageFilterISSRTD22ISSRTD22.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ISSRTD22_SetCoordinateTolerance, None, itkImageToImageFilterISSRTD22ISSRTD22)
itkImageToImageFilterISSRTD22ISSRTD22.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ISSRTD22_GetCoordinateTolerance, None, itkImageToImageFilterISSRTD22ISSRTD22)
itkImageToImageFilterISSRTD22ISSRTD22.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ISSRTD22_SetDirectionTolerance, None, itkImageToImageFilterISSRTD22ISSRTD22)
itkImageToImageFilterISSRTD22ISSRTD22.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ISSRTD22_GetDirectionTolerance, None, itkImageToImageFilterISSRTD22ISSRTD22)
itkImageToImageFilterISSRTD22ISSRTD22_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ISSRTD22_swigregister
itkImageToImageFilterISSRTD22ISSRTD22_swigregister(itkImageToImageFilterISSRTD22ISSRTD22)

def itkImageToImageFilterISSRTD22ISSRTD22_cast(obj: 'itkLightObject') -> "itkImageToImageFilterISSRTD22ISSRTD22 *":
    """itkImageToImageFilterISSRTD22ISSRTD22_cast(itkLightObject obj) -> itkImageToImageFilterISSRTD22ISSRTD22"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22ISSRTD22_cast(obj)

class itkImageToImageFilterISSRTD22IUC2(itkImageSourcePython.itkImageSourceIUC2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterISSRTD22IUC2 self, itkImageSSRTD22 image)
        SetInput(itkImageToImageFilterISSRTD22IUC2 self, unsigned int arg0, itkImageSSRTD22 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IUC2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageSSRTD22 const *":
        """
        GetInput(itkImageToImageFilterISSRTD22IUC2 self) -> itkImageSSRTD22
        GetInput(itkImageToImageFilterISSRTD22IUC2 self, unsigned int idx) -> itkImageSSRTD22
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IUC2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageSSRTD22') -> "void":
        """
        PushBackInput(itkImageToImageFilterISSRTD22IUC2 self, itkImageSSRTD22 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IUC2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterISSRTD22IUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IUC2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageSSRTD22') -> "void":
        """PushFrontInput(itkImageToImageFilterISSRTD22IUC2 self, itkImageSSRTD22 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IUC2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterISSRTD22IUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IUC2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterISSRTD22IUC2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IUC2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterISSRTD22IUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IUC2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterISSRTD22IUC2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IUC2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterISSRTD22IUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IUC2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterISSRTD22IUC2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterISSRTD22IUC2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterISSRTD22IUC2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IUC2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterISSRTD22IUC2

        Create a new object of the class itkImageToImageFilterISSRTD22IUC2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterISSRTD22IUC2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterISSRTD22IUC2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterISSRTD22IUC2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterISSRTD22IUC2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IUC2_SetInput, None, itkImageToImageFilterISSRTD22IUC2)
itkImageToImageFilterISSRTD22IUC2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IUC2_GetInput, None, itkImageToImageFilterISSRTD22IUC2)
itkImageToImageFilterISSRTD22IUC2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IUC2_PushBackInput, None, itkImageToImageFilterISSRTD22IUC2)
itkImageToImageFilterISSRTD22IUC2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IUC2_PopBackInput, None, itkImageToImageFilterISSRTD22IUC2)
itkImageToImageFilterISSRTD22IUC2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IUC2_PushFrontInput, None, itkImageToImageFilterISSRTD22IUC2)
itkImageToImageFilterISSRTD22IUC2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IUC2_PopFrontInput, None, itkImageToImageFilterISSRTD22IUC2)
itkImageToImageFilterISSRTD22IUC2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IUC2_SetCoordinateTolerance, None, itkImageToImageFilterISSRTD22IUC2)
itkImageToImageFilterISSRTD22IUC2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IUC2_GetCoordinateTolerance, None, itkImageToImageFilterISSRTD22IUC2)
itkImageToImageFilterISSRTD22IUC2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IUC2_SetDirectionTolerance, None, itkImageToImageFilterISSRTD22IUC2)
itkImageToImageFilterISSRTD22IUC2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IUC2_GetDirectionTolerance, None, itkImageToImageFilterISSRTD22IUC2)
itkImageToImageFilterISSRTD22IUC2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IUC2_swigregister
itkImageToImageFilterISSRTD22IUC2_swigregister(itkImageToImageFilterISSRTD22IUC2)

def itkImageToImageFilterISSRTD22IUC2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterISSRTD22IUC2 *":
    """itkImageToImageFilterISSRTD22IUC2_cast(itkLightObject obj) -> itkImageToImageFilterISSRTD22IUC2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IUC2_cast(obj)

class itkImageToImageFilterISSRTD22IUS2(itkImageSourcePython.itkImageSourceIUS2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterISSRTD22IUS2 self, itkImageSSRTD22 image)
        SetInput(itkImageToImageFilterISSRTD22IUS2 self, unsigned int arg0, itkImageSSRTD22 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IUS2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageSSRTD22 const *":
        """
        GetInput(itkImageToImageFilterISSRTD22IUS2 self) -> itkImageSSRTD22
        GetInput(itkImageToImageFilterISSRTD22IUS2 self, unsigned int idx) -> itkImageSSRTD22
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IUS2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageSSRTD22') -> "void":
        """
        PushBackInput(itkImageToImageFilterISSRTD22IUS2 self, itkImageSSRTD22 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IUS2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterISSRTD22IUS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IUS2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageSSRTD22') -> "void":
        """PushFrontInput(itkImageToImageFilterISSRTD22IUS2 self, itkImageSSRTD22 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IUS2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterISSRTD22IUS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IUS2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterISSRTD22IUS2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IUS2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterISSRTD22IUS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IUS2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterISSRTD22IUS2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IUS2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterISSRTD22IUS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IUS2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterISSRTD22IUS2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterISSRTD22IUS2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterISSRTD22IUS2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IUS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterISSRTD22IUS2

        Create a new object of the class itkImageToImageFilterISSRTD22IUS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterISSRTD22IUS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterISSRTD22IUS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterISSRTD22IUS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterISSRTD22IUS2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IUS2_SetInput, None, itkImageToImageFilterISSRTD22IUS2)
itkImageToImageFilterISSRTD22IUS2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IUS2_GetInput, None, itkImageToImageFilterISSRTD22IUS2)
itkImageToImageFilterISSRTD22IUS2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IUS2_PushBackInput, None, itkImageToImageFilterISSRTD22IUS2)
itkImageToImageFilterISSRTD22IUS2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IUS2_PopBackInput, None, itkImageToImageFilterISSRTD22IUS2)
itkImageToImageFilterISSRTD22IUS2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IUS2_PushFrontInput, None, itkImageToImageFilterISSRTD22IUS2)
itkImageToImageFilterISSRTD22IUS2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IUS2_PopFrontInput, None, itkImageToImageFilterISSRTD22IUS2)
itkImageToImageFilterISSRTD22IUS2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IUS2_SetCoordinateTolerance, None, itkImageToImageFilterISSRTD22IUS2)
itkImageToImageFilterISSRTD22IUS2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IUS2_GetCoordinateTolerance, None, itkImageToImageFilterISSRTD22IUS2)
itkImageToImageFilterISSRTD22IUS2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IUS2_SetDirectionTolerance, None, itkImageToImageFilterISSRTD22IUS2)
itkImageToImageFilterISSRTD22IUS2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IUS2_GetDirectionTolerance, None, itkImageToImageFilterISSRTD22IUS2)
itkImageToImageFilterISSRTD22IUS2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IUS2_swigregister
itkImageToImageFilterISSRTD22IUS2_swigregister(itkImageToImageFilterISSRTD22IUS2)

def itkImageToImageFilterISSRTD22IUS2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterISSRTD22IUS2 *":
    """itkImageToImageFilterISSRTD22IUS2_cast(itkLightObject obj) -> itkImageToImageFilterISSRTD22IUS2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD22IUS2_cast(obj)

class itkImageToImageFilterISSRTD33ID3(itkImageSourcePython.itkImageSourceID3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterISSRTD33ID3 self, itkImageSSRTD33 image)
        SetInput(itkImageToImageFilterISSRTD33ID3 self, unsigned int arg0, itkImageSSRTD33 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ID3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageSSRTD33 const *":
        """
        GetInput(itkImageToImageFilterISSRTD33ID3 self) -> itkImageSSRTD33
        GetInput(itkImageToImageFilterISSRTD33ID3 self, unsigned int idx) -> itkImageSSRTD33
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ID3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageSSRTD33') -> "void":
        """
        PushBackInput(itkImageToImageFilterISSRTD33ID3 self, itkImageSSRTD33 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ID3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterISSRTD33ID3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ID3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageSSRTD33') -> "void":
        """PushFrontInput(itkImageToImageFilterISSRTD33ID3 self, itkImageSSRTD33 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ID3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterISSRTD33ID3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ID3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterISSRTD33ID3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ID3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterISSRTD33ID3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ID3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterISSRTD33ID3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ID3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterISSRTD33ID3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ID3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterISSRTD33ID3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterISSRTD33ID3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterISSRTD33ID3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ID3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterISSRTD33ID3

        Create a new object of the class itkImageToImageFilterISSRTD33ID3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterISSRTD33ID3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterISSRTD33ID3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterISSRTD33ID3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterISSRTD33ID3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ID3_SetInput, None, itkImageToImageFilterISSRTD33ID3)
itkImageToImageFilterISSRTD33ID3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ID3_GetInput, None, itkImageToImageFilterISSRTD33ID3)
itkImageToImageFilterISSRTD33ID3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ID3_PushBackInput, None, itkImageToImageFilterISSRTD33ID3)
itkImageToImageFilterISSRTD33ID3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ID3_PopBackInput, None, itkImageToImageFilterISSRTD33ID3)
itkImageToImageFilterISSRTD33ID3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ID3_PushFrontInput, None, itkImageToImageFilterISSRTD33ID3)
itkImageToImageFilterISSRTD33ID3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ID3_PopFrontInput, None, itkImageToImageFilterISSRTD33ID3)
itkImageToImageFilterISSRTD33ID3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ID3_SetCoordinateTolerance, None, itkImageToImageFilterISSRTD33ID3)
itkImageToImageFilterISSRTD33ID3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ID3_GetCoordinateTolerance, None, itkImageToImageFilterISSRTD33ID3)
itkImageToImageFilterISSRTD33ID3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ID3_SetDirectionTolerance, None, itkImageToImageFilterISSRTD33ID3)
itkImageToImageFilterISSRTD33ID3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ID3_GetDirectionTolerance, None, itkImageToImageFilterISSRTD33ID3)
itkImageToImageFilterISSRTD33ID3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ID3_swigregister
itkImageToImageFilterISSRTD33ID3_swigregister(itkImageToImageFilterISSRTD33ID3)

def itkImageToImageFilterISSRTD33ID3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterISSRTD33ID3 *":
    """itkImageToImageFilterISSRTD33ID3_cast(itkLightObject obj) -> itkImageToImageFilterISSRTD33ID3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ID3_cast(obj)

class itkImageToImageFilterISSRTD33IF3(itkImageSourcePython.itkImageSourceIF3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterISSRTD33IF3 self, itkImageSSRTD33 image)
        SetInput(itkImageToImageFilterISSRTD33IF3 self, unsigned int arg0, itkImageSSRTD33 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IF3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageSSRTD33 const *":
        """
        GetInput(itkImageToImageFilterISSRTD33IF3 self) -> itkImageSSRTD33
        GetInput(itkImageToImageFilterISSRTD33IF3 self, unsigned int idx) -> itkImageSSRTD33
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IF3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageSSRTD33') -> "void":
        """
        PushBackInput(itkImageToImageFilterISSRTD33IF3 self, itkImageSSRTD33 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IF3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterISSRTD33IF3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IF3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageSSRTD33') -> "void":
        """PushFrontInput(itkImageToImageFilterISSRTD33IF3 self, itkImageSSRTD33 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IF3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterISSRTD33IF3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IF3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterISSRTD33IF3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IF3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterISSRTD33IF3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IF3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterISSRTD33IF3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IF3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterISSRTD33IF3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IF3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterISSRTD33IF3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterISSRTD33IF3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterISSRTD33IF3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IF3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterISSRTD33IF3

        Create a new object of the class itkImageToImageFilterISSRTD33IF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterISSRTD33IF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterISSRTD33IF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterISSRTD33IF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterISSRTD33IF3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IF3_SetInput, None, itkImageToImageFilterISSRTD33IF3)
itkImageToImageFilterISSRTD33IF3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IF3_GetInput, None, itkImageToImageFilterISSRTD33IF3)
itkImageToImageFilterISSRTD33IF3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IF3_PushBackInput, None, itkImageToImageFilterISSRTD33IF3)
itkImageToImageFilterISSRTD33IF3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IF3_PopBackInput, None, itkImageToImageFilterISSRTD33IF3)
itkImageToImageFilterISSRTD33IF3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IF3_PushFrontInput, None, itkImageToImageFilterISSRTD33IF3)
itkImageToImageFilterISSRTD33IF3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IF3_PopFrontInput, None, itkImageToImageFilterISSRTD33IF3)
itkImageToImageFilterISSRTD33IF3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IF3_SetCoordinateTolerance, None, itkImageToImageFilterISSRTD33IF3)
itkImageToImageFilterISSRTD33IF3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IF3_GetCoordinateTolerance, None, itkImageToImageFilterISSRTD33IF3)
itkImageToImageFilterISSRTD33IF3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IF3_SetDirectionTolerance, None, itkImageToImageFilterISSRTD33IF3)
itkImageToImageFilterISSRTD33IF3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IF3_GetDirectionTolerance, None, itkImageToImageFilterISSRTD33IF3)
itkImageToImageFilterISSRTD33IF3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IF3_swigregister
itkImageToImageFilterISSRTD33IF3_swigregister(itkImageToImageFilterISSRTD33IF3)

def itkImageToImageFilterISSRTD33IF3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterISSRTD33IF3 *":
    """itkImageToImageFilterISSRTD33IF3_cast(itkLightObject obj) -> itkImageToImageFilterISSRTD33IF3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IF3_cast(obj)

class itkImageToImageFilterISSRTD33ISS3(itkImageSourcePython.itkImageSourceISS3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterISSRTD33ISS3 self, itkImageSSRTD33 image)
        SetInput(itkImageToImageFilterISSRTD33ISS3 self, unsigned int arg0, itkImageSSRTD33 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ISS3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageSSRTD33 const *":
        """
        GetInput(itkImageToImageFilterISSRTD33ISS3 self) -> itkImageSSRTD33
        GetInput(itkImageToImageFilterISSRTD33ISS3 self, unsigned int idx) -> itkImageSSRTD33
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ISS3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageSSRTD33') -> "void":
        """
        PushBackInput(itkImageToImageFilterISSRTD33ISS3 self, itkImageSSRTD33 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ISS3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterISSRTD33ISS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ISS3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageSSRTD33') -> "void":
        """PushFrontInput(itkImageToImageFilterISSRTD33ISS3 self, itkImageSSRTD33 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ISS3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterISSRTD33ISS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ISS3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterISSRTD33ISS3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ISS3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterISSRTD33ISS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ISS3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterISSRTD33ISS3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ISS3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterISSRTD33ISS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ISS3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterISSRTD33ISS3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterISSRTD33ISS3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterISSRTD33ISS3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ISS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterISSRTD33ISS3

        Create a new object of the class itkImageToImageFilterISSRTD33ISS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterISSRTD33ISS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterISSRTD33ISS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterISSRTD33ISS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterISSRTD33ISS3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ISS3_SetInput, None, itkImageToImageFilterISSRTD33ISS3)
itkImageToImageFilterISSRTD33ISS3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ISS3_GetInput, None, itkImageToImageFilterISSRTD33ISS3)
itkImageToImageFilterISSRTD33ISS3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ISS3_PushBackInput, None, itkImageToImageFilterISSRTD33ISS3)
itkImageToImageFilterISSRTD33ISS3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ISS3_PopBackInput, None, itkImageToImageFilterISSRTD33ISS3)
itkImageToImageFilterISSRTD33ISS3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ISS3_PushFrontInput, None, itkImageToImageFilterISSRTD33ISS3)
itkImageToImageFilterISSRTD33ISS3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ISS3_PopFrontInput, None, itkImageToImageFilterISSRTD33ISS3)
itkImageToImageFilterISSRTD33ISS3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ISS3_SetCoordinateTolerance, None, itkImageToImageFilterISSRTD33ISS3)
itkImageToImageFilterISSRTD33ISS3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ISS3_GetCoordinateTolerance, None, itkImageToImageFilterISSRTD33ISS3)
itkImageToImageFilterISSRTD33ISS3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ISS3_SetDirectionTolerance, None, itkImageToImageFilterISSRTD33ISS3)
itkImageToImageFilterISSRTD33ISS3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ISS3_GetDirectionTolerance, None, itkImageToImageFilterISSRTD33ISS3)
itkImageToImageFilterISSRTD33ISS3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ISS3_swigregister
itkImageToImageFilterISSRTD33ISS3_swigregister(itkImageToImageFilterISSRTD33ISS3)

def itkImageToImageFilterISSRTD33ISS3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterISSRTD33ISS3 *":
    """itkImageToImageFilterISSRTD33ISS3_cast(itkLightObject obj) -> itkImageToImageFilterISSRTD33ISS3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ISS3_cast(obj)

class itkImageToImageFilterISSRTD33ISSRTD33(itkImageSourcePython.itkImageSourceISSRTD33):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterISSRTD33ISSRTD33 self, itkImageSSRTD33 image)
        SetInput(itkImageToImageFilterISSRTD33ISSRTD33 self, unsigned int arg0, itkImageSSRTD33 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ISSRTD33_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageSSRTD33 const *":
        """
        GetInput(itkImageToImageFilterISSRTD33ISSRTD33 self) -> itkImageSSRTD33
        GetInput(itkImageToImageFilterISSRTD33ISSRTD33 self, unsigned int idx) -> itkImageSSRTD33
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ISSRTD33_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageSSRTD33') -> "void":
        """
        PushBackInput(itkImageToImageFilterISSRTD33ISSRTD33 self, itkImageSSRTD33 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ISSRTD33_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterISSRTD33ISSRTD33 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ISSRTD33_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageSSRTD33') -> "void":
        """PushFrontInput(itkImageToImageFilterISSRTD33ISSRTD33 self, itkImageSSRTD33 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ISSRTD33_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterISSRTD33ISSRTD33 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ISSRTD33_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterISSRTD33ISSRTD33 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ISSRTD33_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterISSRTD33ISSRTD33 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ISSRTD33_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterISSRTD33ISSRTD33 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ISSRTD33_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterISSRTD33ISSRTD33 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ISSRTD33_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterISSRTD33ISSRTD33

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterISSRTD33ISSRTD33 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterISSRTD33ISSRTD33"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ISSRTD33_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterISSRTD33ISSRTD33

        Create a new object of the class itkImageToImageFilterISSRTD33ISSRTD33 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterISSRTD33ISSRTD33.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterISSRTD33ISSRTD33.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterISSRTD33ISSRTD33.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterISSRTD33ISSRTD33.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ISSRTD33_SetInput, None, itkImageToImageFilterISSRTD33ISSRTD33)
itkImageToImageFilterISSRTD33ISSRTD33.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ISSRTD33_GetInput, None, itkImageToImageFilterISSRTD33ISSRTD33)
itkImageToImageFilterISSRTD33ISSRTD33.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ISSRTD33_PushBackInput, None, itkImageToImageFilterISSRTD33ISSRTD33)
itkImageToImageFilterISSRTD33ISSRTD33.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ISSRTD33_PopBackInput, None, itkImageToImageFilterISSRTD33ISSRTD33)
itkImageToImageFilterISSRTD33ISSRTD33.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ISSRTD33_PushFrontInput, None, itkImageToImageFilterISSRTD33ISSRTD33)
itkImageToImageFilterISSRTD33ISSRTD33.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ISSRTD33_PopFrontInput, None, itkImageToImageFilterISSRTD33ISSRTD33)
itkImageToImageFilterISSRTD33ISSRTD33.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ISSRTD33_SetCoordinateTolerance, None, itkImageToImageFilterISSRTD33ISSRTD33)
itkImageToImageFilterISSRTD33ISSRTD33.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ISSRTD33_GetCoordinateTolerance, None, itkImageToImageFilterISSRTD33ISSRTD33)
itkImageToImageFilterISSRTD33ISSRTD33.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ISSRTD33_SetDirectionTolerance, None, itkImageToImageFilterISSRTD33ISSRTD33)
itkImageToImageFilterISSRTD33ISSRTD33.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ISSRTD33_GetDirectionTolerance, None, itkImageToImageFilterISSRTD33ISSRTD33)
itkImageToImageFilterISSRTD33ISSRTD33_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ISSRTD33_swigregister
itkImageToImageFilterISSRTD33ISSRTD33_swigregister(itkImageToImageFilterISSRTD33ISSRTD33)

def itkImageToImageFilterISSRTD33ISSRTD33_cast(obj: 'itkLightObject') -> "itkImageToImageFilterISSRTD33ISSRTD33 *":
    """itkImageToImageFilterISSRTD33ISSRTD33_cast(itkLightObject obj) -> itkImageToImageFilterISSRTD33ISSRTD33"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33ISSRTD33_cast(obj)

class itkImageToImageFilterISSRTD33IUC3(itkImageSourcePython.itkImageSourceIUC3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterISSRTD33IUC3 self, itkImageSSRTD33 image)
        SetInput(itkImageToImageFilterISSRTD33IUC3 self, unsigned int arg0, itkImageSSRTD33 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IUC3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageSSRTD33 const *":
        """
        GetInput(itkImageToImageFilterISSRTD33IUC3 self) -> itkImageSSRTD33
        GetInput(itkImageToImageFilterISSRTD33IUC3 self, unsigned int idx) -> itkImageSSRTD33
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IUC3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageSSRTD33') -> "void":
        """
        PushBackInput(itkImageToImageFilterISSRTD33IUC3 self, itkImageSSRTD33 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IUC3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterISSRTD33IUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IUC3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageSSRTD33') -> "void":
        """PushFrontInput(itkImageToImageFilterISSRTD33IUC3 self, itkImageSSRTD33 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IUC3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterISSRTD33IUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IUC3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterISSRTD33IUC3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IUC3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterISSRTD33IUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IUC3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterISSRTD33IUC3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IUC3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterISSRTD33IUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IUC3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterISSRTD33IUC3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterISSRTD33IUC3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterISSRTD33IUC3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IUC3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterISSRTD33IUC3

        Create a new object of the class itkImageToImageFilterISSRTD33IUC3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterISSRTD33IUC3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterISSRTD33IUC3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterISSRTD33IUC3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterISSRTD33IUC3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IUC3_SetInput, None, itkImageToImageFilterISSRTD33IUC3)
itkImageToImageFilterISSRTD33IUC3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IUC3_GetInput, None, itkImageToImageFilterISSRTD33IUC3)
itkImageToImageFilterISSRTD33IUC3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IUC3_PushBackInput, None, itkImageToImageFilterISSRTD33IUC3)
itkImageToImageFilterISSRTD33IUC3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IUC3_PopBackInput, None, itkImageToImageFilterISSRTD33IUC3)
itkImageToImageFilterISSRTD33IUC3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IUC3_PushFrontInput, None, itkImageToImageFilterISSRTD33IUC3)
itkImageToImageFilterISSRTD33IUC3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IUC3_PopFrontInput, None, itkImageToImageFilterISSRTD33IUC3)
itkImageToImageFilterISSRTD33IUC3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IUC3_SetCoordinateTolerance, None, itkImageToImageFilterISSRTD33IUC3)
itkImageToImageFilterISSRTD33IUC3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IUC3_GetCoordinateTolerance, None, itkImageToImageFilterISSRTD33IUC3)
itkImageToImageFilterISSRTD33IUC3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IUC3_SetDirectionTolerance, None, itkImageToImageFilterISSRTD33IUC3)
itkImageToImageFilterISSRTD33IUC3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IUC3_GetDirectionTolerance, None, itkImageToImageFilterISSRTD33IUC3)
itkImageToImageFilterISSRTD33IUC3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IUC3_swigregister
itkImageToImageFilterISSRTD33IUC3_swigregister(itkImageToImageFilterISSRTD33IUC3)

def itkImageToImageFilterISSRTD33IUC3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterISSRTD33IUC3 *":
    """itkImageToImageFilterISSRTD33IUC3_cast(itkLightObject obj) -> itkImageToImageFilterISSRTD33IUC3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IUC3_cast(obj)

class itkImageToImageFilterISSRTD33IUS3(itkImageSourcePython.itkImageSourceIUS3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterISSRTD33IUS3 self, itkImageSSRTD33 image)
        SetInput(itkImageToImageFilterISSRTD33IUS3 self, unsigned int arg0, itkImageSSRTD33 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IUS3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageSSRTD33 const *":
        """
        GetInput(itkImageToImageFilterISSRTD33IUS3 self) -> itkImageSSRTD33
        GetInput(itkImageToImageFilterISSRTD33IUS3 self, unsigned int idx) -> itkImageSSRTD33
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IUS3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageSSRTD33') -> "void":
        """
        PushBackInput(itkImageToImageFilterISSRTD33IUS3 self, itkImageSSRTD33 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IUS3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterISSRTD33IUS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IUS3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageSSRTD33') -> "void":
        """PushFrontInput(itkImageToImageFilterISSRTD33IUS3 self, itkImageSSRTD33 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IUS3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterISSRTD33IUS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IUS3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterISSRTD33IUS3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IUS3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterISSRTD33IUS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IUS3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterISSRTD33IUS3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IUS3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterISSRTD33IUS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IUS3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterISSRTD33IUS3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterISSRTD33IUS3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterISSRTD33IUS3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IUS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterISSRTD33IUS3

        Create a new object of the class itkImageToImageFilterISSRTD33IUS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterISSRTD33IUS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterISSRTD33IUS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterISSRTD33IUS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterISSRTD33IUS3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IUS3_SetInput, None, itkImageToImageFilterISSRTD33IUS3)
itkImageToImageFilterISSRTD33IUS3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IUS3_GetInput, None, itkImageToImageFilterISSRTD33IUS3)
itkImageToImageFilterISSRTD33IUS3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IUS3_PushBackInput, None, itkImageToImageFilterISSRTD33IUS3)
itkImageToImageFilterISSRTD33IUS3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IUS3_PopBackInput, None, itkImageToImageFilterISSRTD33IUS3)
itkImageToImageFilterISSRTD33IUS3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IUS3_PushFrontInput, None, itkImageToImageFilterISSRTD33IUS3)
itkImageToImageFilterISSRTD33IUS3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IUS3_PopFrontInput, None, itkImageToImageFilterISSRTD33IUS3)
itkImageToImageFilterISSRTD33IUS3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IUS3_SetCoordinateTolerance, None, itkImageToImageFilterISSRTD33IUS3)
itkImageToImageFilterISSRTD33IUS3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IUS3_GetCoordinateTolerance, None, itkImageToImageFilterISSRTD33IUS3)
itkImageToImageFilterISSRTD33IUS3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IUS3_SetDirectionTolerance, None, itkImageToImageFilterISSRTD33IUS3)
itkImageToImageFilterISSRTD33IUS3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IUS3_GetDirectionTolerance, None, itkImageToImageFilterISSRTD33IUS3)
itkImageToImageFilterISSRTD33IUS3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IUS3_swigregister
itkImageToImageFilterISSRTD33IUS3_swigregister(itkImageToImageFilterISSRTD33IUS3)

def itkImageToImageFilterISSRTD33IUS3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterISSRTD33IUS3 *":
    """itkImageToImageFilterISSRTD33IUS3_cast(itkLightObject obj) -> itkImageToImageFilterISSRTD33IUS3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterISSRTD33IUS3_cast(obj)

class itkImageToImageFilterIUC2ICF2(itkImageSourcePython.itkImageSourceICF2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUC2ICF2 self, itkImageUC2 image)
        SetInput(itkImageToImageFilterIUC2ICF2 self, unsigned int arg0, itkImageUC2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICF2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUC2 const *":
        """
        GetInput(itkImageToImageFilterIUC2ICF2 self) -> itkImageUC2
        GetInput(itkImageToImageFilterIUC2ICF2 self, unsigned int idx) -> itkImageUC2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICF2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUC2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUC2ICF2 self, itkImageUC2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICF2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUC2ICF2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICF2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUC2') -> "void":
        """PushFrontInput(itkImageToImageFilterIUC2ICF2 self, itkImageUC2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICF2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUC2ICF2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICF2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUC2ICF2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICF2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUC2ICF2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICF2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUC2ICF2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICF2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUC2ICF2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICF2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUC2ICF2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC2ICF2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUC2ICF2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICF2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUC2ICF2

        Create a new object of the class itkImageToImageFilterIUC2ICF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUC2ICF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUC2ICF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUC2ICF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUC2ICF2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICF2_SetInput, None, itkImageToImageFilterIUC2ICF2)
itkImageToImageFilterIUC2ICF2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICF2_GetInput, None, itkImageToImageFilterIUC2ICF2)
itkImageToImageFilterIUC2ICF2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICF2_PushBackInput, None, itkImageToImageFilterIUC2ICF2)
itkImageToImageFilterIUC2ICF2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICF2_PopBackInput, None, itkImageToImageFilterIUC2ICF2)
itkImageToImageFilterIUC2ICF2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICF2_PushFrontInput, None, itkImageToImageFilterIUC2ICF2)
itkImageToImageFilterIUC2ICF2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICF2_PopFrontInput, None, itkImageToImageFilterIUC2ICF2)
itkImageToImageFilterIUC2ICF2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICF2_SetCoordinateTolerance, None, itkImageToImageFilterIUC2ICF2)
itkImageToImageFilterIUC2ICF2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICF2_GetCoordinateTolerance, None, itkImageToImageFilterIUC2ICF2)
itkImageToImageFilterIUC2ICF2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICF2_SetDirectionTolerance, None, itkImageToImageFilterIUC2ICF2)
itkImageToImageFilterIUC2ICF2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICF2_GetDirectionTolerance, None, itkImageToImageFilterIUC2ICF2)
itkImageToImageFilterIUC2ICF2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICF2_swigregister
itkImageToImageFilterIUC2ICF2_swigregister(itkImageToImageFilterIUC2ICF2)

def itkImageToImageFilterIUC2ICF2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC2ICF2 *":
    """itkImageToImageFilterIUC2ICF2_cast(itkLightObject obj) -> itkImageToImageFilterIUC2ICF2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICF2_cast(obj)

class itkImageToImageFilterIUC2ICVF22(itkImageSourcePython.itkImageSourceICVF22):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUC2ICVF22 self, itkImageUC2 image)
        SetInput(itkImageToImageFilterIUC2ICVF22 self, unsigned int arg0, itkImageUC2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF22_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUC2 const *":
        """
        GetInput(itkImageToImageFilterIUC2ICVF22 self) -> itkImageUC2
        GetInput(itkImageToImageFilterIUC2ICVF22 self, unsigned int idx) -> itkImageUC2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF22_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUC2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUC2ICVF22 self, itkImageUC2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF22_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUC2ICVF22 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF22_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUC2') -> "void":
        """PushFrontInput(itkImageToImageFilterIUC2ICVF22 self, itkImageUC2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF22_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUC2ICVF22 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF22_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUC2ICVF22 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF22_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUC2ICVF22 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF22_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUC2ICVF22 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF22_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUC2ICVF22 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF22_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUC2ICVF22

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC2ICVF22 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUC2ICVF22"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF22_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUC2ICVF22

        Create a new object of the class itkImageToImageFilterIUC2ICVF22 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUC2ICVF22.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUC2ICVF22.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUC2ICVF22.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUC2ICVF22.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF22_SetInput, None, itkImageToImageFilterIUC2ICVF22)
itkImageToImageFilterIUC2ICVF22.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF22_GetInput, None, itkImageToImageFilterIUC2ICVF22)
itkImageToImageFilterIUC2ICVF22.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF22_PushBackInput, None, itkImageToImageFilterIUC2ICVF22)
itkImageToImageFilterIUC2ICVF22.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF22_PopBackInput, None, itkImageToImageFilterIUC2ICVF22)
itkImageToImageFilterIUC2ICVF22.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF22_PushFrontInput, None, itkImageToImageFilterIUC2ICVF22)
itkImageToImageFilterIUC2ICVF22.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF22_PopFrontInput, None, itkImageToImageFilterIUC2ICVF22)
itkImageToImageFilterIUC2ICVF22.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF22_SetCoordinateTolerance, None, itkImageToImageFilterIUC2ICVF22)
itkImageToImageFilterIUC2ICVF22.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF22_GetCoordinateTolerance, None, itkImageToImageFilterIUC2ICVF22)
itkImageToImageFilterIUC2ICVF22.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF22_SetDirectionTolerance, None, itkImageToImageFilterIUC2ICVF22)
itkImageToImageFilterIUC2ICVF22.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF22_GetDirectionTolerance, None, itkImageToImageFilterIUC2ICVF22)
itkImageToImageFilterIUC2ICVF22_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF22_swigregister
itkImageToImageFilterIUC2ICVF22_swigregister(itkImageToImageFilterIUC2ICVF22)

def itkImageToImageFilterIUC2ICVF22_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC2ICVF22 *":
    """itkImageToImageFilterIUC2ICVF22_cast(itkLightObject obj) -> itkImageToImageFilterIUC2ICVF22"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF22_cast(obj)

class itkImageToImageFilterIUC2ICVF32(itkImageSourcePython.itkImageSourceICVF32):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUC2ICVF32 self, itkImageUC2 image)
        SetInput(itkImageToImageFilterIUC2ICVF32 self, unsigned int arg0, itkImageUC2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF32_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUC2 const *":
        """
        GetInput(itkImageToImageFilterIUC2ICVF32 self) -> itkImageUC2
        GetInput(itkImageToImageFilterIUC2ICVF32 self, unsigned int idx) -> itkImageUC2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF32_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUC2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUC2ICVF32 self, itkImageUC2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF32_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUC2ICVF32 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF32_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUC2') -> "void":
        """PushFrontInput(itkImageToImageFilterIUC2ICVF32 self, itkImageUC2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF32_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUC2ICVF32 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF32_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUC2ICVF32 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF32_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUC2ICVF32 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF32_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUC2ICVF32 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF32_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUC2ICVF32 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF32_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUC2ICVF32

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC2ICVF32 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUC2ICVF32"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF32_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUC2ICVF32

        Create a new object of the class itkImageToImageFilterIUC2ICVF32 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUC2ICVF32.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUC2ICVF32.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUC2ICVF32.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUC2ICVF32.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF32_SetInput, None, itkImageToImageFilterIUC2ICVF32)
itkImageToImageFilterIUC2ICVF32.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF32_GetInput, None, itkImageToImageFilterIUC2ICVF32)
itkImageToImageFilterIUC2ICVF32.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF32_PushBackInput, None, itkImageToImageFilterIUC2ICVF32)
itkImageToImageFilterIUC2ICVF32.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF32_PopBackInput, None, itkImageToImageFilterIUC2ICVF32)
itkImageToImageFilterIUC2ICVF32.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF32_PushFrontInput, None, itkImageToImageFilterIUC2ICVF32)
itkImageToImageFilterIUC2ICVF32.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF32_PopFrontInput, None, itkImageToImageFilterIUC2ICVF32)
itkImageToImageFilterIUC2ICVF32.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF32_SetCoordinateTolerance, None, itkImageToImageFilterIUC2ICVF32)
itkImageToImageFilterIUC2ICVF32.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF32_GetCoordinateTolerance, None, itkImageToImageFilterIUC2ICVF32)
itkImageToImageFilterIUC2ICVF32.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF32_SetDirectionTolerance, None, itkImageToImageFilterIUC2ICVF32)
itkImageToImageFilterIUC2ICVF32.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF32_GetDirectionTolerance, None, itkImageToImageFilterIUC2ICVF32)
itkImageToImageFilterIUC2ICVF32_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF32_swigregister
itkImageToImageFilterIUC2ICVF32_swigregister(itkImageToImageFilterIUC2ICVF32)

def itkImageToImageFilterIUC2ICVF32_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC2ICVF32 *":
    """itkImageToImageFilterIUC2ICVF32_cast(itkLightObject obj) -> itkImageToImageFilterIUC2ICVF32"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF32_cast(obj)

class itkImageToImageFilterIUC2ICVF42(itkImageSourcePython.itkImageSourceICVF42):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUC2ICVF42 self, itkImageUC2 image)
        SetInput(itkImageToImageFilterIUC2ICVF42 self, unsigned int arg0, itkImageUC2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF42_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUC2 const *":
        """
        GetInput(itkImageToImageFilterIUC2ICVF42 self) -> itkImageUC2
        GetInput(itkImageToImageFilterIUC2ICVF42 self, unsigned int idx) -> itkImageUC2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF42_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUC2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUC2ICVF42 self, itkImageUC2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF42_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUC2ICVF42 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF42_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUC2') -> "void":
        """PushFrontInput(itkImageToImageFilterIUC2ICVF42 self, itkImageUC2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF42_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUC2ICVF42 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF42_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUC2ICVF42 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF42_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUC2ICVF42 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF42_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUC2ICVF42 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF42_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUC2ICVF42 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF42_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUC2ICVF42

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC2ICVF42 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUC2ICVF42"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF42_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUC2ICVF42

        Create a new object of the class itkImageToImageFilterIUC2ICVF42 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUC2ICVF42.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUC2ICVF42.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUC2ICVF42.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUC2ICVF42.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF42_SetInput, None, itkImageToImageFilterIUC2ICVF42)
itkImageToImageFilterIUC2ICVF42.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF42_GetInput, None, itkImageToImageFilterIUC2ICVF42)
itkImageToImageFilterIUC2ICVF42.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF42_PushBackInput, None, itkImageToImageFilterIUC2ICVF42)
itkImageToImageFilterIUC2ICVF42.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF42_PopBackInput, None, itkImageToImageFilterIUC2ICVF42)
itkImageToImageFilterIUC2ICVF42.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF42_PushFrontInput, None, itkImageToImageFilterIUC2ICVF42)
itkImageToImageFilterIUC2ICVF42.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF42_PopFrontInput, None, itkImageToImageFilterIUC2ICVF42)
itkImageToImageFilterIUC2ICVF42.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF42_SetCoordinateTolerance, None, itkImageToImageFilterIUC2ICVF42)
itkImageToImageFilterIUC2ICVF42.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF42_GetCoordinateTolerance, None, itkImageToImageFilterIUC2ICVF42)
itkImageToImageFilterIUC2ICVF42.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF42_SetDirectionTolerance, None, itkImageToImageFilterIUC2ICVF42)
itkImageToImageFilterIUC2ICVF42.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF42_GetDirectionTolerance, None, itkImageToImageFilterIUC2ICVF42)
itkImageToImageFilterIUC2ICVF42_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF42_swigregister
itkImageToImageFilterIUC2ICVF42_swigregister(itkImageToImageFilterIUC2ICVF42)

def itkImageToImageFilterIUC2ICVF42_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC2ICVF42 *":
    """itkImageToImageFilterIUC2ICVF42_cast(itkLightObject obj) -> itkImageToImageFilterIUC2ICVF42"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ICVF42_cast(obj)

class itkImageToImageFilterIUC2IRGBAUC2(itkImageSourcePython.itkImageSourceIRGBAUC2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUC2IRGBAUC2 self, itkImageUC2 image)
        SetInput(itkImageToImageFilterIUC2IRGBAUC2 self, unsigned int arg0, itkImageUC2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IRGBAUC2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUC2 const *":
        """
        GetInput(itkImageToImageFilterIUC2IRGBAUC2 self) -> itkImageUC2
        GetInput(itkImageToImageFilterIUC2IRGBAUC2 self, unsigned int idx) -> itkImageUC2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IRGBAUC2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUC2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUC2IRGBAUC2 self, itkImageUC2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IRGBAUC2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUC2IRGBAUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IRGBAUC2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUC2') -> "void":
        """PushFrontInput(itkImageToImageFilterIUC2IRGBAUC2 self, itkImageUC2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IRGBAUC2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUC2IRGBAUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IRGBAUC2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUC2IRGBAUC2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IRGBAUC2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUC2IRGBAUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IRGBAUC2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUC2IRGBAUC2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IRGBAUC2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUC2IRGBAUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IRGBAUC2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUC2IRGBAUC2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC2IRGBAUC2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUC2IRGBAUC2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IRGBAUC2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUC2IRGBAUC2

        Create a new object of the class itkImageToImageFilterIUC2IRGBAUC2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUC2IRGBAUC2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUC2IRGBAUC2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUC2IRGBAUC2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUC2IRGBAUC2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2IRGBAUC2_SetInput, None, itkImageToImageFilterIUC2IRGBAUC2)
itkImageToImageFilterIUC2IRGBAUC2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2IRGBAUC2_GetInput, None, itkImageToImageFilterIUC2IRGBAUC2)
itkImageToImageFilterIUC2IRGBAUC2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2IRGBAUC2_PushBackInput, None, itkImageToImageFilterIUC2IRGBAUC2)
itkImageToImageFilterIUC2IRGBAUC2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2IRGBAUC2_PopBackInput, None, itkImageToImageFilterIUC2IRGBAUC2)
itkImageToImageFilterIUC2IRGBAUC2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2IRGBAUC2_PushFrontInput, None, itkImageToImageFilterIUC2IRGBAUC2)
itkImageToImageFilterIUC2IRGBAUC2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2IRGBAUC2_PopFrontInput, None, itkImageToImageFilterIUC2IRGBAUC2)
itkImageToImageFilterIUC2IRGBAUC2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2IRGBAUC2_SetCoordinateTolerance, None, itkImageToImageFilterIUC2IRGBAUC2)
itkImageToImageFilterIUC2IRGBAUC2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2IRGBAUC2_GetCoordinateTolerance, None, itkImageToImageFilterIUC2IRGBAUC2)
itkImageToImageFilterIUC2IRGBAUC2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2IRGBAUC2_SetDirectionTolerance, None, itkImageToImageFilterIUC2IRGBAUC2)
itkImageToImageFilterIUC2IRGBAUC2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2IRGBAUC2_GetDirectionTolerance, None, itkImageToImageFilterIUC2IRGBAUC2)
itkImageToImageFilterIUC2IRGBAUC2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IRGBAUC2_swigregister
itkImageToImageFilterIUC2IRGBAUC2_swigregister(itkImageToImageFilterIUC2IRGBAUC2)

def itkImageToImageFilterIUC2IRGBAUC2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC2IRGBAUC2 *":
    """itkImageToImageFilterIUC2IRGBAUC2_cast(itkLightObject obj) -> itkImageToImageFilterIUC2IRGBAUC2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IRGBAUC2_cast(obj)

class itkImageToImageFilterIUC2IRGBUC2(itkImageSourcePython.itkImageSourceIRGBUC2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUC2IRGBUC2 self, itkImageUC2 image)
        SetInput(itkImageToImageFilterIUC2IRGBUC2 self, unsigned int arg0, itkImageUC2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IRGBUC2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUC2 const *":
        """
        GetInput(itkImageToImageFilterIUC2IRGBUC2 self) -> itkImageUC2
        GetInput(itkImageToImageFilterIUC2IRGBUC2 self, unsigned int idx) -> itkImageUC2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IRGBUC2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUC2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUC2IRGBUC2 self, itkImageUC2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IRGBUC2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUC2IRGBUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IRGBUC2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUC2') -> "void":
        """PushFrontInput(itkImageToImageFilterIUC2IRGBUC2 self, itkImageUC2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IRGBUC2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUC2IRGBUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IRGBUC2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUC2IRGBUC2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IRGBUC2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUC2IRGBUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IRGBUC2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUC2IRGBUC2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IRGBUC2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUC2IRGBUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IRGBUC2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUC2IRGBUC2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC2IRGBUC2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUC2IRGBUC2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IRGBUC2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUC2IRGBUC2

        Create a new object of the class itkImageToImageFilterIUC2IRGBUC2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUC2IRGBUC2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUC2IRGBUC2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUC2IRGBUC2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUC2IRGBUC2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2IRGBUC2_SetInput, None, itkImageToImageFilterIUC2IRGBUC2)
itkImageToImageFilterIUC2IRGBUC2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2IRGBUC2_GetInput, None, itkImageToImageFilterIUC2IRGBUC2)
itkImageToImageFilterIUC2IRGBUC2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2IRGBUC2_PushBackInput, None, itkImageToImageFilterIUC2IRGBUC2)
itkImageToImageFilterIUC2IRGBUC2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2IRGBUC2_PopBackInput, None, itkImageToImageFilterIUC2IRGBUC2)
itkImageToImageFilterIUC2IRGBUC2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2IRGBUC2_PushFrontInput, None, itkImageToImageFilterIUC2IRGBUC2)
itkImageToImageFilterIUC2IRGBUC2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2IRGBUC2_PopFrontInput, None, itkImageToImageFilterIUC2IRGBUC2)
itkImageToImageFilterIUC2IRGBUC2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2IRGBUC2_SetCoordinateTolerance, None, itkImageToImageFilterIUC2IRGBUC2)
itkImageToImageFilterIUC2IRGBUC2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2IRGBUC2_GetCoordinateTolerance, None, itkImageToImageFilterIUC2IRGBUC2)
itkImageToImageFilterIUC2IRGBUC2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2IRGBUC2_SetDirectionTolerance, None, itkImageToImageFilterIUC2IRGBUC2)
itkImageToImageFilterIUC2IRGBUC2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2IRGBUC2_GetDirectionTolerance, None, itkImageToImageFilterIUC2IRGBUC2)
itkImageToImageFilterIUC2IRGBUC2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IRGBUC2_swigregister
itkImageToImageFilterIUC2IRGBUC2_swigregister(itkImageToImageFilterIUC2IRGBUC2)

def itkImageToImageFilterIUC2IRGBUC2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC2IRGBUC2 *":
    """itkImageToImageFilterIUC2IRGBUC2_cast(itkLightObject obj) -> itkImageToImageFilterIUC2IRGBUC2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IRGBUC2_cast(obj)

class itkImageToImageFilterIUC2ISSRTD22(itkImageSourcePython.itkImageSourceISSRTD22):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUC2ISSRTD22 self, itkImageUC2 image)
        SetInput(itkImageToImageFilterIUC2ISSRTD22 self, unsigned int arg0, itkImageUC2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ISSRTD22_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUC2 const *":
        """
        GetInput(itkImageToImageFilterIUC2ISSRTD22 self) -> itkImageUC2
        GetInput(itkImageToImageFilterIUC2ISSRTD22 self, unsigned int idx) -> itkImageUC2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ISSRTD22_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUC2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUC2ISSRTD22 self, itkImageUC2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ISSRTD22_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUC2ISSRTD22 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ISSRTD22_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUC2') -> "void":
        """PushFrontInput(itkImageToImageFilterIUC2ISSRTD22 self, itkImageUC2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ISSRTD22_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUC2ISSRTD22 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ISSRTD22_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUC2ISSRTD22 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ISSRTD22_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUC2ISSRTD22 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ISSRTD22_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUC2ISSRTD22 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ISSRTD22_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUC2ISSRTD22 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ISSRTD22_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUC2ISSRTD22

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC2ISSRTD22 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUC2ISSRTD22"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ISSRTD22_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUC2ISSRTD22

        Create a new object of the class itkImageToImageFilterIUC2ISSRTD22 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUC2ISSRTD22.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUC2ISSRTD22.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUC2ISSRTD22.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUC2ISSRTD22.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2ISSRTD22_SetInput, None, itkImageToImageFilterIUC2ISSRTD22)
itkImageToImageFilterIUC2ISSRTD22.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2ISSRTD22_GetInput, None, itkImageToImageFilterIUC2ISSRTD22)
itkImageToImageFilterIUC2ISSRTD22.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2ISSRTD22_PushBackInput, None, itkImageToImageFilterIUC2ISSRTD22)
itkImageToImageFilterIUC2ISSRTD22.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2ISSRTD22_PopBackInput, None, itkImageToImageFilterIUC2ISSRTD22)
itkImageToImageFilterIUC2ISSRTD22.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2ISSRTD22_PushFrontInput, None, itkImageToImageFilterIUC2ISSRTD22)
itkImageToImageFilterIUC2ISSRTD22.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2ISSRTD22_PopFrontInput, None, itkImageToImageFilterIUC2ISSRTD22)
itkImageToImageFilterIUC2ISSRTD22.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2ISSRTD22_SetCoordinateTolerance, None, itkImageToImageFilterIUC2ISSRTD22)
itkImageToImageFilterIUC2ISSRTD22.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2ISSRTD22_GetCoordinateTolerance, None, itkImageToImageFilterIUC2ISSRTD22)
itkImageToImageFilterIUC2ISSRTD22.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2ISSRTD22_SetDirectionTolerance, None, itkImageToImageFilterIUC2ISSRTD22)
itkImageToImageFilterIUC2ISSRTD22.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2ISSRTD22_GetDirectionTolerance, None, itkImageToImageFilterIUC2ISSRTD22)
itkImageToImageFilterIUC2ISSRTD22_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ISSRTD22_swigregister
itkImageToImageFilterIUC2ISSRTD22_swigregister(itkImageToImageFilterIUC2ISSRTD22)

def itkImageToImageFilterIUC2ISSRTD22_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC2ISSRTD22 *":
    """itkImageToImageFilterIUC2ISSRTD22_cast(itkLightObject obj) -> itkImageToImageFilterIUC2ISSRTD22"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2ISSRTD22_cast(obj)

class itkImageToImageFilterIUC2IUC3(itkImageSourcePython.itkImageSourceIUC3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUC2IUC3 self, itkImageUC2 image)
        SetInput(itkImageToImageFilterIUC2IUC3 self, unsigned int arg0, itkImageUC2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IUC3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUC2 const *":
        """
        GetInput(itkImageToImageFilterIUC2IUC3 self) -> itkImageUC2
        GetInput(itkImageToImageFilterIUC2IUC3 self, unsigned int idx) -> itkImageUC2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IUC3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUC2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUC2IUC3 self, itkImageUC2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IUC3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUC2IUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IUC3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUC2') -> "void":
        """PushFrontInput(itkImageToImageFilterIUC2IUC3 self, itkImageUC2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IUC3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUC2IUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IUC3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUC2IUC3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IUC3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUC2IUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IUC3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUC2IUC3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IUC3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUC2IUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IUC3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUC2IUC3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC2IUC3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUC2IUC3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IUC3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUC2IUC3

        Create a new object of the class itkImageToImageFilterIUC2IUC3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUC2IUC3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUC2IUC3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUC2IUC3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUC2IUC3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2IUC3_SetInput, None, itkImageToImageFilterIUC2IUC3)
itkImageToImageFilterIUC2IUC3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2IUC3_GetInput, None, itkImageToImageFilterIUC2IUC3)
itkImageToImageFilterIUC2IUC3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2IUC3_PushBackInput, None, itkImageToImageFilterIUC2IUC3)
itkImageToImageFilterIUC2IUC3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2IUC3_PopBackInput, None, itkImageToImageFilterIUC2IUC3)
itkImageToImageFilterIUC2IUC3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2IUC3_PushFrontInput, None, itkImageToImageFilterIUC2IUC3)
itkImageToImageFilterIUC2IUC3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2IUC3_PopFrontInput, None, itkImageToImageFilterIUC2IUC3)
itkImageToImageFilterIUC2IUC3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2IUC3_SetCoordinateTolerance, None, itkImageToImageFilterIUC2IUC3)
itkImageToImageFilterIUC2IUC3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2IUC3_GetCoordinateTolerance, None, itkImageToImageFilterIUC2IUC3)
itkImageToImageFilterIUC2IUC3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2IUC3_SetDirectionTolerance, None, itkImageToImageFilterIUC2IUC3)
itkImageToImageFilterIUC2IUC3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2IUC3_GetDirectionTolerance, None, itkImageToImageFilterIUC2IUC3)
itkImageToImageFilterIUC2IUC3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IUC3_swigregister
itkImageToImageFilterIUC2IUC3_swigregister(itkImageToImageFilterIUC2IUC3)

def itkImageToImageFilterIUC2IUC3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC2IUC3 *":
    """itkImageToImageFilterIUC2IUC3_cast(itkLightObject obj) -> itkImageToImageFilterIUC2IUC3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IUC3_cast(obj)

class itkImageToImageFilterIUC2IVF22(itkImageSourcePython.itkImageSourceIVF22):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUC2IVF22 self, itkImageUC2 image)
        SetInput(itkImageToImageFilterIUC2IVF22 self, unsigned int arg0, itkImageUC2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF22_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUC2 const *":
        """
        GetInput(itkImageToImageFilterIUC2IVF22 self) -> itkImageUC2
        GetInput(itkImageToImageFilterIUC2IVF22 self, unsigned int idx) -> itkImageUC2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF22_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUC2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUC2IVF22 self, itkImageUC2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF22_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUC2IVF22 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF22_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUC2') -> "void":
        """PushFrontInput(itkImageToImageFilterIUC2IVF22 self, itkImageUC2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF22_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUC2IVF22 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF22_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUC2IVF22 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF22_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUC2IVF22 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF22_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUC2IVF22 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF22_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUC2IVF22 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF22_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUC2IVF22

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC2IVF22 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUC2IVF22"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF22_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUC2IVF22

        Create a new object of the class itkImageToImageFilterIUC2IVF22 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUC2IVF22.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUC2IVF22.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUC2IVF22.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUC2IVF22.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF22_SetInput, None, itkImageToImageFilterIUC2IVF22)
itkImageToImageFilterIUC2IVF22.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF22_GetInput, None, itkImageToImageFilterIUC2IVF22)
itkImageToImageFilterIUC2IVF22.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF22_PushBackInput, None, itkImageToImageFilterIUC2IVF22)
itkImageToImageFilterIUC2IVF22.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF22_PopBackInput, None, itkImageToImageFilterIUC2IVF22)
itkImageToImageFilterIUC2IVF22.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF22_PushFrontInput, None, itkImageToImageFilterIUC2IVF22)
itkImageToImageFilterIUC2IVF22.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF22_PopFrontInput, None, itkImageToImageFilterIUC2IVF22)
itkImageToImageFilterIUC2IVF22.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF22_SetCoordinateTolerance, None, itkImageToImageFilterIUC2IVF22)
itkImageToImageFilterIUC2IVF22.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF22_GetCoordinateTolerance, None, itkImageToImageFilterIUC2IVF22)
itkImageToImageFilterIUC2IVF22.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF22_SetDirectionTolerance, None, itkImageToImageFilterIUC2IVF22)
itkImageToImageFilterIUC2IVF22.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF22_GetDirectionTolerance, None, itkImageToImageFilterIUC2IVF22)
itkImageToImageFilterIUC2IVF22_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF22_swigregister
itkImageToImageFilterIUC2IVF22_swigregister(itkImageToImageFilterIUC2IVF22)

def itkImageToImageFilterIUC2IVF22_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC2IVF22 *":
    """itkImageToImageFilterIUC2IVF22_cast(itkLightObject obj) -> itkImageToImageFilterIUC2IVF22"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF22_cast(obj)

class itkImageToImageFilterIUC2IVF32(itkImageSourcePython.itkImageSourceIVF32):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUC2IVF32 self, itkImageUC2 image)
        SetInput(itkImageToImageFilterIUC2IVF32 self, unsigned int arg0, itkImageUC2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF32_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUC2 const *":
        """
        GetInput(itkImageToImageFilterIUC2IVF32 self) -> itkImageUC2
        GetInput(itkImageToImageFilterIUC2IVF32 self, unsigned int idx) -> itkImageUC2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF32_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUC2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUC2IVF32 self, itkImageUC2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF32_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUC2IVF32 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF32_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUC2') -> "void":
        """PushFrontInput(itkImageToImageFilterIUC2IVF32 self, itkImageUC2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF32_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUC2IVF32 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF32_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUC2IVF32 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF32_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUC2IVF32 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF32_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUC2IVF32 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF32_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUC2IVF32 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF32_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUC2IVF32

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC2IVF32 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUC2IVF32"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF32_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUC2IVF32

        Create a new object of the class itkImageToImageFilterIUC2IVF32 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUC2IVF32.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUC2IVF32.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUC2IVF32.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUC2IVF32.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF32_SetInput, None, itkImageToImageFilterIUC2IVF32)
itkImageToImageFilterIUC2IVF32.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF32_GetInput, None, itkImageToImageFilterIUC2IVF32)
itkImageToImageFilterIUC2IVF32.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF32_PushBackInput, None, itkImageToImageFilterIUC2IVF32)
itkImageToImageFilterIUC2IVF32.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF32_PopBackInput, None, itkImageToImageFilterIUC2IVF32)
itkImageToImageFilterIUC2IVF32.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF32_PushFrontInput, None, itkImageToImageFilterIUC2IVF32)
itkImageToImageFilterIUC2IVF32.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF32_PopFrontInput, None, itkImageToImageFilterIUC2IVF32)
itkImageToImageFilterIUC2IVF32.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF32_SetCoordinateTolerance, None, itkImageToImageFilterIUC2IVF32)
itkImageToImageFilterIUC2IVF32.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF32_GetCoordinateTolerance, None, itkImageToImageFilterIUC2IVF32)
itkImageToImageFilterIUC2IVF32.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF32_SetDirectionTolerance, None, itkImageToImageFilterIUC2IVF32)
itkImageToImageFilterIUC2IVF32.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF32_GetDirectionTolerance, None, itkImageToImageFilterIUC2IVF32)
itkImageToImageFilterIUC2IVF32_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF32_swigregister
itkImageToImageFilterIUC2IVF32_swigregister(itkImageToImageFilterIUC2IVF32)

def itkImageToImageFilterIUC2IVF32_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC2IVF32 *":
    """itkImageToImageFilterIUC2IVF32_cast(itkLightObject obj) -> itkImageToImageFilterIUC2IVF32"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF32_cast(obj)

class itkImageToImageFilterIUC2IVF42(itkImageSourcePython.itkImageSourceIVF42):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUC2IVF42 self, itkImageUC2 image)
        SetInput(itkImageToImageFilterIUC2IVF42 self, unsigned int arg0, itkImageUC2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF42_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUC2 const *":
        """
        GetInput(itkImageToImageFilterIUC2IVF42 self) -> itkImageUC2
        GetInput(itkImageToImageFilterIUC2IVF42 self, unsigned int idx) -> itkImageUC2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF42_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUC2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUC2IVF42 self, itkImageUC2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF42_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUC2IVF42 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF42_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUC2') -> "void":
        """PushFrontInput(itkImageToImageFilterIUC2IVF42 self, itkImageUC2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF42_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUC2IVF42 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF42_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUC2IVF42 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF42_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUC2IVF42 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF42_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUC2IVF42 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF42_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUC2IVF42 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF42_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUC2IVF42

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC2IVF42 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUC2IVF42"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF42_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUC2IVF42

        Create a new object of the class itkImageToImageFilterIUC2IVF42 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUC2IVF42.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUC2IVF42.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUC2IVF42.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUC2IVF42.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF42_SetInput, None, itkImageToImageFilterIUC2IVF42)
itkImageToImageFilterIUC2IVF42.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF42_GetInput, None, itkImageToImageFilterIUC2IVF42)
itkImageToImageFilterIUC2IVF42.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF42_PushBackInput, None, itkImageToImageFilterIUC2IVF42)
itkImageToImageFilterIUC2IVF42.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF42_PopBackInput, None, itkImageToImageFilterIUC2IVF42)
itkImageToImageFilterIUC2IVF42.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF42_PushFrontInput, None, itkImageToImageFilterIUC2IVF42)
itkImageToImageFilterIUC2IVF42.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF42_PopFrontInput, None, itkImageToImageFilterIUC2IVF42)
itkImageToImageFilterIUC2IVF42.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF42_SetCoordinateTolerance, None, itkImageToImageFilterIUC2IVF42)
itkImageToImageFilterIUC2IVF42.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF42_GetCoordinateTolerance, None, itkImageToImageFilterIUC2IVF42)
itkImageToImageFilterIUC2IVF42.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF42_SetDirectionTolerance, None, itkImageToImageFilterIUC2IVF42)
itkImageToImageFilterIUC2IVF42.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF42_GetDirectionTolerance, None, itkImageToImageFilterIUC2IVF42)
itkImageToImageFilterIUC2IVF42_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF42_swigregister
itkImageToImageFilterIUC2IVF42_swigregister(itkImageToImageFilterIUC2IVF42)

def itkImageToImageFilterIUC2IVF42_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC2IVF42 *":
    """itkImageToImageFilterIUC2IVF42_cast(itkLightObject obj) -> itkImageToImageFilterIUC2IVF42"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2IVF42_cast(obj)

class itkImageToImageFilterIUC2VID2(itkImageSourcePython.itkImageSourceVID2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUC2VID2 self, itkImageUC2 image)
        SetInput(itkImageToImageFilterIUC2VID2 self, unsigned int arg0, itkImageUC2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VID2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUC2 const *":
        """
        GetInput(itkImageToImageFilterIUC2VID2 self) -> itkImageUC2
        GetInput(itkImageToImageFilterIUC2VID2 self, unsigned int idx) -> itkImageUC2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VID2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUC2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUC2VID2 self, itkImageUC2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VID2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUC2VID2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VID2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUC2') -> "void":
        """PushFrontInput(itkImageToImageFilterIUC2VID2 self, itkImageUC2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VID2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUC2VID2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VID2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUC2VID2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VID2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUC2VID2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VID2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUC2VID2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VID2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUC2VID2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VID2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUC2VID2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC2VID2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUC2VID2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VID2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUC2VID2

        Create a new object of the class itkImageToImageFilterIUC2VID2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUC2VID2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUC2VID2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUC2VID2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUC2VID2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2VID2_SetInput, None, itkImageToImageFilterIUC2VID2)
itkImageToImageFilterIUC2VID2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2VID2_GetInput, None, itkImageToImageFilterIUC2VID2)
itkImageToImageFilterIUC2VID2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2VID2_PushBackInput, None, itkImageToImageFilterIUC2VID2)
itkImageToImageFilterIUC2VID2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2VID2_PopBackInput, None, itkImageToImageFilterIUC2VID2)
itkImageToImageFilterIUC2VID2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2VID2_PushFrontInput, None, itkImageToImageFilterIUC2VID2)
itkImageToImageFilterIUC2VID2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2VID2_PopFrontInput, None, itkImageToImageFilterIUC2VID2)
itkImageToImageFilterIUC2VID2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2VID2_SetCoordinateTolerance, None, itkImageToImageFilterIUC2VID2)
itkImageToImageFilterIUC2VID2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2VID2_GetCoordinateTolerance, None, itkImageToImageFilterIUC2VID2)
itkImageToImageFilterIUC2VID2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2VID2_SetDirectionTolerance, None, itkImageToImageFilterIUC2VID2)
itkImageToImageFilterIUC2VID2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2VID2_GetDirectionTolerance, None, itkImageToImageFilterIUC2VID2)
itkImageToImageFilterIUC2VID2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VID2_swigregister
itkImageToImageFilterIUC2VID2_swigregister(itkImageToImageFilterIUC2VID2)

def itkImageToImageFilterIUC2VID2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC2VID2 *":
    """itkImageToImageFilterIUC2VID2_cast(itkLightObject obj) -> itkImageToImageFilterIUC2VID2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VID2_cast(obj)

class itkImageToImageFilterIUC2VIF2(itkImageSourcePython.itkImageSourceVIF2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUC2VIF2 self, itkImageUC2 image)
        SetInput(itkImageToImageFilterIUC2VIF2 self, unsigned int arg0, itkImageUC2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIF2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUC2 const *":
        """
        GetInput(itkImageToImageFilterIUC2VIF2 self) -> itkImageUC2
        GetInput(itkImageToImageFilterIUC2VIF2 self, unsigned int idx) -> itkImageUC2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIF2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUC2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUC2VIF2 self, itkImageUC2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIF2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUC2VIF2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIF2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUC2') -> "void":
        """PushFrontInput(itkImageToImageFilterIUC2VIF2 self, itkImageUC2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIF2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUC2VIF2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIF2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUC2VIF2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIF2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUC2VIF2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIF2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUC2VIF2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIF2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUC2VIF2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIF2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUC2VIF2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC2VIF2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUC2VIF2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIF2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUC2VIF2

        Create a new object of the class itkImageToImageFilterIUC2VIF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUC2VIF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUC2VIF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUC2VIF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUC2VIF2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIF2_SetInput, None, itkImageToImageFilterIUC2VIF2)
itkImageToImageFilterIUC2VIF2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIF2_GetInput, None, itkImageToImageFilterIUC2VIF2)
itkImageToImageFilterIUC2VIF2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIF2_PushBackInput, None, itkImageToImageFilterIUC2VIF2)
itkImageToImageFilterIUC2VIF2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIF2_PopBackInput, None, itkImageToImageFilterIUC2VIF2)
itkImageToImageFilterIUC2VIF2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIF2_PushFrontInput, None, itkImageToImageFilterIUC2VIF2)
itkImageToImageFilterIUC2VIF2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIF2_PopFrontInput, None, itkImageToImageFilterIUC2VIF2)
itkImageToImageFilterIUC2VIF2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIF2_SetCoordinateTolerance, None, itkImageToImageFilterIUC2VIF2)
itkImageToImageFilterIUC2VIF2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIF2_GetCoordinateTolerance, None, itkImageToImageFilterIUC2VIF2)
itkImageToImageFilterIUC2VIF2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIF2_SetDirectionTolerance, None, itkImageToImageFilterIUC2VIF2)
itkImageToImageFilterIUC2VIF2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIF2_GetDirectionTolerance, None, itkImageToImageFilterIUC2VIF2)
itkImageToImageFilterIUC2VIF2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIF2_swigregister
itkImageToImageFilterIUC2VIF2_swigregister(itkImageToImageFilterIUC2VIF2)

def itkImageToImageFilterIUC2VIF2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC2VIF2 *":
    """itkImageToImageFilterIUC2VIF2_cast(itkLightObject obj) -> itkImageToImageFilterIUC2VIF2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIF2_cast(obj)

class itkImageToImageFilterIUC2VISS2(itkImageSourcePython.itkImageSourceVISS2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUC2VISS2 self, itkImageUC2 image)
        SetInput(itkImageToImageFilterIUC2VISS2 self, unsigned int arg0, itkImageUC2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VISS2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUC2 const *":
        """
        GetInput(itkImageToImageFilterIUC2VISS2 self) -> itkImageUC2
        GetInput(itkImageToImageFilterIUC2VISS2 self, unsigned int idx) -> itkImageUC2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VISS2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUC2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUC2VISS2 self, itkImageUC2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VISS2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUC2VISS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VISS2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUC2') -> "void":
        """PushFrontInput(itkImageToImageFilterIUC2VISS2 self, itkImageUC2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VISS2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUC2VISS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VISS2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUC2VISS2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VISS2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUC2VISS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VISS2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUC2VISS2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VISS2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUC2VISS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VISS2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUC2VISS2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC2VISS2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUC2VISS2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VISS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUC2VISS2

        Create a new object of the class itkImageToImageFilterIUC2VISS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUC2VISS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUC2VISS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUC2VISS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUC2VISS2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2VISS2_SetInput, None, itkImageToImageFilterIUC2VISS2)
itkImageToImageFilterIUC2VISS2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2VISS2_GetInput, None, itkImageToImageFilterIUC2VISS2)
itkImageToImageFilterIUC2VISS2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2VISS2_PushBackInput, None, itkImageToImageFilterIUC2VISS2)
itkImageToImageFilterIUC2VISS2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2VISS2_PopBackInput, None, itkImageToImageFilterIUC2VISS2)
itkImageToImageFilterIUC2VISS2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2VISS2_PushFrontInput, None, itkImageToImageFilterIUC2VISS2)
itkImageToImageFilterIUC2VISS2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2VISS2_PopFrontInput, None, itkImageToImageFilterIUC2VISS2)
itkImageToImageFilterIUC2VISS2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2VISS2_SetCoordinateTolerance, None, itkImageToImageFilterIUC2VISS2)
itkImageToImageFilterIUC2VISS2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2VISS2_GetCoordinateTolerance, None, itkImageToImageFilterIUC2VISS2)
itkImageToImageFilterIUC2VISS2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2VISS2_SetDirectionTolerance, None, itkImageToImageFilterIUC2VISS2)
itkImageToImageFilterIUC2VISS2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2VISS2_GetDirectionTolerance, None, itkImageToImageFilterIUC2VISS2)
itkImageToImageFilterIUC2VISS2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VISS2_swigregister
itkImageToImageFilterIUC2VISS2_swigregister(itkImageToImageFilterIUC2VISS2)

def itkImageToImageFilterIUC2VISS2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC2VISS2 *":
    """itkImageToImageFilterIUC2VISS2_cast(itkLightObject obj) -> itkImageToImageFilterIUC2VISS2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VISS2_cast(obj)

class itkImageToImageFilterIUC2VIUC2(itkImageSourcePython.itkImageSourceVIUC2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUC2VIUC2 self, itkImageUC2 image)
        SetInput(itkImageToImageFilterIUC2VIUC2 self, unsigned int arg0, itkImageUC2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIUC2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUC2 const *":
        """
        GetInput(itkImageToImageFilterIUC2VIUC2 self) -> itkImageUC2
        GetInput(itkImageToImageFilterIUC2VIUC2 self, unsigned int idx) -> itkImageUC2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIUC2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUC2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUC2VIUC2 self, itkImageUC2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIUC2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUC2VIUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIUC2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUC2') -> "void":
        """PushFrontInput(itkImageToImageFilterIUC2VIUC2 self, itkImageUC2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIUC2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUC2VIUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIUC2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUC2VIUC2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIUC2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUC2VIUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIUC2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUC2VIUC2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIUC2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUC2VIUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIUC2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUC2VIUC2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC2VIUC2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUC2VIUC2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIUC2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUC2VIUC2

        Create a new object of the class itkImageToImageFilterIUC2VIUC2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUC2VIUC2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUC2VIUC2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUC2VIUC2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUC2VIUC2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIUC2_SetInput, None, itkImageToImageFilterIUC2VIUC2)
itkImageToImageFilterIUC2VIUC2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIUC2_GetInput, None, itkImageToImageFilterIUC2VIUC2)
itkImageToImageFilterIUC2VIUC2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIUC2_PushBackInput, None, itkImageToImageFilterIUC2VIUC2)
itkImageToImageFilterIUC2VIUC2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIUC2_PopBackInput, None, itkImageToImageFilterIUC2VIUC2)
itkImageToImageFilterIUC2VIUC2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIUC2_PushFrontInput, None, itkImageToImageFilterIUC2VIUC2)
itkImageToImageFilterIUC2VIUC2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIUC2_PopFrontInput, None, itkImageToImageFilterIUC2VIUC2)
itkImageToImageFilterIUC2VIUC2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIUC2_SetCoordinateTolerance, None, itkImageToImageFilterIUC2VIUC2)
itkImageToImageFilterIUC2VIUC2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIUC2_GetCoordinateTolerance, None, itkImageToImageFilterIUC2VIUC2)
itkImageToImageFilterIUC2VIUC2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIUC2_SetDirectionTolerance, None, itkImageToImageFilterIUC2VIUC2)
itkImageToImageFilterIUC2VIUC2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIUC2_GetDirectionTolerance, None, itkImageToImageFilterIUC2VIUC2)
itkImageToImageFilterIUC2VIUC2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIUC2_swigregister
itkImageToImageFilterIUC2VIUC2_swigregister(itkImageToImageFilterIUC2VIUC2)

def itkImageToImageFilterIUC2VIUC2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC2VIUC2 *":
    """itkImageToImageFilterIUC2VIUC2_cast(itkLightObject obj) -> itkImageToImageFilterIUC2VIUC2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIUC2_cast(obj)

class itkImageToImageFilterIUC2VIUS2(itkImageSourcePython.itkImageSourceVIUS2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUC2VIUS2 self, itkImageUC2 image)
        SetInput(itkImageToImageFilterIUC2VIUS2 self, unsigned int arg0, itkImageUC2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIUS2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUC2 const *":
        """
        GetInput(itkImageToImageFilterIUC2VIUS2 self) -> itkImageUC2
        GetInput(itkImageToImageFilterIUC2VIUS2 self, unsigned int idx) -> itkImageUC2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIUS2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUC2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUC2VIUS2 self, itkImageUC2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIUS2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUC2VIUS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIUS2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUC2') -> "void":
        """PushFrontInput(itkImageToImageFilterIUC2VIUS2 self, itkImageUC2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIUS2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUC2VIUS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIUS2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUC2VIUS2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIUS2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUC2VIUS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIUS2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUC2VIUS2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIUS2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUC2VIUS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIUS2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUC2VIUS2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC2VIUS2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUC2VIUS2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIUS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUC2VIUS2

        Create a new object of the class itkImageToImageFilterIUC2VIUS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUC2VIUS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUC2VIUS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUC2VIUS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUC2VIUS2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIUS2_SetInput, None, itkImageToImageFilterIUC2VIUS2)
itkImageToImageFilterIUC2VIUS2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIUS2_GetInput, None, itkImageToImageFilterIUC2VIUS2)
itkImageToImageFilterIUC2VIUS2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIUS2_PushBackInput, None, itkImageToImageFilterIUC2VIUS2)
itkImageToImageFilterIUC2VIUS2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIUS2_PopBackInput, None, itkImageToImageFilterIUC2VIUS2)
itkImageToImageFilterIUC2VIUS2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIUS2_PushFrontInput, None, itkImageToImageFilterIUC2VIUS2)
itkImageToImageFilterIUC2VIUS2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIUS2_PopFrontInput, None, itkImageToImageFilterIUC2VIUS2)
itkImageToImageFilterIUC2VIUS2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIUS2_SetCoordinateTolerance, None, itkImageToImageFilterIUC2VIUS2)
itkImageToImageFilterIUC2VIUS2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIUS2_GetCoordinateTolerance, None, itkImageToImageFilterIUC2VIUS2)
itkImageToImageFilterIUC2VIUS2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIUS2_SetDirectionTolerance, None, itkImageToImageFilterIUC2VIUS2)
itkImageToImageFilterIUC2VIUS2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIUS2_GetDirectionTolerance, None, itkImageToImageFilterIUC2VIUS2)
itkImageToImageFilterIUC2VIUS2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIUS2_swigregister
itkImageToImageFilterIUC2VIUS2_swigregister(itkImageToImageFilterIUC2VIUS2)

def itkImageToImageFilterIUC2VIUS2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC2VIUS2 *":
    """itkImageToImageFilterIUC2VIUS2_cast(itkLightObject obj) -> itkImageToImageFilterIUC2VIUS2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUC2VIUS2_cast(obj)

class itkImageToImageFilterIUC3ICF3(itkImageSourcePython.itkImageSourceICF3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUC3ICF3 self, itkImageUC3 image)
        SetInput(itkImageToImageFilterIUC3ICF3 self, unsigned int arg0, itkImageUC3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICF3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUC3 const *":
        """
        GetInput(itkImageToImageFilterIUC3ICF3 self) -> itkImageUC3
        GetInput(itkImageToImageFilterIUC3ICF3 self, unsigned int idx) -> itkImageUC3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICF3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUC3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUC3ICF3 self, itkImageUC3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICF3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUC3ICF3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICF3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUC3') -> "void":
        """PushFrontInput(itkImageToImageFilterIUC3ICF3 self, itkImageUC3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICF3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUC3ICF3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICF3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUC3ICF3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICF3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUC3ICF3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICF3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUC3ICF3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICF3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUC3ICF3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICF3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUC3ICF3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC3ICF3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUC3ICF3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICF3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUC3ICF3

        Create a new object of the class itkImageToImageFilterIUC3ICF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUC3ICF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUC3ICF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUC3ICF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUC3ICF3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICF3_SetInput, None, itkImageToImageFilterIUC3ICF3)
itkImageToImageFilterIUC3ICF3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICF3_GetInput, None, itkImageToImageFilterIUC3ICF3)
itkImageToImageFilterIUC3ICF3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICF3_PushBackInput, None, itkImageToImageFilterIUC3ICF3)
itkImageToImageFilterIUC3ICF3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICF3_PopBackInput, None, itkImageToImageFilterIUC3ICF3)
itkImageToImageFilterIUC3ICF3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICF3_PushFrontInput, None, itkImageToImageFilterIUC3ICF3)
itkImageToImageFilterIUC3ICF3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICF3_PopFrontInput, None, itkImageToImageFilterIUC3ICF3)
itkImageToImageFilterIUC3ICF3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICF3_SetCoordinateTolerance, None, itkImageToImageFilterIUC3ICF3)
itkImageToImageFilterIUC3ICF3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICF3_GetCoordinateTolerance, None, itkImageToImageFilterIUC3ICF3)
itkImageToImageFilterIUC3ICF3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICF3_SetDirectionTolerance, None, itkImageToImageFilterIUC3ICF3)
itkImageToImageFilterIUC3ICF3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICF3_GetDirectionTolerance, None, itkImageToImageFilterIUC3ICF3)
itkImageToImageFilterIUC3ICF3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICF3_swigregister
itkImageToImageFilterIUC3ICF3_swigregister(itkImageToImageFilterIUC3ICF3)

def itkImageToImageFilterIUC3ICF3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC3ICF3 *":
    """itkImageToImageFilterIUC3ICF3_cast(itkLightObject obj) -> itkImageToImageFilterIUC3ICF3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICF3_cast(obj)

class itkImageToImageFilterIUC3ICVF23(itkImageSourcePython.itkImageSourceICVF23):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUC3ICVF23 self, itkImageUC3 image)
        SetInput(itkImageToImageFilterIUC3ICVF23 self, unsigned int arg0, itkImageUC3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF23_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUC3 const *":
        """
        GetInput(itkImageToImageFilterIUC3ICVF23 self) -> itkImageUC3
        GetInput(itkImageToImageFilterIUC3ICVF23 self, unsigned int idx) -> itkImageUC3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF23_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUC3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUC3ICVF23 self, itkImageUC3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF23_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUC3ICVF23 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF23_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUC3') -> "void":
        """PushFrontInput(itkImageToImageFilterIUC3ICVF23 self, itkImageUC3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF23_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUC3ICVF23 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF23_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUC3ICVF23 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF23_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUC3ICVF23 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF23_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUC3ICVF23 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF23_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUC3ICVF23 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF23_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUC3ICVF23

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC3ICVF23 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUC3ICVF23"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF23_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUC3ICVF23

        Create a new object of the class itkImageToImageFilterIUC3ICVF23 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUC3ICVF23.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUC3ICVF23.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUC3ICVF23.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUC3ICVF23.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF23_SetInput, None, itkImageToImageFilterIUC3ICVF23)
itkImageToImageFilterIUC3ICVF23.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF23_GetInput, None, itkImageToImageFilterIUC3ICVF23)
itkImageToImageFilterIUC3ICVF23.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF23_PushBackInput, None, itkImageToImageFilterIUC3ICVF23)
itkImageToImageFilterIUC3ICVF23.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF23_PopBackInput, None, itkImageToImageFilterIUC3ICVF23)
itkImageToImageFilterIUC3ICVF23.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF23_PushFrontInput, None, itkImageToImageFilterIUC3ICVF23)
itkImageToImageFilterIUC3ICVF23.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF23_PopFrontInput, None, itkImageToImageFilterIUC3ICVF23)
itkImageToImageFilterIUC3ICVF23.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF23_SetCoordinateTolerance, None, itkImageToImageFilterIUC3ICVF23)
itkImageToImageFilterIUC3ICVF23.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF23_GetCoordinateTolerance, None, itkImageToImageFilterIUC3ICVF23)
itkImageToImageFilterIUC3ICVF23.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF23_SetDirectionTolerance, None, itkImageToImageFilterIUC3ICVF23)
itkImageToImageFilterIUC3ICVF23.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF23_GetDirectionTolerance, None, itkImageToImageFilterIUC3ICVF23)
itkImageToImageFilterIUC3ICVF23_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF23_swigregister
itkImageToImageFilterIUC3ICVF23_swigregister(itkImageToImageFilterIUC3ICVF23)

def itkImageToImageFilterIUC3ICVF23_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC3ICVF23 *":
    """itkImageToImageFilterIUC3ICVF23_cast(itkLightObject obj) -> itkImageToImageFilterIUC3ICVF23"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF23_cast(obj)

class itkImageToImageFilterIUC3ICVF33(itkImageSourcePython.itkImageSourceICVF33):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUC3ICVF33 self, itkImageUC3 image)
        SetInput(itkImageToImageFilterIUC3ICVF33 self, unsigned int arg0, itkImageUC3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF33_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUC3 const *":
        """
        GetInput(itkImageToImageFilterIUC3ICVF33 self) -> itkImageUC3
        GetInput(itkImageToImageFilterIUC3ICVF33 self, unsigned int idx) -> itkImageUC3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF33_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUC3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUC3ICVF33 self, itkImageUC3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF33_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUC3ICVF33 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF33_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUC3') -> "void":
        """PushFrontInput(itkImageToImageFilterIUC3ICVF33 self, itkImageUC3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF33_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUC3ICVF33 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF33_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUC3ICVF33 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF33_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUC3ICVF33 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF33_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUC3ICVF33 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF33_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUC3ICVF33 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF33_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUC3ICVF33

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC3ICVF33 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUC3ICVF33"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF33_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUC3ICVF33

        Create a new object of the class itkImageToImageFilterIUC3ICVF33 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUC3ICVF33.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUC3ICVF33.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUC3ICVF33.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUC3ICVF33.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF33_SetInput, None, itkImageToImageFilterIUC3ICVF33)
itkImageToImageFilterIUC3ICVF33.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF33_GetInput, None, itkImageToImageFilterIUC3ICVF33)
itkImageToImageFilterIUC3ICVF33.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF33_PushBackInput, None, itkImageToImageFilterIUC3ICVF33)
itkImageToImageFilterIUC3ICVF33.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF33_PopBackInput, None, itkImageToImageFilterIUC3ICVF33)
itkImageToImageFilterIUC3ICVF33.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF33_PushFrontInput, None, itkImageToImageFilterIUC3ICVF33)
itkImageToImageFilterIUC3ICVF33.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF33_PopFrontInput, None, itkImageToImageFilterIUC3ICVF33)
itkImageToImageFilterIUC3ICVF33.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF33_SetCoordinateTolerance, None, itkImageToImageFilterIUC3ICVF33)
itkImageToImageFilterIUC3ICVF33.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF33_GetCoordinateTolerance, None, itkImageToImageFilterIUC3ICVF33)
itkImageToImageFilterIUC3ICVF33.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF33_SetDirectionTolerance, None, itkImageToImageFilterIUC3ICVF33)
itkImageToImageFilterIUC3ICVF33.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF33_GetDirectionTolerance, None, itkImageToImageFilterIUC3ICVF33)
itkImageToImageFilterIUC3ICVF33_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF33_swigregister
itkImageToImageFilterIUC3ICVF33_swigregister(itkImageToImageFilterIUC3ICVF33)

def itkImageToImageFilterIUC3ICVF33_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC3ICVF33 *":
    """itkImageToImageFilterIUC3ICVF33_cast(itkLightObject obj) -> itkImageToImageFilterIUC3ICVF33"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF33_cast(obj)

class itkImageToImageFilterIUC3ICVF43(itkImageSourcePython.itkImageSourceICVF43):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUC3ICVF43 self, itkImageUC3 image)
        SetInput(itkImageToImageFilterIUC3ICVF43 self, unsigned int arg0, itkImageUC3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF43_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUC3 const *":
        """
        GetInput(itkImageToImageFilterIUC3ICVF43 self) -> itkImageUC3
        GetInput(itkImageToImageFilterIUC3ICVF43 self, unsigned int idx) -> itkImageUC3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF43_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUC3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUC3ICVF43 self, itkImageUC3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF43_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUC3ICVF43 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF43_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUC3') -> "void":
        """PushFrontInput(itkImageToImageFilterIUC3ICVF43 self, itkImageUC3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF43_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUC3ICVF43 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF43_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUC3ICVF43 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF43_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUC3ICVF43 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF43_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUC3ICVF43 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF43_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUC3ICVF43 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF43_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUC3ICVF43

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC3ICVF43 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUC3ICVF43"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF43_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUC3ICVF43

        Create a new object of the class itkImageToImageFilterIUC3ICVF43 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUC3ICVF43.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUC3ICVF43.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUC3ICVF43.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUC3ICVF43.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF43_SetInput, None, itkImageToImageFilterIUC3ICVF43)
itkImageToImageFilterIUC3ICVF43.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF43_GetInput, None, itkImageToImageFilterIUC3ICVF43)
itkImageToImageFilterIUC3ICVF43.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF43_PushBackInput, None, itkImageToImageFilterIUC3ICVF43)
itkImageToImageFilterIUC3ICVF43.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF43_PopBackInput, None, itkImageToImageFilterIUC3ICVF43)
itkImageToImageFilterIUC3ICVF43.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF43_PushFrontInput, None, itkImageToImageFilterIUC3ICVF43)
itkImageToImageFilterIUC3ICVF43.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF43_PopFrontInput, None, itkImageToImageFilterIUC3ICVF43)
itkImageToImageFilterIUC3ICVF43.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF43_SetCoordinateTolerance, None, itkImageToImageFilterIUC3ICVF43)
itkImageToImageFilterIUC3ICVF43.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF43_GetCoordinateTolerance, None, itkImageToImageFilterIUC3ICVF43)
itkImageToImageFilterIUC3ICVF43.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF43_SetDirectionTolerance, None, itkImageToImageFilterIUC3ICVF43)
itkImageToImageFilterIUC3ICVF43.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF43_GetDirectionTolerance, None, itkImageToImageFilterIUC3ICVF43)
itkImageToImageFilterIUC3ICVF43_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF43_swigregister
itkImageToImageFilterIUC3ICVF43_swigregister(itkImageToImageFilterIUC3ICVF43)

def itkImageToImageFilterIUC3ICVF43_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC3ICVF43 *":
    """itkImageToImageFilterIUC3ICVF43_cast(itkLightObject obj) -> itkImageToImageFilterIUC3ICVF43"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ICVF43_cast(obj)

class itkImageToImageFilterIUC3IRGBAUC3(itkImageSourcePython.itkImageSourceIRGBAUC3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUC3IRGBAUC3 self, itkImageUC3 image)
        SetInput(itkImageToImageFilterIUC3IRGBAUC3 self, unsigned int arg0, itkImageUC3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IRGBAUC3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUC3 const *":
        """
        GetInput(itkImageToImageFilterIUC3IRGBAUC3 self) -> itkImageUC3
        GetInput(itkImageToImageFilterIUC3IRGBAUC3 self, unsigned int idx) -> itkImageUC3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IRGBAUC3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUC3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUC3IRGBAUC3 self, itkImageUC3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IRGBAUC3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUC3IRGBAUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IRGBAUC3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUC3') -> "void":
        """PushFrontInput(itkImageToImageFilterIUC3IRGBAUC3 self, itkImageUC3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IRGBAUC3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUC3IRGBAUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IRGBAUC3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUC3IRGBAUC3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IRGBAUC3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUC3IRGBAUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IRGBAUC3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUC3IRGBAUC3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IRGBAUC3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUC3IRGBAUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IRGBAUC3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUC3IRGBAUC3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC3IRGBAUC3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUC3IRGBAUC3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IRGBAUC3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUC3IRGBAUC3

        Create a new object of the class itkImageToImageFilterIUC3IRGBAUC3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUC3IRGBAUC3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUC3IRGBAUC3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUC3IRGBAUC3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUC3IRGBAUC3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3IRGBAUC3_SetInput, None, itkImageToImageFilterIUC3IRGBAUC3)
itkImageToImageFilterIUC3IRGBAUC3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3IRGBAUC3_GetInput, None, itkImageToImageFilterIUC3IRGBAUC3)
itkImageToImageFilterIUC3IRGBAUC3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3IRGBAUC3_PushBackInput, None, itkImageToImageFilterIUC3IRGBAUC3)
itkImageToImageFilterIUC3IRGBAUC3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3IRGBAUC3_PopBackInput, None, itkImageToImageFilterIUC3IRGBAUC3)
itkImageToImageFilterIUC3IRGBAUC3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3IRGBAUC3_PushFrontInput, None, itkImageToImageFilterIUC3IRGBAUC3)
itkImageToImageFilterIUC3IRGBAUC3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3IRGBAUC3_PopFrontInput, None, itkImageToImageFilterIUC3IRGBAUC3)
itkImageToImageFilterIUC3IRGBAUC3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3IRGBAUC3_SetCoordinateTolerance, None, itkImageToImageFilterIUC3IRGBAUC3)
itkImageToImageFilterIUC3IRGBAUC3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3IRGBAUC3_GetCoordinateTolerance, None, itkImageToImageFilterIUC3IRGBAUC3)
itkImageToImageFilterIUC3IRGBAUC3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3IRGBAUC3_SetDirectionTolerance, None, itkImageToImageFilterIUC3IRGBAUC3)
itkImageToImageFilterIUC3IRGBAUC3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3IRGBAUC3_GetDirectionTolerance, None, itkImageToImageFilterIUC3IRGBAUC3)
itkImageToImageFilterIUC3IRGBAUC3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IRGBAUC3_swigregister
itkImageToImageFilterIUC3IRGBAUC3_swigregister(itkImageToImageFilterIUC3IRGBAUC3)

def itkImageToImageFilterIUC3IRGBAUC3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC3IRGBAUC3 *":
    """itkImageToImageFilterIUC3IRGBAUC3_cast(itkLightObject obj) -> itkImageToImageFilterIUC3IRGBAUC3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IRGBAUC3_cast(obj)

class itkImageToImageFilterIUC3IRGBUC3(itkImageSourcePython.itkImageSourceIRGBUC3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUC3IRGBUC3 self, itkImageUC3 image)
        SetInput(itkImageToImageFilterIUC3IRGBUC3 self, unsigned int arg0, itkImageUC3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IRGBUC3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUC3 const *":
        """
        GetInput(itkImageToImageFilterIUC3IRGBUC3 self) -> itkImageUC3
        GetInput(itkImageToImageFilterIUC3IRGBUC3 self, unsigned int idx) -> itkImageUC3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IRGBUC3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUC3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUC3IRGBUC3 self, itkImageUC3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IRGBUC3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUC3IRGBUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IRGBUC3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUC3') -> "void":
        """PushFrontInput(itkImageToImageFilterIUC3IRGBUC3 self, itkImageUC3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IRGBUC3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUC3IRGBUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IRGBUC3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUC3IRGBUC3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IRGBUC3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUC3IRGBUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IRGBUC3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUC3IRGBUC3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IRGBUC3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUC3IRGBUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IRGBUC3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUC3IRGBUC3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC3IRGBUC3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUC3IRGBUC3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IRGBUC3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUC3IRGBUC3

        Create a new object of the class itkImageToImageFilterIUC3IRGBUC3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUC3IRGBUC3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUC3IRGBUC3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUC3IRGBUC3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUC3IRGBUC3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3IRGBUC3_SetInput, None, itkImageToImageFilterIUC3IRGBUC3)
itkImageToImageFilterIUC3IRGBUC3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3IRGBUC3_GetInput, None, itkImageToImageFilterIUC3IRGBUC3)
itkImageToImageFilterIUC3IRGBUC3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3IRGBUC3_PushBackInput, None, itkImageToImageFilterIUC3IRGBUC3)
itkImageToImageFilterIUC3IRGBUC3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3IRGBUC3_PopBackInput, None, itkImageToImageFilterIUC3IRGBUC3)
itkImageToImageFilterIUC3IRGBUC3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3IRGBUC3_PushFrontInput, None, itkImageToImageFilterIUC3IRGBUC3)
itkImageToImageFilterIUC3IRGBUC3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3IRGBUC3_PopFrontInput, None, itkImageToImageFilterIUC3IRGBUC3)
itkImageToImageFilterIUC3IRGBUC3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3IRGBUC3_SetCoordinateTolerance, None, itkImageToImageFilterIUC3IRGBUC3)
itkImageToImageFilterIUC3IRGBUC3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3IRGBUC3_GetCoordinateTolerance, None, itkImageToImageFilterIUC3IRGBUC3)
itkImageToImageFilterIUC3IRGBUC3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3IRGBUC3_SetDirectionTolerance, None, itkImageToImageFilterIUC3IRGBUC3)
itkImageToImageFilterIUC3IRGBUC3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3IRGBUC3_GetDirectionTolerance, None, itkImageToImageFilterIUC3IRGBUC3)
itkImageToImageFilterIUC3IRGBUC3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IRGBUC3_swigregister
itkImageToImageFilterIUC3IRGBUC3_swigregister(itkImageToImageFilterIUC3IRGBUC3)

def itkImageToImageFilterIUC3IRGBUC3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC3IRGBUC3 *":
    """itkImageToImageFilterIUC3IRGBUC3_cast(itkLightObject obj) -> itkImageToImageFilterIUC3IRGBUC3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IRGBUC3_cast(obj)

class itkImageToImageFilterIUC3ISSRTD33(itkImageSourcePython.itkImageSourceISSRTD33):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUC3ISSRTD33 self, itkImageUC3 image)
        SetInput(itkImageToImageFilterIUC3ISSRTD33 self, unsigned int arg0, itkImageUC3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ISSRTD33_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUC3 const *":
        """
        GetInput(itkImageToImageFilterIUC3ISSRTD33 self) -> itkImageUC3
        GetInput(itkImageToImageFilterIUC3ISSRTD33 self, unsigned int idx) -> itkImageUC3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ISSRTD33_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUC3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUC3ISSRTD33 self, itkImageUC3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ISSRTD33_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUC3ISSRTD33 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ISSRTD33_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUC3') -> "void":
        """PushFrontInput(itkImageToImageFilterIUC3ISSRTD33 self, itkImageUC3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ISSRTD33_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUC3ISSRTD33 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ISSRTD33_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUC3ISSRTD33 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ISSRTD33_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUC3ISSRTD33 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ISSRTD33_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUC3ISSRTD33 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ISSRTD33_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUC3ISSRTD33 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ISSRTD33_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUC3ISSRTD33

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC3ISSRTD33 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUC3ISSRTD33"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ISSRTD33_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUC3ISSRTD33

        Create a new object of the class itkImageToImageFilterIUC3ISSRTD33 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUC3ISSRTD33.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUC3ISSRTD33.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUC3ISSRTD33.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUC3ISSRTD33.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3ISSRTD33_SetInput, None, itkImageToImageFilterIUC3ISSRTD33)
itkImageToImageFilterIUC3ISSRTD33.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3ISSRTD33_GetInput, None, itkImageToImageFilterIUC3ISSRTD33)
itkImageToImageFilterIUC3ISSRTD33.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3ISSRTD33_PushBackInput, None, itkImageToImageFilterIUC3ISSRTD33)
itkImageToImageFilterIUC3ISSRTD33.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3ISSRTD33_PopBackInput, None, itkImageToImageFilterIUC3ISSRTD33)
itkImageToImageFilterIUC3ISSRTD33.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3ISSRTD33_PushFrontInput, None, itkImageToImageFilterIUC3ISSRTD33)
itkImageToImageFilterIUC3ISSRTD33.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3ISSRTD33_PopFrontInput, None, itkImageToImageFilterIUC3ISSRTD33)
itkImageToImageFilterIUC3ISSRTD33.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3ISSRTD33_SetCoordinateTolerance, None, itkImageToImageFilterIUC3ISSRTD33)
itkImageToImageFilterIUC3ISSRTD33.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3ISSRTD33_GetCoordinateTolerance, None, itkImageToImageFilterIUC3ISSRTD33)
itkImageToImageFilterIUC3ISSRTD33.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3ISSRTD33_SetDirectionTolerance, None, itkImageToImageFilterIUC3ISSRTD33)
itkImageToImageFilterIUC3ISSRTD33.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3ISSRTD33_GetDirectionTolerance, None, itkImageToImageFilterIUC3ISSRTD33)
itkImageToImageFilterIUC3ISSRTD33_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ISSRTD33_swigregister
itkImageToImageFilterIUC3ISSRTD33_swigregister(itkImageToImageFilterIUC3ISSRTD33)

def itkImageToImageFilterIUC3ISSRTD33_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC3ISSRTD33 *":
    """itkImageToImageFilterIUC3ISSRTD33_cast(itkLightObject obj) -> itkImageToImageFilterIUC3ISSRTD33"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3ISSRTD33_cast(obj)

class itkImageToImageFilterIUC3IUC2(itkImageSourcePython.itkImageSourceIUC2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUC3IUC2 self, itkImageUC3 image)
        SetInput(itkImageToImageFilterIUC3IUC2 self, unsigned int arg0, itkImageUC3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IUC2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUC3 const *":
        """
        GetInput(itkImageToImageFilterIUC3IUC2 self) -> itkImageUC3
        GetInput(itkImageToImageFilterIUC3IUC2 self, unsigned int idx) -> itkImageUC3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IUC2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUC3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUC3IUC2 self, itkImageUC3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IUC2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUC3IUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IUC2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUC3') -> "void":
        """PushFrontInput(itkImageToImageFilterIUC3IUC2 self, itkImageUC3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IUC2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUC3IUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IUC2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUC3IUC2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IUC2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUC3IUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IUC2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUC3IUC2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IUC2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUC3IUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IUC2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUC3IUC2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC3IUC2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUC3IUC2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IUC2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUC3IUC2

        Create a new object of the class itkImageToImageFilterIUC3IUC2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUC3IUC2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUC3IUC2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUC3IUC2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUC3IUC2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3IUC2_SetInput, None, itkImageToImageFilterIUC3IUC2)
itkImageToImageFilterIUC3IUC2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3IUC2_GetInput, None, itkImageToImageFilterIUC3IUC2)
itkImageToImageFilterIUC3IUC2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3IUC2_PushBackInput, None, itkImageToImageFilterIUC3IUC2)
itkImageToImageFilterIUC3IUC2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3IUC2_PopBackInput, None, itkImageToImageFilterIUC3IUC2)
itkImageToImageFilterIUC3IUC2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3IUC2_PushFrontInput, None, itkImageToImageFilterIUC3IUC2)
itkImageToImageFilterIUC3IUC2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3IUC2_PopFrontInput, None, itkImageToImageFilterIUC3IUC2)
itkImageToImageFilterIUC3IUC2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3IUC2_SetCoordinateTolerance, None, itkImageToImageFilterIUC3IUC2)
itkImageToImageFilterIUC3IUC2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3IUC2_GetCoordinateTolerance, None, itkImageToImageFilterIUC3IUC2)
itkImageToImageFilterIUC3IUC2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3IUC2_SetDirectionTolerance, None, itkImageToImageFilterIUC3IUC2)
itkImageToImageFilterIUC3IUC2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3IUC2_GetDirectionTolerance, None, itkImageToImageFilterIUC3IUC2)
itkImageToImageFilterIUC3IUC2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IUC2_swigregister
itkImageToImageFilterIUC3IUC2_swigregister(itkImageToImageFilterIUC3IUC2)

def itkImageToImageFilterIUC3IUC2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC3IUC2 *":
    """itkImageToImageFilterIUC3IUC2_cast(itkLightObject obj) -> itkImageToImageFilterIUC3IUC2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IUC2_cast(obj)

class itkImageToImageFilterIUC3IVF23(itkImageSourcePython.itkImageSourceIVF23):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUC3IVF23 self, itkImageUC3 image)
        SetInput(itkImageToImageFilterIUC3IVF23 self, unsigned int arg0, itkImageUC3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF23_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUC3 const *":
        """
        GetInput(itkImageToImageFilterIUC3IVF23 self) -> itkImageUC3
        GetInput(itkImageToImageFilterIUC3IVF23 self, unsigned int idx) -> itkImageUC3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF23_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUC3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUC3IVF23 self, itkImageUC3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF23_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUC3IVF23 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF23_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUC3') -> "void":
        """PushFrontInput(itkImageToImageFilterIUC3IVF23 self, itkImageUC3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF23_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUC3IVF23 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF23_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUC3IVF23 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF23_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUC3IVF23 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF23_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUC3IVF23 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF23_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUC3IVF23 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF23_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUC3IVF23

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC3IVF23 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUC3IVF23"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF23_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUC3IVF23

        Create a new object of the class itkImageToImageFilterIUC3IVF23 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUC3IVF23.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUC3IVF23.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUC3IVF23.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUC3IVF23.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF23_SetInput, None, itkImageToImageFilterIUC3IVF23)
itkImageToImageFilterIUC3IVF23.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF23_GetInput, None, itkImageToImageFilterIUC3IVF23)
itkImageToImageFilterIUC3IVF23.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF23_PushBackInput, None, itkImageToImageFilterIUC3IVF23)
itkImageToImageFilterIUC3IVF23.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF23_PopBackInput, None, itkImageToImageFilterIUC3IVF23)
itkImageToImageFilterIUC3IVF23.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF23_PushFrontInput, None, itkImageToImageFilterIUC3IVF23)
itkImageToImageFilterIUC3IVF23.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF23_PopFrontInput, None, itkImageToImageFilterIUC3IVF23)
itkImageToImageFilterIUC3IVF23.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF23_SetCoordinateTolerance, None, itkImageToImageFilterIUC3IVF23)
itkImageToImageFilterIUC3IVF23.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF23_GetCoordinateTolerance, None, itkImageToImageFilterIUC3IVF23)
itkImageToImageFilterIUC3IVF23.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF23_SetDirectionTolerance, None, itkImageToImageFilterIUC3IVF23)
itkImageToImageFilterIUC3IVF23.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF23_GetDirectionTolerance, None, itkImageToImageFilterIUC3IVF23)
itkImageToImageFilterIUC3IVF23_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF23_swigregister
itkImageToImageFilterIUC3IVF23_swigregister(itkImageToImageFilterIUC3IVF23)

def itkImageToImageFilterIUC3IVF23_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC3IVF23 *":
    """itkImageToImageFilterIUC3IVF23_cast(itkLightObject obj) -> itkImageToImageFilterIUC3IVF23"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF23_cast(obj)

class itkImageToImageFilterIUC3IVF33(itkImageSourcePython.itkImageSourceIVF33):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUC3IVF33 self, itkImageUC3 image)
        SetInput(itkImageToImageFilterIUC3IVF33 self, unsigned int arg0, itkImageUC3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF33_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUC3 const *":
        """
        GetInput(itkImageToImageFilterIUC3IVF33 self) -> itkImageUC3
        GetInput(itkImageToImageFilterIUC3IVF33 self, unsigned int idx) -> itkImageUC3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF33_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUC3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUC3IVF33 self, itkImageUC3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF33_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUC3IVF33 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF33_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUC3') -> "void":
        """PushFrontInput(itkImageToImageFilterIUC3IVF33 self, itkImageUC3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF33_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUC3IVF33 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF33_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUC3IVF33 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF33_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUC3IVF33 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF33_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUC3IVF33 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF33_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUC3IVF33 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF33_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUC3IVF33

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC3IVF33 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUC3IVF33"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF33_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUC3IVF33

        Create a new object of the class itkImageToImageFilterIUC3IVF33 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUC3IVF33.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUC3IVF33.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUC3IVF33.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUC3IVF33.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF33_SetInput, None, itkImageToImageFilterIUC3IVF33)
itkImageToImageFilterIUC3IVF33.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF33_GetInput, None, itkImageToImageFilterIUC3IVF33)
itkImageToImageFilterIUC3IVF33.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF33_PushBackInput, None, itkImageToImageFilterIUC3IVF33)
itkImageToImageFilterIUC3IVF33.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF33_PopBackInput, None, itkImageToImageFilterIUC3IVF33)
itkImageToImageFilterIUC3IVF33.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF33_PushFrontInput, None, itkImageToImageFilterIUC3IVF33)
itkImageToImageFilterIUC3IVF33.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF33_PopFrontInput, None, itkImageToImageFilterIUC3IVF33)
itkImageToImageFilterIUC3IVF33.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF33_SetCoordinateTolerance, None, itkImageToImageFilterIUC3IVF33)
itkImageToImageFilterIUC3IVF33.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF33_GetCoordinateTolerance, None, itkImageToImageFilterIUC3IVF33)
itkImageToImageFilterIUC3IVF33.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF33_SetDirectionTolerance, None, itkImageToImageFilterIUC3IVF33)
itkImageToImageFilterIUC3IVF33.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF33_GetDirectionTolerance, None, itkImageToImageFilterIUC3IVF33)
itkImageToImageFilterIUC3IVF33_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF33_swigregister
itkImageToImageFilterIUC3IVF33_swigregister(itkImageToImageFilterIUC3IVF33)

def itkImageToImageFilterIUC3IVF33_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC3IVF33 *":
    """itkImageToImageFilterIUC3IVF33_cast(itkLightObject obj) -> itkImageToImageFilterIUC3IVF33"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF33_cast(obj)

class itkImageToImageFilterIUC3IVF43(itkImageSourcePython.itkImageSourceIVF43):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUC3IVF43 self, itkImageUC3 image)
        SetInput(itkImageToImageFilterIUC3IVF43 self, unsigned int arg0, itkImageUC3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF43_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUC3 const *":
        """
        GetInput(itkImageToImageFilterIUC3IVF43 self) -> itkImageUC3
        GetInput(itkImageToImageFilterIUC3IVF43 self, unsigned int idx) -> itkImageUC3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF43_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUC3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUC3IVF43 self, itkImageUC3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF43_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUC3IVF43 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF43_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUC3') -> "void":
        """PushFrontInput(itkImageToImageFilterIUC3IVF43 self, itkImageUC3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF43_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUC3IVF43 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF43_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUC3IVF43 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF43_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUC3IVF43 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF43_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUC3IVF43 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF43_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUC3IVF43 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF43_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUC3IVF43

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC3IVF43 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUC3IVF43"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF43_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUC3IVF43

        Create a new object of the class itkImageToImageFilterIUC3IVF43 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUC3IVF43.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUC3IVF43.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUC3IVF43.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUC3IVF43.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF43_SetInput, None, itkImageToImageFilterIUC3IVF43)
itkImageToImageFilterIUC3IVF43.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF43_GetInput, None, itkImageToImageFilterIUC3IVF43)
itkImageToImageFilterIUC3IVF43.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF43_PushBackInput, None, itkImageToImageFilterIUC3IVF43)
itkImageToImageFilterIUC3IVF43.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF43_PopBackInput, None, itkImageToImageFilterIUC3IVF43)
itkImageToImageFilterIUC3IVF43.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF43_PushFrontInput, None, itkImageToImageFilterIUC3IVF43)
itkImageToImageFilterIUC3IVF43.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF43_PopFrontInput, None, itkImageToImageFilterIUC3IVF43)
itkImageToImageFilterIUC3IVF43.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF43_SetCoordinateTolerance, None, itkImageToImageFilterIUC3IVF43)
itkImageToImageFilterIUC3IVF43.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF43_GetCoordinateTolerance, None, itkImageToImageFilterIUC3IVF43)
itkImageToImageFilterIUC3IVF43.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF43_SetDirectionTolerance, None, itkImageToImageFilterIUC3IVF43)
itkImageToImageFilterIUC3IVF43.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF43_GetDirectionTolerance, None, itkImageToImageFilterIUC3IVF43)
itkImageToImageFilterIUC3IVF43_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF43_swigregister
itkImageToImageFilterIUC3IVF43_swigregister(itkImageToImageFilterIUC3IVF43)

def itkImageToImageFilterIUC3IVF43_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC3IVF43 *":
    """itkImageToImageFilterIUC3IVF43_cast(itkLightObject obj) -> itkImageToImageFilterIUC3IVF43"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3IVF43_cast(obj)

class itkImageToImageFilterIUC3VID3(itkImageSourcePython.itkImageSourceVID3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUC3VID3 self, itkImageUC3 image)
        SetInput(itkImageToImageFilterIUC3VID3 self, unsigned int arg0, itkImageUC3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VID3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUC3 const *":
        """
        GetInput(itkImageToImageFilterIUC3VID3 self) -> itkImageUC3
        GetInput(itkImageToImageFilterIUC3VID3 self, unsigned int idx) -> itkImageUC3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VID3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUC3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUC3VID3 self, itkImageUC3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VID3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUC3VID3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VID3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUC3') -> "void":
        """PushFrontInput(itkImageToImageFilterIUC3VID3 self, itkImageUC3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VID3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUC3VID3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VID3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUC3VID3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VID3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUC3VID3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VID3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUC3VID3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VID3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUC3VID3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VID3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUC3VID3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC3VID3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUC3VID3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VID3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUC3VID3

        Create a new object of the class itkImageToImageFilterIUC3VID3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUC3VID3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUC3VID3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUC3VID3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUC3VID3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3VID3_SetInput, None, itkImageToImageFilterIUC3VID3)
itkImageToImageFilterIUC3VID3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3VID3_GetInput, None, itkImageToImageFilterIUC3VID3)
itkImageToImageFilterIUC3VID3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3VID3_PushBackInput, None, itkImageToImageFilterIUC3VID3)
itkImageToImageFilterIUC3VID3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3VID3_PopBackInput, None, itkImageToImageFilterIUC3VID3)
itkImageToImageFilterIUC3VID3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3VID3_PushFrontInput, None, itkImageToImageFilterIUC3VID3)
itkImageToImageFilterIUC3VID3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3VID3_PopFrontInput, None, itkImageToImageFilterIUC3VID3)
itkImageToImageFilterIUC3VID3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3VID3_SetCoordinateTolerance, None, itkImageToImageFilterIUC3VID3)
itkImageToImageFilterIUC3VID3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3VID3_GetCoordinateTolerance, None, itkImageToImageFilterIUC3VID3)
itkImageToImageFilterIUC3VID3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3VID3_SetDirectionTolerance, None, itkImageToImageFilterIUC3VID3)
itkImageToImageFilterIUC3VID3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3VID3_GetDirectionTolerance, None, itkImageToImageFilterIUC3VID3)
itkImageToImageFilterIUC3VID3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VID3_swigregister
itkImageToImageFilterIUC3VID3_swigregister(itkImageToImageFilterIUC3VID3)

def itkImageToImageFilterIUC3VID3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC3VID3 *":
    """itkImageToImageFilterIUC3VID3_cast(itkLightObject obj) -> itkImageToImageFilterIUC3VID3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VID3_cast(obj)

class itkImageToImageFilterIUC3VIF3(itkImageSourcePython.itkImageSourceVIF3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUC3VIF3 self, itkImageUC3 image)
        SetInput(itkImageToImageFilterIUC3VIF3 self, unsigned int arg0, itkImageUC3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIF3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUC3 const *":
        """
        GetInput(itkImageToImageFilterIUC3VIF3 self) -> itkImageUC3
        GetInput(itkImageToImageFilterIUC3VIF3 self, unsigned int idx) -> itkImageUC3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIF3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUC3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUC3VIF3 self, itkImageUC3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIF3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUC3VIF3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIF3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUC3') -> "void":
        """PushFrontInput(itkImageToImageFilterIUC3VIF3 self, itkImageUC3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIF3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUC3VIF3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIF3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUC3VIF3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIF3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUC3VIF3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIF3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUC3VIF3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIF3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUC3VIF3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIF3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUC3VIF3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC3VIF3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUC3VIF3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIF3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUC3VIF3

        Create a new object of the class itkImageToImageFilterIUC3VIF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUC3VIF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUC3VIF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUC3VIF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUC3VIF3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIF3_SetInput, None, itkImageToImageFilterIUC3VIF3)
itkImageToImageFilterIUC3VIF3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIF3_GetInput, None, itkImageToImageFilterIUC3VIF3)
itkImageToImageFilterIUC3VIF3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIF3_PushBackInput, None, itkImageToImageFilterIUC3VIF3)
itkImageToImageFilterIUC3VIF3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIF3_PopBackInput, None, itkImageToImageFilterIUC3VIF3)
itkImageToImageFilterIUC3VIF3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIF3_PushFrontInput, None, itkImageToImageFilterIUC3VIF3)
itkImageToImageFilterIUC3VIF3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIF3_PopFrontInput, None, itkImageToImageFilterIUC3VIF3)
itkImageToImageFilterIUC3VIF3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIF3_SetCoordinateTolerance, None, itkImageToImageFilterIUC3VIF3)
itkImageToImageFilterIUC3VIF3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIF3_GetCoordinateTolerance, None, itkImageToImageFilterIUC3VIF3)
itkImageToImageFilterIUC3VIF3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIF3_SetDirectionTolerance, None, itkImageToImageFilterIUC3VIF3)
itkImageToImageFilterIUC3VIF3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIF3_GetDirectionTolerance, None, itkImageToImageFilterIUC3VIF3)
itkImageToImageFilterIUC3VIF3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIF3_swigregister
itkImageToImageFilterIUC3VIF3_swigregister(itkImageToImageFilterIUC3VIF3)

def itkImageToImageFilterIUC3VIF3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC3VIF3 *":
    """itkImageToImageFilterIUC3VIF3_cast(itkLightObject obj) -> itkImageToImageFilterIUC3VIF3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIF3_cast(obj)

class itkImageToImageFilterIUC3VISS3(itkImageSourcePython.itkImageSourceVISS3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUC3VISS3 self, itkImageUC3 image)
        SetInput(itkImageToImageFilterIUC3VISS3 self, unsigned int arg0, itkImageUC3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VISS3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUC3 const *":
        """
        GetInput(itkImageToImageFilterIUC3VISS3 self) -> itkImageUC3
        GetInput(itkImageToImageFilterIUC3VISS3 self, unsigned int idx) -> itkImageUC3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VISS3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUC3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUC3VISS3 self, itkImageUC3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VISS3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUC3VISS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VISS3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUC3') -> "void":
        """PushFrontInput(itkImageToImageFilterIUC3VISS3 self, itkImageUC3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VISS3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUC3VISS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VISS3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUC3VISS3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VISS3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUC3VISS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VISS3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUC3VISS3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VISS3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUC3VISS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VISS3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUC3VISS3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC3VISS3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUC3VISS3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VISS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUC3VISS3

        Create a new object of the class itkImageToImageFilterIUC3VISS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUC3VISS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUC3VISS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUC3VISS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUC3VISS3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3VISS3_SetInput, None, itkImageToImageFilterIUC3VISS3)
itkImageToImageFilterIUC3VISS3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3VISS3_GetInput, None, itkImageToImageFilterIUC3VISS3)
itkImageToImageFilterIUC3VISS3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3VISS3_PushBackInput, None, itkImageToImageFilterIUC3VISS3)
itkImageToImageFilterIUC3VISS3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3VISS3_PopBackInput, None, itkImageToImageFilterIUC3VISS3)
itkImageToImageFilterIUC3VISS3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3VISS3_PushFrontInput, None, itkImageToImageFilterIUC3VISS3)
itkImageToImageFilterIUC3VISS3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3VISS3_PopFrontInput, None, itkImageToImageFilterIUC3VISS3)
itkImageToImageFilterIUC3VISS3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3VISS3_SetCoordinateTolerance, None, itkImageToImageFilterIUC3VISS3)
itkImageToImageFilterIUC3VISS3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3VISS3_GetCoordinateTolerance, None, itkImageToImageFilterIUC3VISS3)
itkImageToImageFilterIUC3VISS3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3VISS3_SetDirectionTolerance, None, itkImageToImageFilterIUC3VISS3)
itkImageToImageFilterIUC3VISS3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3VISS3_GetDirectionTolerance, None, itkImageToImageFilterIUC3VISS3)
itkImageToImageFilterIUC3VISS3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VISS3_swigregister
itkImageToImageFilterIUC3VISS3_swigregister(itkImageToImageFilterIUC3VISS3)

def itkImageToImageFilterIUC3VISS3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC3VISS3 *":
    """itkImageToImageFilterIUC3VISS3_cast(itkLightObject obj) -> itkImageToImageFilterIUC3VISS3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VISS3_cast(obj)

class itkImageToImageFilterIUC3VIUC3(itkImageSourcePython.itkImageSourceVIUC3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUC3VIUC3 self, itkImageUC3 image)
        SetInput(itkImageToImageFilterIUC3VIUC3 self, unsigned int arg0, itkImageUC3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIUC3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUC3 const *":
        """
        GetInput(itkImageToImageFilterIUC3VIUC3 self) -> itkImageUC3
        GetInput(itkImageToImageFilterIUC3VIUC3 self, unsigned int idx) -> itkImageUC3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIUC3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUC3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUC3VIUC3 self, itkImageUC3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIUC3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUC3VIUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIUC3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUC3') -> "void":
        """PushFrontInput(itkImageToImageFilterIUC3VIUC3 self, itkImageUC3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIUC3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUC3VIUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIUC3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUC3VIUC3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIUC3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUC3VIUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIUC3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUC3VIUC3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIUC3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUC3VIUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIUC3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUC3VIUC3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC3VIUC3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUC3VIUC3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIUC3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUC3VIUC3

        Create a new object of the class itkImageToImageFilterIUC3VIUC3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUC3VIUC3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUC3VIUC3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUC3VIUC3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUC3VIUC3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIUC3_SetInput, None, itkImageToImageFilterIUC3VIUC3)
itkImageToImageFilterIUC3VIUC3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIUC3_GetInput, None, itkImageToImageFilterIUC3VIUC3)
itkImageToImageFilterIUC3VIUC3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIUC3_PushBackInput, None, itkImageToImageFilterIUC3VIUC3)
itkImageToImageFilterIUC3VIUC3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIUC3_PopBackInput, None, itkImageToImageFilterIUC3VIUC3)
itkImageToImageFilterIUC3VIUC3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIUC3_PushFrontInput, None, itkImageToImageFilterIUC3VIUC3)
itkImageToImageFilterIUC3VIUC3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIUC3_PopFrontInput, None, itkImageToImageFilterIUC3VIUC3)
itkImageToImageFilterIUC3VIUC3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIUC3_SetCoordinateTolerance, None, itkImageToImageFilterIUC3VIUC3)
itkImageToImageFilterIUC3VIUC3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIUC3_GetCoordinateTolerance, None, itkImageToImageFilterIUC3VIUC3)
itkImageToImageFilterIUC3VIUC3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIUC3_SetDirectionTolerance, None, itkImageToImageFilterIUC3VIUC3)
itkImageToImageFilterIUC3VIUC3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIUC3_GetDirectionTolerance, None, itkImageToImageFilterIUC3VIUC3)
itkImageToImageFilterIUC3VIUC3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIUC3_swigregister
itkImageToImageFilterIUC3VIUC3_swigregister(itkImageToImageFilterIUC3VIUC3)

def itkImageToImageFilterIUC3VIUC3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC3VIUC3 *":
    """itkImageToImageFilterIUC3VIUC3_cast(itkLightObject obj) -> itkImageToImageFilterIUC3VIUC3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIUC3_cast(obj)

class itkImageToImageFilterIUC3VIUS3(itkImageSourcePython.itkImageSourceVIUS3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUC3VIUS3 self, itkImageUC3 image)
        SetInput(itkImageToImageFilterIUC3VIUS3 self, unsigned int arg0, itkImageUC3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIUS3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUC3 const *":
        """
        GetInput(itkImageToImageFilterIUC3VIUS3 self) -> itkImageUC3
        GetInput(itkImageToImageFilterIUC3VIUS3 self, unsigned int idx) -> itkImageUC3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIUS3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUC3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUC3VIUS3 self, itkImageUC3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIUS3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUC3VIUS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIUS3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUC3') -> "void":
        """PushFrontInput(itkImageToImageFilterIUC3VIUS3 self, itkImageUC3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIUS3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUC3VIUS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIUS3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUC3VIUS3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIUS3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUC3VIUS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIUS3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUC3VIUS3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIUS3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUC3VIUS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIUS3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUC3VIUS3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC3VIUS3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUC3VIUS3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIUS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUC3VIUS3

        Create a new object of the class itkImageToImageFilterIUC3VIUS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUC3VIUS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUC3VIUS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUC3VIUS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUC3VIUS3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIUS3_SetInput, None, itkImageToImageFilterIUC3VIUS3)
itkImageToImageFilterIUC3VIUS3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIUS3_GetInput, None, itkImageToImageFilterIUC3VIUS3)
itkImageToImageFilterIUC3VIUS3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIUS3_PushBackInput, None, itkImageToImageFilterIUC3VIUS3)
itkImageToImageFilterIUC3VIUS3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIUS3_PopBackInput, None, itkImageToImageFilterIUC3VIUS3)
itkImageToImageFilterIUC3VIUS3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIUS3_PushFrontInput, None, itkImageToImageFilterIUC3VIUS3)
itkImageToImageFilterIUC3VIUS3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIUS3_PopFrontInput, None, itkImageToImageFilterIUC3VIUS3)
itkImageToImageFilterIUC3VIUS3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIUS3_SetCoordinateTolerance, None, itkImageToImageFilterIUC3VIUS3)
itkImageToImageFilterIUC3VIUS3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIUS3_GetCoordinateTolerance, None, itkImageToImageFilterIUC3VIUS3)
itkImageToImageFilterIUC3VIUS3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIUS3_SetDirectionTolerance, None, itkImageToImageFilterIUC3VIUS3)
itkImageToImageFilterIUC3VIUS3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIUS3_GetDirectionTolerance, None, itkImageToImageFilterIUC3VIUS3)
itkImageToImageFilterIUC3VIUS3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIUS3_swigregister
itkImageToImageFilterIUC3VIUS3_swigregister(itkImageToImageFilterIUC3VIUS3)

def itkImageToImageFilterIUC3VIUS3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC3VIUS3 *":
    """itkImageToImageFilterIUC3VIUS3_cast(itkLightObject obj) -> itkImageToImageFilterIUC3VIUS3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUC3VIUS3_cast(obj)

class itkImageToImageFilterIUL2IRGBAUC2(itkImageSourcePython.itkImageSourceIRGBAUC2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUL2IRGBAUC2 self, itkImageUL2 image)
        SetInput(itkImageToImageFilterIUL2IRGBAUC2 self, unsigned int arg0, itkImageUL2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUL2IRGBAUC2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUL2 const *":
        """
        GetInput(itkImageToImageFilterIUL2IRGBAUC2 self) -> itkImageUL2
        GetInput(itkImageToImageFilterIUL2IRGBAUC2 self, unsigned int idx) -> itkImageUL2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUL2IRGBAUC2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUL2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUL2IRGBAUC2 self, itkImageUL2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUL2IRGBAUC2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUL2IRGBAUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUL2IRGBAUC2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUL2') -> "void":
        """PushFrontInput(itkImageToImageFilterIUL2IRGBAUC2 self, itkImageUL2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUL2IRGBAUC2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUL2IRGBAUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUL2IRGBAUC2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUL2IRGBAUC2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUL2IRGBAUC2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUL2IRGBAUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUL2IRGBAUC2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUL2IRGBAUC2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUL2IRGBAUC2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUL2IRGBAUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUL2IRGBAUC2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUL2IRGBAUC2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUL2IRGBAUC2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUL2IRGBAUC2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUL2IRGBAUC2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUL2IRGBAUC2

        Create a new object of the class itkImageToImageFilterIUL2IRGBAUC2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUL2IRGBAUC2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUL2IRGBAUC2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUL2IRGBAUC2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUL2IRGBAUC2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUL2IRGBAUC2_SetInput, None, itkImageToImageFilterIUL2IRGBAUC2)
itkImageToImageFilterIUL2IRGBAUC2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUL2IRGBAUC2_GetInput, None, itkImageToImageFilterIUL2IRGBAUC2)
itkImageToImageFilterIUL2IRGBAUC2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUL2IRGBAUC2_PushBackInput, None, itkImageToImageFilterIUL2IRGBAUC2)
itkImageToImageFilterIUL2IRGBAUC2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUL2IRGBAUC2_PopBackInput, None, itkImageToImageFilterIUL2IRGBAUC2)
itkImageToImageFilterIUL2IRGBAUC2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUL2IRGBAUC2_PushFrontInput, None, itkImageToImageFilterIUL2IRGBAUC2)
itkImageToImageFilterIUL2IRGBAUC2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUL2IRGBAUC2_PopFrontInput, None, itkImageToImageFilterIUL2IRGBAUC2)
itkImageToImageFilterIUL2IRGBAUC2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUL2IRGBAUC2_SetCoordinateTolerance, None, itkImageToImageFilterIUL2IRGBAUC2)
itkImageToImageFilterIUL2IRGBAUC2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUL2IRGBAUC2_GetCoordinateTolerance, None, itkImageToImageFilterIUL2IRGBAUC2)
itkImageToImageFilterIUL2IRGBAUC2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUL2IRGBAUC2_SetDirectionTolerance, None, itkImageToImageFilterIUL2IRGBAUC2)
itkImageToImageFilterIUL2IRGBAUC2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUL2IRGBAUC2_GetDirectionTolerance, None, itkImageToImageFilterIUL2IRGBAUC2)
itkImageToImageFilterIUL2IRGBAUC2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUL2IRGBAUC2_swigregister
itkImageToImageFilterIUL2IRGBAUC2_swigregister(itkImageToImageFilterIUL2IRGBAUC2)

def itkImageToImageFilterIUL2IRGBAUC2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUL2IRGBAUC2 *":
    """itkImageToImageFilterIUL2IRGBAUC2_cast(itkLightObject obj) -> itkImageToImageFilterIUL2IRGBAUC2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUL2IRGBAUC2_cast(obj)

class itkImageToImageFilterIUL2IRGBUC2(itkImageSourcePython.itkImageSourceIRGBUC2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUL2IRGBUC2 self, itkImageUL2 image)
        SetInput(itkImageToImageFilterIUL2IRGBUC2 self, unsigned int arg0, itkImageUL2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUL2IRGBUC2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUL2 const *":
        """
        GetInput(itkImageToImageFilterIUL2IRGBUC2 self) -> itkImageUL2
        GetInput(itkImageToImageFilterIUL2IRGBUC2 self, unsigned int idx) -> itkImageUL2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUL2IRGBUC2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUL2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUL2IRGBUC2 self, itkImageUL2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUL2IRGBUC2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUL2IRGBUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUL2IRGBUC2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUL2') -> "void":
        """PushFrontInput(itkImageToImageFilterIUL2IRGBUC2 self, itkImageUL2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUL2IRGBUC2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUL2IRGBUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUL2IRGBUC2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUL2IRGBUC2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUL2IRGBUC2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUL2IRGBUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUL2IRGBUC2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUL2IRGBUC2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUL2IRGBUC2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUL2IRGBUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUL2IRGBUC2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUL2IRGBUC2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUL2IRGBUC2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUL2IRGBUC2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUL2IRGBUC2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUL2IRGBUC2

        Create a new object of the class itkImageToImageFilterIUL2IRGBUC2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUL2IRGBUC2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUL2IRGBUC2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUL2IRGBUC2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUL2IRGBUC2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUL2IRGBUC2_SetInput, None, itkImageToImageFilterIUL2IRGBUC2)
itkImageToImageFilterIUL2IRGBUC2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUL2IRGBUC2_GetInput, None, itkImageToImageFilterIUL2IRGBUC2)
itkImageToImageFilterIUL2IRGBUC2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUL2IRGBUC2_PushBackInput, None, itkImageToImageFilterIUL2IRGBUC2)
itkImageToImageFilterIUL2IRGBUC2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUL2IRGBUC2_PopBackInput, None, itkImageToImageFilterIUL2IRGBUC2)
itkImageToImageFilterIUL2IRGBUC2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUL2IRGBUC2_PushFrontInput, None, itkImageToImageFilterIUL2IRGBUC2)
itkImageToImageFilterIUL2IRGBUC2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUL2IRGBUC2_PopFrontInput, None, itkImageToImageFilterIUL2IRGBUC2)
itkImageToImageFilterIUL2IRGBUC2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUL2IRGBUC2_SetCoordinateTolerance, None, itkImageToImageFilterIUL2IRGBUC2)
itkImageToImageFilterIUL2IRGBUC2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUL2IRGBUC2_GetCoordinateTolerance, None, itkImageToImageFilterIUL2IRGBUC2)
itkImageToImageFilterIUL2IRGBUC2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUL2IRGBUC2_SetDirectionTolerance, None, itkImageToImageFilterIUL2IRGBUC2)
itkImageToImageFilterIUL2IRGBUC2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUL2IRGBUC2_GetDirectionTolerance, None, itkImageToImageFilterIUL2IRGBUC2)
itkImageToImageFilterIUL2IRGBUC2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUL2IRGBUC2_swigregister
itkImageToImageFilterIUL2IRGBUC2_swigregister(itkImageToImageFilterIUL2IRGBUC2)

def itkImageToImageFilterIUL2IRGBUC2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUL2IRGBUC2 *":
    """itkImageToImageFilterIUL2IRGBUC2_cast(itkLightObject obj) -> itkImageToImageFilterIUL2IRGBUC2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUL2IRGBUC2_cast(obj)

class itkImageToImageFilterIUL3IRGBAUC3(itkImageSourcePython.itkImageSourceIRGBAUC3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUL3IRGBAUC3 self, itkImageUL3 image)
        SetInput(itkImageToImageFilterIUL3IRGBAUC3 self, unsigned int arg0, itkImageUL3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUL3IRGBAUC3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUL3 const *":
        """
        GetInput(itkImageToImageFilterIUL3IRGBAUC3 self) -> itkImageUL3
        GetInput(itkImageToImageFilterIUL3IRGBAUC3 self, unsigned int idx) -> itkImageUL3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUL3IRGBAUC3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUL3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUL3IRGBAUC3 self, itkImageUL3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUL3IRGBAUC3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUL3IRGBAUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUL3IRGBAUC3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUL3') -> "void":
        """PushFrontInput(itkImageToImageFilterIUL3IRGBAUC3 self, itkImageUL3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUL3IRGBAUC3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUL3IRGBAUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUL3IRGBAUC3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUL3IRGBAUC3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUL3IRGBAUC3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUL3IRGBAUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUL3IRGBAUC3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUL3IRGBAUC3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUL3IRGBAUC3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUL3IRGBAUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUL3IRGBAUC3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUL3IRGBAUC3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUL3IRGBAUC3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUL3IRGBAUC3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUL3IRGBAUC3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUL3IRGBAUC3

        Create a new object of the class itkImageToImageFilterIUL3IRGBAUC3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUL3IRGBAUC3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUL3IRGBAUC3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUL3IRGBAUC3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUL3IRGBAUC3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUL3IRGBAUC3_SetInput, None, itkImageToImageFilterIUL3IRGBAUC3)
itkImageToImageFilterIUL3IRGBAUC3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUL3IRGBAUC3_GetInput, None, itkImageToImageFilterIUL3IRGBAUC3)
itkImageToImageFilterIUL3IRGBAUC3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUL3IRGBAUC3_PushBackInput, None, itkImageToImageFilterIUL3IRGBAUC3)
itkImageToImageFilterIUL3IRGBAUC3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUL3IRGBAUC3_PopBackInput, None, itkImageToImageFilterIUL3IRGBAUC3)
itkImageToImageFilterIUL3IRGBAUC3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUL3IRGBAUC3_PushFrontInput, None, itkImageToImageFilterIUL3IRGBAUC3)
itkImageToImageFilterIUL3IRGBAUC3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUL3IRGBAUC3_PopFrontInput, None, itkImageToImageFilterIUL3IRGBAUC3)
itkImageToImageFilterIUL3IRGBAUC3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUL3IRGBAUC3_SetCoordinateTolerance, None, itkImageToImageFilterIUL3IRGBAUC3)
itkImageToImageFilterIUL3IRGBAUC3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUL3IRGBAUC3_GetCoordinateTolerance, None, itkImageToImageFilterIUL3IRGBAUC3)
itkImageToImageFilterIUL3IRGBAUC3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUL3IRGBAUC3_SetDirectionTolerance, None, itkImageToImageFilterIUL3IRGBAUC3)
itkImageToImageFilterIUL3IRGBAUC3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUL3IRGBAUC3_GetDirectionTolerance, None, itkImageToImageFilterIUL3IRGBAUC3)
itkImageToImageFilterIUL3IRGBAUC3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUL3IRGBAUC3_swigregister
itkImageToImageFilterIUL3IRGBAUC3_swigregister(itkImageToImageFilterIUL3IRGBAUC3)

def itkImageToImageFilterIUL3IRGBAUC3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUL3IRGBAUC3 *":
    """itkImageToImageFilterIUL3IRGBAUC3_cast(itkLightObject obj) -> itkImageToImageFilterIUL3IRGBAUC3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUL3IRGBAUC3_cast(obj)

class itkImageToImageFilterIUL3IRGBUC3(itkImageSourcePython.itkImageSourceIRGBUC3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUL3IRGBUC3 self, itkImageUL3 image)
        SetInput(itkImageToImageFilterIUL3IRGBUC3 self, unsigned int arg0, itkImageUL3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUL3IRGBUC3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUL3 const *":
        """
        GetInput(itkImageToImageFilterIUL3IRGBUC3 self) -> itkImageUL3
        GetInput(itkImageToImageFilterIUL3IRGBUC3 self, unsigned int idx) -> itkImageUL3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUL3IRGBUC3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUL3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUL3IRGBUC3 self, itkImageUL3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUL3IRGBUC3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUL3IRGBUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUL3IRGBUC3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUL3') -> "void":
        """PushFrontInput(itkImageToImageFilterIUL3IRGBUC3 self, itkImageUL3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUL3IRGBUC3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUL3IRGBUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUL3IRGBUC3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUL3IRGBUC3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUL3IRGBUC3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUL3IRGBUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUL3IRGBUC3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUL3IRGBUC3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUL3IRGBUC3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUL3IRGBUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUL3IRGBUC3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUL3IRGBUC3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUL3IRGBUC3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUL3IRGBUC3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUL3IRGBUC3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUL3IRGBUC3

        Create a new object of the class itkImageToImageFilterIUL3IRGBUC3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUL3IRGBUC3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUL3IRGBUC3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUL3IRGBUC3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUL3IRGBUC3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUL3IRGBUC3_SetInput, None, itkImageToImageFilterIUL3IRGBUC3)
itkImageToImageFilterIUL3IRGBUC3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUL3IRGBUC3_GetInput, None, itkImageToImageFilterIUL3IRGBUC3)
itkImageToImageFilterIUL3IRGBUC3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUL3IRGBUC3_PushBackInput, None, itkImageToImageFilterIUL3IRGBUC3)
itkImageToImageFilterIUL3IRGBUC3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUL3IRGBUC3_PopBackInput, None, itkImageToImageFilterIUL3IRGBUC3)
itkImageToImageFilterIUL3IRGBUC3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUL3IRGBUC3_PushFrontInput, None, itkImageToImageFilterIUL3IRGBUC3)
itkImageToImageFilterIUL3IRGBUC3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUL3IRGBUC3_PopFrontInput, None, itkImageToImageFilterIUL3IRGBUC3)
itkImageToImageFilterIUL3IRGBUC3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUL3IRGBUC3_SetCoordinateTolerance, None, itkImageToImageFilterIUL3IRGBUC3)
itkImageToImageFilterIUL3IRGBUC3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUL3IRGBUC3_GetCoordinateTolerance, None, itkImageToImageFilterIUL3IRGBUC3)
itkImageToImageFilterIUL3IRGBUC3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUL3IRGBUC3_SetDirectionTolerance, None, itkImageToImageFilterIUL3IRGBUC3)
itkImageToImageFilterIUL3IRGBUC3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUL3IRGBUC3_GetDirectionTolerance, None, itkImageToImageFilterIUL3IRGBUC3)
itkImageToImageFilterIUL3IRGBUC3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUL3IRGBUC3_swigregister
itkImageToImageFilterIUL3IRGBUC3_swigregister(itkImageToImageFilterIUL3IRGBUC3)

def itkImageToImageFilterIUL3IRGBUC3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUL3IRGBUC3 *":
    """itkImageToImageFilterIUL3IRGBUC3_cast(itkLightObject obj) -> itkImageToImageFilterIUL3IRGBUC3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUL3IRGBUC3_cast(obj)

class itkImageToImageFilterIUS2ICF2(itkImageSourcePython.itkImageSourceICF2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUS2ICF2 self, itkImageUS2 image)
        SetInput(itkImageToImageFilterIUS2ICF2 self, unsigned int arg0, itkImageUS2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICF2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUS2 const *":
        """
        GetInput(itkImageToImageFilterIUS2ICF2 self) -> itkImageUS2
        GetInput(itkImageToImageFilterIUS2ICF2 self, unsigned int idx) -> itkImageUS2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICF2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUS2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUS2ICF2 self, itkImageUS2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICF2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUS2ICF2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICF2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUS2') -> "void":
        """PushFrontInput(itkImageToImageFilterIUS2ICF2 self, itkImageUS2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICF2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUS2ICF2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICF2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUS2ICF2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICF2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUS2ICF2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICF2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUS2ICF2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICF2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUS2ICF2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICF2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUS2ICF2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS2ICF2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUS2ICF2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICF2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUS2ICF2

        Create a new object of the class itkImageToImageFilterIUS2ICF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUS2ICF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUS2ICF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUS2ICF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUS2ICF2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICF2_SetInput, None, itkImageToImageFilterIUS2ICF2)
itkImageToImageFilterIUS2ICF2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICF2_GetInput, None, itkImageToImageFilterIUS2ICF2)
itkImageToImageFilterIUS2ICF2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICF2_PushBackInput, None, itkImageToImageFilterIUS2ICF2)
itkImageToImageFilterIUS2ICF2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICF2_PopBackInput, None, itkImageToImageFilterIUS2ICF2)
itkImageToImageFilterIUS2ICF2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICF2_PushFrontInput, None, itkImageToImageFilterIUS2ICF2)
itkImageToImageFilterIUS2ICF2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICF2_PopFrontInput, None, itkImageToImageFilterIUS2ICF2)
itkImageToImageFilterIUS2ICF2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICF2_SetCoordinateTolerance, None, itkImageToImageFilterIUS2ICF2)
itkImageToImageFilterIUS2ICF2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICF2_GetCoordinateTolerance, None, itkImageToImageFilterIUS2ICF2)
itkImageToImageFilterIUS2ICF2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICF2_SetDirectionTolerance, None, itkImageToImageFilterIUS2ICF2)
itkImageToImageFilterIUS2ICF2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICF2_GetDirectionTolerance, None, itkImageToImageFilterIUS2ICF2)
itkImageToImageFilterIUS2ICF2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICF2_swigregister
itkImageToImageFilterIUS2ICF2_swigregister(itkImageToImageFilterIUS2ICF2)

def itkImageToImageFilterIUS2ICF2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS2ICF2 *":
    """itkImageToImageFilterIUS2ICF2_cast(itkLightObject obj) -> itkImageToImageFilterIUS2ICF2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICF2_cast(obj)

class itkImageToImageFilterIUS2ICVF22(itkImageSourcePython.itkImageSourceICVF22):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUS2ICVF22 self, itkImageUS2 image)
        SetInput(itkImageToImageFilterIUS2ICVF22 self, unsigned int arg0, itkImageUS2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF22_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUS2 const *":
        """
        GetInput(itkImageToImageFilterIUS2ICVF22 self) -> itkImageUS2
        GetInput(itkImageToImageFilterIUS2ICVF22 self, unsigned int idx) -> itkImageUS2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF22_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUS2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUS2ICVF22 self, itkImageUS2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF22_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUS2ICVF22 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF22_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUS2') -> "void":
        """PushFrontInput(itkImageToImageFilterIUS2ICVF22 self, itkImageUS2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF22_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUS2ICVF22 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF22_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUS2ICVF22 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF22_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUS2ICVF22 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF22_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUS2ICVF22 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF22_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUS2ICVF22 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF22_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUS2ICVF22

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS2ICVF22 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUS2ICVF22"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF22_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUS2ICVF22

        Create a new object of the class itkImageToImageFilterIUS2ICVF22 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUS2ICVF22.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUS2ICVF22.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUS2ICVF22.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUS2ICVF22.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF22_SetInput, None, itkImageToImageFilterIUS2ICVF22)
itkImageToImageFilterIUS2ICVF22.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF22_GetInput, None, itkImageToImageFilterIUS2ICVF22)
itkImageToImageFilterIUS2ICVF22.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF22_PushBackInput, None, itkImageToImageFilterIUS2ICVF22)
itkImageToImageFilterIUS2ICVF22.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF22_PopBackInput, None, itkImageToImageFilterIUS2ICVF22)
itkImageToImageFilterIUS2ICVF22.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF22_PushFrontInput, None, itkImageToImageFilterIUS2ICVF22)
itkImageToImageFilterIUS2ICVF22.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF22_PopFrontInput, None, itkImageToImageFilterIUS2ICVF22)
itkImageToImageFilterIUS2ICVF22.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF22_SetCoordinateTolerance, None, itkImageToImageFilterIUS2ICVF22)
itkImageToImageFilterIUS2ICVF22.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF22_GetCoordinateTolerance, None, itkImageToImageFilterIUS2ICVF22)
itkImageToImageFilterIUS2ICVF22.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF22_SetDirectionTolerance, None, itkImageToImageFilterIUS2ICVF22)
itkImageToImageFilterIUS2ICVF22.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF22_GetDirectionTolerance, None, itkImageToImageFilterIUS2ICVF22)
itkImageToImageFilterIUS2ICVF22_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF22_swigregister
itkImageToImageFilterIUS2ICVF22_swigregister(itkImageToImageFilterIUS2ICVF22)

def itkImageToImageFilterIUS2ICVF22_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS2ICVF22 *":
    """itkImageToImageFilterIUS2ICVF22_cast(itkLightObject obj) -> itkImageToImageFilterIUS2ICVF22"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF22_cast(obj)

class itkImageToImageFilterIUS2ICVF32(itkImageSourcePython.itkImageSourceICVF32):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUS2ICVF32 self, itkImageUS2 image)
        SetInput(itkImageToImageFilterIUS2ICVF32 self, unsigned int arg0, itkImageUS2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF32_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUS2 const *":
        """
        GetInput(itkImageToImageFilterIUS2ICVF32 self) -> itkImageUS2
        GetInput(itkImageToImageFilterIUS2ICVF32 self, unsigned int idx) -> itkImageUS2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF32_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUS2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUS2ICVF32 self, itkImageUS2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF32_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUS2ICVF32 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF32_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUS2') -> "void":
        """PushFrontInput(itkImageToImageFilterIUS2ICVF32 self, itkImageUS2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF32_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUS2ICVF32 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF32_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUS2ICVF32 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF32_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUS2ICVF32 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF32_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUS2ICVF32 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF32_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUS2ICVF32 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF32_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUS2ICVF32

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS2ICVF32 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUS2ICVF32"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF32_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUS2ICVF32

        Create a new object of the class itkImageToImageFilterIUS2ICVF32 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUS2ICVF32.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUS2ICVF32.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUS2ICVF32.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUS2ICVF32.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF32_SetInput, None, itkImageToImageFilterIUS2ICVF32)
itkImageToImageFilterIUS2ICVF32.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF32_GetInput, None, itkImageToImageFilterIUS2ICVF32)
itkImageToImageFilterIUS2ICVF32.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF32_PushBackInput, None, itkImageToImageFilterIUS2ICVF32)
itkImageToImageFilterIUS2ICVF32.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF32_PopBackInput, None, itkImageToImageFilterIUS2ICVF32)
itkImageToImageFilterIUS2ICVF32.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF32_PushFrontInput, None, itkImageToImageFilterIUS2ICVF32)
itkImageToImageFilterIUS2ICVF32.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF32_PopFrontInput, None, itkImageToImageFilterIUS2ICVF32)
itkImageToImageFilterIUS2ICVF32.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF32_SetCoordinateTolerance, None, itkImageToImageFilterIUS2ICVF32)
itkImageToImageFilterIUS2ICVF32.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF32_GetCoordinateTolerance, None, itkImageToImageFilterIUS2ICVF32)
itkImageToImageFilterIUS2ICVF32.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF32_SetDirectionTolerance, None, itkImageToImageFilterIUS2ICVF32)
itkImageToImageFilterIUS2ICVF32.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF32_GetDirectionTolerance, None, itkImageToImageFilterIUS2ICVF32)
itkImageToImageFilterIUS2ICVF32_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF32_swigregister
itkImageToImageFilterIUS2ICVF32_swigregister(itkImageToImageFilterIUS2ICVF32)

def itkImageToImageFilterIUS2ICVF32_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS2ICVF32 *":
    """itkImageToImageFilterIUS2ICVF32_cast(itkLightObject obj) -> itkImageToImageFilterIUS2ICVF32"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF32_cast(obj)

class itkImageToImageFilterIUS2ICVF42(itkImageSourcePython.itkImageSourceICVF42):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUS2ICVF42 self, itkImageUS2 image)
        SetInput(itkImageToImageFilterIUS2ICVF42 self, unsigned int arg0, itkImageUS2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF42_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUS2 const *":
        """
        GetInput(itkImageToImageFilterIUS2ICVF42 self) -> itkImageUS2
        GetInput(itkImageToImageFilterIUS2ICVF42 self, unsigned int idx) -> itkImageUS2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF42_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUS2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUS2ICVF42 self, itkImageUS2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF42_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUS2ICVF42 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF42_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUS2') -> "void":
        """PushFrontInput(itkImageToImageFilterIUS2ICVF42 self, itkImageUS2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF42_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUS2ICVF42 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF42_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUS2ICVF42 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF42_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUS2ICVF42 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF42_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUS2ICVF42 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF42_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUS2ICVF42 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF42_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUS2ICVF42

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS2ICVF42 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUS2ICVF42"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF42_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUS2ICVF42

        Create a new object of the class itkImageToImageFilterIUS2ICVF42 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUS2ICVF42.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUS2ICVF42.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUS2ICVF42.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUS2ICVF42.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF42_SetInput, None, itkImageToImageFilterIUS2ICVF42)
itkImageToImageFilterIUS2ICVF42.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF42_GetInput, None, itkImageToImageFilterIUS2ICVF42)
itkImageToImageFilterIUS2ICVF42.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF42_PushBackInput, None, itkImageToImageFilterIUS2ICVF42)
itkImageToImageFilterIUS2ICVF42.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF42_PopBackInput, None, itkImageToImageFilterIUS2ICVF42)
itkImageToImageFilterIUS2ICVF42.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF42_PushFrontInput, None, itkImageToImageFilterIUS2ICVF42)
itkImageToImageFilterIUS2ICVF42.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF42_PopFrontInput, None, itkImageToImageFilterIUS2ICVF42)
itkImageToImageFilterIUS2ICVF42.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF42_SetCoordinateTolerance, None, itkImageToImageFilterIUS2ICVF42)
itkImageToImageFilterIUS2ICVF42.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF42_GetCoordinateTolerance, None, itkImageToImageFilterIUS2ICVF42)
itkImageToImageFilterIUS2ICVF42.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF42_SetDirectionTolerance, None, itkImageToImageFilterIUS2ICVF42)
itkImageToImageFilterIUS2ICVF42.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF42_GetDirectionTolerance, None, itkImageToImageFilterIUS2ICVF42)
itkImageToImageFilterIUS2ICVF42_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF42_swigregister
itkImageToImageFilterIUS2ICVF42_swigregister(itkImageToImageFilterIUS2ICVF42)

def itkImageToImageFilterIUS2ICVF42_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS2ICVF42 *":
    """itkImageToImageFilterIUS2ICVF42_cast(itkLightObject obj) -> itkImageToImageFilterIUS2ICVF42"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ICVF42_cast(obj)

class itkImageToImageFilterIUS2IRGBAUC2(itkImageSourcePython.itkImageSourceIRGBAUC2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUS2IRGBAUC2 self, itkImageUS2 image)
        SetInput(itkImageToImageFilterIUS2IRGBAUC2 self, unsigned int arg0, itkImageUS2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IRGBAUC2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUS2 const *":
        """
        GetInput(itkImageToImageFilterIUS2IRGBAUC2 self) -> itkImageUS2
        GetInput(itkImageToImageFilterIUS2IRGBAUC2 self, unsigned int idx) -> itkImageUS2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IRGBAUC2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUS2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUS2IRGBAUC2 self, itkImageUS2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IRGBAUC2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUS2IRGBAUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IRGBAUC2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUS2') -> "void":
        """PushFrontInput(itkImageToImageFilterIUS2IRGBAUC2 self, itkImageUS2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IRGBAUC2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUS2IRGBAUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IRGBAUC2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUS2IRGBAUC2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IRGBAUC2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUS2IRGBAUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IRGBAUC2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUS2IRGBAUC2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IRGBAUC2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUS2IRGBAUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IRGBAUC2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUS2IRGBAUC2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS2IRGBAUC2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUS2IRGBAUC2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IRGBAUC2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUS2IRGBAUC2

        Create a new object of the class itkImageToImageFilterIUS2IRGBAUC2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUS2IRGBAUC2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUS2IRGBAUC2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUS2IRGBAUC2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUS2IRGBAUC2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2IRGBAUC2_SetInput, None, itkImageToImageFilterIUS2IRGBAUC2)
itkImageToImageFilterIUS2IRGBAUC2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2IRGBAUC2_GetInput, None, itkImageToImageFilterIUS2IRGBAUC2)
itkImageToImageFilterIUS2IRGBAUC2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2IRGBAUC2_PushBackInput, None, itkImageToImageFilterIUS2IRGBAUC2)
itkImageToImageFilterIUS2IRGBAUC2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2IRGBAUC2_PopBackInput, None, itkImageToImageFilterIUS2IRGBAUC2)
itkImageToImageFilterIUS2IRGBAUC2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2IRGBAUC2_PushFrontInput, None, itkImageToImageFilterIUS2IRGBAUC2)
itkImageToImageFilterIUS2IRGBAUC2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2IRGBAUC2_PopFrontInput, None, itkImageToImageFilterIUS2IRGBAUC2)
itkImageToImageFilterIUS2IRGBAUC2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2IRGBAUC2_SetCoordinateTolerance, None, itkImageToImageFilterIUS2IRGBAUC2)
itkImageToImageFilterIUS2IRGBAUC2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2IRGBAUC2_GetCoordinateTolerance, None, itkImageToImageFilterIUS2IRGBAUC2)
itkImageToImageFilterIUS2IRGBAUC2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2IRGBAUC2_SetDirectionTolerance, None, itkImageToImageFilterIUS2IRGBAUC2)
itkImageToImageFilterIUS2IRGBAUC2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2IRGBAUC2_GetDirectionTolerance, None, itkImageToImageFilterIUS2IRGBAUC2)
itkImageToImageFilterIUS2IRGBAUC2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IRGBAUC2_swigregister
itkImageToImageFilterIUS2IRGBAUC2_swigregister(itkImageToImageFilterIUS2IRGBAUC2)

def itkImageToImageFilterIUS2IRGBAUC2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS2IRGBAUC2 *":
    """itkImageToImageFilterIUS2IRGBAUC2_cast(itkLightObject obj) -> itkImageToImageFilterIUS2IRGBAUC2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IRGBAUC2_cast(obj)

class itkImageToImageFilterIUS2IRGBUC2(itkImageSourcePython.itkImageSourceIRGBUC2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUS2IRGBUC2 self, itkImageUS2 image)
        SetInput(itkImageToImageFilterIUS2IRGBUC2 self, unsigned int arg0, itkImageUS2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IRGBUC2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUS2 const *":
        """
        GetInput(itkImageToImageFilterIUS2IRGBUC2 self) -> itkImageUS2
        GetInput(itkImageToImageFilterIUS2IRGBUC2 self, unsigned int idx) -> itkImageUS2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IRGBUC2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUS2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUS2IRGBUC2 self, itkImageUS2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IRGBUC2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUS2IRGBUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IRGBUC2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUS2') -> "void":
        """PushFrontInput(itkImageToImageFilterIUS2IRGBUC2 self, itkImageUS2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IRGBUC2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUS2IRGBUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IRGBUC2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUS2IRGBUC2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IRGBUC2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUS2IRGBUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IRGBUC2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUS2IRGBUC2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IRGBUC2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUS2IRGBUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IRGBUC2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUS2IRGBUC2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS2IRGBUC2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUS2IRGBUC2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IRGBUC2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUS2IRGBUC2

        Create a new object of the class itkImageToImageFilterIUS2IRGBUC2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUS2IRGBUC2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUS2IRGBUC2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUS2IRGBUC2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUS2IRGBUC2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2IRGBUC2_SetInput, None, itkImageToImageFilterIUS2IRGBUC2)
itkImageToImageFilterIUS2IRGBUC2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2IRGBUC2_GetInput, None, itkImageToImageFilterIUS2IRGBUC2)
itkImageToImageFilterIUS2IRGBUC2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2IRGBUC2_PushBackInput, None, itkImageToImageFilterIUS2IRGBUC2)
itkImageToImageFilterIUS2IRGBUC2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2IRGBUC2_PopBackInput, None, itkImageToImageFilterIUS2IRGBUC2)
itkImageToImageFilterIUS2IRGBUC2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2IRGBUC2_PushFrontInput, None, itkImageToImageFilterIUS2IRGBUC2)
itkImageToImageFilterIUS2IRGBUC2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2IRGBUC2_PopFrontInput, None, itkImageToImageFilterIUS2IRGBUC2)
itkImageToImageFilterIUS2IRGBUC2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2IRGBUC2_SetCoordinateTolerance, None, itkImageToImageFilterIUS2IRGBUC2)
itkImageToImageFilterIUS2IRGBUC2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2IRGBUC2_GetCoordinateTolerance, None, itkImageToImageFilterIUS2IRGBUC2)
itkImageToImageFilterIUS2IRGBUC2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2IRGBUC2_SetDirectionTolerance, None, itkImageToImageFilterIUS2IRGBUC2)
itkImageToImageFilterIUS2IRGBUC2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2IRGBUC2_GetDirectionTolerance, None, itkImageToImageFilterIUS2IRGBUC2)
itkImageToImageFilterIUS2IRGBUC2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IRGBUC2_swigregister
itkImageToImageFilterIUS2IRGBUC2_swigregister(itkImageToImageFilterIUS2IRGBUC2)

def itkImageToImageFilterIUS2IRGBUC2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS2IRGBUC2 *":
    """itkImageToImageFilterIUS2IRGBUC2_cast(itkLightObject obj) -> itkImageToImageFilterIUS2IRGBUC2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IRGBUC2_cast(obj)

class itkImageToImageFilterIUS2ISSRTD22(itkImageSourcePython.itkImageSourceISSRTD22):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUS2ISSRTD22 self, itkImageUS2 image)
        SetInput(itkImageToImageFilterIUS2ISSRTD22 self, unsigned int arg0, itkImageUS2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ISSRTD22_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUS2 const *":
        """
        GetInput(itkImageToImageFilterIUS2ISSRTD22 self) -> itkImageUS2
        GetInput(itkImageToImageFilterIUS2ISSRTD22 self, unsigned int idx) -> itkImageUS2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ISSRTD22_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUS2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUS2ISSRTD22 self, itkImageUS2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ISSRTD22_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUS2ISSRTD22 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ISSRTD22_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUS2') -> "void":
        """PushFrontInput(itkImageToImageFilterIUS2ISSRTD22 self, itkImageUS2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ISSRTD22_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUS2ISSRTD22 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ISSRTD22_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUS2ISSRTD22 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ISSRTD22_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUS2ISSRTD22 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ISSRTD22_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUS2ISSRTD22 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ISSRTD22_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUS2ISSRTD22 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ISSRTD22_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUS2ISSRTD22

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS2ISSRTD22 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUS2ISSRTD22"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ISSRTD22_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUS2ISSRTD22

        Create a new object of the class itkImageToImageFilterIUS2ISSRTD22 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUS2ISSRTD22.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUS2ISSRTD22.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUS2ISSRTD22.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUS2ISSRTD22.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2ISSRTD22_SetInput, None, itkImageToImageFilterIUS2ISSRTD22)
itkImageToImageFilterIUS2ISSRTD22.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2ISSRTD22_GetInput, None, itkImageToImageFilterIUS2ISSRTD22)
itkImageToImageFilterIUS2ISSRTD22.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2ISSRTD22_PushBackInput, None, itkImageToImageFilterIUS2ISSRTD22)
itkImageToImageFilterIUS2ISSRTD22.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2ISSRTD22_PopBackInput, None, itkImageToImageFilterIUS2ISSRTD22)
itkImageToImageFilterIUS2ISSRTD22.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2ISSRTD22_PushFrontInput, None, itkImageToImageFilterIUS2ISSRTD22)
itkImageToImageFilterIUS2ISSRTD22.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2ISSRTD22_PopFrontInput, None, itkImageToImageFilterIUS2ISSRTD22)
itkImageToImageFilterIUS2ISSRTD22.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2ISSRTD22_SetCoordinateTolerance, None, itkImageToImageFilterIUS2ISSRTD22)
itkImageToImageFilterIUS2ISSRTD22.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2ISSRTD22_GetCoordinateTolerance, None, itkImageToImageFilterIUS2ISSRTD22)
itkImageToImageFilterIUS2ISSRTD22.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2ISSRTD22_SetDirectionTolerance, None, itkImageToImageFilterIUS2ISSRTD22)
itkImageToImageFilterIUS2ISSRTD22.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2ISSRTD22_GetDirectionTolerance, None, itkImageToImageFilterIUS2ISSRTD22)
itkImageToImageFilterIUS2ISSRTD22_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ISSRTD22_swigregister
itkImageToImageFilterIUS2ISSRTD22_swigregister(itkImageToImageFilterIUS2ISSRTD22)

def itkImageToImageFilterIUS2ISSRTD22_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS2ISSRTD22 *":
    """itkImageToImageFilterIUS2ISSRTD22_cast(itkLightObject obj) -> itkImageToImageFilterIUS2ISSRTD22"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2ISSRTD22_cast(obj)

class itkImageToImageFilterIUS2IUS3(itkImageSourcePython.itkImageSourceIUS3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUS2IUS3 self, itkImageUS2 image)
        SetInput(itkImageToImageFilterIUS2IUS3 self, unsigned int arg0, itkImageUS2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IUS3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUS2 const *":
        """
        GetInput(itkImageToImageFilterIUS2IUS3 self) -> itkImageUS2
        GetInput(itkImageToImageFilterIUS2IUS3 self, unsigned int idx) -> itkImageUS2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IUS3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUS2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUS2IUS3 self, itkImageUS2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IUS3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUS2IUS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IUS3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUS2') -> "void":
        """PushFrontInput(itkImageToImageFilterIUS2IUS3 self, itkImageUS2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IUS3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUS2IUS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IUS3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUS2IUS3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IUS3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUS2IUS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IUS3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUS2IUS3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IUS3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUS2IUS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IUS3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUS2IUS3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS2IUS3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUS2IUS3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IUS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUS2IUS3

        Create a new object of the class itkImageToImageFilterIUS2IUS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUS2IUS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUS2IUS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUS2IUS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUS2IUS3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2IUS3_SetInput, None, itkImageToImageFilterIUS2IUS3)
itkImageToImageFilterIUS2IUS3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2IUS3_GetInput, None, itkImageToImageFilterIUS2IUS3)
itkImageToImageFilterIUS2IUS3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2IUS3_PushBackInput, None, itkImageToImageFilterIUS2IUS3)
itkImageToImageFilterIUS2IUS3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2IUS3_PopBackInput, None, itkImageToImageFilterIUS2IUS3)
itkImageToImageFilterIUS2IUS3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2IUS3_PushFrontInput, None, itkImageToImageFilterIUS2IUS3)
itkImageToImageFilterIUS2IUS3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2IUS3_PopFrontInput, None, itkImageToImageFilterIUS2IUS3)
itkImageToImageFilterIUS2IUS3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2IUS3_SetCoordinateTolerance, None, itkImageToImageFilterIUS2IUS3)
itkImageToImageFilterIUS2IUS3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2IUS3_GetCoordinateTolerance, None, itkImageToImageFilterIUS2IUS3)
itkImageToImageFilterIUS2IUS3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2IUS3_SetDirectionTolerance, None, itkImageToImageFilterIUS2IUS3)
itkImageToImageFilterIUS2IUS3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2IUS3_GetDirectionTolerance, None, itkImageToImageFilterIUS2IUS3)
itkImageToImageFilterIUS2IUS3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IUS3_swigregister
itkImageToImageFilterIUS2IUS3_swigregister(itkImageToImageFilterIUS2IUS3)

def itkImageToImageFilterIUS2IUS3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS2IUS3 *":
    """itkImageToImageFilterIUS2IUS3_cast(itkLightObject obj) -> itkImageToImageFilterIUS2IUS3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IUS3_cast(obj)

class itkImageToImageFilterIUS2IVF22(itkImageSourcePython.itkImageSourceIVF22):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUS2IVF22 self, itkImageUS2 image)
        SetInput(itkImageToImageFilterIUS2IVF22 self, unsigned int arg0, itkImageUS2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF22_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUS2 const *":
        """
        GetInput(itkImageToImageFilterIUS2IVF22 self) -> itkImageUS2
        GetInput(itkImageToImageFilterIUS2IVF22 self, unsigned int idx) -> itkImageUS2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF22_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUS2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUS2IVF22 self, itkImageUS2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF22_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUS2IVF22 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF22_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUS2') -> "void":
        """PushFrontInput(itkImageToImageFilterIUS2IVF22 self, itkImageUS2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF22_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUS2IVF22 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF22_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUS2IVF22 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF22_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUS2IVF22 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF22_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUS2IVF22 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF22_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUS2IVF22 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF22_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUS2IVF22

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS2IVF22 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUS2IVF22"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF22_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUS2IVF22

        Create a new object of the class itkImageToImageFilterIUS2IVF22 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUS2IVF22.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUS2IVF22.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUS2IVF22.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUS2IVF22.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF22_SetInput, None, itkImageToImageFilterIUS2IVF22)
itkImageToImageFilterIUS2IVF22.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF22_GetInput, None, itkImageToImageFilterIUS2IVF22)
itkImageToImageFilterIUS2IVF22.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF22_PushBackInput, None, itkImageToImageFilterIUS2IVF22)
itkImageToImageFilterIUS2IVF22.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF22_PopBackInput, None, itkImageToImageFilterIUS2IVF22)
itkImageToImageFilterIUS2IVF22.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF22_PushFrontInput, None, itkImageToImageFilterIUS2IVF22)
itkImageToImageFilterIUS2IVF22.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF22_PopFrontInput, None, itkImageToImageFilterIUS2IVF22)
itkImageToImageFilterIUS2IVF22.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF22_SetCoordinateTolerance, None, itkImageToImageFilterIUS2IVF22)
itkImageToImageFilterIUS2IVF22.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF22_GetCoordinateTolerance, None, itkImageToImageFilterIUS2IVF22)
itkImageToImageFilterIUS2IVF22.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF22_SetDirectionTolerance, None, itkImageToImageFilterIUS2IVF22)
itkImageToImageFilterIUS2IVF22.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF22_GetDirectionTolerance, None, itkImageToImageFilterIUS2IVF22)
itkImageToImageFilterIUS2IVF22_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF22_swigregister
itkImageToImageFilterIUS2IVF22_swigregister(itkImageToImageFilterIUS2IVF22)

def itkImageToImageFilterIUS2IVF22_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS2IVF22 *":
    """itkImageToImageFilterIUS2IVF22_cast(itkLightObject obj) -> itkImageToImageFilterIUS2IVF22"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF22_cast(obj)

class itkImageToImageFilterIUS2IVF32(itkImageSourcePython.itkImageSourceIVF32):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUS2IVF32 self, itkImageUS2 image)
        SetInput(itkImageToImageFilterIUS2IVF32 self, unsigned int arg0, itkImageUS2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF32_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUS2 const *":
        """
        GetInput(itkImageToImageFilterIUS2IVF32 self) -> itkImageUS2
        GetInput(itkImageToImageFilterIUS2IVF32 self, unsigned int idx) -> itkImageUS2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF32_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUS2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUS2IVF32 self, itkImageUS2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF32_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUS2IVF32 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF32_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUS2') -> "void":
        """PushFrontInput(itkImageToImageFilterIUS2IVF32 self, itkImageUS2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF32_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUS2IVF32 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF32_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUS2IVF32 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF32_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUS2IVF32 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF32_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUS2IVF32 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF32_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUS2IVF32 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF32_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUS2IVF32

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS2IVF32 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUS2IVF32"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF32_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUS2IVF32

        Create a new object of the class itkImageToImageFilterIUS2IVF32 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUS2IVF32.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUS2IVF32.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUS2IVF32.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUS2IVF32.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF32_SetInput, None, itkImageToImageFilterIUS2IVF32)
itkImageToImageFilterIUS2IVF32.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF32_GetInput, None, itkImageToImageFilterIUS2IVF32)
itkImageToImageFilterIUS2IVF32.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF32_PushBackInput, None, itkImageToImageFilterIUS2IVF32)
itkImageToImageFilterIUS2IVF32.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF32_PopBackInput, None, itkImageToImageFilterIUS2IVF32)
itkImageToImageFilterIUS2IVF32.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF32_PushFrontInput, None, itkImageToImageFilterIUS2IVF32)
itkImageToImageFilterIUS2IVF32.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF32_PopFrontInput, None, itkImageToImageFilterIUS2IVF32)
itkImageToImageFilterIUS2IVF32.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF32_SetCoordinateTolerance, None, itkImageToImageFilterIUS2IVF32)
itkImageToImageFilterIUS2IVF32.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF32_GetCoordinateTolerance, None, itkImageToImageFilterIUS2IVF32)
itkImageToImageFilterIUS2IVF32.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF32_SetDirectionTolerance, None, itkImageToImageFilterIUS2IVF32)
itkImageToImageFilterIUS2IVF32.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF32_GetDirectionTolerance, None, itkImageToImageFilterIUS2IVF32)
itkImageToImageFilterIUS2IVF32_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF32_swigregister
itkImageToImageFilterIUS2IVF32_swigregister(itkImageToImageFilterIUS2IVF32)

def itkImageToImageFilterIUS2IVF32_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS2IVF32 *":
    """itkImageToImageFilterIUS2IVF32_cast(itkLightObject obj) -> itkImageToImageFilterIUS2IVF32"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF32_cast(obj)

class itkImageToImageFilterIUS2IVF42(itkImageSourcePython.itkImageSourceIVF42):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUS2IVF42 self, itkImageUS2 image)
        SetInput(itkImageToImageFilterIUS2IVF42 self, unsigned int arg0, itkImageUS2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF42_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUS2 const *":
        """
        GetInput(itkImageToImageFilterIUS2IVF42 self) -> itkImageUS2
        GetInput(itkImageToImageFilterIUS2IVF42 self, unsigned int idx) -> itkImageUS2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF42_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUS2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUS2IVF42 self, itkImageUS2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF42_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUS2IVF42 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF42_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUS2') -> "void":
        """PushFrontInput(itkImageToImageFilterIUS2IVF42 self, itkImageUS2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF42_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUS2IVF42 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF42_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUS2IVF42 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF42_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUS2IVF42 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF42_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUS2IVF42 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF42_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUS2IVF42 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF42_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUS2IVF42

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS2IVF42 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUS2IVF42"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF42_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUS2IVF42

        Create a new object of the class itkImageToImageFilterIUS2IVF42 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUS2IVF42.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUS2IVF42.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUS2IVF42.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUS2IVF42.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF42_SetInput, None, itkImageToImageFilterIUS2IVF42)
itkImageToImageFilterIUS2IVF42.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF42_GetInput, None, itkImageToImageFilterIUS2IVF42)
itkImageToImageFilterIUS2IVF42.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF42_PushBackInput, None, itkImageToImageFilterIUS2IVF42)
itkImageToImageFilterIUS2IVF42.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF42_PopBackInput, None, itkImageToImageFilterIUS2IVF42)
itkImageToImageFilterIUS2IVF42.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF42_PushFrontInput, None, itkImageToImageFilterIUS2IVF42)
itkImageToImageFilterIUS2IVF42.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF42_PopFrontInput, None, itkImageToImageFilterIUS2IVF42)
itkImageToImageFilterIUS2IVF42.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF42_SetCoordinateTolerance, None, itkImageToImageFilterIUS2IVF42)
itkImageToImageFilterIUS2IVF42.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF42_GetCoordinateTolerance, None, itkImageToImageFilterIUS2IVF42)
itkImageToImageFilterIUS2IVF42.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF42_SetDirectionTolerance, None, itkImageToImageFilterIUS2IVF42)
itkImageToImageFilterIUS2IVF42.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF42_GetDirectionTolerance, None, itkImageToImageFilterIUS2IVF42)
itkImageToImageFilterIUS2IVF42_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF42_swigregister
itkImageToImageFilterIUS2IVF42_swigregister(itkImageToImageFilterIUS2IVF42)

def itkImageToImageFilterIUS2IVF42_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS2IVF42 *":
    """itkImageToImageFilterIUS2IVF42_cast(itkLightObject obj) -> itkImageToImageFilterIUS2IVF42"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2IVF42_cast(obj)

class itkImageToImageFilterIUS2VID2(itkImageSourcePython.itkImageSourceVID2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUS2VID2 self, itkImageUS2 image)
        SetInput(itkImageToImageFilterIUS2VID2 self, unsigned int arg0, itkImageUS2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VID2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUS2 const *":
        """
        GetInput(itkImageToImageFilterIUS2VID2 self) -> itkImageUS2
        GetInput(itkImageToImageFilterIUS2VID2 self, unsigned int idx) -> itkImageUS2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VID2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUS2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUS2VID2 self, itkImageUS2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VID2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUS2VID2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VID2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUS2') -> "void":
        """PushFrontInput(itkImageToImageFilterIUS2VID2 self, itkImageUS2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VID2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUS2VID2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VID2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUS2VID2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VID2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUS2VID2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VID2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUS2VID2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VID2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUS2VID2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VID2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUS2VID2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS2VID2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUS2VID2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VID2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUS2VID2

        Create a new object of the class itkImageToImageFilterIUS2VID2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUS2VID2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUS2VID2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUS2VID2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUS2VID2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2VID2_SetInput, None, itkImageToImageFilterIUS2VID2)
itkImageToImageFilterIUS2VID2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2VID2_GetInput, None, itkImageToImageFilterIUS2VID2)
itkImageToImageFilterIUS2VID2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2VID2_PushBackInput, None, itkImageToImageFilterIUS2VID2)
itkImageToImageFilterIUS2VID2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2VID2_PopBackInput, None, itkImageToImageFilterIUS2VID2)
itkImageToImageFilterIUS2VID2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2VID2_PushFrontInput, None, itkImageToImageFilterIUS2VID2)
itkImageToImageFilterIUS2VID2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2VID2_PopFrontInput, None, itkImageToImageFilterIUS2VID2)
itkImageToImageFilterIUS2VID2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2VID2_SetCoordinateTolerance, None, itkImageToImageFilterIUS2VID2)
itkImageToImageFilterIUS2VID2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2VID2_GetCoordinateTolerance, None, itkImageToImageFilterIUS2VID2)
itkImageToImageFilterIUS2VID2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2VID2_SetDirectionTolerance, None, itkImageToImageFilterIUS2VID2)
itkImageToImageFilterIUS2VID2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2VID2_GetDirectionTolerance, None, itkImageToImageFilterIUS2VID2)
itkImageToImageFilterIUS2VID2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VID2_swigregister
itkImageToImageFilterIUS2VID2_swigregister(itkImageToImageFilterIUS2VID2)

def itkImageToImageFilterIUS2VID2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS2VID2 *":
    """itkImageToImageFilterIUS2VID2_cast(itkLightObject obj) -> itkImageToImageFilterIUS2VID2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VID2_cast(obj)

class itkImageToImageFilterIUS2VIF2(itkImageSourcePython.itkImageSourceVIF2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUS2VIF2 self, itkImageUS2 image)
        SetInput(itkImageToImageFilterIUS2VIF2 self, unsigned int arg0, itkImageUS2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIF2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUS2 const *":
        """
        GetInput(itkImageToImageFilterIUS2VIF2 self) -> itkImageUS2
        GetInput(itkImageToImageFilterIUS2VIF2 self, unsigned int idx) -> itkImageUS2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIF2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUS2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUS2VIF2 self, itkImageUS2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIF2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUS2VIF2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIF2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUS2') -> "void":
        """PushFrontInput(itkImageToImageFilterIUS2VIF2 self, itkImageUS2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIF2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUS2VIF2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIF2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUS2VIF2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIF2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUS2VIF2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIF2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUS2VIF2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIF2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUS2VIF2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIF2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUS2VIF2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS2VIF2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUS2VIF2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIF2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUS2VIF2

        Create a new object of the class itkImageToImageFilterIUS2VIF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUS2VIF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUS2VIF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUS2VIF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUS2VIF2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIF2_SetInput, None, itkImageToImageFilterIUS2VIF2)
itkImageToImageFilterIUS2VIF2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIF2_GetInput, None, itkImageToImageFilterIUS2VIF2)
itkImageToImageFilterIUS2VIF2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIF2_PushBackInput, None, itkImageToImageFilterIUS2VIF2)
itkImageToImageFilterIUS2VIF2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIF2_PopBackInput, None, itkImageToImageFilterIUS2VIF2)
itkImageToImageFilterIUS2VIF2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIF2_PushFrontInput, None, itkImageToImageFilterIUS2VIF2)
itkImageToImageFilterIUS2VIF2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIF2_PopFrontInput, None, itkImageToImageFilterIUS2VIF2)
itkImageToImageFilterIUS2VIF2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIF2_SetCoordinateTolerance, None, itkImageToImageFilterIUS2VIF2)
itkImageToImageFilterIUS2VIF2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIF2_GetCoordinateTolerance, None, itkImageToImageFilterIUS2VIF2)
itkImageToImageFilterIUS2VIF2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIF2_SetDirectionTolerance, None, itkImageToImageFilterIUS2VIF2)
itkImageToImageFilterIUS2VIF2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIF2_GetDirectionTolerance, None, itkImageToImageFilterIUS2VIF2)
itkImageToImageFilterIUS2VIF2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIF2_swigregister
itkImageToImageFilterIUS2VIF2_swigregister(itkImageToImageFilterIUS2VIF2)

def itkImageToImageFilterIUS2VIF2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS2VIF2 *":
    """itkImageToImageFilterIUS2VIF2_cast(itkLightObject obj) -> itkImageToImageFilterIUS2VIF2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIF2_cast(obj)

class itkImageToImageFilterIUS2VISS2(itkImageSourcePython.itkImageSourceVISS2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUS2VISS2 self, itkImageUS2 image)
        SetInput(itkImageToImageFilterIUS2VISS2 self, unsigned int arg0, itkImageUS2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VISS2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUS2 const *":
        """
        GetInput(itkImageToImageFilterIUS2VISS2 self) -> itkImageUS2
        GetInput(itkImageToImageFilterIUS2VISS2 self, unsigned int idx) -> itkImageUS2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VISS2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUS2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUS2VISS2 self, itkImageUS2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VISS2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUS2VISS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VISS2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUS2') -> "void":
        """PushFrontInput(itkImageToImageFilterIUS2VISS2 self, itkImageUS2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VISS2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUS2VISS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VISS2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUS2VISS2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VISS2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUS2VISS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VISS2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUS2VISS2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VISS2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUS2VISS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VISS2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUS2VISS2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS2VISS2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUS2VISS2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VISS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUS2VISS2

        Create a new object of the class itkImageToImageFilterIUS2VISS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUS2VISS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUS2VISS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUS2VISS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUS2VISS2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2VISS2_SetInput, None, itkImageToImageFilterIUS2VISS2)
itkImageToImageFilterIUS2VISS2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2VISS2_GetInput, None, itkImageToImageFilterIUS2VISS2)
itkImageToImageFilterIUS2VISS2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2VISS2_PushBackInput, None, itkImageToImageFilterIUS2VISS2)
itkImageToImageFilterIUS2VISS2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2VISS2_PopBackInput, None, itkImageToImageFilterIUS2VISS2)
itkImageToImageFilterIUS2VISS2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2VISS2_PushFrontInput, None, itkImageToImageFilterIUS2VISS2)
itkImageToImageFilterIUS2VISS2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2VISS2_PopFrontInput, None, itkImageToImageFilterIUS2VISS2)
itkImageToImageFilterIUS2VISS2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2VISS2_SetCoordinateTolerance, None, itkImageToImageFilterIUS2VISS2)
itkImageToImageFilterIUS2VISS2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2VISS2_GetCoordinateTolerance, None, itkImageToImageFilterIUS2VISS2)
itkImageToImageFilterIUS2VISS2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2VISS2_SetDirectionTolerance, None, itkImageToImageFilterIUS2VISS2)
itkImageToImageFilterIUS2VISS2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2VISS2_GetDirectionTolerance, None, itkImageToImageFilterIUS2VISS2)
itkImageToImageFilterIUS2VISS2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VISS2_swigregister
itkImageToImageFilterIUS2VISS2_swigregister(itkImageToImageFilterIUS2VISS2)

def itkImageToImageFilterIUS2VISS2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS2VISS2 *":
    """itkImageToImageFilterIUS2VISS2_cast(itkLightObject obj) -> itkImageToImageFilterIUS2VISS2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VISS2_cast(obj)

class itkImageToImageFilterIUS2VIUC2(itkImageSourcePython.itkImageSourceVIUC2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUS2VIUC2 self, itkImageUS2 image)
        SetInput(itkImageToImageFilterIUS2VIUC2 self, unsigned int arg0, itkImageUS2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIUC2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUS2 const *":
        """
        GetInput(itkImageToImageFilterIUS2VIUC2 self) -> itkImageUS2
        GetInput(itkImageToImageFilterIUS2VIUC2 self, unsigned int idx) -> itkImageUS2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIUC2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUS2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUS2VIUC2 self, itkImageUS2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIUC2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUS2VIUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIUC2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUS2') -> "void":
        """PushFrontInput(itkImageToImageFilterIUS2VIUC2 self, itkImageUS2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIUC2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUS2VIUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIUC2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUS2VIUC2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIUC2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUS2VIUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIUC2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUS2VIUC2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIUC2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUS2VIUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIUC2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUS2VIUC2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS2VIUC2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUS2VIUC2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIUC2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUS2VIUC2

        Create a new object of the class itkImageToImageFilterIUS2VIUC2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUS2VIUC2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUS2VIUC2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUS2VIUC2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUS2VIUC2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIUC2_SetInput, None, itkImageToImageFilterIUS2VIUC2)
itkImageToImageFilterIUS2VIUC2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIUC2_GetInput, None, itkImageToImageFilterIUS2VIUC2)
itkImageToImageFilterIUS2VIUC2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIUC2_PushBackInput, None, itkImageToImageFilterIUS2VIUC2)
itkImageToImageFilterIUS2VIUC2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIUC2_PopBackInput, None, itkImageToImageFilterIUS2VIUC2)
itkImageToImageFilterIUS2VIUC2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIUC2_PushFrontInput, None, itkImageToImageFilterIUS2VIUC2)
itkImageToImageFilterIUS2VIUC2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIUC2_PopFrontInput, None, itkImageToImageFilterIUS2VIUC2)
itkImageToImageFilterIUS2VIUC2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIUC2_SetCoordinateTolerance, None, itkImageToImageFilterIUS2VIUC2)
itkImageToImageFilterIUS2VIUC2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIUC2_GetCoordinateTolerance, None, itkImageToImageFilterIUS2VIUC2)
itkImageToImageFilterIUS2VIUC2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIUC2_SetDirectionTolerance, None, itkImageToImageFilterIUS2VIUC2)
itkImageToImageFilterIUS2VIUC2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIUC2_GetDirectionTolerance, None, itkImageToImageFilterIUS2VIUC2)
itkImageToImageFilterIUS2VIUC2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIUC2_swigregister
itkImageToImageFilterIUS2VIUC2_swigregister(itkImageToImageFilterIUS2VIUC2)

def itkImageToImageFilterIUS2VIUC2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS2VIUC2 *":
    """itkImageToImageFilterIUS2VIUC2_cast(itkLightObject obj) -> itkImageToImageFilterIUS2VIUC2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIUC2_cast(obj)

class itkImageToImageFilterIUS2VIUS2(itkImageSourcePython.itkImageSourceVIUS2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUS2VIUS2 self, itkImageUS2 image)
        SetInput(itkImageToImageFilterIUS2VIUS2 self, unsigned int arg0, itkImageUS2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIUS2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUS2 const *":
        """
        GetInput(itkImageToImageFilterIUS2VIUS2 self) -> itkImageUS2
        GetInput(itkImageToImageFilterIUS2VIUS2 self, unsigned int idx) -> itkImageUS2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIUS2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUS2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUS2VIUS2 self, itkImageUS2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIUS2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUS2VIUS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIUS2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUS2') -> "void":
        """PushFrontInput(itkImageToImageFilterIUS2VIUS2 self, itkImageUS2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIUS2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUS2VIUS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIUS2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUS2VIUS2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIUS2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUS2VIUS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIUS2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUS2VIUS2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIUS2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUS2VIUS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIUS2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUS2VIUS2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS2VIUS2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUS2VIUS2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIUS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUS2VIUS2

        Create a new object of the class itkImageToImageFilterIUS2VIUS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUS2VIUS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUS2VIUS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUS2VIUS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUS2VIUS2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIUS2_SetInput, None, itkImageToImageFilterIUS2VIUS2)
itkImageToImageFilterIUS2VIUS2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIUS2_GetInput, None, itkImageToImageFilterIUS2VIUS2)
itkImageToImageFilterIUS2VIUS2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIUS2_PushBackInput, None, itkImageToImageFilterIUS2VIUS2)
itkImageToImageFilterIUS2VIUS2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIUS2_PopBackInput, None, itkImageToImageFilterIUS2VIUS2)
itkImageToImageFilterIUS2VIUS2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIUS2_PushFrontInput, None, itkImageToImageFilterIUS2VIUS2)
itkImageToImageFilterIUS2VIUS2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIUS2_PopFrontInput, None, itkImageToImageFilterIUS2VIUS2)
itkImageToImageFilterIUS2VIUS2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIUS2_SetCoordinateTolerance, None, itkImageToImageFilterIUS2VIUS2)
itkImageToImageFilterIUS2VIUS2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIUS2_GetCoordinateTolerance, None, itkImageToImageFilterIUS2VIUS2)
itkImageToImageFilterIUS2VIUS2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIUS2_SetDirectionTolerance, None, itkImageToImageFilterIUS2VIUS2)
itkImageToImageFilterIUS2VIUS2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIUS2_GetDirectionTolerance, None, itkImageToImageFilterIUS2VIUS2)
itkImageToImageFilterIUS2VIUS2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIUS2_swigregister
itkImageToImageFilterIUS2VIUS2_swigregister(itkImageToImageFilterIUS2VIUS2)

def itkImageToImageFilterIUS2VIUS2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS2VIUS2 *":
    """itkImageToImageFilterIUS2VIUS2_cast(itkLightObject obj) -> itkImageToImageFilterIUS2VIUS2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUS2VIUS2_cast(obj)

class itkImageToImageFilterIUS3ICF3(itkImageSourcePython.itkImageSourceICF3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUS3ICF3 self, itkImageUS3 image)
        SetInput(itkImageToImageFilterIUS3ICF3 self, unsigned int arg0, itkImageUS3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICF3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUS3 const *":
        """
        GetInput(itkImageToImageFilterIUS3ICF3 self) -> itkImageUS3
        GetInput(itkImageToImageFilterIUS3ICF3 self, unsigned int idx) -> itkImageUS3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICF3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUS3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUS3ICF3 self, itkImageUS3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICF3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUS3ICF3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICF3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUS3') -> "void":
        """PushFrontInput(itkImageToImageFilterIUS3ICF3 self, itkImageUS3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICF3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUS3ICF3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICF3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUS3ICF3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICF3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUS3ICF3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICF3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUS3ICF3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICF3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUS3ICF3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICF3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUS3ICF3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS3ICF3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUS3ICF3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICF3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUS3ICF3

        Create a new object of the class itkImageToImageFilterIUS3ICF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUS3ICF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUS3ICF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUS3ICF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUS3ICF3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICF3_SetInput, None, itkImageToImageFilterIUS3ICF3)
itkImageToImageFilterIUS3ICF3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICF3_GetInput, None, itkImageToImageFilterIUS3ICF3)
itkImageToImageFilterIUS3ICF3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICF3_PushBackInput, None, itkImageToImageFilterIUS3ICF3)
itkImageToImageFilterIUS3ICF3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICF3_PopBackInput, None, itkImageToImageFilterIUS3ICF3)
itkImageToImageFilterIUS3ICF3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICF3_PushFrontInput, None, itkImageToImageFilterIUS3ICF3)
itkImageToImageFilterIUS3ICF3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICF3_PopFrontInput, None, itkImageToImageFilterIUS3ICF3)
itkImageToImageFilterIUS3ICF3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICF3_SetCoordinateTolerance, None, itkImageToImageFilterIUS3ICF3)
itkImageToImageFilterIUS3ICF3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICF3_GetCoordinateTolerance, None, itkImageToImageFilterIUS3ICF3)
itkImageToImageFilterIUS3ICF3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICF3_SetDirectionTolerance, None, itkImageToImageFilterIUS3ICF3)
itkImageToImageFilterIUS3ICF3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICF3_GetDirectionTolerance, None, itkImageToImageFilterIUS3ICF3)
itkImageToImageFilterIUS3ICF3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICF3_swigregister
itkImageToImageFilterIUS3ICF3_swigregister(itkImageToImageFilterIUS3ICF3)

def itkImageToImageFilterIUS3ICF3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS3ICF3 *":
    """itkImageToImageFilterIUS3ICF3_cast(itkLightObject obj) -> itkImageToImageFilterIUS3ICF3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICF3_cast(obj)

class itkImageToImageFilterIUS3ICVF23(itkImageSourcePython.itkImageSourceICVF23):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUS3ICVF23 self, itkImageUS3 image)
        SetInput(itkImageToImageFilterIUS3ICVF23 self, unsigned int arg0, itkImageUS3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF23_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUS3 const *":
        """
        GetInput(itkImageToImageFilterIUS3ICVF23 self) -> itkImageUS3
        GetInput(itkImageToImageFilterIUS3ICVF23 self, unsigned int idx) -> itkImageUS3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF23_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUS3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUS3ICVF23 self, itkImageUS3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF23_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUS3ICVF23 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF23_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUS3') -> "void":
        """PushFrontInput(itkImageToImageFilterIUS3ICVF23 self, itkImageUS3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF23_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUS3ICVF23 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF23_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUS3ICVF23 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF23_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUS3ICVF23 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF23_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUS3ICVF23 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF23_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUS3ICVF23 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF23_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUS3ICVF23

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS3ICVF23 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUS3ICVF23"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF23_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUS3ICVF23

        Create a new object of the class itkImageToImageFilterIUS3ICVF23 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUS3ICVF23.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUS3ICVF23.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUS3ICVF23.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUS3ICVF23.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF23_SetInput, None, itkImageToImageFilterIUS3ICVF23)
itkImageToImageFilterIUS3ICVF23.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF23_GetInput, None, itkImageToImageFilterIUS3ICVF23)
itkImageToImageFilterIUS3ICVF23.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF23_PushBackInput, None, itkImageToImageFilterIUS3ICVF23)
itkImageToImageFilterIUS3ICVF23.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF23_PopBackInput, None, itkImageToImageFilterIUS3ICVF23)
itkImageToImageFilterIUS3ICVF23.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF23_PushFrontInput, None, itkImageToImageFilterIUS3ICVF23)
itkImageToImageFilterIUS3ICVF23.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF23_PopFrontInput, None, itkImageToImageFilterIUS3ICVF23)
itkImageToImageFilterIUS3ICVF23.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF23_SetCoordinateTolerance, None, itkImageToImageFilterIUS3ICVF23)
itkImageToImageFilterIUS3ICVF23.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF23_GetCoordinateTolerance, None, itkImageToImageFilterIUS3ICVF23)
itkImageToImageFilterIUS3ICVF23.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF23_SetDirectionTolerance, None, itkImageToImageFilterIUS3ICVF23)
itkImageToImageFilterIUS3ICVF23.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF23_GetDirectionTolerance, None, itkImageToImageFilterIUS3ICVF23)
itkImageToImageFilterIUS3ICVF23_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF23_swigregister
itkImageToImageFilterIUS3ICVF23_swigregister(itkImageToImageFilterIUS3ICVF23)

def itkImageToImageFilterIUS3ICVF23_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS3ICVF23 *":
    """itkImageToImageFilterIUS3ICVF23_cast(itkLightObject obj) -> itkImageToImageFilterIUS3ICVF23"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF23_cast(obj)

class itkImageToImageFilterIUS3ICVF33(itkImageSourcePython.itkImageSourceICVF33):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUS3ICVF33 self, itkImageUS3 image)
        SetInput(itkImageToImageFilterIUS3ICVF33 self, unsigned int arg0, itkImageUS3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF33_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUS3 const *":
        """
        GetInput(itkImageToImageFilterIUS3ICVF33 self) -> itkImageUS3
        GetInput(itkImageToImageFilterIUS3ICVF33 self, unsigned int idx) -> itkImageUS3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF33_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUS3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUS3ICVF33 self, itkImageUS3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF33_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUS3ICVF33 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF33_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUS3') -> "void":
        """PushFrontInput(itkImageToImageFilterIUS3ICVF33 self, itkImageUS3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF33_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUS3ICVF33 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF33_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUS3ICVF33 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF33_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUS3ICVF33 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF33_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUS3ICVF33 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF33_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUS3ICVF33 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF33_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUS3ICVF33

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS3ICVF33 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUS3ICVF33"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF33_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUS3ICVF33

        Create a new object of the class itkImageToImageFilterIUS3ICVF33 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUS3ICVF33.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUS3ICVF33.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUS3ICVF33.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUS3ICVF33.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF33_SetInput, None, itkImageToImageFilterIUS3ICVF33)
itkImageToImageFilterIUS3ICVF33.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF33_GetInput, None, itkImageToImageFilterIUS3ICVF33)
itkImageToImageFilterIUS3ICVF33.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF33_PushBackInput, None, itkImageToImageFilterIUS3ICVF33)
itkImageToImageFilterIUS3ICVF33.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF33_PopBackInput, None, itkImageToImageFilterIUS3ICVF33)
itkImageToImageFilterIUS3ICVF33.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF33_PushFrontInput, None, itkImageToImageFilterIUS3ICVF33)
itkImageToImageFilterIUS3ICVF33.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF33_PopFrontInput, None, itkImageToImageFilterIUS3ICVF33)
itkImageToImageFilterIUS3ICVF33.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF33_SetCoordinateTolerance, None, itkImageToImageFilterIUS3ICVF33)
itkImageToImageFilterIUS3ICVF33.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF33_GetCoordinateTolerance, None, itkImageToImageFilterIUS3ICVF33)
itkImageToImageFilterIUS3ICVF33.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF33_SetDirectionTolerance, None, itkImageToImageFilterIUS3ICVF33)
itkImageToImageFilterIUS3ICVF33.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF33_GetDirectionTolerance, None, itkImageToImageFilterIUS3ICVF33)
itkImageToImageFilterIUS3ICVF33_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF33_swigregister
itkImageToImageFilterIUS3ICVF33_swigregister(itkImageToImageFilterIUS3ICVF33)

def itkImageToImageFilterIUS3ICVF33_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS3ICVF33 *":
    """itkImageToImageFilterIUS3ICVF33_cast(itkLightObject obj) -> itkImageToImageFilterIUS3ICVF33"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF33_cast(obj)

class itkImageToImageFilterIUS3ICVF43(itkImageSourcePython.itkImageSourceICVF43):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUS3ICVF43 self, itkImageUS3 image)
        SetInput(itkImageToImageFilterIUS3ICVF43 self, unsigned int arg0, itkImageUS3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF43_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUS3 const *":
        """
        GetInput(itkImageToImageFilterIUS3ICVF43 self) -> itkImageUS3
        GetInput(itkImageToImageFilterIUS3ICVF43 self, unsigned int idx) -> itkImageUS3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF43_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUS3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUS3ICVF43 self, itkImageUS3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF43_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUS3ICVF43 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF43_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUS3') -> "void":
        """PushFrontInput(itkImageToImageFilterIUS3ICVF43 self, itkImageUS3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF43_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUS3ICVF43 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF43_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUS3ICVF43 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF43_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUS3ICVF43 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF43_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUS3ICVF43 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF43_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUS3ICVF43 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF43_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUS3ICVF43

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS3ICVF43 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUS3ICVF43"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF43_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUS3ICVF43

        Create a new object of the class itkImageToImageFilterIUS3ICVF43 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUS3ICVF43.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUS3ICVF43.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUS3ICVF43.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUS3ICVF43.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF43_SetInput, None, itkImageToImageFilterIUS3ICVF43)
itkImageToImageFilterIUS3ICVF43.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF43_GetInput, None, itkImageToImageFilterIUS3ICVF43)
itkImageToImageFilterIUS3ICVF43.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF43_PushBackInput, None, itkImageToImageFilterIUS3ICVF43)
itkImageToImageFilterIUS3ICVF43.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF43_PopBackInput, None, itkImageToImageFilterIUS3ICVF43)
itkImageToImageFilterIUS3ICVF43.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF43_PushFrontInput, None, itkImageToImageFilterIUS3ICVF43)
itkImageToImageFilterIUS3ICVF43.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF43_PopFrontInput, None, itkImageToImageFilterIUS3ICVF43)
itkImageToImageFilterIUS3ICVF43.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF43_SetCoordinateTolerance, None, itkImageToImageFilterIUS3ICVF43)
itkImageToImageFilterIUS3ICVF43.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF43_GetCoordinateTolerance, None, itkImageToImageFilterIUS3ICVF43)
itkImageToImageFilterIUS3ICVF43.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF43_SetDirectionTolerance, None, itkImageToImageFilterIUS3ICVF43)
itkImageToImageFilterIUS3ICVF43.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF43_GetDirectionTolerance, None, itkImageToImageFilterIUS3ICVF43)
itkImageToImageFilterIUS3ICVF43_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF43_swigregister
itkImageToImageFilterIUS3ICVF43_swigregister(itkImageToImageFilterIUS3ICVF43)

def itkImageToImageFilterIUS3ICVF43_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS3ICVF43 *":
    """itkImageToImageFilterIUS3ICVF43_cast(itkLightObject obj) -> itkImageToImageFilterIUS3ICVF43"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ICVF43_cast(obj)

class itkImageToImageFilterIUS3IRGBAUC3(itkImageSourcePython.itkImageSourceIRGBAUC3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUS3IRGBAUC3 self, itkImageUS3 image)
        SetInput(itkImageToImageFilterIUS3IRGBAUC3 self, unsigned int arg0, itkImageUS3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IRGBAUC3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUS3 const *":
        """
        GetInput(itkImageToImageFilterIUS3IRGBAUC3 self) -> itkImageUS3
        GetInput(itkImageToImageFilterIUS3IRGBAUC3 self, unsigned int idx) -> itkImageUS3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IRGBAUC3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUS3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUS3IRGBAUC3 self, itkImageUS3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IRGBAUC3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUS3IRGBAUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IRGBAUC3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUS3') -> "void":
        """PushFrontInput(itkImageToImageFilterIUS3IRGBAUC3 self, itkImageUS3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IRGBAUC3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUS3IRGBAUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IRGBAUC3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUS3IRGBAUC3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IRGBAUC3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUS3IRGBAUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IRGBAUC3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUS3IRGBAUC3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IRGBAUC3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUS3IRGBAUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IRGBAUC3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUS3IRGBAUC3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS3IRGBAUC3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUS3IRGBAUC3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IRGBAUC3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUS3IRGBAUC3

        Create a new object of the class itkImageToImageFilterIUS3IRGBAUC3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUS3IRGBAUC3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUS3IRGBAUC3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUS3IRGBAUC3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUS3IRGBAUC3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3IRGBAUC3_SetInput, None, itkImageToImageFilterIUS3IRGBAUC3)
itkImageToImageFilterIUS3IRGBAUC3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3IRGBAUC3_GetInput, None, itkImageToImageFilterIUS3IRGBAUC3)
itkImageToImageFilterIUS3IRGBAUC3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3IRGBAUC3_PushBackInput, None, itkImageToImageFilterIUS3IRGBAUC3)
itkImageToImageFilterIUS3IRGBAUC3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3IRGBAUC3_PopBackInput, None, itkImageToImageFilterIUS3IRGBAUC3)
itkImageToImageFilterIUS3IRGBAUC3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3IRGBAUC3_PushFrontInput, None, itkImageToImageFilterIUS3IRGBAUC3)
itkImageToImageFilterIUS3IRGBAUC3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3IRGBAUC3_PopFrontInput, None, itkImageToImageFilterIUS3IRGBAUC3)
itkImageToImageFilterIUS3IRGBAUC3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3IRGBAUC3_SetCoordinateTolerance, None, itkImageToImageFilterIUS3IRGBAUC3)
itkImageToImageFilterIUS3IRGBAUC3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3IRGBAUC3_GetCoordinateTolerance, None, itkImageToImageFilterIUS3IRGBAUC3)
itkImageToImageFilterIUS3IRGBAUC3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3IRGBAUC3_SetDirectionTolerance, None, itkImageToImageFilterIUS3IRGBAUC3)
itkImageToImageFilterIUS3IRGBAUC3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3IRGBAUC3_GetDirectionTolerance, None, itkImageToImageFilterIUS3IRGBAUC3)
itkImageToImageFilterIUS3IRGBAUC3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IRGBAUC3_swigregister
itkImageToImageFilterIUS3IRGBAUC3_swigregister(itkImageToImageFilterIUS3IRGBAUC3)

def itkImageToImageFilterIUS3IRGBAUC3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS3IRGBAUC3 *":
    """itkImageToImageFilterIUS3IRGBAUC3_cast(itkLightObject obj) -> itkImageToImageFilterIUS3IRGBAUC3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IRGBAUC3_cast(obj)

class itkImageToImageFilterIUS3IRGBUC3(itkImageSourcePython.itkImageSourceIRGBUC3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUS3IRGBUC3 self, itkImageUS3 image)
        SetInput(itkImageToImageFilterIUS3IRGBUC3 self, unsigned int arg0, itkImageUS3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IRGBUC3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUS3 const *":
        """
        GetInput(itkImageToImageFilterIUS3IRGBUC3 self) -> itkImageUS3
        GetInput(itkImageToImageFilterIUS3IRGBUC3 self, unsigned int idx) -> itkImageUS3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IRGBUC3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUS3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUS3IRGBUC3 self, itkImageUS3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IRGBUC3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUS3IRGBUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IRGBUC3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUS3') -> "void":
        """PushFrontInput(itkImageToImageFilterIUS3IRGBUC3 self, itkImageUS3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IRGBUC3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUS3IRGBUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IRGBUC3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUS3IRGBUC3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IRGBUC3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUS3IRGBUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IRGBUC3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUS3IRGBUC3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IRGBUC3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUS3IRGBUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IRGBUC3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUS3IRGBUC3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS3IRGBUC3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUS3IRGBUC3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IRGBUC3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUS3IRGBUC3

        Create a new object of the class itkImageToImageFilterIUS3IRGBUC3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUS3IRGBUC3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUS3IRGBUC3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUS3IRGBUC3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUS3IRGBUC3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3IRGBUC3_SetInput, None, itkImageToImageFilterIUS3IRGBUC3)
itkImageToImageFilterIUS3IRGBUC3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3IRGBUC3_GetInput, None, itkImageToImageFilterIUS3IRGBUC3)
itkImageToImageFilterIUS3IRGBUC3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3IRGBUC3_PushBackInput, None, itkImageToImageFilterIUS3IRGBUC3)
itkImageToImageFilterIUS3IRGBUC3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3IRGBUC3_PopBackInput, None, itkImageToImageFilterIUS3IRGBUC3)
itkImageToImageFilterIUS3IRGBUC3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3IRGBUC3_PushFrontInput, None, itkImageToImageFilterIUS3IRGBUC3)
itkImageToImageFilterIUS3IRGBUC3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3IRGBUC3_PopFrontInput, None, itkImageToImageFilterIUS3IRGBUC3)
itkImageToImageFilterIUS3IRGBUC3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3IRGBUC3_SetCoordinateTolerance, None, itkImageToImageFilterIUS3IRGBUC3)
itkImageToImageFilterIUS3IRGBUC3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3IRGBUC3_GetCoordinateTolerance, None, itkImageToImageFilterIUS3IRGBUC3)
itkImageToImageFilterIUS3IRGBUC3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3IRGBUC3_SetDirectionTolerance, None, itkImageToImageFilterIUS3IRGBUC3)
itkImageToImageFilterIUS3IRGBUC3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3IRGBUC3_GetDirectionTolerance, None, itkImageToImageFilterIUS3IRGBUC3)
itkImageToImageFilterIUS3IRGBUC3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IRGBUC3_swigregister
itkImageToImageFilterIUS3IRGBUC3_swigregister(itkImageToImageFilterIUS3IRGBUC3)

def itkImageToImageFilterIUS3IRGBUC3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS3IRGBUC3 *":
    """itkImageToImageFilterIUS3IRGBUC3_cast(itkLightObject obj) -> itkImageToImageFilterIUS3IRGBUC3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IRGBUC3_cast(obj)

class itkImageToImageFilterIUS3ISSRTD33(itkImageSourcePython.itkImageSourceISSRTD33):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUS3ISSRTD33 self, itkImageUS3 image)
        SetInput(itkImageToImageFilterIUS3ISSRTD33 self, unsigned int arg0, itkImageUS3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ISSRTD33_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUS3 const *":
        """
        GetInput(itkImageToImageFilterIUS3ISSRTD33 self) -> itkImageUS3
        GetInput(itkImageToImageFilterIUS3ISSRTD33 self, unsigned int idx) -> itkImageUS3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ISSRTD33_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUS3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUS3ISSRTD33 self, itkImageUS3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ISSRTD33_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUS3ISSRTD33 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ISSRTD33_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUS3') -> "void":
        """PushFrontInput(itkImageToImageFilterIUS3ISSRTD33 self, itkImageUS3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ISSRTD33_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUS3ISSRTD33 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ISSRTD33_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUS3ISSRTD33 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ISSRTD33_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUS3ISSRTD33 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ISSRTD33_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUS3ISSRTD33 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ISSRTD33_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUS3ISSRTD33 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ISSRTD33_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUS3ISSRTD33

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS3ISSRTD33 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUS3ISSRTD33"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ISSRTD33_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUS3ISSRTD33

        Create a new object of the class itkImageToImageFilterIUS3ISSRTD33 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUS3ISSRTD33.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUS3ISSRTD33.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUS3ISSRTD33.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUS3ISSRTD33.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3ISSRTD33_SetInput, None, itkImageToImageFilterIUS3ISSRTD33)
itkImageToImageFilterIUS3ISSRTD33.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3ISSRTD33_GetInput, None, itkImageToImageFilterIUS3ISSRTD33)
itkImageToImageFilterIUS3ISSRTD33.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3ISSRTD33_PushBackInput, None, itkImageToImageFilterIUS3ISSRTD33)
itkImageToImageFilterIUS3ISSRTD33.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3ISSRTD33_PopBackInput, None, itkImageToImageFilterIUS3ISSRTD33)
itkImageToImageFilterIUS3ISSRTD33.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3ISSRTD33_PushFrontInput, None, itkImageToImageFilterIUS3ISSRTD33)
itkImageToImageFilterIUS3ISSRTD33.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3ISSRTD33_PopFrontInput, None, itkImageToImageFilterIUS3ISSRTD33)
itkImageToImageFilterIUS3ISSRTD33.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3ISSRTD33_SetCoordinateTolerance, None, itkImageToImageFilterIUS3ISSRTD33)
itkImageToImageFilterIUS3ISSRTD33.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3ISSRTD33_GetCoordinateTolerance, None, itkImageToImageFilterIUS3ISSRTD33)
itkImageToImageFilterIUS3ISSRTD33.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3ISSRTD33_SetDirectionTolerance, None, itkImageToImageFilterIUS3ISSRTD33)
itkImageToImageFilterIUS3ISSRTD33.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3ISSRTD33_GetDirectionTolerance, None, itkImageToImageFilterIUS3ISSRTD33)
itkImageToImageFilterIUS3ISSRTD33_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ISSRTD33_swigregister
itkImageToImageFilterIUS3ISSRTD33_swigregister(itkImageToImageFilterIUS3ISSRTD33)

def itkImageToImageFilterIUS3ISSRTD33_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS3ISSRTD33 *":
    """itkImageToImageFilterIUS3ISSRTD33_cast(itkLightObject obj) -> itkImageToImageFilterIUS3ISSRTD33"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3ISSRTD33_cast(obj)

class itkImageToImageFilterIUS3IUS2(itkImageSourcePython.itkImageSourceIUS2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUS3IUS2 self, itkImageUS3 image)
        SetInput(itkImageToImageFilterIUS3IUS2 self, unsigned int arg0, itkImageUS3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IUS2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUS3 const *":
        """
        GetInput(itkImageToImageFilterIUS3IUS2 self) -> itkImageUS3
        GetInput(itkImageToImageFilterIUS3IUS2 self, unsigned int idx) -> itkImageUS3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IUS2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUS3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUS3IUS2 self, itkImageUS3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IUS2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUS3IUS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IUS2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUS3') -> "void":
        """PushFrontInput(itkImageToImageFilterIUS3IUS2 self, itkImageUS3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IUS2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUS3IUS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IUS2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUS3IUS2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IUS2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUS3IUS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IUS2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUS3IUS2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IUS2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUS3IUS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IUS2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUS3IUS2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS3IUS2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUS3IUS2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IUS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUS3IUS2

        Create a new object of the class itkImageToImageFilterIUS3IUS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUS3IUS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUS3IUS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUS3IUS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUS3IUS2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3IUS2_SetInput, None, itkImageToImageFilterIUS3IUS2)
itkImageToImageFilterIUS3IUS2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3IUS2_GetInput, None, itkImageToImageFilterIUS3IUS2)
itkImageToImageFilterIUS3IUS2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3IUS2_PushBackInput, None, itkImageToImageFilterIUS3IUS2)
itkImageToImageFilterIUS3IUS2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3IUS2_PopBackInput, None, itkImageToImageFilterIUS3IUS2)
itkImageToImageFilterIUS3IUS2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3IUS2_PushFrontInput, None, itkImageToImageFilterIUS3IUS2)
itkImageToImageFilterIUS3IUS2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3IUS2_PopFrontInput, None, itkImageToImageFilterIUS3IUS2)
itkImageToImageFilterIUS3IUS2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3IUS2_SetCoordinateTolerance, None, itkImageToImageFilterIUS3IUS2)
itkImageToImageFilterIUS3IUS2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3IUS2_GetCoordinateTolerance, None, itkImageToImageFilterIUS3IUS2)
itkImageToImageFilterIUS3IUS2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3IUS2_SetDirectionTolerance, None, itkImageToImageFilterIUS3IUS2)
itkImageToImageFilterIUS3IUS2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3IUS2_GetDirectionTolerance, None, itkImageToImageFilterIUS3IUS2)
itkImageToImageFilterIUS3IUS2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IUS2_swigregister
itkImageToImageFilterIUS3IUS2_swigregister(itkImageToImageFilterIUS3IUS2)

def itkImageToImageFilterIUS3IUS2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS3IUS2 *":
    """itkImageToImageFilterIUS3IUS2_cast(itkLightObject obj) -> itkImageToImageFilterIUS3IUS2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IUS2_cast(obj)

class itkImageToImageFilterIUS3IVF23(itkImageSourcePython.itkImageSourceIVF23):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUS3IVF23 self, itkImageUS3 image)
        SetInput(itkImageToImageFilterIUS3IVF23 self, unsigned int arg0, itkImageUS3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF23_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUS3 const *":
        """
        GetInput(itkImageToImageFilterIUS3IVF23 self) -> itkImageUS3
        GetInput(itkImageToImageFilterIUS3IVF23 self, unsigned int idx) -> itkImageUS3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF23_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUS3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUS3IVF23 self, itkImageUS3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF23_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUS3IVF23 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF23_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUS3') -> "void":
        """PushFrontInput(itkImageToImageFilterIUS3IVF23 self, itkImageUS3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF23_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUS3IVF23 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF23_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUS3IVF23 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF23_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUS3IVF23 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF23_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUS3IVF23 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF23_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUS3IVF23 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF23_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUS3IVF23

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS3IVF23 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUS3IVF23"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF23_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUS3IVF23

        Create a new object of the class itkImageToImageFilterIUS3IVF23 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUS3IVF23.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUS3IVF23.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUS3IVF23.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUS3IVF23.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF23_SetInput, None, itkImageToImageFilterIUS3IVF23)
itkImageToImageFilterIUS3IVF23.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF23_GetInput, None, itkImageToImageFilterIUS3IVF23)
itkImageToImageFilterIUS3IVF23.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF23_PushBackInput, None, itkImageToImageFilterIUS3IVF23)
itkImageToImageFilterIUS3IVF23.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF23_PopBackInput, None, itkImageToImageFilterIUS3IVF23)
itkImageToImageFilterIUS3IVF23.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF23_PushFrontInput, None, itkImageToImageFilterIUS3IVF23)
itkImageToImageFilterIUS3IVF23.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF23_PopFrontInput, None, itkImageToImageFilterIUS3IVF23)
itkImageToImageFilterIUS3IVF23.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF23_SetCoordinateTolerance, None, itkImageToImageFilterIUS3IVF23)
itkImageToImageFilterIUS3IVF23.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF23_GetCoordinateTolerance, None, itkImageToImageFilterIUS3IVF23)
itkImageToImageFilterIUS3IVF23.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF23_SetDirectionTolerance, None, itkImageToImageFilterIUS3IVF23)
itkImageToImageFilterIUS3IVF23.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF23_GetDirectionTolerance, None, itkImageToImageFilterIUS3IVF23)
itkImageToImageFilterIUS3IVF23_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF23_swigregister
itkImageToImageFilterIUS3IVF23_swigregister(itkImageToImageFilterIUS3IVF23)

def itkImageToImageFilterIUS3IVF23_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS3IVF23 *":
    """itkImageToImageFilterIUS3IVF23_cast(itkLightObject obj) -> itkImageToImageFilterIUS3IVF23"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF23_cast(obj)

class itkImageToImageFilterIUS3IVF33(itkImageSourcePython.itkImageSourceIVF33):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUS3IVF33 self, itkImageUS3 image)
        SetInput(itkImageToImageFilterIUS3IVF33 self, unsigned int arg0, itkImageUS3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF33_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUS3 const *":
        """
        GetInput(itkImageToImageFilterIUS3IVF33 self) -> itkImageUS3
        GetInput(itkImageToImageFilterIUS3IVF33 self, unsigned int idx) -> itkImageUS3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF33_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUS3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUS3IVF33 self, itkImageUS3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF33_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUS3IVF33 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF33_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUS3') -> "void":
        """PushFrontInput(itkImageToImageFilterIUS3IVF33 self, itkImageUS3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF33_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUS3IVF33 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF33_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUS3IVF33 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF33_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUS3IVF33 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF33_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUS3IVF33 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF33_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUS3IVF33 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF33_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUS3IVF33

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS3IVF33 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUS3IVF33"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF33_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUS3IVF33

        Create a new object of the class itkImageToImageFilterIUS3IVF33 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUS3IVF33.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUS3IVF33.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUS3IVF33.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUS3IVF33.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF33_SetInput, None, itkImageToImageFilterIUS3IVF33)
itkImageToImageFilterIUS3IVF33.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF33_GetInput, None, itkImageToImageFilterIUS3IVF33)
itkImageToImageFilterIUS3IVF33.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF33_PushBackInput, None, itkImageToImageFilterIUS3IVF33)
itkImageToImageFilterIUS3IVF33.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF33_PopBackInput, None, itkImageToImageFilterIUS3IVF33)
itkImageToImageFilterIUS3IVF33.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF33_PushFrontInput, None, itkImageToImageFilterIUS3IVF33)
itkImageToImageFilterIUS3IVF33.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF33_PopFrontInput, None, itkImageToImageFilterIUS3IVF33)
itkImageToImageFilterIUS3IVF33.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF33_SetCoordinateTolerance, None, itkImageToImageFilterIUS3IVF33)
itkImageToImageFilterIUS3IVF33.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF33_GetCoordinateTolerance, None, itkImageToImageFilterIUS3IVF33)
itkImageToImageFilterIUS3IVF33.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF33_SetDirectionTolerance, None, itkImageToImageFilterIUS3IVF33)
itkImageToImageFilterIUS3IVF33.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF33_GetDirectionTolerance, None, itkImageToImageFilterIUS3IVF33)
itkImageToImageFilterIUS3IVF33_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF33_swigregister
itkImageToImageFilterIUS3IVF33_swigregister(itkImageToImageFilterIUS3IVF33)

def itkImageToImageFilterIUS3IVF33_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS3IVF33 *":
    """itkImageToImageFilterIUS3IVF33_cast(itkLightObject obj) -> itkImageToImageFilterIUS3IVF33"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF33_cast(obj)

class itkImageToImageFilterIUS3IVF43(itkImageSourcePython.itkImageSourceIVF43):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUS3IVF43 self, itkImageUS3 image)
        SetInput(itkImageToImageFilterIUS3IVF43 self, unsigned int arg0, itkImageUS3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF43_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUS3 const *":
        """
        GetInput(itkImageToImageFilterIUS3IVF43 self) -> itkImageUS3
        GetInput(itkImageToImageFilterIUS3IVF43 self, unsigned int idx) -> itkImageUS3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF43_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUS3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUS3IVF43 self, itkImageUS3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF43_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUS3IVF43 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF43_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUS3') -> "void":
        """PushFrontInput(itkImageToImageFilterIUS3IVF43 self, itkImageUS3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF43_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUS3IVF43 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF43_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUS3IVF43 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF43_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUS3IVF43 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF43_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUS3IVF43 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF43_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUS3IVF43 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF43_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUS3IVF43

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS3IVF43 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUS3IVF43"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF43_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUS3IVF43

        Create a new object of the class itkImageToImageFilterIUS3IVF43 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUS3IVF43.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUS3IVF43.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUS3IVF43.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUS3IVF43.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF43_SetInput, None, itkImageToImageFilterIUS3IVF43)
itkImageToImageFilterIUS3IVF43.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF43_GetInput, None, itkImageToImageFilterIUS3IVF43)
itkImageToImageFilterIUS3IVF43.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF43_PushBackInput, None, itkImageToImageFilterIUS3IVF43)
itkImageToImageFilterIUS3IVF43.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF43_PopBackInput, None, itkImageToImageFilterIUS3IVF43)
itkImageToImageFilterIUS3IVF43.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF43_PushFrontInput, None, itkImageToImageFilterIUS3IVF43)
itkImageToImageFilterIUS3IVF43.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF43_PopFrontInput, None, itkImageToImageFilterIUS3IVF43)
itkImageToImageFilterIUS3IVF43.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF43_SetCoordinateTolerance, None, itkImageToImageFilterIUS3IVF43)
itkImageToImageFilterIUS3IVF43.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF43_GetCoordinateTolerance, None, itkImageToImageFilterIUS3IVF43)
itkImageToImageFilterIUS3IVF43.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF43_SetDirectionTolerance, None, itkImageToImageFilterIUS3IVF43)
itkImageToImageFilterIUS3IVF43.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF43_GetDirectionTolerance, None, itkImageToImageFilterIUS3IVF43)
itkImageToImageFilterIUS3IVF43_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF43_swigregister
itkImageToImageFilterIUS3IVF43_swigregister(itkImageToImageFilterIUS3IVF43)

def itkImageToImageFilterIUS3IVF43_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS3IVF43 *":
    """itkImageToImageFilterIUS3IVF43_cast(itkLightObject obj) -> itkImageToImageFilterIUS3IVF43"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3IVF43_cast(obj)

class itkImageToImageFilterIUS3VID3(itkImageSourcePython.itkImageSourceVID3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUS3VID3 self, itkImageUS3 image)
        SetInput(itkImageToImageFilterIUS3VID3 self, unsigned int arg0, itkImageUS3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VID3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUS3 const *":
        """
        GetInput(itkImageToImageFilterIUS3VID3 self) -> itkImageUS3
        GetInput(itkImageToImageFilterIUS3VID3 self, unsigned int idx) -> itkImageUS3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VID3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUS3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUS3VID3 self, itkImageUS3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VID3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUS3VID3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VID3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUS3') -> "void":
        """PushFrontInput(itkImageToImageFilterIUS3VID3 self, itkImageUS3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VID3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUS3VID3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VID3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUS3VID3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VID3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUS3VID3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VID3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUS3VID3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VID3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUS3VID3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VID3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUS3VID3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS3VID3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUS3VID3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VID3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUS3VID3

        Create a new object of the class itkImageToImageFilterIUS3VID3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUS3VID3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUS3VID3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUS3VID3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUS3VID3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3VID3_SetInput, None, itkImageToImageFilterIUS3VID3)
itkImageToImageFilterIUS3VID3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3VID3_GetInput, None, itkImageToImageFilterIUS3VID3)
itkImageToImageFilterIUS3VID3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3VID3_PushBackInput, None, itkImageToImageFilterIUS3VID3)
itkImageToImageFilterIUS3VID3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3VID3_PopBackInput, None, itkImageToImageFilterIUS3VID3)
itkImageToImageFilterIUS3VID3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3VID3_PushFrontInput, None, itkImageToImageFilterIUS3VID3)
itkImageToImageFilterIUS3VID3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3VID3_PopFrontInput, None, itkImageToImageFilterIUS3VID3)
itkImageToImageFilterIUS3VID3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3VID3_SetCoordinateTolerance, None, itkImageToImageFilterIUS3VID3)
itkImageToImageFilterIUS3VID3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3VID3_GetCoordinateTolerance, None, itkImageToImageFilterIUS3VID3)
itkImageToImageFilterIUS3VID3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3VID3_SetDirectionTolerance, None, itkImageToImageFilterIUS3VID3)
itkImageToImageFilterIUS3VID3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3VID3_GetDirectionTolerance, None, itkImageToImageFilterIUS3VID3)
itkImageToImageFilterIUS3VID3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VID3_swigregister
itkImageToImageFilterIUS3VID3_swigregister(itkImageToImageFilterIUS3VID3)

def itkImageToImageFilterIUS3VID3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS3VID3 *":
    """itkImageToImageFilterIUS3VID3_cast(itkLightObject obj) -> itkImageToImageFilterIUS3VID3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VID3_cast(obj)

class itkImageToImageFilterIUS3VIF3(itkImageSourcePython.itkImageSourceVIF3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUS3VIF3 self, itkImageUS3 image)
        SetInput(itkImageToImageFilterIUS3VIF3 self, unsigned int arg0, itkImageUS3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIF3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUS3 const *":
        """
        GetInput(itkImageToImageFilterIUS3VIF3 self) -> itkImageUS3
        GetInput(itkImageToImageFilterIUS3VIF3 self, unsigned int idx) -> itkImageUS3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIF3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUS3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUS3VIF3 self, itkImageUS3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIF3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUS3VIF3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIF3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUS3') -> "void":
        """PushFrontInput(itkImageToImageFilterIUS3VIF3 self, itkImageUS3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIF3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUS3VIF3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIF3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUS3VIF3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIF3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUS3VIF3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIF3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUS3VIF3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIF3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUS3VIF3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIF3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUS3VIF3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS3VIF3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUS3VIF3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIF3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUS3VIF3

        Create a new object of the class itkImageToImageFilterIUS3VIF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUS3VIF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUS3VIF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUS3VIF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUS3VIF3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIF3_SetInput, None, itkImageToImageFilterIUS3VIF3)
itkImageToImageFilterIUS3VIF3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIF3_GetInput, None, itkImageToImageFilterIUS3VIF3)
itkImageToImageFilterIUS3VIF3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIF3_PushBackInput, None, itkImageToImageFilterIUS3VIF3)
itkImageToImageFilterIUS3VIF3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIF3_PopBackInput, None, itkImageToImageFilterIUS3VIF3)
itkImageToImageFilterIUS3VIF3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIF3_PushFrontInput, None, itkImageToImageFilterIUS3VIF3)
itkImageToImageFilterIUS3VIF3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIF3_PopFrontInput, None, itkImageToImageFilterIUS3VIF3)
itkImageToImageFilterIUS3VIF3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIF3_SetCoordinateTolerance, None, itkImageToImageFilterIUS3VIF3)
itkImageToImageFilterIUS3VIF3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIF3_GetCoordinateTolerance, None, itkImageToImageFilterIUS3VIF3)
itkImageToImageFilterIUS3VIF3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIF3_SetDirectionTolerance, None, itkImageToImageFilterIUS3VIF3)
itkImageToImageFilterIUS3VIF3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIF3_GetDirectionTolerance, None, itkImageToImageFilterIUS3VIF3)
itkImageToImageFilterIUS3VIF3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIF3_swigregister
itkImageToImageFilterIUS3VIF3_swigregister(itkImageToImageFilterIUS3VIF3)

def itkImageToImageFilterIUS3VIF3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS3VIF3 *":
    """itkImageToImageFilterIUS3VIF3_cast(itkLightObject obj) -> itkImageToImageFilterIUS3VIF3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIF3_cast(obj)

class itkImageToImageFilterIUS3VISS3(itkImageSourcePython.itkImageSourceVISS3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUS3VISS3 self, itkImageUS3 image)
        SetInput(itkImageToImageFilterIUS3VISS3 self, unsigned int arg0, itkImageUS3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VISS3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUS3 const *":
        """
        GetInput(itkImageToImageFilterIUS3VISS3 self) -> itkImageUS3
        GetInput(itkImageToImageFilterIUS3VISS3 self, unsigned int idx) -> itkImageUS3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VISS3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUS3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUS3VISS3 self, itkImageUS3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VISS3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUS3VISS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VISS3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUS3') -> "void":
        """PushFrontInput(itkImageToImageFilterIUS3VISS3 self, itkImageUS3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VISS3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUS3VISS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VISS3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUS3VISS3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VISS3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUS3VISS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VISS3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUS3VISS3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VISS3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUS3VISS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VISS3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUS3VISS3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS3VISS3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUS3VISS3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VISS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUS3VISS3

        Create a new object of the class itkImageToImageFilterIUS3VISS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUS3VISS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUS3VISS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUS3VISS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUS3VISS3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3VISS3_SetInput, None, itkImageToImageFilterIUS3VISS3)
itkImageToImageFilterIUS3VISS3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3VISS3_GetInput, None, itkImageToImageFilterIUS3VISS3)
itkImageToImageFilterIUS3VISS3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3VISS3_PushBackInput, None, itkImageToImageFilterIUS3VISS3)
itkImageToImageFilterIUS3VISS3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3VISS3_PopBackInput, None, itkImageToImageFilterIUS3VISS3)
itkImageToImageFilterIUS3VISS3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3VISS3_PushFrontInput, None, itkImageToImageFilterIUS3VISS3)
itkImageToImageFilterIUS3VISS3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3VISS3_PopFrontInput, None, itkImageToImageFilterIUS3VISS3)
itkImageToImageFilterIUS3VISS3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3VISS3_SetCoordinateTolerance, None, itkImageToImageFilterIUS3VISS3)
itkImageToImageFilterIUS3VISS3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3VISS3_GetCoordinateTolerance, None, itkImageToImageFilterIUS3VISS3)
itkImageToImageFilterIUS3VISS3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3VISS3_SetDirectionTolerance, None, itkImageToImageFilterIUS3VISS3)
itkImageToImageFilterIUS3VISS3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3VISS3_GetDirectionTolerance, None, itkImageToImageFilterIUS3VISS3)
itkImageToImageFilterIUS3VISS3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VISS3_swigregister
itkImageToImageFilterIUS3VISS3_swigregister(itkImageToImageFilterIUS3VISS3)

def itkImageToImageFilterIUS3VISS3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS3VISS3 *":
    """itkImageToImageFilterIUS3VISS3_cast(itkLightObject obj) -> itkImageToImageFilterIUS3VISS3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VISS3_cast(obj)

class itkImageToImageFilterIUS3VIUC3(itkImageSourcePython.itkImageSourceVIUC3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUS3VIUC3 self, itkImageUS3 image)
        SetInput(itkImageToImageFilterIUS3VIUC3 self, unsigned int arg0, itkImageUS3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIUC3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUS3 const *":
        """
        GetInput(itkImageToImageFilterIUS3VIUC3 self) -> itkImageUS3
        GetInput(itkImageToImageFilterIUS3VIUC3 self, unsigned int idx) -> itkImageUS3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIUC3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUS3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUS3VIUC3 self, itkImageUS3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIUC3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUS3VIUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIUC3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUS3') -> "void":
        """PushFrontInput(itkImageToImageFilterIUS3VIUC3 self, itkImageUS3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIUC3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUS3VIUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIUC3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUS3VIUC3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIUC3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUS3VIUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIUC3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUS3VIUC3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIUC3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUS3VIUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIUC3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUS3VIUC3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS3VIUC3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUS3VIUC3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIUC3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUS3VIUC3

        Create a new object of the class itkImageToImageFilterIUS3VIUC3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUS3VIUC3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUS3VIUC3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUS3VIUC3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUS3VIUC3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIUC3_SetInput, None, itkImageToImageFilterIUS3VIUC3)
itkImageToImageFilterIUS3VIUC3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIUC3_GetInput, None, itkImageToImageFilterIUS3VIUC3)
itkImageToImageFilterIUS3VIUC3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIUC3_PushBackInput, None, itkImageToImageFilterIUS3VIUC3)
itkImageToImageFilterIUS3VIUC3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIUC3_PopBackInput, None, itkImageToImageFilterIUS3VIUC3)
itkImageToImageFilterIUS3VIUC3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIUC3_PushFrontInput, None, itkImageToImageFilterIUS3VIUC3)
itkImageToImageFilterIUS3VIUC3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIUC3_PopFrontInput, None, itkImageToImageFilterIUS3VIUC3)
itkImageToImageFilterIUS3VIUC3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIUC3_SetCoordinateTolerance, None, itkImageToImageFilterIUS3VIUC3)
itkImageToImageFilterIUS3VIUC3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIUC3_GetCoordinateTolerance, None, itkImageToImageFilterIUS3VIUC3)
itkImageToImageFilterIUS3VIUC3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIUC3_SetDirectionTolerance, None, itkImageToImageFilterIUS3VIUC3)
itkImageToImageFilterIUS3VIUC3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIUC3_GetDirectionTolerance, None, itkImageToImageFilterIUS3VIUC3)
itkImageToImageFilterIUS3VIUC3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIUC3_swigregister
itkImageToImageFilterIUS3VIUC3_swigregister(itkImageToImageFilterIUS3VIUC3)

def itkImageToImageFilterIUS3VIUC3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS3VIUC3 *":
    """itkImageToImageFilterIUS3VIUC3_cast(itkLightObject obj) -> itkImageToImageFilterIUS3VIUC3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIUC3_cast(obj)

class itkImageToImageFilterIUS3VIUS3(itkImageSourcePython.itkImageSourceVIUS3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUS3VIUS3 self, itkImageUS3 image)
        SetInput(itkImageToImageFilterIUS3VIUS3 self, unsigned int arg0, itkImageUS3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIUS3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUS3 const *":
        """
        GetInput(itkImageToImageFilterIUS3VIUS3 self) -> itkImageUS3
        GetInput(itkImageToImageFilterIUS3VIUS3 self, unsigned int idx) -> itkImageUS3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIUS3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUS3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUS3VIUS3 self, itkImageUS3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIUS3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUS3VIUS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIUS3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUS3') -> "void":
        """PushFrontInput(itkImageToImageFilterIUS3VIUS3 self, itkImageUS3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIUS3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUS3VIUS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIUS3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUS3VIUS3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIUS3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUS3VIUS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIUS3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUS3VIUS3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIUS3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUS3VIUS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIUS3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIUS3VIUS3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS3VIUS3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUS3VIUS3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIUS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUS3VIUS3

        Create a new object of the class itkImageToImageFilterIUS3VIUS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUS3VIUS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUS3VIUS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUS3VIUS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUS3VIUS3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIUS3_SetInput, None, itkImageToImageFilterIUS3VIUS3)
itkImageToImageFilterIUS3VIUS3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIUS3_GetInput, None, itkImageToImageFilterIUS3VIUS3)
itkImageToImageFilterIUS3VIUS3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIUS3_PushBackInput, None, itkImageToImageFilterIUS3VIUS3)
itkImageToImageFilterIUS3VIUS3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIUS3_PopBackInput, None, itkImageToImageFilterIUS3VIUS3)
itkImageToImageFilterIUS3VIUS3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIUS3_PushFrontInput, None, itkImageToImageFilterIUS3VIUS3)
itkImageToImageFilterIUS3VIUS3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIUS3_PopFrontInput, None, itkImageToImageFilterIUS3VIUS3)
itkImageToImageFilterIUS3VIUS3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIUS3_SetCoordinateTolerance, None, itkImageToImageFilterIUS3VIUS3)
itkImageToImageFilterIUS3VIUS3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIUS3_GetCoordinateTolerance, None, itkImageToImageFilterIUS3VIUS3)
itkImageToImageFilterIUS3VIUS3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIUS3_SetDirectionTolerance, None, itkImageToImageFilterIUS3VIUS3)
itkImageToImageFilterIUS3VIUS3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIUS3_GetDirectionTolerance, None, itkImageToImageFilterIUS3VIUS3)
itkImageToImageFilterIUS3VIUS3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIUS3_swigregister
itkImageToImageFilterIUS3VIUS3_swigregister(itkImageToImageFilterIUS3VIUS3)

def itkImageToImageFilterIUS3VIUS3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS3VIUS3 *":
    """itkImageToImageFilterIUS3VIUS3_cast(itkLightObject obj) -> itkImageToImageFilterIUS3VIUS3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIUS3VIUS3_cast(obj)

class itkImageToImageFilterIVF22ID2(itkImageSourcePython.itkImageSourceID2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIVF22ID2 self, itkImageVF22 image)
        SetInput(itkImageToImageFilterIVF22ID2 self, unsigned int arg0, itkImageVF22 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF22ID2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageVF22 const *":
        """
        GetInput(itkImageToImageFilterIVF22ID2 self) -> itkImageVF22
        GetInput(itkImageToImageFilterIVF22ID2 self, unsigned int idx) -> itkImageVF22
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF22ID2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageVF22') -> "void":
        """
        PushBackInput(itkImageToImageFilterIVF22ID2 self, itkImageVF22 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF22ID2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIVF22ID2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF22ID2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageVF22') -> "void":
        """PushFrontInput(itkImageToImageFilterIVF22ID2 self, itkImageVF22 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF22ID2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIVF22ID2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF22ID2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIVF22ID2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF22ID2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIVF22ID2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF22ID2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIVF22ID2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF22ID2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIVF22ID2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF22ID2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIVF22ID2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF22ID2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIVF22ID2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF22ID2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIVF22ID2

        Create a new object of the class itkImageToImageFilterIVF22ID2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIVF22ID2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIVF22ID2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIVF22ID2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIVF22ID2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF22ID2_SetInput, None, itkImageToImageFilterIVF22ID2)
itkImageToImageFilterIVF22ID2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF22ID2_GetInput, None, itkImageToImageFilterIVF22ID2)
itkImageToImageFilterIVF22ID2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF22ID2_PushBackInput, None, itkImageToImageFilterIVF22ID2)
itkImageToImageFilterIVF22ID2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF22ID2_PopBackInput, None, itkImageToImageFilterIVF22ID2)
itkImageToImageFilterIVF22ID2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF22ID2_PushFrontInput, None, itkImageToImageFilterIVF22ID2)
itkImageToImageFilterIVF22ID2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF22ID2_PopFrontInput, None, itkImageToImageFilterIVF22ID2)
itkImageToImageFilterIVF22ID2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF22ID2_SetCoordinateTolerance, None, itkImageToImageFilterIVF22ID2)
itkImageToImageFilterIVF22ID2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF22ID2_GetCoordinateTolerance, None, itkImageToImageFilterIVF22ID2)
itkImageToImageFilterIVF22ID2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF22ID2_SetDirectionTolerance, None, itkImageToImageFilterIVF22ID2)
itkImageToImageFilterIVF22ID2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF22ID2_GetDirectionTolerance, None, itkImageToImageFilterIVF22ID2)
itkImageToImageFilterIVF22ID2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIVF22ID2_swigregister
itkImageToImageFilterIVF22ID2_swigregister(itkImageToImageFilterIVF22ID2)

def itkImageToImageFilterIVF22ID2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF22ID2 *":
    """itkImageToImageFilterIVF22ID2_cast(itkLightObject obj) -> itkImageToImageFilterIVF22ID2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIVF22ID2_cast(obj)

class itkImageToImageFilterIVF22IF2(itkImageSourcePython.itkImageSourceIF2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIVF22IF2 self, itkImageVF22 image)
        SetInput(itkImageToImageFilterIVF22IF2 self, unsigned int arg0, itkImageVF22 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF22IF2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageVF22 const *":
        """
        GetInput(itkImageToImageFilterIVF22IF2 self) -> itkImageVF22
        GetInput(itkImageToImageFilterIVF22IF2 self, unsigned int idx) -> itkImageVF22
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF22IF2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageVF22') -> "void":
        """
        PushBackInput(itkImageToImageFilterIVF22IF2 self, itkImageVF22 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF22IF2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIVF22IF2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF22IF2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageVF22') -> "void":
        """PushFrontInput(itkImageToImageFilterIVF22IF2 self, itkImageVF22 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF22IF2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIVF22IF2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF22IF2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIVF22IF2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF22IF2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIVF22IF2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF22IF2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIVF22IF2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF22IF2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIVF22IF2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF22IF2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIVF22IF2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF22IF2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIVF22IF2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF22IF2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIVF22IF2

        Create a new object of the class itkImageToImageFilterIVF22IF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIVF22IF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIVF22IF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIVF22IF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIVF22IF2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF22IF2_SetInput, None, itkImageToImageFilterIVF22IF2)
itkImageToImageFilterIVF22IF2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF22IF2_GetInput, None, itkImageToImageFilterIVF22IF2)
itkImageToImageFilterIVF22IF2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF22IF2_PushBackInput, None, itkImageToImageFilterIVF22IF2)
itkImageToImageFilterIVF22IF2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF22IF2_PopBackInput, None, itkImageToImageFilterIVF22IF2)
itkImageToImageFilterIVF22IF2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF22IF2_PushFrontInput, None, itkImageToImageFilterIVF22IF2)
itkImageToImageFilterIVF22IF2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF22IF2_PopFrontInput, None, itkImageToImageFilterIVF22IF2)
itkImageToImageFilterIVF22IF2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF22IF2_SetCoordinateTolerance, None, itkImageToImageFilterIVF22IF2)
itkImageToImageFilterIVF22IF2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF22IF2_GetCoordinateTolerance, None, itkImageToImageFilterIVF22IF2)
itkImageToImageFilterIVF22IF2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF22IF2_SetDirectionTolerance, None, itkImageToImageFilterIVF22IF2)
itkImageToImageFilterIVF22IF2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF22IF2_GetDirectionTolerance, None, itkImageToImageFilterIVF22IF2)
itkImageToImageFilterIVF22IF2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIVF22IF2_swigregister
itkImageToImageFilterIVF22IF2_swigregister(itkImageToImageFilterIVF22IF2)

def itkImageToImageFilterIVF22IF2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF22IF2 *":
    """itkImageToImageFilterIVF22IF2_cast(itkLightObject obj) -> itkImageToImageFilterIVF22IF2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIVF22IF2_cast(obj)

class itkImageToImageFilterIVF22ISS2(itkImageSourcePython.itkImageSourceISS2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIVF22ISS2 self, itkImageVF22 image)
        SetInput(itkImageToImageFilterIVF22ISS2 self, unsigned int arg0, itkImageVF22 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF22ISS2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageVF22 const *":
        """
        GetInput(itkImageToImageFilterIVF22ISS2 self) -> itkImageVF22
        GetInput(itkImageToImageFilterIVF22ISS2 self, unsigned int idx) -> itkImageVF22
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF22ISS2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageVF22') -> "void":
        """
        PushBackInput(itkImageToImageFilterIVF22ISS2 self, itkImageVF22 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF22ISS2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIVF22ISS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF22ISS2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageVF22') -> "void":
        """PushFrontInput(itkImageToImageFilterIVF22ISS2 self, itkImageVF22 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF22ISS2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIVF22ISS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF22ISS2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIVF22ISS2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF22ISS2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIVF22ISS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF22ISS2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIVF22ISS2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF22ISS2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIVF22ISS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF22ISS2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIVF22ISS2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF22ISS2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIVF22ISS2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF22ISS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIVF22ISS2

        Create a new object of the class itkImageToImageFilterIVF22ISS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIVF22ISS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIVF22ISS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIVF22ISS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIVF22ISS2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF22ISS2_SetInput, None, itkImageToImageFilterIVF22ISS2)
itkImageToImageFilterIVF22ISS2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF22ISS2_GetInput, None, itkImageToImageFilterIVF22ISS2)
itkImageToImageFilterIVF22ISS2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF22ISS2_PushBackInput, None, itkImageToImageFilterIVF22ISS2)
itkImageToImageFilterIVF22ISS2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF22ISS2_PopBackInput, None, itkImageToImageFilterIVF22ISS2)
itkImageToImageFilterIVF22ISS2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF22ISS2_PushFrontInput, None, itkImageToImageFilterIVF22ISS2)
itkImageToImageFilterIVF22ISS2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF22ISS2_PopFrontInput, None, itkImageToImageFilterIVF22ISS2)
itkImageToImageFilterIVF22ISS2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF22ISS2_SetCoordinateTolerance, None, itkImageToImageFilterIVF22ISS2)
itkImageToImageFilterIVF22ISS2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF22ISS2_GetCoordinateTolerance, None, itkImageToImageFilterIVF22ISS2)
itkImageToImageFilterIVF22ISS2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF22ISS2_SetDirectionTolerance, None, itkImageToImageFilterIVF22ISS2)
itkImageToImageFilterIVF22ISS2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF22ISS2_GetDirectionTolerance, None, itkImageToImageFilterIVF22ISS2)
itkImageToImageFilterIVF22ISS2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIVF22ISS2_swigregister
itkImageToImageFilterIVF22ISS2_swigregister(itkImageToImageFilterIVF22ISS2)

def itkImageToImageFilterIVF22ISS2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF22ISS2 *":
    """itkImageToImageFilterIVF22ISS2_cast(itkLightObject obj) -> itkImageToImageFilterIVF22ISS2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIVF22ISS2_cast(obj)

class itkImageToImageFilterIVF22IUC2(itkImageSourcePython.itkImageSourceIUC2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIVF22IUC2 self, itkImageVF22 image)
        SetInput(itkImageToImageFilterIVF22IUC2 self, unsigned int arg0, itkImageVF22 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF22IUC2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageVF22 const *":
        """
        GetInput(itkImageToImageFilterIVF22IUC2 self) -> itkImageVF22
        GetInput(itkImageToImageFilterIVF22IUC2 self, unsigned int idx) -> itkImageVF22
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF22IUC2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageVF22') -> "void":
        """
        PushBackInput(itkImageToImageFilterIVF22IUC2 self, itkImageVF22 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF22IUC2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIVF22IUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF22IUC2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageVF22') -> "void":
        """PushFrontInput(itkImageToImageFilterIVF22IUC2 self, itkImageVF22 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF22IUC2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIVF22IUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF22IUC2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIVF22IUC2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF22IUC2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIVF22IUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF22IUC2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIVF22IUC2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF22IUC2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIVF22IUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF22IUC2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIVF22IUC2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF22IUC2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIVF22IUC2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF22IUC2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIVF22IUC2

        Create a new object of the class itkImageToImageFilterIVF22IUC2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIVF22IUC2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIVF22IUC2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIVF22IUC2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIVF22IUC2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF22IUC2_SetInput, None, itkImageToImageFilterIVF22IUC2)
itkImageToImageFilterIVF22IUC2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF22IUC2_GetInput, None, itkImageToImageFilterIVF22IUC2)
itkImageToImageFilterIVF22IUC2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF22IUC2_PushBackInput, None, itkImageToImageFilterIVF22IUC2)
itkImageToImageFilterIVF22IUC2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF22IUC2_PopBackInput, None, itkImageToImageFilterIVF22IUC2)
itkImageToImageFilterIVF22IUC2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF22IUC2_PushFrontInput, None, itkImageToImageFilterIVF22IUC2)
itkImageToImageFilterIVF22IUC2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF22IUC2_PopFrontInput, None, itkImageToImageFilterIVF22IUC2)
itkImageToImageFilterIVF22IUC2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF22IUC2_SetCoordinateTolerance, None, itkImageToImageFilterIVF22IUC2)
itkImageToImageFilterIVF22IUC2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF22IUC2_GetCoordinateTolerance, None, itkImageToImageFilterIVF22IUC2)
itkImageToImageFilterIVF22IUC2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF22IUC2_SetDirectionTolerance, None, itkImageToImageFilterIVF22IUC2)
itkImageToImageFilterIVF22IUC2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF22IUC2_GetDirectionTolerance, None, itkImageToImageFilterIVF22IUC2)
itkImageToImageFilterIVF22IUC2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIVF22IUC2_swigregister
itkImageToImageFilterIVF22IUC2_swigregister(itkImageToImageFilterIVF22IUC2)

def itkImageToImageFilterIVF22IUC2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF22IUC2 *":
    """itkImageToImageFilterIVF22IUC2_cast(itkLightObject obj) -> itkImageToImageFilterIVF22IUC2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIVF22IUC2_cast(obj)

class itkImageToImageFilterIVF22IUS2(itkImageSourcePython.itkImageSourceIUS2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIVF22IUS2 self, itkImageVF22 image)
        SetInput(itkImageToImageFilterIVF22IUS2 self, unsigned int arg0, itkImageVF22 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF22IUS2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageVF22 const *":
        """
        GetInput(itkImageToImageFilterIVF22IUS2 self) -> itkImageVF22
        GetInput(itkImageToImageFilterIVF22IUS2 self, unsigned int idx) -> itkImageVF22
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF22IUS2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageVF22') -> "void":
        """
        PushBackInput(itkImageToImageFilterIVF22IUS2 self, itkImageVF22 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF22IUS2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIVF22IUS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF22IUS2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageVF22') -> "void":
        """PushFrontInput(itkImageToImageFilterIVF22IUS2 self, itkImageVF22 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF22IUS2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIVF22IUS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF22IUS2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIVF22IUS2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF22IUS2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIVF22IUS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF22IUS2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIVF22IUS2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF22IUS2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIVF22IUS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF22IUS2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIVF22IUS2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF22IUS2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIVF22IUS2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF22IUS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIVF22IUS2

        Create a new object of the class itkImageToImageFilterIVF22IUS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIVF22IUS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIVF22IUS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIVF22IUS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIVF22IUS2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF22IUS2_SetInput, None, itkImageToImageFilterIVF22IUS2)
itkImageToImageFilterIVF22IUS2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF22IUS2_GetInput, None, itkImageToImageFilterIVF22IUS2)
itkImageToImageFilterIVF22IUS2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF22IUS2_PushBackInput, None, itkImageToImageFilterIVF22IUS2)
itkImageToImageFilterIVF22IUS2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF22IUS2_PopBackInput, None, itkImageToImageFilterIVF22IUS2)
itkImageToImageFilterIVF22IUS2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF22IUS2_PushFrontInput, None, itkImageToImageFilterIVF22IUS2)
itkImageToImageFilterIVF22IUS2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF22IUS2_PopFrontInput, None, itkImageToImageFilterIVF22IUS2)
itkImageToImageFilterIVF22IUS2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF22IUS2_SetCoordinateTolerance, None, itkImageToImageFilterIVF22IUS2)
itkImageToImageFilterIVF22IUS2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF22IUS2_GetCoordinateTolerance, None, itkImageToImageFilterIVF22IUS2)
itkImageToImageFilterIVF22IUS2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF22IUS2_SetDirectionTolerance, None, itkImageToImageFilterIVF22IUS2)
itkImageToImageFilterIVF22IUS2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF22IUS2_GetDirectionTolerance, None, itkImageToImageFilterIVF22IUS2)
itkImageToImageFilterIVF22IUS2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIVF22IUS2_swigregister
itkImageToImageFilterIVF22IUS2_swigregister(itkImageToImageFilterIVF22IUS2)

def itkImageToImageFilterIVF22IUS2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF22IUS2 *":
    """itkImageToImageFilterIVF22IUS2_cast(itkLightObject obj) -> itkImageToImageFilterIVF22IUS2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIVF22IUS2_cast(obj)

class itkImageToImageFilterIVF23ID3(itkImageSourcePython.itkImageSourceID3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIVF23ID3 self, itkImageVF23 image)
        SetInput(itkImageToImageFilterIVF23ID3 self, unsigned int arg0, itkImageVF23 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF23ID3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageVF23 const *":
        """
        GetInput(itkImageToImageFilterIVF23ID3 self) -> itkImageVF23
        GetInput(itkImageToImageFilterIVF23ID3 self, unsigned int idx) -> itkImageVF23
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF23ID3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageVF23') -> "void":
        """
        PushBackInput(itkImageToImageFilterIVF23ID3 self, itkImageVF23 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF23ID3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIVF23ID3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF23ID3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageVF23') -> "void":
        """PushFrontInput(itkImageToImageFilterIVF23ID3 self, itkImageVF23 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF23ID3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIVF23ID3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF23ID3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIVF23ID3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF23ID3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIVF23ID3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF23ID3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIVF23ID3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF23ID3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIVF23ID3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF23ID3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIVF23ID3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF23ID3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIVF23ID3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF23ID3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIVF23ID3

        Create a new object of the class itkImageToImageFilterIVF23ID3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIVF23ID3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIVF23ID3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIVF23ID3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIVF23ID3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF23ID3_SetInput, None, itkImageToImageFilterIVF23ID3)
itkImageToImageFilterIVF23ID3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF23ID3_GetInput, None, itkImageToImageFilterIVF23ID3)
itkImageToImageFilterIVF23ID3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF23ID3_PushBackInput, None, itkImageToImageFilterIVF23ID3)
itkImageToImageFilterIVF23ID3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF23ID3_PopBackInput, None, itkImageToImageFilterIVF23ID3)
itkImageToImageFilterIVF23ID3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF23ID3_PushFrontInput, None, itkImageToImageFilterIVF23ID3)
itkImageToImageFilterIVF23ID3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF23ID3_PopFrontInput, None, itkImageToImageFilterIVF23ID3)
itkImageToImageFilterIVF23ID3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF23ID3_SetCoordinateTolerance, None, itkImageToImageFilterIVF23ID3)
itkImageToImageFilterIVF23ID3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF23ID3_GetCoordinateTolerance, None, itkImageToImageFilterIVF23ID3)
itkImageToImageFilterIVF23ID3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF23ID3_SetDirectionTolerance, None, itkImageToImageFilterIVF23ID3)
itkImageToImageFilterIVF23ID3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF23ID3_GetDirectionTolerance, None, itkImageToImageFilterIVF23ID3)
itkImageToImageFilterIVF23ID3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIVF23ID3_swigregister
itkImageToImageFilterIVF23ID3_swigregister(itkImageToImageFilterIVF23ID3)

def itkImageToImageFilterIVF23ID3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF23ID3 *":
    """itkImageToImageFilterIVF23ID3_cast(itkLightObject obj) -> itkImageToImageFilterIVF23ID3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIVF23ID3_cast(obj)

class itkImageToImageFilterIVF23IF3(itkImageSourcePython.itkImageSourceIF3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIVF23IF3 self, itkImageVF23 image)
        SetInput(itkImageToImageFilterIVF23IF3 self, unsigned int arg0, itkImageVF23 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF23IF3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageVF23 const *":
        """
        GetInput(itkImageToImageFilterIVF23IF3 self) -> itkImageVF23
        GetInput(itkImageToImageFilterIVF23IF3 self, unsigned int idx) -> itkImageVF23
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF23IF3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageVF23') -> "void":
        """
        PushBackInput(itkImageToImageFilterIVF23IF3 self, itkImageVF23 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF23IF3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIVF23IF3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF23IF3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageVF23') -> "void":
        """PushFrontInput(itkImageToImageFilterIVF23IF3 self, itkImageVF23 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF23IF3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIVF23IF3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF23IF3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIVF23IF3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF23IF3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIVF23IF3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF23IF3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIVF23IF3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF23IF3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIVF23IF3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF23IF3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIVF23IF3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF23IF3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIVF23IF3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF23IF3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIVF23IF3

        Create a new object of the class itkImageToImageFilterIVF23IF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIVF23IF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIVF23IF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIVF23IF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIVF23IF3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF23IF3_SetInput, None, itkImageToImageFilterIVF23IF3)
itkImageToImageFilterIVF23IF3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF23IF3_GetInput, None, itkImageToImageFilterIVF23IF3)
itkImageToImageFilterIVF23IF3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF23IF3_PushBackInput, None, itkImageToImageFilterIVF23IF3)
itkImageToImageFilterIVF23IF3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF23IF3_PopBackInput, None, itkImageToImageFilterIVF23IF3)
itkImageToImageFilterIVF23IF3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF23IF3_PushFrontInput, None, itkImageToImageFilterIVF23IF3)
itkImageToImageFilterIVF23IF3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF23IF3_PopFrontInput, None, itkImageToImageFilterIVF23IF3)
itkImageToImageFilterIVF23IF3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF23IF3_SetCoordinateTolerance, None, itkImageToImageFilterIVF23IF3)
itkImageToImageFilterIVF23IF3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF23IF3_GetCoordinateTolerance, None, itkImageToImageFilterIVF23IF3)
itkImageToImageFilterIVF23IF3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF23IF3_SetDirectionTolerance, None, itkImageToImageFilterIVF23IF3)
itkImageToImageFilterIVF23IF3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF23IF3_GetDirectionTolerance, None, itkImageToImageFilterIVF23IF3)
itkImageToImageFilterIVF23IF3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIVF23IF3_swigregister
itkImageToImageFilterIVF23IF3_swigregister(itkImageToImageFilterIVF23IF3)

def itkImageToImageFilterIVF23IF3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF23IF3 *":
    """itkImageToImageFilterIVF23IF3_cast(itkLightObject obj) -> itkImageToImageFilterIVF23IF3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIVF23IF3_cast(obj)

class itkImageToImageFilterIVF23ISS3(itkImageSourcePython.itkImageSourceISS3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIVF23ISS3 self, itkImageVF23 image)
        SetInput(itkImageToImageFilterIVF23ISS3 self, unsigned int arg0, itkImageVF23 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF23ISS3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageVF23 const *":
        """
        GetInput(itkImageToImageFilterIVF23ISS3 self) -> itkImageVF23
        GetInput(itkImageToImageFilterIVF23ISS3 self, unsigned int idx) -> itkImageVF23
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF23ISS3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageVF23') -> "void":
        """
        PushBackInput(itkImageToImageFilterIVF23ISS3 self, itkImageVF23 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF23ISS3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIVF23ISS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF23ISS3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageVF23') -> "void":
        """PushFrontInput(itkImageToImageFilterIVF23ISS3 self, itkImageVF23 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF23ISS3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIVF23ISS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF23ISS3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIVF23ISS3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF23ISS3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIVF23ISS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF23ISS3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIVF23ISS3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF23ISS3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIVF23ISS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF23ISS3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIVF23ISS3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF23ISS3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIVF23ISS3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF23ISS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIVF23ISS3

        Create a new object of the class itkImageToImageFilterIVF23ISS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIVF23ISS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIVF23ISS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIVF23ISS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIVF23ISS3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF23ISS3_SetInput, None, itkImageToImageFilterIVF23ISS3)
itkImageToImageFilterIVF23ISS3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF23ISS3_GetInput, None, itkImageToImageFilterIVF23ISS3)
itkImageToImageFilterIVF23ISS3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF23ISS3_PushBackInput, None, itkImageToImageFilterIVF23ISS3)
itkImageToImageFilterIVF23ISS3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF23ISS3_PopBackInput, None, itkImageToImageFilterIVF23ISS3)
itkImageToImageFilterIVF23ISS3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF23ISS3_PushFrontInput, None, itkImageToImageFilterIVF23ISS3)
itkImageToImageFilterIVF23ISS3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF23ISS3_PopFrontInput, None, itkImageToImageFilterIVF23ISS3)
itkImageToImageFilterIVF23ISS3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF23ISS3_SetCoordinateTolerance, None, itkImageToImageFilterIVF23ISS3)
itkImageToImageFilterIVF23ISS3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF23ISS3_GetCoordinateTolerance, None, itkImageToImageFilterIVF23ISS3)
itkImageToImageFilterIVF23ISS3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF23ISS3_SetDirectionTolerance, None, itkImageToImageFilterIVF23ISS3)
itkImageToImageFilterIVF23ISS3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF23ISS3_GetDirectionTolerance, None, itkImageToImageFilterIVF23ISS3)
itkImageToImageFilterIVF23ISS3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIVF23ISS3_swigregister
itkImageToImageFilterIVF23ISS3_swigregister(itkImageToImageFilterIVF23ISS3)

def itkImageToImageFilterIVF23ISS3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF23ISS3 *":
    """itkImageToImageFilterIVF23ISS3_cast(itkLightObject obj) -> itkImageToImageFilterIVF23ISS3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIVF23ISS3_cast(obj)

class itkImageToImageFilterIVF23IUC3(itkImageSourcePython.itkImageSourceIUC3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIVF23IUC3 self, itkImageVF23 image)
        SetInput(itkImageToImageFilterIVF23IUC3 self, unsigned int arg0, itkImageVF23 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF23IUC3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageVF23 const *":
        """
        GetInput(itkImageToImageFilterIVF23IUC3 self) -> itkImageVF23
        GetInput(itkImageToImageFilterIVF23IUC3 self, unsigned int idx) -> itkImageVF23
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF23IUC3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageVF23') -> "void":
        """
        PushBackInput(itkImageToImageFilterIVF23IUC3 self, itkImageVF23 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF23IUC3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIVF23IUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF23IUC3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageVF23') -> "void":
        """PushFrontInput(itkImageToImageFilterIVF23IUC3 self, itkImageVF23 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF23IUC3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIVF23IUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF23IUC3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIVF23IUC3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF23IUC3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIVF23IUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF23IUC3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIVF23IUC3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF23IUC3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIVF23IUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF23IUC3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIVF23IUC3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF23IUC3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIVF23IUC3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF23IUC3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIVF23IUC3

        Create a new object of the class itkImageToImageFilterIVF23IUC3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIVF23IUC3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIVF23IUC3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIVF23IUC3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIVF23IUC3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF23IUC3_SetInput, None, itkImageToImageFilterIVF23IUC3)
itkImageToImageFilterIVF23IUC3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF23IUC3_GetInput, None, itkImageToImageFilterIVF23IUC3)
itkImageToImageFilterIVF23IUC3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF23IUC3_PushBackInput, None, itkImageToImageFilterIVF23IUC3)
itkImageToImageFilterIVF23IUC3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF23IUC3_PopBackInput, None, itkImageToImageFilterIVF23IUC3)
itkImageToImageFilterIVF23IUC3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF23IUC3_PushFrontInput, None, itkImageToImageFilterIVF23IUC3)
itkImageToImageFilterIVF23IUC3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF23IUC3_PopFrontInput, None, itkImageToImageFilterIVF23IUC3)
itkImageToImageFilterIVF23IUC3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF23IUC3_SetCoordinateTolerance, None, itkImageToImageFilterIVF23IUC3)
itkImageToImageFilterIVF23IUC3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF23IUC3_GetCoordinateTolerance, None, itkImageToImageFilterIVF23IUC3)
itkImageToImageFilterIVF23IUC3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF23IUC3_SetDirectionTolerance, None, itkImageToImageFilterIVF23IUC3)
itkImageToImageFilterIVF23IUC3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF23IUC3_GetDirectionTolerance, None, itkImageToImageFilterIVF23IUC3)
itkImageToImageFilterIVF23IUC3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIVF23IUC3_swigregister
itkImageToImageFilterIVF23IUC3_swigregister(itkImageToImageFilterIVF23IUC3)

def itkImageToImageFilterIVF23IUC3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF23IUC3 *":
    """itkImageToImageFilterIVF23IUC3_cast(itkLightObject obj) -> itkImageToImageFilterIVF23IUC3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIVF23IUC3_cast(obj)

class itkImageToImageFilterIVF23IUS3(itkImageSourcePython.itkImageSourceIUS3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIVF23IUS3 self, itkImageVF23 image)
        SetInput(itkImageToImageFilterIVF23IUS3 self, unsigned int arg0, itkImageVF23 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF23IUS3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageVF23 const *":
        """
        GetInput(itkImageToImageFilterIVF23IUS3 self) -> itkImageVF23
        GetInput(itkImageToImageFilterIVF23IUS3 self, unsigned int idx) -> itkImageVF23
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF23IUS3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageVF23') -> "void":
        """
        PushBackInput(itkImageToImageFilterIVF23IUS3 self, itkImageVF23 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF23IUS3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIVF23IUS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF23IUS3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageVF23') -> "void":
        """PushFrontInput(itkImageToImageFilterIVF23IUS3 self, itkImageVF23 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF23IUS3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIVF23IUS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF23IUS3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIVF23IUS3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF23IUS3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIVF23IUS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF23IUS3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIVF23IUS3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF23IUS3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIVF23IUS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF23IUS3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIVF23IUS3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF23IUS3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIVF23IUS3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF23IUS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIVF23IUS3

        Create a new object of the class itkImageToImageFilterIVF23IUS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIVF23IUS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIVF23IUS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIVF23IUS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIVF23IUS3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF23IUS3_SetInput, None, itkImageToImageFilterIVF23IUS3)
itkImageToImageFilterIVF23IUS3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF23IUS3_GetInput, None, itkImageToImageFilterIVF23IUS3)
itkImageToImageFilterIVF23IUS3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF23IUS3_PushBackInput, None, itkImageToImageFilterIVF23IUS3)
itkImageToImageFilterIVF23IUS3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF23IUS3_PopBackInput, None, itkImageToImageFilterIVF23IUS3)
itkImageToImageFilterIVF23IUS3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF23IUS3_PushFrontInput, None, itkImageToImageFilterIVF23IUS3)
itkImageToImageFilterIVF23IUS3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF23IUS3_PopFrontInput, None, itkImageToImageFilterIVF23IUS3)
itkImageToImageFilterIVF23IUS3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF23IUS3_SetCoordinateTolerance, None, itkImageToImageFilterIVF23IUS3)
itkImageToImageFilterIVF23IUS3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF23IUS3_GetCoordinateTolerance, None, itkImageToImageFilterIVF23IUS3)
itkImageToImageFilterIVF23IUS3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF23IUS3_SetDirectionTolerance, None, itkImageToImageFilterIVF23IUS3)
itkImageToImageFilterIVF23IUS3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF23IUS3_GetDirectionTolerance, None, itkImageToImageFilterIVF23IUS3)
itkImageToImageFilterIVF23IUS3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIVF23IUS3_swigregister
itkImageToImageFilterIVF23IUS3_swigregister(itkImageToImageFilterIVF23IUS3)

def itkImageToImageFilterIVF23IUS3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF23IUS3 *":
    """itkImageToImageFilterIVF23IUS3_cast(itkLightObject obj) -> itkImageToImageFilterIVF23IUS3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIVF23IUS3_cast(obj)

class itkImageToImageFilterIVF32ID2(itkImageSourcePython.itkImageSourceID2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIVF32ID2 self, itkImageVF32 image)
        SetInput(itkImageToImageFilterIVF32ID2 self, unsigned int arg0, itkImageVF32 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF32ID2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageVF32 const *":
        """
        GetInput(itkImageToImageFilterIVF32ID2 self) -> itkImageVF32
        GetInput(itkImageToImageFilterIVF32ID2 self, unsigned int idx) -> itkImageVF32
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF32ID2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageVF32') -> "void":
        """
        PushBackInput(itkImageToImageFilterIVF32ID2 self, itkImageVF32 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF32ID2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIVF32ID2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF32ID2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageVF32') -> "void":
        """PushFrontInput(itkImageToImageFilterIVF32ID2 self, itkImageVF32 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF32ID2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIVF32ID2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF32ID2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIVF32ID2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF32ID2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIVF32ID2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF32ID2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIVF32ID2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF32ID2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIVF32ID2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF32ID2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIVF32ID2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF32ID2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIVF32ID2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF32ID2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIVF32ID2

        Create a new object of the class itkImageToImageFilterIVF32ID2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIVF32ID2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIVF32ID2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIVF32ID2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIVF32ID2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF32ID2_SetInput, None, itkImageToImageFilterIVF32ID2)
itkImageToImageFilterIVF32ID2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF32ID2_GetInput, None, itkImageToImageFilterIVF32ID2)
itkImageToImageFilterIVF32ID2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF32ID2_PushBackInput, None, itkImageToImageFilterIVF32ID2)
itkImageToImageFilterIVF32ID2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF32ID2_PopBackInput, None, itkImageToImageFilterIVF32ID2)
itkImageToImageFilterIVF32ID2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF32ID2_PushFrontInput, None, itkImageToImageFilterIVF32ID2)
itkImageToImageFilterIVF32ID2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF32ID2_PopFrontInput, None, itkImageToImageFilterIVF32ID2)
itkImageToImageFilterIVF32ID2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF32ID2_SetCoordinateTolerance, None, itkImageToImageFilterIVF32ID2)
itkImageToImageFilterIVF32ID2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF32ID2_GetCoordinateTolerance, None, itkImageToImageFilterIVF32ID2)
itkImageToImageFilterIVF32ID2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF32ID2_SetDirectionTolerance, None, itkImageToImageFilterIVF32ID2)
itkImageToImageFilterIVF32ID2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF32ID2_GetDirectionTolerance, None, itkImageToImageFilterIVF32ID2)
itkImageToImageFilterIVF32ID2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIVF32ID2_swigregister
itkImageToImageFilterIVF32ID2_swigregister(itkImageToImageFilterIVF32ID2)

def itkImageToImageFilterIVF32ID2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF32ID2 *":
    """itkImageToImageFilterIVF32ID2_cast(itkLightObject obj) -> itkImageToImageFilterIVF32ID2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIVF32ID2_cast(obj)

class itkImageToImageFilterIVF32IF2(itkImageSourcePython.itkImageSourceIF2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIVF32IF2 self, itkImageVF32 image)
        SetInput(itkImageToImageFilterIVF32IF2 self, unsigned int arg0, itkImageVF32 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF32IF2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageVF32 const *":
        """
        GetInput(itkImageToImageFilterIVF32IF2 self) -> itkImageVF32
        GetInput(itkImageToImageFilterIVF32IF2 self, unsigned int idx) -> itkImageVF32
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF32IF2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageVF32') -> "void":
        """
        PushBackInput(itkImageToImageFilterIVF32IF2 self, itkImageVF32 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF32IF2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIVF32IF2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF32IF2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageVF32') -> "void":
        """PushFrontInput(itkImageToImageFilterIVF32IF2 self, itkImageVF32 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF32IF2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIVF32IF2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF32IF2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIVF32IF2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF32IF2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIVF32IF2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF32IF2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIVF32IF2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF32IF2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIVF32IF2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF32IF2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIVF32IF2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF32IF2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIVF32IF2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF32IF2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIVF32IF2

        Create a new object of the class itkImageToImageFilterIVF32IF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIVF32IF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIVF32IF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIVF32IF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIVF32IF2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF32IF2_SetInput, None, itkImageToImageFilterIVF32IF2)
itkImageToImageFilterIVF32IF2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF32IF2_GetInput, None, itkImageToImageFilterIVF32IF2)
itkImageToImageFilterIVF32IF2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF32IF2_PushBackInput, None, itkImageToImageFilterIVF32IF2)
itkImageToImageFilterIVF32IF2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF32IF2_PopBackInput, None, itkImageToImageFilterIVF32IF2)
itkImageToImageFilterIVF32IF2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF32IF2_PushFrontInput, None, itkImageToImageFilterIVF32IF2)
itkImageToImageFilterIVF32IF2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF32IF2_PopFrontInput, None, itkImageToImageFilterIVF32IF2)
itkImageToImageFilterIVF32IF2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF32IF2_SetCoordinateTolerance, None, itkImageToImageFilterIVF32IF2)
itkImageToImageFilterIVF32IF2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF32IF2_GetCoordinateTolerance, None, itkImageToImageFilterIVF32IF2)
itkImageToImageFilterIVF32IF2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF32IF2_SetDirectionTolerance, None, itkImageToImageFilterIVF32IF2)
itkImageToImageFilterIVF32IF2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF32IF2_GetDirectionTolerance, None, itkImageToImageFilterIVF32IF2)
itkImageToImageFilterIVF32IF2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIVF32IF2_swigregister
itkImageToImageFilterIVF32IF2_swigregister(itkImageToImageFilterIVF32IF2)

def itkImageToImageFilterIVF32IF2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF32IF2 *":
    """itkImageToImageFilterIVF32IF2_cast(itkLightObject obj) -> itkImageToImageFilterIVF32IF2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIVF32IF2_cast(obj)

class itkImageToImageFilterIVF32ISS2(itkImageSourcePython.itkImageSourceISS2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIVF32ISS2 self, itkImageVF32 image)
        SetInput(itkImageToImageFilterIVF32ISS2 self, unsigned int arg0, itkImageVF32 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF32ISS2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageVF32 const *":
        """
        GetInput(itkImageToImageFilterIVF32ISS2 self) -> itkImageVF32
        GetInput(itkImageToImageFilterIVF32ISS2 self, unsigned int idx) -> itkImageVF32
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF32ISS2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageVF32') -> "void":
        """
        PushBackInput(itkImageToImageFilterIVF32ISS2 self, itkImageVF32 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF32ISS2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIVF32ISS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF32ISS2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageVF32') -> "void":
        """PushFrontInput(itkImageToImageFilterIVF32ISS2 self, itkImageVF32 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF32ISS2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIVF32ISS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF32ISS2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIVF32ISS2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF32ISS2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIVF32ISS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF32ISS2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIVF32ISS2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF32ISS2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIVF32ISS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF32ISS2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIVF32ISS2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF32ISS2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIVF32ISS2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF32ISS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIVF32ISS2

        Create a new object of the class itkImageToImageFilterIVF32ISS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIVF32ISS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIVF32ISS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIVF32ISS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIVF32ISS2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF32ISS2_SetInput, None, itkImageToImageFilterIVF32ISS2)
itkImageToImageFilterIVF32ISS2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF32ISS2_GetInput, None, itkImageToImageFilterIVF32ISS2)
itkImageToImageFilterIVF32ISS2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF32ISS2_PushBackInput, None, itkImageToImageFilterIVF32ISS2)
itkImageToImageFilterIVF32ISS2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF32ISS2_PopBackInput, None, itkImageToImageFilterIVF32ISS2)
itkImageToImageFilterIVF32ISS2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF32ISS2_PushFrontInput, None, itkImageToImageFilterIVF32ISS2)
itkImageToImageFilterIVF32ISS2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF32ISS2_PopFrontInput, None, itkImageToImageFilterIVF32ISS2)
itkImageToImageFilterIVF32ISS2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF32ISS2_SetCoordinateTolerance, None, itkImageToImageFilterIVF32ISS2)
itkImageToImageFilterIVF32ISS2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF32ISS2_GetCoordinateTolerance, None, itkImageToImageFilterIVF32ISS2)
itkImageToImageFilterIVF32ISS2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF32ISS2_SetDirectionTolerance, None, itkImageToImageFilterIVF32ISS2)
itkImageToImageFilterIVF32ISS2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF32ISS2_GetDirectionTolerance, None, itkImageToImageFilterIVF32ISS2)
itkImageToImageFilterIVF32ISS2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIVF32ISS2_swigregister
itkImageToImageFilterIVF32ISS2_swigregister(itkImageToImageFilterIVF32ISS2)

def itkImageToImageFilterIVF32ISS2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF32ISS2 *":
    """itkImageToImageFilterIVF32ISS2_cast(itkLightObject obj) -> itkImageToImageFilterIVF32ISS2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIVF32ISS2_cast(obj)

class itkImageToImageFilterIVF32IUC2(itkImageSourcePython.itkImageSourceIUC2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIVF32IUC2 self, itkImageVF32 image)
        SetInput(itkImageToImageFilterIVF32IUC2 self, unsigned int arg0, itkImageVF32 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF32IUC2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageVF32 const *":
        """
        GetInput(itkImageToImageFilterIVF32IUC2 self) -> itkImageVF32
        GetInput(itkImageToImageFilterIVF32IUC2 self, unsigned int idx) -> itkImageVF32
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF32IUC2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageVF32') -> "void":
        """
        PushBackInput(itkImageToImageFilterIVF32IUC2 self, itkImageVF32 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF32IUC2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIVF32IUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF32IUC2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageVF32') -> "void":
        """PushFrontInput(itkImageToImageFilterIVF32IUC2 self, itkImageVF32 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF32IUC2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIVF32IUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF32IUC2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIVF32IUC2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF32IUC2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIVF32IUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF32IUC2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIVF32IUC2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF32IUC2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIVF32IUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF32IUC2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIVF32IUC2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF32IUC2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIVF32IUC2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF32IUC2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIVF32IUC2

        Create a new object of the class itkImageToImageFilterIVF32IUC2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIVF32IUC2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIVF32IUC2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIVF32IUC2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIVF32IUC2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF32IUC2_SetInput, None, itkImageToImageFilterIVF32IUC2)
itkImageToImageFilterIVF32IUC2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF32IUC2_GetInput, None, itkImageToImageFilterIVF32IUC2)
itkImageToImageFilterIVF32IUC2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF32IUC2_PushBackInput, None, itkImageToImageFilterIVF32IUC2)
itkImageToImageFilterIVF32IUC2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF32IUC2_PopBackInput, None, itkImageToImageFilterIVF32IUC2)
itkImageToImageFilterIVF32IUC2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF32IUC2_PushFrontInput, None, itkImageToImageFilterIVF32IUC2)
itkImageToImageFilterIVF32IUC2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF32IUC2_PopFrontInput, None, itkImageToImageFilterIVF32IUC2)
itkImageToImageFilterIVF32IUC2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF32IUC2_SetCoordinateTolerance, None, itkImageToImageFilterIVF32IUC2)
itkImageToImageFilterIVF32IUC2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF32IUC2_GetCoordinateTolerance, None, itkImageToImageFilterIVF32IUC2)
itkImageToImageFilterIVF32IUC2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF32IUC2_SetDirectionTolerance, None, itkImageToImageFilterIVF32IUC2)
itkImageToImageFilterIVF32IUC2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF32IUC2_GetDirectionTolerance, None, itkImageToImageFilterIVF32IUC2)
itkImageToImageFilterIVF32IUC2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIVF32IUC2_swigregister
itkImageToImageFilterIVF32IUC2_swigregister(itkImageToImageFilterIVF32IUC2)

def itkImageToImageFilterIVF32IUC2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF32IUC2 *":
    """itkImageToImageFilterIVF32IUC2_cast(itkLightObject obj) -> itkImageToImageFilterIVF32IUC2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIVF32IUC2_cast(obj)

class itkImageToImageFilterIVF32IUS2(itkImageSourcePython.itkImageSourceIUS2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIVF32IUS2 self, itkImageVF32 image)
        SetInput(itkImageToImageFilterIVF32IUS2 self, unsigned int arg0, itkImageVF32 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF32IUS2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageVF32 const *":
        """
        GetInput(itkImageToImageFilterIVF32IUS2 self) -> itkImageVF32
        GetInput(itkImageToImageFilterIVF32IUS2 self, unsigned int idx) -> itkImageVF32
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF32IUS2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageVF32') -> "void":
        """
        PushBackInput(itkImageToImageFilterIVF32IUS2 self, itkImageVF32 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF32IUS2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIVF32IUS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF32IUS2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageVF32') -> "void":
        """PushFrontInput(itkImageToImageFilterIVF32IUS2 self, itkImageVF32 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF32IUS2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIVF32IUS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF32IUS2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIVF32IUS2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF32IUS2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIVF32IUS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF32IUS2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIVF32IUS2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF32IUS2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIVF32IUS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF32IUS2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIVF32IUS2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF32IUS2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIVF32IUS2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF32IUS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIVF32IUS2

        Create a new object of the class itkImageToImageFilterIVF32IUS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIVF32IUS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIVF32IUS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIVF32IUS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIVF32IUS2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF32IUS2_SetInput, None, itkImageToImageFilterIVF32IUS2)
itkImageToImageFilterIVF32IUS2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF32IUS2_GetInput, None, itkImageToImageFilterIVF32IUS2)
itkImageToImageFilterIVF32IUS2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF32IUS2_PushBackInput, None, itkImageToImageFilterIVF32IUS2)
itkImageToImageFilterIVF32IUS2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF32IUS2_PopBackInput, None, itkImageToImageFilterIVF32IUS2)
itkImageToImageFilterIVF32IUS2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF32IUS2_PushFrontInput, None, itkImageToImageFilterIVF32IUS2)
itkImageToImageFilterIVF32IUS2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF32IUS2_PopFrontInput, None, itkImageToImageFilterIVF32IUS2)
itkImageToImageFilterIVF32IUS2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF32IUS2_SetCoordinateTolerance, None, itkImageToImageFilterIVF32IUS2)
itkImageToImageFilterIVF32IUS2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF32IUS2_GetCoordinateTolerance, None, itkImageToImageFilterIVF32IUS2)
itkImageToImageFilterIVF32IUS2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF32IUS2_SetDirectionTolerance, None, itkImageToImageFilterIVF32IUS2)
itkImageToImageFilterIVF32IUS2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF32IUS2_GetDirectionTolerance, None, itkImageToImageFilterIVF32IUS2)
itkImageToImageFilterIVF32IUS2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIVF32IUS2_swigregister
itkImageToImageFilterIVF32IUS2_swigregister(itkImageToImageFilterIVF32IUS2)

def itkImageToImageFilterIVF32IUS2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF32IUS2 *":
    """itkImageToImageFilterIVF32IUS2_cast(itkLightObject obj) -> itkImageToImageFilterIVF32IUS2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIVF32IUS2_cast(obj)

class itkImageToImageFilterIVF33ID3(itkImageSourcePython.itkImageSourceID3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIVF33ID3 self, itkImageVF33 image)
        SetInput(itkImageToImageFilterIVF33ID3 self, unsigned int arg0, itkImageVF33 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF33ID3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageVF33 const *":
        """
        GetInput(itkImageToImageFilterIVF33ID3 self) -> itkImageVF33
        GetInput(itkImageToImageFilterIVF33ID3 self, unsigned int idx) -> itkImageVF33
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF33ID3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageVF33') -> "void":
        """
        PushBackInput(itkImageToImageFilterIVF33ID3 self, itkImageVF33 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF33ID3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIVF33ID3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF33ID3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageVF33') -> "void":
        """PushFrontInput(itkImageToImageFilterIVF33ID3 self, itkImageVF33 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF33ID3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIVF33ID3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF33ID3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIVF33ID3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF33ID3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIVF33ID3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF33ID3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIVF33ID3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF33ID3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIVF33ID3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF33ID3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIVF33ID3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF33ID3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIVF33ID3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF33ID3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIVF33ID3

        Create a new object of the class itkImageToImageFilterIVF33ID3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIVF33ID3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIVF33ID3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIVF33ID3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIVF33ID3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF33ID3_SetInput, None, itkImageToImageFilterIVF33ID3)
itkImageToImageFilterIVF33ID3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF33ID3_GetInput, None, itkImageToImageFilterIVF33ID3)
itkImageToImageFilterIVF33ID3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF33ID3_PushBackInput, None, itkImageToImageFilterIVF33ID3)
itkImageToImageFilterIVF33ID3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF33ID3_PopBackInput, None, itkImageToImageFilterIVF33ID3)
itkImageToImageFilterIVF33ID3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF33ID3_PushFrontInput, None, itkImageToImageFilterIVF33ID3)
itkImageToImageFilterIVF33ID3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF33ID3_PopFrontInput, None, itkImageToImageFilterIVF33ID3)
itkImageToImageFilterIVF33ID3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF33ID3_SetCoordinateTolerance, None, itkImageToImageFilterIVF33ID3)
itkImageToImageFilterIVF33ID3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF33ID3_GetCoordinateTolerance, None, itkImageToImageFilterIVF33ID3)
itkImageToImageFilterIVF33ID3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF33ID3_SetDirectionTolerance, None, itkImageToImageFilterIVF33ID3)
itkImageToImageFilterIVF33ID3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF33ID3_GetDirectionTolerance, None, itkImageToImageFilterIVF33ID3)
itkImageToImageFilterIVF33ID3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIVF33ID3_swigregister
itkImageToImageFilterIVF33ID3_swigregister(itkImageToImageFilterIVF33ID3)

def itkImageToImageFilterIVF33ID3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF33ID3 *":
    """itkImageToImageFilterIVF33ID3_cast(itkLightObject obj) -> itkImageToImageFilterIVF33ID3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIVF33ID3_cast(obj)

class itkImageToImageFilterIVF33IF3(itkImageSourcePython.itkImageSourceIF3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIVF33IF3 self, itkImageVF33 image)
        SetInput(itkImageToImageFilterIVF33IF3 self, unsigned int arg0, itkImageVF33 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF33IF3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageVF33 const *":
        """
        GetInput(itkImageToImageFilterIVF33IF3 self) -> itkImageVF33
        GetInput(itkImageToImageFilterIVF33IF3 self, unsigned int idx) -> itkImageVF33
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF33IF3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageVF33') -> "void":
        """
        PushBackInput(itkImageToImageFilterIVF33IF3 self, itkImageVF33 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF33IF3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIVF33IF3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF33IF3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageVF33') -> "void":
        """PushFrontInput(itkImageToImageFilterIVF33IF3 self, itkImageVF33 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF33IF3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIVF33IF3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF33IF3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIVF33IF3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF33IF3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIVF33IF3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF33IF3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIVF33IF3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF33IF3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIVF33IF3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF33IF3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIVF33IF3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF33IF3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIVF33IF3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF33IF3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIVF33IF3

        Create a new object of the class itkImageToImageFilterIVF33IF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIVF33IF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIVF33IF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIVF33IF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIVF33IF3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF33IF3_SetInput, None, itkImageToImageFilterIVF33IF3)
itkImageToImageFilterIVF33IF3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF33IF3_GetInput, None, itkImageToImageFilterIVF33IF3)
itkImageToImageFilterIVF33IF3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF33IF3_PushBackInput, None, itkImageToImageFilterIVF33IF3)
itkImageToImageFilterIVF33IF3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF33IF3_PopBackInput, None, itkImageToImageFilterIVF33IF3)
itkImageToImageFilterIVF33IF3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF33IF3_PushFrontInput, None, itkImageToImageFilterIVF33IF3)
itkImageToImageFilterIVF33IF3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF33IF3_PopFrontInput, None, itkImageToImageFilterIVF33IF3)
itkImageToImageFilterIVF33IF3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF33IF3_SetCoordinateTolerance, None, itkImageToImageFilterIVF33IF3)
itkImageToImageFilterIVF33IF3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF33IF3_GetCoordinateTolerance, None, itkImageToImageFilterIVF33IF3)
itkImageToImageFilterIVF33IF3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF33IF3_SetDirectionTolerance, None, itkImageToImageFilterIVF33IF3)
itkImageToImageFilterIVF33IF3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF33IF3_GetDirectionTolerance, None, itkImageToImageFilterIVF33IF3)
itkImageToImageFilterIVF33IF3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIVF33IF3_swigregister
itkImageToImageFilterIVF33IF3_swigregister(itkImageToImageFilterIVF33IF3)

def itkImageToImageFilterIVF33IF3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF33IF3 *":
    """itkImageToImageFilterIVF33IF3_cast(itkLightObject obj) -> itkImageToImageFilterIVF33IF3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIVF33IF3_cast(obj)

class itkImageToImageFilterIVF33ISS3(itkImageSourcePython.itkImageSourceISS3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIVF33ISS3 self, itkImageVF33 image)
        SetInput(itkImageToImageFilterIVF33ISS3 self, unsigned int arg0, itkImageVF33 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF33ISS3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageVF33 const *":
        """
        GetInput(itkImageToImageFilterIVF33ISS3 self) -> itkImageVF33
        GetInput(itkImageToImageFilterIVF33ISS3 self, unsigned int idx) -> itkImageVF33
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF33ISS3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageVF33') -> "void":
        """
        PushBackInput(itkImageToImageFilterIVF33ISS3 self, itkImageVF33 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF33ISS3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIVF33ISS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF33ISS3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageVF33') -> "void":
        """PushFrontInput(itkImageToImageFilterIVF33ISS3 self, itkImageVF33 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF33ISS3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIVF33ISS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF33ISS3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIVF33ISS3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF33ISS3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIVF33ISS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF33ISS3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIVF33ISS3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF33ISS3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIVF33ISS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF33ISS3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIVF33ISS3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF33ISS3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIVF33ISS3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF33ISS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIVF33ISS3

        Create a new object of the class itkImageToImageFilterIVF33ISS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIVF33ISS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIVF33ISS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIVF33ISS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIVF33ISS3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF33ISS3_SetInput, None, itkImageToImageFilterIVF33ISS3)
itkImageToImageFilterIVF33ISS3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF33ISS3_GetInput, None, itkImageToImageFilterIVF33ISS3)
itkImageToImageFilterIVF33ISS3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF33ISS3_PushBackInput, None, itkImageToImageFilterIVF33ISS3)
itkImageToImageFilterIVF33ISS3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF33ISS3_PopBackInput, None, itkImageToImageFilterIVF33ISS3)
itkImageToImageFilterIVF33ISS3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF33ISS3_PushFrontInput, None, itkImageToImageFilterIVF33ISS3)
itkImageToImageFilterIVF33ISS3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF33ISS3_PopFrontInput, None, itkImageToImageFilterIVF33ISS3)
itkImageToImageFilterIVF33ISS3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF33ISS3_SetCoordinateTolerance, None, itkImageToImageFilterIVF33ISS3)
itkImageToImageFilterIVF33ISS3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF33ISS3_GetCoordinateTolerance, None, itkImageToImageFilterIVF33ISS3)
itkImageToImageFilterIVF33ISS3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF33ISS3_SetDirectionTolerance, None, itkImageToImageFilterIVF33ISS3)
itkImageToImageFilterIVF33ISS3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF33ISS3_GetDirectionTolerance, None, itkImageToImageFilterIVF33ISS3)
itkImageToImageFilterIVF33ISS3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIVF33ISS3_swigregister
itkImageToImageFilterIVF33ISS3_swigregister(itkImageToImageFilterIVF33ISS3)

def itkImageToImageFilterIVF33ISS3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF33ISS3 *":
    """itkImageToImageFilterIVF33ISS3_cast(itkLightObject obj) -> itkImageToImageFilterIVF33ISS3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIVF33ISS3_cast(obj)

class itkImageToImageFilterIVF33IUC3(itkImageSourcePython.itkImageSourceIUC3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIVF33IUC3 self, itkImageVF33 image)
        SetInput(itkImageToImageFilterIVF33IUC3 self, unsigned int arg0, itkImageVF33 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF33IUC3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageVF33 const *":
        """
        GetInput(itkImageToImageFilterIVF33IUC3 self) -> itkImageVF33
        GetInput(itkImageToImageFilterIVF33IUC3 self, unsigned int idx) -> itkImageVF33
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF33IUC3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageVF33') -> "void":
        """
        PushBackInput(itkImageToImageFilterIVF33IUC3 self, itkImageVF33 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF33IUC3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIVF33IUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF33IUC3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageVF33') -> "void":
        """PushFrontInput(itkImageToImageFilterIVF33IUC3 self, itkImageVF33 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF33IUC3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIVF33IUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF33IUC3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIVF33IUC3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF33IUC3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIVF33IUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF33IUC3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIVF33IUC3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF33IUC3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIVF33IUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF33IUC3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIVF33IUC3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF33IUC3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIVF33IUC3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF33IUC3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIVF33IUC3

        Create a new object of the class itkImageToImageFilterIVF33IUC3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIVF33IUC3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIVF33IUC3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIVF33IUC3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIVF33IUC3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF33IUC3_SetInput, None, itkImageToImageFilterIVF33IUC3)
itkImageToImageFilterIVF33IUC3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF33IUC3_GetInput, None, itkImageToImageFilterIVF33IUC3)
itkImageToImageFilterIVF33IUC3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF33IUC3_PushBackInput, None, itkImageToImageFilterIVF33IUC3)
itkImageToImageFilterIVF33IUC3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF33IUC3_PopBackInput, None, itkImageToImageFilterIVF33IUC3)
itkImageToImageFilterIVF33IUC3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF33IUC3_PushFrontInput, None, itkImageToImageFilterIVF33IUC3)
itkImageToImageFilterIVF33IUC3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF33IUC3_PopFrontInput, None, itkImageToImageFilterIVF33IUC3)
itkImageToImageFilterIVF33IUC3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF33IUC3_SetCoordinateTolerance, None, itkImageToImageFilterIVF33IUC3)
itkImageToImageFilterIVF33IUC3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF33IUC3_GetCoordinateTolerance, None, itkImageToImageFilterIVF33IUC3)
itkImageToImageFilterIVF33IUC3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF33IUC3_SetDirectionTolerance, None, itkImageToImageFilterIVF33IUC3)
itkImageToImageFilterIVF33IUC3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF33IUC3_GetDirectionTolerance, None, itkImageToImageFilterIVF33IUC3)
itkImageToImageFilterIVF33IUC3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIVF33IUC3_swigregister
itkImageToImageFilterIVF33IUC3_swigregister(itkImageToImageFilterIVF33IUC3)

def itkImageToImageFilterIVF33IUC3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF33IUC3 *":
    """itkImageToImageFilterIVF33IUC3_cast(itkLightObject obj) -> itkImageToImageFilterIVF33IUC3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIVF33IUC3_cast(obj)

class itkImageToImageFilterIVF33IUS3(itkImageSourcePython.itkImageSourceIUS3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIVF33IUS3 self, itkImageVF33 image)
        SetInput(itkImageToImageFilterIVF33IUS3 self, unsigned int arg0, itkImageVF33 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF33IUS3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageVF33 const *":
        """
        GetInput(itkImageToImageFilterIVF33IUS3 self) -> itkImageVF33
        GetInput(itkImageToImageFilterIVF33IUS3 self, unsigned int idx) -> itkImageVF33
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF33IUS3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageVF33') -> "void":
        """
        PushBackInput(itkImageToImageFilterIVF33IUS3 self, itkImageVF33 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF33IUS3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIVF33IUS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF33IUS3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageVF33') -> "void":
        """PushFrontInput(itkImageToImageFilterIVF33IUS3 self, itkImageVF33 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF33IUS3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIVF33IUS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF33IUS3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIVF33IUS3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF33IUS3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIVF33IUS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF33IUS3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIVF33IUS3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF33IUS3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIVF33IUS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF33IUS3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIVF33IUS3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF33IUS3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIVF33IUS3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF33IUS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIVF33IUS3

        Create a new object of the class itkImageToImageFilterIVF33IUS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIVF33IUS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIVF33IUS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIVF33IUS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIVF33IUS3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF33IUS3_SetInput, None, itkImageToImageFilterIVF33IUS3)
itkImageToImageFilterIVF33IUS3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF33IUS3_GetInput, None, itkImageToImageFilterIVF33IUS3)
itkImageToImageFilterIVF33IUS3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF33IUS3_PushBackInput, None, itkImageToImageFilterIVF33IUS3)
itkImageToImageFilterIVF33IUS3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF33IUS3_PopBackInput, None, itkImageToImageFilterIVF33IUS3)
itkImageToImageFilterIVF33IUS3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF33IUS3_PushFrontInput, None, itkImageToImageFilterIVF33IUS3)
itkImageToImageFilterIVF33IUS3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF33IUS3_PopFrontInput, None, itkImageToImageFilterIVF33IUS3)
itkImageToImageFilterIVF33IUS3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF33IUS3_SetCoordinateTolerance, None, itkImageToImageFilterIVF33IUS3)
itkImageToImageFilterIVF33IUS3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF33IUS3_GetCoordinateTolerance, None, itkImageToImageFilterIVF33IUS3)
itkImageToImageFilterIVF33IUS3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF33IUS3_SetDirectionTolerance, None, itkImageToImageFilterIVF33IUS3)
itkImageToImageFilterIVF33IUS3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF33IUS3_GetDirectionTolerance, None, itkImageToImageFilterIVF33IUS3)
itkImageToImageFilterIVF33IUS3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIVF33IUS3_swigregister
itkImageToImageFilterIVF33IUS3_swigregister(itkImageToImageFilterIVF33IUS3)

def itkImageToImageFilterIVF33IUS3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF33IUS3 *":
    """itkImageToImageFilterIVF33IUS3_cast(itkLightObject obj) -> itkImageToImageFilterIVF33IUS3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIVF33IUS3_cast(obj)

class itkImageToImageFilterIVF42ID2(itkImageSourcePython.itkImageSourceID2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIVF42ID2 self, itkImageVF42 image)
        SetInput(itkImageToImageFilterIVF42ID2 self, unsigned int arg0, itkImageVF42 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF42ID2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageVF42 const *":
        """
        GetInput(itkImageToImageFilterIVF42ID2 self) -> itkImageVF42
        GetInput(itkImageToImageFilterIVF42ID2 self, unsigned int idx) -> itkImageVF42
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF42ID2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageVF42') -> "void":
        """
        PushBackInput(itkImageToImageFilterIVF42ID2 self, itkImageVF42 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF42ID2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIVF42ID2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF42ID2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageVF42') -> "void":
        """PushFrontInput(itkImageToImageFilterIVF42ID2 self, itkImageVF42 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF42ID2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIVF42ID2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF42ID2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIVF42ID2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF42ID2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIVF42ID2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF42ID2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIVF42ID2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF42ID2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIVF42ID2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF42ID2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIVF42ID2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF42ID2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIVF42ID2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF42ID2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIVF42ID2

        Create a new object of the class itkImageToImageFilterIVF42ID2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIVF42ID2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIVF42ID2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIVF42ID2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIVF42ID2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF42ID2_SetInput, None, itkImageToImageFilterIVF42ID2)
itkImageToImageFilterIVF42ID2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF42ID2_GetInput, None, itkImageToImageFilterIVF42ID2)
itkImageToImageFilterIVF42ID2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF42ID2_PushBackInput, None, itkImageToImageFilterIVF42ID2)
itkImageToImageFilterIVF42ID2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF42ID2_PopBackInput, None, itkImageToImageFilterIVF42ID2)
itkImageToImageFilterIVF42ID2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF42ID2_PushFrontInput, None, itkImageToImageFilterIVF42ID2)
itkImageToImageFilterIVF42ID2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF42ID2_PopFrontInput, None, itkImageToImageFilterIVF42ID2)
itkImageToImageFilterIVF42ID2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF42ID2_SetCoordinateTolerance, None, itkImageToImageFilterIVF42ID2)
itkImageToImageFilterIVF42ID2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF42ID2_GetCoordinateTolerance, None, itkImageToImageFilterIVF42ID2)
itkImageToImageFilterIVF42ID2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF42ID2_SetDirectionTolerance, None, itkImageToImageFilterIVF42ID2)
itkImageToImageFilterIVF42ID2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF42ID2_GetDirectionTolerance, None, itkImageToImageFilterIVF42ID2)
itkImageToImageFilterIVF42ID2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIVF42ID2_swigregister
itkImageToImageFilterIVF42ID2_swigregister(itkImageToImageFilterIVF42ID2)

def itkImageToImageFilterIVF42ID2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF42ID2 *":
    """itkImageToImageFilterIVF42ID2_cast(itkLightObject obj) -> itkImageToImageFilterIVF42ID2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIVF42ID2_cast(obj)

class itkImageToImageFilterIVF42IF2(itkImageSourcePython.itkImageSourceIF2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIVF42IF2 self, itkImageVF42 image)
        SetInput(itkImageToImageFilterIVF42IF2 self, unsigned int arg0, itkImageVF42 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF42IF2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageVF42 const *":
        """
        GetInput(itkImageToImageFilterIVF42IF2 self) -> itkImageVF42
        GetInput(itkImageToImageFilterIVF42IF2 self, unsigned int idx) -> itkImageVF42
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF42IF2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageVF42') -> "void":
        """
        PushBackInput(itkImageToImageFilterIVF42IF2 self, itkImageVF42 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF42IF2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIVF42IF2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF42IF2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageVF42') -> "void":
        """PushFrontInput(itkImageToImageFilterIVF42IF2 self, itkImageVF42 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF42IF2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIVF42IF2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF42IF2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIVF42IF2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF42IF2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIVF42IF2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF42IF2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIVF42IF2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF42IF2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIVF42IF2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF42IF2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIVF42IF2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF42IF2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIVF42IF2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF42IF2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIVF42IF2

        Create a new object of the class itkImageToImageFilterIVF42IF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIVF42IF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIVF42IF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIVF42IF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIVF42IF2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF42IF2_SetInput, None, itkImageToImageFilterIVF42IF2)
itkImageToImageFilterIVF42IF2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF42IF2_GetInput, None, itkImageToImageFilterIVF42IF2)
itkImageToImageFilterIVF42IF2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF42IF2_PushBackInput, None, itkImageToImageFilterIVF42IF2)
itkImageToImageFilterIVF42IF2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF42IF2_PopBackInput, None, itkImageToImageFilterIVF42IF2)
itkImageToImageFilterIVF42IF2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF42IF2_PushFrontInput, None, itkImageToImageFilterIVF42IF2)
itkImageToImageFilterIVF42IF2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF42IF2_PopFrontInput, None, itkImageToImageFilterIVF42IF2)
itkImageToImageFilterIVF42IF2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF42IF2_SetCoordinateTolerance, None, itkImageToImageFilterIVF42IF2)
itkImageToImageFilterIVF42IF2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF42IF2_GetCoordinateTolerance, None, itkImageToImageFilterIVF42IF2)
itkImageToImageFilterIVF42IF2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF42IF2_SetDirectionTolerance, None, itkImageToImageFilterIVF42IF2)
itkImageToImageFilterIVF42IF2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF42IF2_GetDirectionTolerance, None, itkImageToImageFilterIVF42IF2)
itkImageToImageFilterIVF42IF2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIVF42IF2_swigregister
itkImageToImageFilterIVF42IF2_swigregister(itkImageToImageFilterIVF42IF2)

def itkImageToImageFilterIVF42IF2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF42IF2 *":
    """itkImageToImageFilterIVF42IF2_cast(itkLightObject obj) -> itkImageToImageFilterIVF42IF2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIVF42IF2_cast(obj)

class itkImageToImageFilterIVF42ISS2(itkImageSourcePython.itkImageSourceISS2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIVF42ISS2 self, itkImageVF42 image)
        SetInput(itkImageToImageFilterIVF42ISS2 self, unsigned int arg0, itkImageVF42 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF42ISS2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageVF42 const *":
        """
        GetInput(itkImageToImageFilterIVF42ISS2 self) -> itkImageVF42
        GetInput(itkImageToImageFilterIVF42ISS2 self, unsigned int idx) -> itkImageVF42
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF42ISS2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageVF42') -> "void":
        """
        PushBackInput(itkImageToImageFilterIVF42ISS2 self, itkImageVF42 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF42ISS2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIVF42ISS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF42ISS2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageVF42') -> "void":
        """PushFrontInput(itkImageToImageFilterIVF42ISS2 self, itkImageVF42 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF42ISS2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIVF42ISS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF42ISS2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIVF42ISS2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF42ISS2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIVF42ISS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF42ISS2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIVF42ISS2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF42ISS2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIVF42ISS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF42ISS2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIVF42ISS2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF42ISS2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIVF42ISS2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF42ISS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIVF42ISS2

        Create a new object of the class itkImageToImageFilterIVF42ISS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIVF42ISS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIVF42ISS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIVF42ISS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIVF42ISS2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF42ISS2_SetInput, None, itkImageToImageFilterIVF42ISS2)
itkImageToImageFilterIVF42ISS2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF42ISS2_GetInput, None, itkImageToImageFilterIVF42ISS2)
itkImageToImageFilterIVF42ISS2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF42ISS2_PushBackInput, None, itkImageToImageFilterIVF42ISS2)
itkImageToImageFilterIVF42ISS2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF42ISS2_PopBackInput, None, itkImageToImageFilterIVF42ISS2)
itkImageToImageFilterIVF42ISS2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF42ISS2_PushFrontInput, None, itkImageToImageFilterIVF42ISS2)
itkImageToImageFilterIVF42ISS2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF42ISS2_PopFrontInput, None, itkImageToImageFilterIVF42ISS2)
itkImageToImageFilterIVF42ISS2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF42ISS2_SetCoordinateTolerance, None, itkImageToImageFilterIVF42ISS2)
itkImageToImageFilterIVF42ISS2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF42ISS2_GetCoordinateTolerance, None, itkImageToImageFilterIVF42ISS2)
itkImageToImageFilterIVF42ISS2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF42ISS2_SetDirectionTolerance, None, itkImageToImageFilterIVF42ISS2)
itkImageToImageFilterIVF42ISS2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF42ISS2_GetDirectionTolerance, None, itkImageToImageFilterIVF42ISS2)
itkImageToImageFilterIVF42ISS2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIVF42ISS2_swigregister
itkImageToImageFilterIVF42ISS2_swigregister(itkImageToImageFilterIVF42ISS2)

def itkImageToImageFilterIVF42ISS2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF42ISS2 *":
    """itkImageToImageFilterIVF42ISS2_cast(itkLightObject obj) -> itkImageToImageFilterIVF42ISS2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIVF42ISS2_cast(obj)

class itkImageToImageFilterIVF42IUC2(itkImageSourcePython.itkImageSourceIUC2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIVF42IUC2 self, itkImageVF42 image)
        SetInput(itkImageToImageFilterIVF42IUC2 self, unsigned int arg0, itkImageVF42 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF42IUC2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageVF42 const *":
        """
        GetInput(itkImageToImageFilterIVF42IUC2 self) -> itkImageVF42
        GetInput(itkImageToImageFilterIVF42IUC2 self, unsigned int idx) -> itkImageVF42
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF42IUC2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageVF42') -> "void":
        """
        PushBackInput(itkImageToImageFilterIVF42IUC2 self, itkImageVF42 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF42IUC2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIVF42IUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF42IUC2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageVF42') -> "void":
        """PushFrontInput(itkImageToImageFilterIVF42IUC2 self, itkImageVF42 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF42IUC2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIVF42IUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF42IUC2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIVF42IUC2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF42IUC2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIVF42IUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF42IUC2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIVF42IUC2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF42IUC2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIVF42IUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF42IUC2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIVF42IUC2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF42IUC2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIVF42IUC2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF42IUC2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIVF42IUC2

        Create a new object of the class itkImageToImageFilterIVF42IUC2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIVF42IUC2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIVF42IUC2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIVF42IUC2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIVF42IUC2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF42IUC2_SetInput, None, itkImageToImageFilterIVF42IUC2)
itkImageToImageFilterIVF42IUC2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF42IUC2_GetInput, None, itkImageToImageFilterIVF42IUC2)
itkImageToImageFilterIVF42IUC2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF42IUC2_PushBackInput, None, itkImageToImageFilterIVF42IUC2)
itkImageToImageFilterIVF42IUC2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF42IUC2_PopBackInput, None, itkImageToImageFilterIVF42IUC2)
itkImageToImageFilterIVF42IUC2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF42IUC2_PushFrontInput, None, itkImageToImageFilterIVF42IUC2)
itkImageToImageFilterIVF42IUC2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF42IUC2_PopFrontInput, None, itkImageToImageFilterIVF42IUC2)
itkImageToImageFilterIVF42IUC2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF42IUC2_SetCoordinateTolerance, None, itkImageToImageFilterIVF42IUC2)
itkImageToImageFilterIVF42IUC2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF42IUC2_GetCoordinateTolerance, None, itkImageToImageFilterIVF42IUC2)
itkImageToImageFilterIVF42IUC2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF42IUC2_SetDirectionTolerance, None, itkImageToImageFilterIVF42IUC2)
itkImageToImageFilterIVF42IUC2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF42IUC2_GetDirectionTolerance, None, itkImageToImageFilterIVF42IUC2)
itkImageToImageFilterIVF42IUC2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIVF42IUC2_swigregister
itkImageToImageFilterIVF42IUC2_swigregister(itkImageToImageFilterIVF42IUC2)

def itkImageToImageFilterIVF42IUC2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF42IUC2 *":
    """itkImageToImageFilterIVF42IUC2_cast(itkLightObject obj) -> itkImageToImageFilterIVF42IUC2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIVF42IUC2_cast(obj)

class itkImageToImageFilterIVF42IUS2(itkImageSourcePython.itkImageSourceIUS2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIVF42IUS2 self, itkImageVF42 image)
        SetInput(itkImageToImageFilterIVF42IUS2 self, unsigned int arg0, itkImageVF42 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF42IUS2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageVF42 const *":
        """
        GetInput(itkImageToImageFilterIVF42IUS2 self) -> itkImageVF42
        GetInput(itkImageToImageFilterIVF42IUS2 self, unsigned int idx) -> itkImageVF42
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF42IUS2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageVF42') -> "void":
        """
        PushBackInput(itkImageToImageFilterIVF42IUS2 self, itkImageVF42 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF42IUS2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIVF42IUS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF42IUS2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageVF42') -> "void":
        """PushFrontInput(itkImageToImageFilterIVF42IUS2 self, itkImageVF42 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF42IUS2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIVF42IUS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF42IUS2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIVF42IUS2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF42IUS2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIVF42IUS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF42IUS2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIVF42IUS2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF42IUS2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIVF42IUS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF42IUS2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIVF42IUS2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF42IUS2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIVF42IUS2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF42IUS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIVF42IUS2

        Create a new object of the class itkImageToImageFilterIVF42IUS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIVF42IUS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIVF42IUS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIVF42IUS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIVF42IUS2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF42IUS2_SetInput, None, itkImageToImageFilterIVF42IUS2)
itkImageToImageFilterIVF42IUS2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF42IUS2_GetInput, None, itkImageToImageFilterIVF42IUS2)
itkImageToImageFilterIVF42IUS2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF42IUS2_PushBackInput, None, itkImageToImageFilterIVF42IUS2)
itkImageToImageFilterIVF42IUS2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF42IUS2_PopBackInput, None, itkImageToImageFilterIVF42IUS2)
itkImageToImageFilterIVF42IUS2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF42IUS2_PushFrontInput, None, itkImageToImageFilterIVF42IUS2)
itkImageToImageFilterIVF42IUS2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF42IUS2_PopFrontInput, None, itkImageToImageFilterIVF42IUS2)
itkImageToImageFilterIVF42IUS2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF42IUS2_SetCoordinateTolerance, None, itkImageToImageFilterIVF42IUS2)
itkImageToImageFilterIVF42IUS2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF42IUS2_GetCoordinateTolerance, None, itkImageToImageFilterIVF42IUS2)
itkImageToImageFilterIVF42IUS2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF42IUS2_SetDirectionTolerance, None, itkImageToImageFilterIVF42IUS2)
itkImageToImageFilterIVF42IUS2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF42IUS2_GetDirectionTolerance, None, itkImageToImageFilterIVF42IUS2)
itkImageToImageFilterIVF42IUS2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIVF42IUS2_swigregister
itkImageToImageFilterIVF42IUS2_swigregister(itkImageToImageFilterIVF42IUS2)

def itkImageToImageFilterIVF42IUS2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF42IUS2 *":
    """itkImageToImageFilterIVF42IUS2_cast(itkLightObject obj) -> itkImageToImageFilterIVF42IUS2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIVF42IUS2_cast(obj)

class itkImageToImageFilterIVF43ID3(itkImageSourcePython.itkImageSourceID3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIVF43ID3 self, itkImageVF43 image)
        SetInput(itkImageToImageFilterIVF43ID3 self, unsigned int arg0, itkImageVF43 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF43ID3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageVF43 const *":
        """
        GetInput(itkImageToImageFilterIVF43ID3 self) -> itkImageVF43
        GetInput(itkImageToImageFilterIVF43ID3 self, unsigned int idx) -> itkImageVF43
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF43ID3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageVF43') -> "void":
        """
        PushBackInput(itkImageToImageFilterIVF43ID3 self, itkImageVF43 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF43ID3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIVF43ID3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF43ID3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageVF43') -> "void":
        """PushFrontInput(itkImageToImageFilterIVF43ID3 self, itkImageVF43 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF43ID3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIVF43ID3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF43ID3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIVF43ID3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF43ID3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIVF43ID3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF43ID3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIVF43ID3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF43ID3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIVF43ID3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF43ID3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIVF43ID3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF43ID3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIVF43ID3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF43ID3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIVF43ID3

        Create a new object of the class itkImageToImageFilterIVF43ID3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIVF43ID3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIVF43ID3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIVF43ID3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIVF43ID3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF43ID3_SetInput, None, itkImageToImageFilterIVF43ID3)
itkImageToImageFilterIVF43ID3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF43ID3_GetInput, None, itkImageToImageFilterIVF43ID3)
itkImageToImageFilterIVF43ID3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF43ID3_PushBackInput, None, itkImageToImageFilterIVF43ID3)
itkImageToImageFilterIVF43ID3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF43ID3_PopBackInput, None, itkImageToImageFilterIVF43ID3)
itkImageToImageFilterIVF43ID3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF43ID3_PushFrontInput, None, itkImageToImageFilterIVF43ID3)
itkImageToImageFilterIVF43ID3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF43ID3_PopFrontInput, None, itkImageToImageFilterIVF43ID3)
itkImageToImageFilterIVF43ID3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF43ID3_SetCoordinateTolerance, None, itkImageToImageFilterIVF43ID3)
itkImageToImageFilterIVF43ID3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF43ID3_GetCoordinateTolerance, None, itkImageToImageFilterIVF43ID3)
itkImageToImageFilterIVF43ID3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF43ID3_SetDirectionTolerance, None, itkImageToImageFilterIVF43ID3)
itkImageToImageFilterIVF43ID3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF43ID3_GetDirectionTolerance, None, itkImageToImageFilterIVF43ID3)
itkImageToImageFilterIVF43ID3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIVF43ID3_swigregister
itkImageToImageFilterIVF43ID3_swigregister(itkImageToImageFilterIVF43ID3)

def itkImageToImageFilterIVF43ID3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF43ID3 *":
    """itkImageToImageFilterIVF43ID3_cast(itkLightObject obj) -> itkImageToImageFilterIVF43ID3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIVF43ID3_cast(obj)

class itkImageToImageFilterIVF43IF3(itkImageSourcePython.itkImageSourceIF3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIVF43IF3 self, itkImageVF43 image)
        SetInput(itkImageToImageFilterIVF43IF3 self, unsigned int arg0, itkImageVF43 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF43IF3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageVF43 const *":
        """
        GetInput(itkImageToImageFilterIVF43IF3 self) -> itkImageVF43
        GetInput(itkImageToImageFilterIVF43IF3 self, unsigned int idx) -> itkImageVF43
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF43IF3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageVF43') -> "void":
        """
        PushBackInput(itkImageToImageFilterIVF43IF3 self, itkImageVF43 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF43IF3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIVF43IF3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF43IF3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageVF43') -> "void":
        """PushFrontInput(itkImageToImageFilterIVF43IF3 self, itkImageVF43 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF43IF3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIVF43IF3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF43IF3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIVF43IF3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF43IF3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIVF43IF3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF43IF3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIVF43IF3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF43IF3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIVF43IF3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF43IF3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIVF43IF3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF43IF3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIVF43IF3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF43IF3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIVF43IF3

        Create a new object of the class itkImageToImageFilterIVF43IF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIVF43IF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIVF43IF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIVF43IF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIVF43IF3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF43IF3_SetInput, None, itkImageToImageFilterIVF43IF3)
itkImageToImageFilterIVF43IF3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF43IF3_GetInput, None, itkImageToImageFilterIVF43IF3)
itkImageToImageFilterIVF43IF3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF43IF3_PushBackInput, None, itkImageToImageFilterIVF43IF3)
itkImageToImageFilterIVF43IF3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF43IF3_PopBackInput, None, itkImageToImageFilterIVF43IF3)
itkImageToImageFilterIVF43IF3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF43IF3_PushFrontInput, None, itkImageToImageFilterIVF43IF3)
itkImageToImageFilterIVF43IF3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF43IF3_PopFrontInput, None, itkImageToImageFilterIVF43IF3)
itkImageToImageFilterIVF43IF3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF43IF3_SetCoordinateTolerance, None, itkImageToImageFilterIVF43IF3)
itkImageToImageFilterIVF43IF3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF43IF3_GetCoordinateTolerance, None, itkImageToImageFilterIVF43IF3)
itkImageToImageFilterIVF43IF3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF43IF3_SetDirectionTolerance, None, itkImageToImageFilterIVF43IF3)
itkImageToImageFilterIVF43IF3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF43IF3_GetDirectionTolerance, None, itkImageToImageFilterIVF43IF3)
itkImageToImageFilterIVF43IF3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIVF43IF3_swigregister
itkImageToImageFilterIVF43IF3_swigregister(itkImageToImageFilterIVF43IF3)

def itkImageToImageFilterIVF43IF3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF43IF3 *":
    """itkImageToImageFilterIVF43IF3_cast(itkLightObject obj) -> itkImageToImageFilterIVF43IF3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIVF43IF3_cast(obj)

class itkImageToImageFilterIVF43ISS3(itkImageSourcePython.itkImageSourceISS3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIVF43ISS3 self, itkImageVF43 image)
        SetInput(itkImageToImageFilterIVF43ISS3 self, unsigned int arg0, itkImageVF43 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF43ISS3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageVF43 const *":
        """
        GetInput(itkImageToImageFilterIVF43ISS3 self) -> itkImageVF43
        GetInput(itkImageToImageFilterIVF43ISS3 self, unsigned int idx) -> itkImageVF43
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF43ISS3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageVF43') -> "void":
        """
        PushBackInput(itkImageToImageFilterIVF43ISS3 self, itkImageVF43 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF43ISS3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIVF43ISS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF43ISS3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageVF43') -> "void":
        """PushFrontInput(itkImageToImageFilterIVF43ISS3 self, itkImageVF43 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF43ISS3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIVF43ISS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF43ISS3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIVF43ISS3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF43ISS3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIVF43ISS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF43ISS3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIVF43ISS3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF43ISS3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIVF43ISS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF43ISS3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIVF43ISS3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF43ISS3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIVF43ISS3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF43ISS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIVF43ISS3

        Create a new object of the class itkImageToImageFilterIVF43ISS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIVF43ISS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIVF43ISS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIVF43ISS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIVF43ISS3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF43ISS3_SetInput, None, itkImageToImageFilterIVF43ISS3)
itkImageToImageFilterIVF43ISS3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF43ISS3_GetInput, None, itkImageToImageFilterIVF43ISS3)
itkImageToImageFilterIVF43ISS3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF43ISS3_PushBackInput, None, itkImageToImageFilterIVF43ISS3)
itkImageToImageFilterIVF43ISS3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF43ISS3_PopBackInput, None, itkImageToImageFilterIVF43ISS3)
itkImageToImageFilterIVF43ISS3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF43ISS3_PushFrontInput, None, itkImageToImageFilterIVF43ISS3)
itkImageToImageFilterIVF43ISS3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF43ISS3_PopFrontInput, None, itkImageToImageFilterIVF43ISS3)
itkImageToImageFilterIVF43ISS3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF43ISS3_SetCoordinateTolerance, None, itkImageToImageFilterIVF43ISS3)
itkImageToImageFilterIVF43ISS3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF43ISS3_GetCoordinateTolerance, None, itkImageToImageFilterIVF43ISS3)
itkImageToImageFilterIVF43ISS3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF43ISS3_SetDirectionTolerance, None, itkImageToImageFilterIVF43ISS3)
itkImageToImageFilterIVF43ISS3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF43ISS3_GetDirectionTolerance, None, itkImageToImageFilterIVF43ISS3)
itkImageToImageFilterIVF43ISS3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIVF43ISS3_swigregister
itkImageToImageFilterIVF43ISS3_swigregister(itkImageToImageFilterIVF43ISS3)

def itkImageToImageFilterIVF43ISS3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF43ISS3 *":
    """itkImageToImageFilterIVF43ISS3_cast(itkLightObject obj) -> itkImageToImageFilterIVF43ISS3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIVF43ISS3_cast(obj)

class itkImageToImageFilterIVF43IUC3(itkImageSourcePython.itkImageSourceIUC3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIVF43IUC3 self, itkImageVF43 image)
        SetInput(itkImageToImageFilterIVF43IUC3 self, unsigned int arg0, itkImageVF43 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF43IUC3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageVF43 const *":
        """
        GetInput(itkImageToImageFilterIVF43IUC3 self) -> itkImageVF43
        GetInput(itkImageToImageFilterIVF43IUC3 self, unsigned int idx) -> itkImageVF43
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF43IUC3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageVF43') -> "void":
        """
        PushBackInput(itkImageToImageFilterIVF43IUC3 self, itkImageVF43 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF43IUC3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIVF43IUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF43IUC3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageVF43') -> "void":
        """PushFrontInput(itkImageToImageFilterIVF43IUC3 self, itkImageVF43 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF43IUC3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIVF43IUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF43IUC3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIVF43IUC3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF43IUC3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIVF43IUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF43IUC3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIVF43IUC3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF43IUC3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIVF43IUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF43IUC3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIVF43IUC3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF43IUC3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIVF43IUC3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF43IUC3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIVF43IUC3

        Create a new object of the class itkImageToImageFilterIVF43IUC3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIVF43IUC3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIVF43IUC3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIVF43IUC3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIVF43IUC3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF43IUC3_SetInput, None, itkImageToImageFilterIVF43IUC3)
itkImageToImageFilterIVF43IUC3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF43IUC3_GetInput, None, itkImageToImageFilterIVF43IUC3)
itkImageToImageFilterIVF43IUC3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF43IUC3_PushBackInput, None, itkImageToImageFilterIVF43IUC3)
itkImageToImageFilterIVF43IUC3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF43IUC3_PopBackInput, None, itkImageToImageFilterIVF43IUC3)
itkImageToImageFilterIVF43IUC3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF43IUC3_PushFrontInput, None, itkImageToImageFilterIVF43IUC3)
itkImageToImageFilterIVF43IUC3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF43IUC3_PopFrontInput, None, itkImageToImageFilterIVF43IUC3)
itkImageToImageFilterIVF43IUC3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF43IUC3_SetCoordinateTolerance, None, itkImageToImageFilterIVF43IUC3)
itkImageToImageFilterIVF43IUC3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF43IUC3_GetCoordinateTolerance, None, itkImageToImageFilterIVF43IUC3)
itkImageToImageFilterIVF43IUC3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF43IUC3_SetDirectionTolerance, None, itkImageToImageFilterIVF43IUC3)
itkImageToImageFilterIVF43IUC3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF43IUC3_GetDirectionTolerance, None, itkImageToImageFilterIVF43IUC3)
itkImageToImageFilterIVF43IUC3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIVF43IUC3_swigregister
itkImageToImageFilterIVF43IUC3_swigregister(itkImageToImageFilterIVF43IUC3)

def itkImageToImageFilterIVF43IUC3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF43IUC3 *":
    """itkImageToImageFilterIVF43IUC3_cast(itkLightObject obj) -> itkImageToImageFilterIVF43IUC3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIVF43IUC3_cast(obj)

class itkImageToImageFilterIVF43IUS3(itkImageSourcePython.itkImageSourceIUS3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIVF43IUS3 self, itkImageVF43 image)
        SetInput(itkImageToImageFilterIVF43IUS3 self, unsigned int arg0, itkImageVF43 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF43IUS3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageVF43 const *":
        """
        GetInput(itkImageToImageFilterIVF43IUS3 self) -> itkImageVF43
        GetInput(itkImageToImageFilterIVF43IUS3 self, unsigned int idx) -> itkImageVF43
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF43IUS3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageVF43') -> "void":
        """
        PushBackInput(itkImageToImageFilterIVF43IUS3 self, itkImageVF43 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF43IUS3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIVF43IUS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF43IUS3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageVF43') -> "void":
        """PushFrontInput(itkImageToImageFilterIVF43IUS3 self, itkImageVF43 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF43IUS3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIVF43IUS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF43IUS3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIVF43IUS3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF43IUS3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIVF43IUS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF43IUS3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIVF43IUS3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF43IUS3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIVF43IUS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF43IUS3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterIVF43IUS3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF43IUS3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIVF43IUS3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterIVF43IUS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIVF43IUS3

        Create a new object of the class itkImageToImageFilterIVF43IUS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIVF43IUS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIVF43IUS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIVF43IUS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIVF43IUS3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF43IUS3_SetInput, None, itkImageToImageFilterIVF43IUS3)
itkImageToImageFilterIVF43IUS3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF43IUS3_GetInput, None, itkImageToImageFilterIVF43IUS3)
itkImageToImageFilterIVF43IUS3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF43IUS3_PushBackInput, None, itkImageToImageFilterIVF43IUS3)
itkImageToImageFilterIVF43IUS3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF43IUS3_PopBackInput, None, itkImageToImageFilterIVF43IUS3)
itkImageToImageFilterIVF43IUS3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF43IUS3_PushFrontInput, None, itkImageToImageFilterIVF43IUS3)
itkImageToImageFilterIVF43IUS3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF43IUS3_PopFrontInput, None, itkImageToImageFilterIVF43IUS3)
itkImageToImageFilterIVF43IUS3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF43IUS3_SetCoordinateTolerance, None, itkImageToImageFilterIVF43IUS3)
itkImageToImageFilterIVF43IUS3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF43IUS3_GetCoordinateTolerance, None, itkImageToImageFilterIVF43IUS3)
itkImageToImageFilterIVF43IUS3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF43IUS3_SetDirectionTolerance, None, itkImageToImageFilterIVF43IUS3)
itkImageToImageFilterIVF43IUS3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterIVF43IUS3_GetDirectionTolerance, None, itkImageToImageFilterIVF43IUS3)
itkImageToImageFilterIVF43IUS3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterIVF43IUS3_swigregister
itkImageToImageFilterIVF43IUS3_swigregister(itkImageToImageFilterIVF43IUS3)

def itkImageToImageFilterIVF43IUS3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIVF43IUS3 *":
    """itkImageToImageFilterIVF43IUS3_cast(itkLightObject obj) -> itkImageToImageFilterIVF43IUS3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterIVF43IUS3_cast(obj)

class itkImageToImageFilterVID2ID2(itkImageSourcePython.itkImageSourceID2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterVID2ID2 self, itkVectorImageD2 image)
        SetInput(itkImageToImageFilterVID2ID2 self, unsigned int arg0, itkVectorImageD2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID2ID2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkVectorImageD2 const *":
        """
        GetInput(itkImageToImageFilterVID2ID2 self) -> itkVectorImageD2
        GetInput(itkImageToImageFilterVID2ID2 self, unsigned int idx) -> itkVectorImageD2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID2ID2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkVectorImageD2') -> "void":
        """
        PushBackInput(itkImageToImageFilterVID2ID2 self, itkVectorImageD2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID2ID2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterVID2ID2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID2ID2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkVectorImageD2') -> "void":
        """PushFrontInput(itkImageToImageFilterVID2ID2 self, itkVectorImageD2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID2ID2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterVID2ID2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID2ID2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterVID2ID2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID2ID2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterVID2ID2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID2ID2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterVID2ID2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID2ID2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterVID2ID2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID2ID2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterVID2ID2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterVID2ID2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterVID2ID2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID2ID2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterVID2ID2

        Create a new object of the class itkImageToImageFilterVID2ID2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterVID2ID2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterVID2ID2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterVID2ID2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterVID2ID2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID2ID2_SetInput, None, itkImageToImageFilterVID2ID2)
itkImageToImageFilterVID2ID2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID2ID2_GetInput, None, itkImageToImageFilterVID2ID2)
itkImageToImageFilterVID2ID2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID2ID2_PushBackInput, None, itkImageToImageFilterVID2ID2)
itkImageToImageFilterVID2ID2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID2ID2_PopBackInput, None, itkImageToImageFilterVID2ID2)
itkImageToImageFilterVID2ID2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID2ID2_PushFrontInput, None, itkImageToImageFilterVID2ID2)
itkImageToImageFilterVID2ID2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID2ID2_PopFrontInput, None, itkImageToImageFilterVID2ID2)
itkImageToImageFilterVID2ID2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID2ID2_SetCoordinateTolerance, None, itkImageToImageFilterVID2ID2)
itkImageToImageFilterVID2ID2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID2ID2_GetCoordinateTolerance, None, itkImageToImageFilterVID2ID2)
itkImageToImageFilterVID2ID2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID2ID2_SetDirectionTolerance, None, itkImageToImageFilterVID2ID2)
itkImageToImageFilterVID2ID2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID2ID2_GetDirectionTolerance, None, itkImageToImageFilterVID2ID2)
itkImageToImageFilterVID2ID2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterVID2ID2_swigregister
itkImageToImageFilterVID2ID2_swigregister(itkImageToImageFilterVID2ID2)

def itkImageToImageFilterVID2ID2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterVID2ID2 *":
    """itkImageToImageFilterVID2ID2_cast(itkLightObject obj) -> itkImageToImageFilterVID2ID2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterVID2ID2_cast(obj)

class itkImageToImageFilterVID2IF2(itkImageSourcePython.itkImageSourceIF2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterVID2IF2 self, itkVectorImageD2 image)
        SetInput(itkImageToImageFilterVID2IF2 self, unsigned int arg0, itkVectorImageD2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID2IF2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkVectorImageD2 const *":
        """
        GetInput(itkImageToImageFilterVID2IF2 self) -> itkVectorImageD2
        GetInput(itkImageToImageFilterVID2IF2 self, unsigned int idx) -> itkVectorImageD2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID2IF2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkVectorImageD2') -> "void":
        """
        PushBackInput(itkImageToImageFilterVID2IF2 self, itkVectorImageD2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID2IF2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterVID2IF2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID2IF2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkVectorImageD2') -> "void":
        """PushFrontInput(itkImageToImageFilterVID2IF2 self, itkVectorImageD2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID2IF2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterVID2IF2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID2IF2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterVID2IF2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID2IF2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterVID2IF2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID2IF2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterVID2IF2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID2IF2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterVID2IF2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID2IF2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterVID2IF2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterVID2IF2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterVID2IF2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID2IF2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterVID2IF2

        Create a new object of the class itkImageToImageFilterVID2IF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterVID2IF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterVID2IF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterVID2IF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterVID2IF2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID2IF2_SetInput, None, itkImageToImageFilterVID2IF2)
itkImageToImageFilterVID2IF2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID2IF2_GetInput, None, itkImageToImageFilterVID2IF2)
itkImageToImageFilterVID2IF2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID2IF2_PushBackInput, None, itkImageToImageFilterVID2IF2)
itkImageToImageFilterVID2IF2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID2IF2_PopBackInput, None, itkImageToImageFilterVID2IF2)
itkImageToImageFilterVID2IF2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID2IF2_PushFrontInput, None, itkImageToImageFilterVID2IF2)
itkImageToImageFilterVID2IF2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID2IF2_PopFrontInput, None, itkImageToImageFilterVID2IF2)
itkImageToImageFilterVID2IF2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID2IF2_SetCoordinateTolerance, None, itkImageToImageFilterVID2IF2)
itkImageToImageFilterVID2IF2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID2IF2_GetCoordinateTolerance, None, itkImageToImageFilterVID2IF2)
itkImageToImageFilterVID2IF2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID2IF2_SetDirectionTolerance, None, itkImageToImageFilterVID2IF2)
itkImageToImageFilterVID2IF2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID2IF2_GetDirectionTolerance, None, itkImageToImageFilterVID2IF2)
itkImageToImageFilterVID2IF2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterVID2IF2_swigregister
itkImageToImageFilterVID2IF2_swigregister(itkImageToImageFilterVID2IF2)

def itkImageToImageFilterVID2IF2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterVID2IF2 *":
    """itkImageToImageFilterVID2IF2_cast(itkLightObject obj) -> itkImageToImageFilterVID2IF2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterVID2IF2_cast(obj)

class itkImageToImageFilterVID2ISS2(itkImageSourcePython.itkImageSourceISS2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterVID2ISS2 self, itkVectorImageD2 image)
        SetInput(itkImageToImageFilterVID2ISS2 self, unsigned int arg0, itkVectorImageD2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID2ISS2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkVectorImageD2 const *":
        """
        GetInput(itkImageToImageFilterVID2ISS2 self) -> itkVectorImageD2
        GetInput(itkImageToImageFilterVID2ISS2 self, unsigned int idx) -> itkVectorImageD2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID2ISS2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkVectorImageD2') -> "void":
        """
        PushBackInput(itkImageToImageFilterVID2ISS2 self, itkVectorImageD2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID2ISS2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterVID2ISS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID2ISS2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkVectorImageD2') -> "void":
        """PushFrontInput(itkImageToImageFilterVID2ISS2 self, itkVectorImageD2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID2ISS2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterVID2ISS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID2ISS2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterVID2ISS2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID2ISS2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterVID2ISS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID2ISS2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterVID2ISS2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID2ISS2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterVID2ISS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID2ISS2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterVID2ISS2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterVID2ISS2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterVID2ISS2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID2ISS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterVID2ISS2

        Create a new object of the class itkImageToImageFilterVID2ISS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterVID2ISS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterVID2ISS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterVID2ISS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterVID2ISS2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID2ISS2_SetInput, None, itkImageToImageFilterVID2ISS2)
itkImageToImageFilterVID2ISS2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID2ISS2_GetInput, None, itkImageToImageFilterVID2ISS2)
itkImageToImageFilterVID2ISS2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID2ISS2_PushBackInput, None, itkImageToImageFilterVID2ISS2)
itkImageToImageFilterVID2ISS2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID2ISS2_PopBackInput, None, itkImageToImageFilterVID2ISS2)
itkImageToImageFilterVID2ISS2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID2ISS2_PushFrontInput, None, itkImageToImageFilterVID2ISS2)
itkImageToImageFilterVID2ISS2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID2ISS2_PopFrontInput, None, itkImageToImageFilterVID2ISS2)
itkImageToImageFilterVID2ISS2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID2ISS2_SetCoordinateTolerance, None, itkImageToImageFilterVID2ISS2)
itkImageToImageFilterVID2ISS2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID2ISS2_GetCoordinateTolerance, None, itkImageToImageFilterVID2ISS2)
itkImageToImageFilterVID2ISS2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID2ISS2_SetDirectionTolerance, None, itkImageToImageFilterVID2ISS2)
itkImageToImageFilterVID2ISS2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID2ISS2_GetDirectionTolerance, None, itkImageToImageFilterVID2ISS2)
itkImageToImageFilterVID2ISS2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterVID2ISS2_swigregister
itkImageToImageFilterVID2ISS2_swigregister(itkImageToImageFilterVID2ISS2)

def itkImageToImageFilterVID2ISS2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterVID2ISS2 *":
    """itkImageToImageFilterVID2ISS2_cast(itkLightObject obj) -> itkImageToImageFilterVID2ISS2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterVID2ISS2_cast(obj)

class itkImageToImageFilterVID2IUC2(itkImageSourcePython.itkImageSourceIUC2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterVID2IUC2 self, itkVectorImageD2 image)
        SetInput(itkImageToImageFilterVID2IUC2 self, unsigned int arg0, itkVectorImageD2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID2IUC2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkVectorImageD2 const *":
        """
        GetInput(itkImageToImageFilterVID2IUC2 self) -> itkVectorImageD2
        GetInput(itkImageToImageFilterVID2IUC2 self, unsigned int idx) -> itkVectorImageD2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID2IUC2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkVectorImageD2') -> "void":
        """
        PushBackInput(itkImageToImageFilterVID2IUC2 self, itkVectorImageD2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID2IUC2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterVID2IUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID2IUC2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkVectorImageD2') -> "void":
        """PushFrontInput(itkImageToImageFilterVID2IUC2 self, itkVectorImageD2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID2IUC2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterVID2IUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID2IUC2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterVID2IUC2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID2IUC2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterVID2IUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID2IUC2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterVID2IUC2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID2IUC2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterVID2IUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID2IUC2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterVID2IUC2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterVID2IUC2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterVID2IUC2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID2IUC2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterVID2IUC2

        Create a new object of the class itkImageToImageFilterVID2IUC2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterVID2IUC2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterVID2IUC2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterVID2IUC2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterVID2IUC2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID2IUC2_SetInput, None, itkImageToImageFilterVID2IUC2)
itkImageToImageFilterVID2IUC2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID2IUC2_GetInput, None, itkImageToImageFilterVID2IUC2)
itkImageToImageFilterVID2IUC2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID2IUC2_PushBackInput, None, itkImageToImageFilterVID2IUC2)
itkImageToImageFilterVID2IUC2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID2IUC2_PopBackInput, None, itkImageToImageFilterVID2IUC2)
itkImageToImageFilterVID2IUC2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID2IUC2_PushFrontInput, None, itkImageToImageFilterVID2IUC2)
itkImageToImageFilterVID2IUC2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID2IUC2_PopFrontInput, None, itkImageToImageFilterVID2IUC2)
itkImageToImageFilterVID2IUC2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID2IUC2_SetCoordinateTolerance, None, itkImageToImageFilterVID2IUC2)
itkImageToImageFilterVID2IUC2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID2IUC2_GetCoordinateTolerance, None, itkImageToImageFilterVID2IUC2)
itkImageToImageFilterVID2IUC2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID2IUC2_SetDirectionTolerance, None, itkImageToImageFilterVID2IUC2)
itkImageToImageFilterVID2IUC2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID2IUC2_GetDirectionTolerance, None, itkImageToImageFilterVID2IUC2)
itkImageToImageFilterVID2IUC2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterVID2IUC2_swigregister
itkImageToImageFilterVID2IUC2_swigregister(itkImageToImageFilterVID2IUC2)

def itkImageToImageFilterVID2IUC2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterVID2IUC2 *":
    """itkImageToImageFilterVID2IUC2_cast(itkLightObject obj) -> itkImageToImageFilterVID2IUC2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterVID2IUC2_cast(obj)

class itkImageToImageFilterVID2IUS2(itkImageSourcePython.itkImageSourceIUS2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterVID2IUS2 self, itkVectorImageD2 image)
        SetInput(itkImageToImageFilterVID2IUS2 self, unsigned int arg0, itkVectorImageD2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID2IUS2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkVectorImageD2 const *":
        """
        GetInput(itkImageToImageFilterVID2IUS2 self) -> itkVectorImageD2
        GetInput(itkImageToImageFilterVID2IUS2 self, unsigned int idx) -> itkVectorImageD2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID2IUS2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkVectorImageD2') -> "void":
        """
        PushBackInput(itkImageToImageFilterVID2IUS2 self, itkVectorImageD2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID2IUS2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterVID2IUS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID2IUS2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkVectorImageD2') -> "void":
        """PushFrontInput(itkImageToImageFilterVID2IUS2 self, itkVectorImageD2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID2IUS2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterVID2IUS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID2IUS2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterVID2IUS2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID2IUS2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterVID2IUS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID2IUS2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterVID2IUS2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID2IUS2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterVID2IUS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID2IUS2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterVID2IUS2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterVID2IUS2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterVID2IUS2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID2IUS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterVID2IUS2

        Create a new object of the class itkImageToImageFilterVID2IUS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterVID2IUS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterVID2IUS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterVID2IUS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterVID2IUS2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID2IUS2_SetInput, None, itkImageToImageFilterVID2IUS2)
itkImageToImageFilterVID2IUS2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID2IUS2_GetInput, None, itkImageToImageFilterVID2IUS2)
itkImageToImageFilterVID2IUS2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID2IUS2_PushBackInput, None, itkImageToImageFilterVID2IUS2)
itkImageToImageFilterVID2IUS2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID2IUS2_PopBackInput, None, itkImageToImageFilterVID2IUS2)
itkImageToImageFilterVID2IUS2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID2IUS2_PushFrontInput, None, itkImageToImageFilterVID2IUS2)
itkImageToImageFilterVID2IUS2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID2IUS2_PopFrontInput, None, itkImageToImageFilterVID2IUS2)
itkImageToImageFilterVID2IUS2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID2IUS2_SetCoordinateTolerance, None, itkImageToImageFilterVID2IUS2)
itkImageToImageFilterVID2IUS2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID2IUS2_GetCoordinateTolerance, None, itkImageToImageFilterVID2IUS2)
itkImageToImageFilterVID2IUS2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID2IUS2_SetDirectionTolerance, None, itkImageToImageFilterVID2IUS2)
itkImageToImageFilterVID2IUS2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID2IUS2_GetDirectionTolerance, None, itkImageToImageFilterVID2IUS2)
itkImageToImageFilterVID2IUS2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterVID2IUS2_swigregister
itkImageToImageFilterVID2IUS2_swigregister(itkImageToImageFilterVID2IUS2)

def itkImageToImageFilterVID2IUS2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterVID2IUS2 *":
    """itkImageToImageFilterVID2IUS2_cast(itkLightObject obj) -> itkImageToImageFilterVID2IUS2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterVID2IUS2_cast(obj)

class itkImageToImageFilterVID3ID3(itkImageSourcePython.itkImageSourceID3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterVID3ID3 self, itkVectorImageD3 image)
        SetInput(itkImageToImageFilterVID3ID3 self, unsigned int arg0, itkVectorImageD3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID3ID3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkVectorImageD3 const *":
        """
        GetInput(itkImageToImageFilterVID3ID3 self) -> itkVectorImageD3
        GetInput(itkImageToImageFilterVID3ID3 self, unsigned int idx) -> itkVectorImageD3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID3ID3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkVectorImageD3') -> "void":
        """
        PushBackInput(itkImageToImageFilterVID3ID3 self, itkVectorImageD3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID3ID3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterVID3ID3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID3ID3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkVectorImageD3') -> "void":
        """PushFrontInput(itkImageToImageFilterVID3ID3 self, itkVectorImageD3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID3ID3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterVID3ID3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID3ID3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterVID3ID3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID3ID3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterVID3ID3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID3ID3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterVID3ID3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID3ID3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterVID3ID3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID3ID3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterVID3ID3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterVID3ID3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterVID3ID3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID3ID3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterVID3ID3

        Create a new object of the class itkImageToImageFilterVID3ID3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterVID3ID3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterVID3ID3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterVID3ID3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterVID3ID3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID3ID3_SetInput, None, itkImageToImageFilterVID3ID3)
itkImageToImageFilterVID3ID3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID3ID3_GetInput, None, itkImageToImageFilterVID3ID3)
itkImageToImageFilterVID3ID3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID3ID3_PushBackInput, None, itkImageToImageFilterVID3ID3)
itkImageToImageFilterVID3ID3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID3ID3_PopBackInput, None, itkImageToImageFilterVID3ID3)
itkImageToImageFilterVID3ID3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID3ID3_PushFrontInput, None, itkImageToImageFilterVID3ID3)
itkImageToImageFilterVID3ID3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID3ID3_PopFrontInput, None, itkImageToImageFilterVID3ID3)
itkImageToImageFilterVID3ID3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID3ID3_SetCoordinateTolerance, None, itkImageToImageFilterVID3ID3)
itkImageToImageFilterVID3ID3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID3ID3_GetCoordinateTolerance, None, itkImageToImageFilterVID3ID3)
itkImageToImageFilterVID3ID3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID3ID3_SetDirectionTolerance, None, itkImageToImageFilterVID3ID3)
itkImageToImageFilterVID3ID3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID3ID3_GetDirectionTolerance, None, itkImageToImageFilterVID3ID3)
itkImageToImageFilterVID3ID3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterVID3ID3_swigregister
itkImageToImageFilterVID3ID3_swigregister(itkImageToImageFilterVID3ID3)

def itkImageToImageFilterVID3ID3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterVID3ID3 *":
    """itkImageToImageFilterVID3ID3_cast(itkLightObject obj) -> itkImageToImageFilterVID3ID3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterVID3ID3_cast(obj)

class itkImageToImageFilterVID3IF3(itkImageSourcePython.itkImageSourceIF3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterVID3IF3 self, itkVectorImageD3 image)
        SetInput(itkImageToImageFilterVID3IF3 self, unsigned int arg0, itkVectorImageD3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID3IF3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkVectorImageD3 const *":
        """
        GetInput(itkImageToImageFilterVID3IF3 self) -> itkVectorImageD3
        GetInput(itkImageToImageFilterVID3IF3 self, unsigned int idx) -> itkVectorImageD3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID3IF3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkVectorImageD3') -> "void":
        """
        PushBackInput(itkImageToImageFilterVID3IF3 self, itkVectorImageD3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID3IF3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterVID3IF3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID3IF3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkVectorImageD3') -> "void":
        """PushFrontInput(itkImageToImageFilterVID3IF3 self, itkVectorImageD3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID3IF3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterVID3IF3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID3IF3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterVID3IF3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID3IF3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterVID3IF3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID3IF3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterVID3IF3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID3IF3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterVID3IF3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID3IF3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterVID3IF3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterVID3IF3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterVID3IF3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID3IF3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterVID3IF3

        Create a new object of the class itkImageToImageFilterVID3IF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterVID3IF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterVID3IF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterVID3IF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterVID3IF3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID3IF3_SetInput, None, itkImageToImageFilterVID3IF3)
itkImageToImageFilterVID3IF3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID3IF3_GetInput, None, itkImageToImageFilterVID3IF3)
itkImageToImageFilterVID3IF3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID3IF3_PushBackInput, None, itkImageToImageFilterVID3IF3)
itkImageToImageFilterVID3IF3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID3IF3_PopBackInput, None, itkImageToImageFilterVID3IF3)
itkImageToImageFilterVID3IF3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID3IF3_PushFrontInput, None, itkImageToImageFilterVID3IF3)
itkImageToImageFilterVID3IF3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID3IF3_PopFrontInput, None, itkImageToImageFilterVID3IF3)
itkImageToImageFilterVID3IF3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID3IF3_SetCoordinateTolerance, None, itkImageToImageFilterVID3IF3)
itkImageToImageFilterVID3IF3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID3IF3_GetCoordinateTolerance, None, itkImageToImageFilterVID3IF3)
itkImageToImageFilterVID3IF3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID3IF3_SetDirectionTolerance, None, itkImageToImageFilterVID3IF3)
itkImageToImageFilterVID3IF3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID3IF3_GetDirectionTolerance, None, itkImageToImageFilterVID3IF3)
itkImageToImageFilterVID3IF3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterVID3IF3_swigregister
itkImageToImageFilterVID3IF3_swigregister(itkImageToImageFilterVID3IF3)

def itkImageToImageFilterVID3IF3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterVID3IF3 *":
    """itkImageToImageFilterVID3IF3_cast(itkLightObject obj) -> itkImageToImageFilterVID3IF3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterVID3IF3_cast(obj)

class itkImageToImageFilterVID3ISS3(itkImageSourcePython.itkImageSourceISS3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterVID3ISS3 self, itkVectorImageD3 image)
        SetInput(itkImageToImageFilterVID3ISS3 self, unsigned int arg0, itkVectorImageD3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID3ISS3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkVectorImageD3 const *":
        """
        GetInput(itkImageToImageFilterVID3ISS3 self) -> itkVectorImageD3
        GetInput(itkImageToImageFilterVID3ISS3 self, unsigned int idx) -> itkVectorImageD3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID3ISS3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkVectorImageD3') -> "void":
        """
        PushBackInput(itkImageToImageFilterVID3ISS3 self, itkVectorImageD3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID3ISS3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterVID3ISS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID3ISS3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkVectorImageD3') -> "void":
        """PushFrontInput(itkImageToImageFilterVID3ISS3 self, itkVectorImageD3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID3ISS3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterVID3ISS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID3ISS3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterVID3ISS3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID3ISS3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterVID3ISS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID3ISS3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterVID3ISS3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID3ISS3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterVID3ISS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID3ISS3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterVID3ISS3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterVID3ISS3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterVID3ISS3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID3ISS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterVID3ISS3

        Create a new object of the class itkImageToImageFilterVID3ISS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterVID3ISS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterVID3ISS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterVID3ISS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterVID3ISS3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID3ISS3_SetInput, None, itkImageToImageFilterVID3ISS3)
itkImageToImageFilterVID3ISS3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID3ISS3_GetInput, None, itkImageToImageFilterVID3ISS3)
itkImageToImageFilterVID3ISS3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID3ISS3_PushBackInput, None, itkImageToImageFilterVID3ISS3)
itkImageToImageFilterVID3ISS3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID3ISS3_PopBackInput, None, itkImageToImageFilterVID3ISS3)
itkImageToImageFilterVID3ISS3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID3ISS3_PushFrontInput, None, itkImageToImageFilterVID3ISS3)
itkImageToImageFilterVID3ISS3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID3ISS3_PopFrontInput, None, itkImageToImageFilterVID3ISS3)
itkImageToImageFilterVID3ISS3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID3ISS3_SetCoordinateTolerance, None, itkImageToImageFilterVID3ISS3)
itkImageToImageFilterVID3ISS3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID3ISS3_GetCoordinateTolerance, None, itkImageToImageFilterVID3ISS3)
itkImageToImageFilterVID3ISS3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID3ISS3_SetDirectionTolerance, None, itkImageToImageFilterVID3ISS3)
itkImageToImageFilterVID3ISS3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID3ISS3_GetDirectionTolerance, None, itkImageToImageFilterVID3ISS3)
itkImageToImageFilterVID3ISS3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterVID3ISS3_swigregister
itkImageToImageFilterVID3ISS3_swigregister(itkImageToImageFilterVID3ISS3)

def itkImageToImageFilterVID3ISS3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterVID3ISS3 *":
    """itkImageToImageFilterVID3ISS3_cast(itkLightObject obj) -> itkImageToImageFilterVID3ISS3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterVID3ISS3_cast(obj)

class itkImageToImageFilterVID3IUC3(itkImageSourcePython.itkImageSourceIUC3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterVID3IUC3 self, itkVectorImageD3 image)
        SetInput(itkImageToImageFilterVID3IUC3 self, unsigned int arg0, itkVectorImageD3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID3IUC3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkVectorImageD3 const *":
        """
        GetInput(itkImageToImageFilterVID3IUC3 self) -> itkVectorImageD3
        GetInput(itkImageToImageFilterVID3IUC3 self, unsigned int idx) -> itkVectorImageD3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID3IUC3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkVectorImageD3') -> "void":
        """
        PushBackInput(itkImageToImageFilterVID3IUC3 self, itkVectorImageD3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID3IUC3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterVID3IUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID3IUC3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkVectorImageD3') -> "void":
        """PushFrontInput(itkImageToImageFilterVID3IUC3 self, itkVectorImageD3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID3IUC3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterVID3IUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID3IUC3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterVID3IUC3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID3IUC3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterVID3IUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID3IUC3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterVID3IUC3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID3IUC3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterVID3IUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID3IUC3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterVID3IUC3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterVID3IUC3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterVID3IUC3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID3IUC3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterVID3IUC3

        Create a new object of the class itkImageToImageFilterVID3IUC3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterVID3IUC3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterVID3IUC3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterVID3IUC3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterVID3IUC3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID3IUC3_SetInput, None, itkImageToImageFilterVID3IUC3)
itkImageToImageFilterVID3IUC3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID3IUC3_GetInput, None, itkImageToImageFilterVID3IUC3)
itkImageToImageFilterVID3IUC3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID3IUC3_PushBackInput, None, itkImageToImageFilterVID3IUC3)
itkImageToImageFilterVID3IUC3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID3IUC3_PopBackInput, None, itkImageToImageFilterVID3IUC3)
itkImageToImageFilterVID3IUC3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID3IUC3_PushFrontInput, None, itkImageToImageFilterVID3IUC3)
itkImageToImageFilterVID3IUC3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID3IUC3_PopFrontInput, None, itkImageToImageFilterVID3IUC3)
itkImageToImageFilterVID3IUC3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID3IUC3_SetCoordinateTolerance, None, itkImageToImageFilterVID3IUC3)
itkImageToImageFilterVID3IUC3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID3IUC3_GetCoordinateTolerance, None, itkImageToImageFilterVID3IUC3)
itkImageToImageFilterVID3IUC3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID3IUC3_SetDirectionTolerance, None, itkImageToImageFilterVID3IUC3)
itkImageToImageFilterVID3IUC3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID3IUC3_GetDirectionTolerance, None, itkImageToImageFilterVID3IUC3)
itkImageToImageFilterVID3IUC3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterVID3IUC3_swigregister
itkImageToImageFilterVID3IUC3_swigregister(itkImageToImageFilterVID3IUC3)

def itkImageToImageFilterVID3IUC3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterVID3IUC3 *":
    """itkImageToImageFilterVID3IUC3_cast(itkLightObject obj) -> itkImageToImageFilterVID3IUC3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterVID3IUC3_cast(obj)

class itkImageToImageFilterVID3IUS3(itkImageSourcePython.itkImageSourceIUS3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterVID3IUS3 self, itkVectorImageD3 image)
        SetInput(itkImageToImageFilterVID3IUS3 self, unsigned int arg0, itkVectorImageD3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID3IUS3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkVectorImageD3 const *":
        """
        GetInput(itkImageToImageFilterVID3IUS3 self) -> itkVectorImageD3
        GetInput(itkImageToImageFilterVID3IUS3 self, unsigned int idx) -> itkVectorImageD3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID3IUS3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkVectorImageD3') -> "void":
        """
        PushBackInput(itkImageToImageFilterVID3IUS3 self, itkVectorImageD3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID3IUS3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterVID3IUS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID3IUS3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkVectorImageD3') -> "void":
        """PushFrontInput(itkImageToImageFilterVID3IUS3 self, itkVectorImageD3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID3IUS3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterVID3IUS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID3IUS3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterVID3IUS3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID3IUS3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterVID3IUS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID3IUS3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterVID3IUS3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID3IUS3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterVID3IUS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID3IUS3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterVID3IUS3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterVID3IUS3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterVID3IUS3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVID3IUS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterVID3IUS3

        Create a new object of the class itkImageToImageFilterVID3IUS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterVID3IUS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterVID3IUS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterVID3IUS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterVID3IUS3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID3IUS3_SetInput, None, itkImageToImageFilterVID3IUS3)
itkImageToImageFilterVID3IUS3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID3IUS3_GetInput, None, itkImageToImageFilterVID3IUS3)
itkImageToImageFilterVID3IUS3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID3IUS3_PushBackInput, None, itkImageToImageFilterVID3IUS3)
itkImageToImageFilterVID3IUS3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID3IUS3_PopBackInput, None, itkImageToImageFilterVID3IUS3)
itkImageToImageFilterVID3IUS3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID3IUS3_PushFrontInput, None, itkImageToImageFilterVID3IUS3)
itkImageToImageFilterVID3IUS3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID3IUS3_PopFrontInput, None, itkImageToImageFilterVID3IUS3)
itkImageToImageFilterVID3IUS3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID3IUS3_SetCoordinateTolerance, None, itkImageToImageFilterVID3IUS3)
itkImageToImageFilterVID3IUS3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID3IUS3_GetCoordinateTolerance, None, itkImageToImageFilterVID3IUS3)
itkImageToImageFilterVID3IUS3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID3IUS3_SetDirectionTolerance, None, itkImageToImageFilterVID3IUS3)
itkImageToImageFilterVID3IUS3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVID3IUS3_GetDirectionTolerance, None, itkImageToImageFilterVID3IUS3)
itkImageToImageFilterVID3IUS3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterVID3IUS3_swigregister
itkImageToImageFilterVID3IUS3_swigregister(itkImageToImageFilterVID3IUS3)

def itkImageToImageFilterVID3IUS3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterVID3IUS3 *":
    """itkImageToImageFilterVID3IUS3_cast(itkLightObject obj) -> itkImageToImageFilterVID3IUS3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterVID3IUS3_cast(obj)

class itkImageToImageFilterVIF2ID2(itkImageSourcePython.itkImageSourceID2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterVIF2ID2 self, itkVectorImageF2 image)
        SetInput(itkImageToImageFilterVIF2ID2 self, unsigned int arg0, itkVectorImageF2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF2ID2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkVectorImageF2 const *":
        """
        GetInput(itkImageToImageFilterVIF2ID2 self) -> itkVectorImageF2
        GetInput(itkImageToImageFilterVIF2ID2 self, unsigned int idx) -> itkVectorImageF2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF2ID2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkVectorImageF2') -> "void":
        """
        PushBackInput(itkImageToImageFilterVIF2ID2 self, itkVectorImageF2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF2ID2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterVIF2ID2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF2ID2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkVectorImageF2') -> "void":
        """PushFrontInput(itkImageToImageFilterVIF2ID2 self, itkVectorImageF2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF2ID2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterVIF2ID2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF2ID2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterVIF2ID2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF2ID2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterVIF2ID2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF2ID2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterVIF2ID2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF2ID2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterVIF2ID2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF2ID2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterVIF2ID2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIF2ID2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterVIF2ID2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF2ID2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterVIF2ID2

        Create a new object of the class itkImageToImageFilterVIF2ID2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterVIF2ID2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterVIF2ID2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterVIF2ID2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterVIF2ID2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF2ID2_SetInput, None, itkImageToImageFilterVIF2ID2)
itkImageToImageFilterVIF2ID2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF2ID2_GetInput, None, itkImageToImageFilterVIF2ID2)
itkImageToImageFilterVIF2ID2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF2ID2_PushBackInput, None, itkImageToImageFilterVIF2ID2)
itkImageToImageFilterVIF2ID2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF2ID2_PopBackInput, None, itkImageToImageFilterVIF2ID2)
itkImageToImageFilterVIF2ID2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF2ID2_PushFrontInput, None, itkImageToImageFilterVIF2ID2)
itkImageToImageFilterVIF2ID2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF2ID2_PopFrontInput, None, itkImageToImageFilterVIF2ID2)
itkImageToImageFilterVIF2ID2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF2ID2_SetCoordinateTolerance, None, itkImageToImageFilterVIF2ID2)
itkImageToImageFilterVIF2ID2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF2ID2_GetCoordinateTolerance, None, itkImageToImageFilterVIF2ID2)
itkImageToImageFilterVIF2ID2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF2ID2_SetDirectionTolerance, None, itkImageToImageFilterVIF2ID2)
itkImageToImageFilterVIF2ID2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF2ID2_GetDirectionTolerance, None, itkImageToImageFilterVIF2ID2)
itkImageToImageFilterVIF2ID2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterVIF2ID2_swigregister
itkImageToImageFilterVIF2ID2_swigregister(itkImageToImageFilterVIF2ID2)

def itkImageToImageFilterVIF2ID2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIF2ID2 *":
    """itkImageToImageFilterVIF2ID2_cast(itkLightObject obj) -> itkImageToImageFilterVIF2ID2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterVIF2ID2_cast(obj)

class itkImageToImageFilterVIF2IF2(itkImageSourcePython.itkImageSourceIF2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterVIF2IF2 self, itkVectorImageF2 image)
        SetInput(itkImageToImageFilterVIF2IF2 self, unsigned int arg0, itkVectorImageF2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF2IF2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkVectorImageF2 const *":
        """
        GetInput(itkImageToImageFilterVIF2IF2 self) -> itkVectorImageF2
        GetInput(itkImageToImageFilterVIF2IF2 self, unsigned int idx) -> itkVectorImageF2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF2IF2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkVectorImageF2') -> "void":
        """
        PushBackInput(itkImageToImageFilterVIF2IF2 self, itkVectorImageF2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF2IF2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterVIF2IF2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF2IF2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkVectorImageF2') -> "void":
        """PushFrontInput(itkImageToImageFilterVIF2IF2 self, itkVectorImageF2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF2IF2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterVIF2IF2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF2IF2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterVIF2IF2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF2IF2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterVIF2IF2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF2IF2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterVIF2IF2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF2IF2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterVIF2IF2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF2IF2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterVIF2IF2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIF2IF2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterVIF2IF2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF2IF2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterVIF2IF2

        Create a new object of the class itkImageToImageFilterVIF2IF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterVIF2IF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterVIF2IF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterVIF2IF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterVIF2IF2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF2IF2_SetInput, None, itkImageToImageFilterVIF2IF2)
itkImageToImageFilterVIF2IF2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF2IF2_GetInput, None, itkImageToImageFilterVIF2IF2)
itkImageToImageFilterVIF2IF2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF2IF2_PushBackInput, None, itkImageToImageFilterVIF2IF2)
itkImageToImageFilterVIF2IF2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF2IF2_PopBackInput, None, itkImageToImageFilterVIF2IF2)
itkImageToImageFilterVIF2IF2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF2IF2_PushFrontInput, None, itkImageToImageFilterVIF2IF2)
itkImageToImageFilterVIF2IF2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF2IF2_PopFrontInput, None, itkImageToImageFilterVIF2IF2)
itkImageToImageFilterVIF2IF2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF2IF2_SetCoordinateTolerance, None, itkImageToImageFilterVIF2IF2)
itkImageToImageFilterVIF2IF2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF2IF2_GetCoordinateTolerance, None, itkImageToImageFilterVIF2IF2)
itkImageToImageFilterVIF2IF2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF2IF2_SetDirectionTolerance, None, itkImageToImageFilterVIF2IF2)
itkImageToImageFilterVIF2IF2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF2IF2_GetDirectionTolerance, None, itkImageToImageFilterVIF2IF2)
itkImageToImageFilterVIF2IF2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterVIF2IF2_swigregister
itkImageToImageFilterVIF2IF2_swigregister(itkImageToImageFilterVIF2IF2)

def itkImageToImageFilterVIF2IF2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIF2IF2 *":
    """itkImageToImageFilterVIF2IF2_cast(itkLightObject obj) -> itkImageToImageFilterVIF2IF2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterVIF2IF2_cast(obj)

class itkImageToImageFilterVIF2ISS2(itkImageSourcePython.itkImageSourceISS2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterVIF2ISS2 self, itkVectorImageF2 image)
        SetInput(itkImageToImageFilterVIF2ISS2 self, unsigned int arg0, itkVectorImageF2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF2ISS2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkVectorImageF2 const *":
        """
        GetInput(itkImageToImageFilterVIF2ISS2 self) -> itkVectorImageF2
        GetInput(itkImageToImageFilterVIF2ISS2 self, unsigned int idx) -> itkVectorImageF2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF2ISS2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkVectorImageF2') -> "void":
        """
        PushBackInput(itkImageToImageFilterVIF2ISS2 self, itkVectorImageF2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF2ISS2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterVIF2ISS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF2ISS2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkVectorImageF2') -> "void":
        """PushFrontInput(itkImageToImageFilterVIF2ISS2 self, itkVectorImageF2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF2ISS2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterVIF2ISS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF2ISS2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterVIF2ISS2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF2ISS2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterVIF2ISS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF2ISS2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterVIF2ISS2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF2ISS2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterVIF2ISS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF2ISS2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterVIF2ISS2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIF2ISS2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterVIF2ISS2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF2ISS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterVIF2ISS2

        Create a new object of the class itkImageToImageFilterVIF2ISS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterVIF2ISS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterVIF2ISS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterVIF2ISS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterVIF2ISS2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF2ISS2_SetInput, None, itkImageToImageFilterVIF2ISS2)
itkImageToImageFilterVIF2ISS2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF2ISS2_GetInput, None, itkImageToImageFilterVIF2ISS2)
itkImageToImageFilterVIF2ISS2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF2ISS2_PushBackInput, None, itkImageToImageFilterVIF2ISS2)
itkImageToImageFilterVIF2ISS2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF2ISS2_PopBackInput, None, itkImageToImageFilterVIF2ISS2)
itkImageToImageFilterVIF2ISS2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF2ISS2_PushFrontInput, None, itkImageToImageFilterVIF2ISS2)
itkImageToImageFilterVIF2ISS2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF2ISS2_PopFrontInput, None, itkImageToImageFilterVIF2ISS2)
itkImageToImageFilterVIF2ISS2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF2ISS2_SetCoordinateTolerance, None, itkImageToImageFilterVIF2ISS2)
itkImageToImageFilterVIF2ISS2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF2ISS2_GetCoordinateTolerance, None, itkImageToImageFilterVIF2ISS2)
itkImageToImageFilterVIF2ISS2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF2ISS2_SetDirectionTolerance, None, itkImageToImageFilterVIF2ISS2)
itkImageToImageFilterVIF2ISS2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF2ISS2_GetDirectionTolerance, None, itkImageToImageFilterVIF2ISS2)
itkImageToImageFilterVIF2ISS2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterVIF2ISS2_swigregister
itkImageToImageFilterVIF2ISS2_swigregister(itkImageToImageFilterVIF2ISS2)

def itkImageToImageFilterVIF2ISS2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIF2ISS2 *":
    """itkImageToImageFilterVIF2ISS2_cast(itkLightObject obj) -> itkImageToImageFilterVIF2ISS2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterVIF2ISS2_cast(obj)

class itkImageToImageFilterVIF2IUC2(itkImageSourcePython.itkImageSourceIUC2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterVIF2IUC2 self, itkVectorImageF2 image)
        SetInput(itkImageToImageFilterVIF2IUC2 self, unsigned int arg0, itkVectorImageF2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF2IUC2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkVectorImageF2 const *":
        """
        GetInput(itkImageToImageFilterVIF2IUC2 self) -> itkVectorImageF2
        GetInput(itkImageToImageFilterVIF2IUC2 self, unsigned int idx) -> itkVectorImageF2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF2IUC2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkVectorImageF2') -> "void":
        """
        PushBackInput(itkImageToImageFilterVIF2IUC2 self, itkVectorImageF2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF2IUC2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterVIF2IUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF2IUC2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkVectorImageF2') -> "void":
        """PushFrontInput(itkImageToImageFilterVIF2IUC2 self, itkVectorImageF2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF2IUC2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterVIF2IUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF2IUC2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterVIF2IUC2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF2IUC2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterVIF2IUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF2IUC2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterVIF2IUC2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF2IUC2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterVIF2IUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF2IUC2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterVIF2IUC2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIF2IUC2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterVIF2IUC2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF2IUC2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterVIF2IUC2

        Create a new object of the class itkImageToImageFilterVIF2IUC2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterVIF2IUC2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterVIF2IUC2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterVIF2IUC2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterVIF2IUC2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF2IUC2_SetInput, None, itkImageToImageFilterVIF2IUC2)
itkImageToImageFilterVIF2IUC2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF2IUC2_GetInput, None, itkImageToImageFilterVIF2IUC2)
itkImageToImageFilterVIF2IUC2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF2IUC2_PushBackInput, None, itkImageToImageFilterVIF2IUC2)
itkImageToImageFilterVIF2IUC2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF2IUC2_PopBackInput, None, itkImageToImageFilterVIF2IUC2)
itkImageToImageFilterVIF2IUC2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF2IUC2_PushFrontInput, None, itkImageToImageFilterVIF2IUC2)
itkImageToImageFilterVIF2IUC2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF2IUC2_PopFrontInput, None, itkImageToImageFilterVIF2IUC2)
itkImageToImageFilterVIF2IUC2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF2IUC2_SetCoordinateTolerance, None, itkImageToImageFilterVIF2IUC2)
itkImageToImageFilterVIF2IUC2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF2IUC2_GetCoordinateTolerance, None, itkImageToImageFilterVIF2IUC2)
itkImageToImageFilterVIF2IUC2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF2IUC2_SetDirectionTolerance, None, itkImageToImageFilterVIF2IUC2)
itkImageToImageFilterVIF2IUC2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF2IUC2_GetDirectionTolerance, None, itkImageToImageFilterVIF2IUC2)
itkImageToImageFilterVIF2IUC2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterVIF2IUC2_swigregister
itkImageToImageFilterVIF2IUC2_swigregister(itkImageToImageFilterVIF2IUC2)

def itkImageToImageFilterVIF2IUC2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIF2IUC2 *":
    """itkImageToImageFilterVIF2IUC2_cast(itkLightObject obj) -> itkImageToImageFilterVIF2IUC2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterVIF2IUC2_cast(obj)

class itkImageToImageFilterVIF2IUS2(itkImageSourcePython.itkImageSourceIUS2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterVIF2IUS2 self, itkVectorImageF2 image)
        SetInput(itkImageToImageFilterVIF2IUS2 self, unsigned int arg0, itkVectorImageF2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF2IUS2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkVectorImageF2 const *":
        """
        GetInput(itkImageToImageFilterVIF2IUS2 self) -> itkVectorImageF2
        GetInput(itkImageToImageFilterVIF2IUS2 self, unsigned int idx) -> itkVectorImageF2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF2IUS2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkVectorImageF2') -> "void":
        """
        PushBackInput(itkImageToImageFilterVIF2IUS2 self, itkVectorImageF2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF2IUS2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterVIF2IUS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF2IUS2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkVectorImageF2') -> "void":
        """PushFrontInput(itkImageToImageFilterVIF2IUS2 self, itkVectorImageF2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF2IUS2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterVIF2IUS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF2IUS2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterVIF2IUS2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF2IUS2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterVIF2IUS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF2IUS2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterVIF2IUS2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF2IUS2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterVIF2IUS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF2IUS2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterVIF2IUS2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIF2IUS2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterVIF2IUS2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF2IUS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterVIF2IUS2

        Create a new object of the class itkImageToImageFilterVIF2IUS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterVIF2IUS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterVIF2IUS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterVIF2IUS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterVIF2IUS2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF2IUS2_SetInput, None, itkImageToImageFilterVIF2IUS2)
itkImageToImageFilterVIF2IUS2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF2IUS2_GetInput, None, itkImageToImageFilterVIF2IUS2)
itkImageToImageFilterVIF2IUS2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF2IUS2_PushBackInput, None, itkImageToImageFilterVIF2IUS2)
itkImageToImageFilterVIF2IUS2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF2IUS2_PopBackInput, None, itkImageToImageFilterVIF2IUS2)
itkImageToImageFilterVIF2IUS2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF2IUS2_PushFrontInput, None, itkImageToImageFilterVIF2IUS2)
itkImageToImageFilterVIF2IUS2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF2IUS2_PopFrontInput, None, itkImageToImageFilterVIF2IUS2)
itkImageToImageFilterVIF2IUS2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF2IUS2_SetCoordinateTolerance, None, itkImageToImageFilterVIF2IUS2)
itkImageToImageFilterVIF2IUS2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF2IUS2_GetCoordinateTolerance, None, itkImageToImageFilterVIF2IUS2)
itkImageToImageFilterVIF2IUS2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF2IUS2_SetDirectionTolerance, None, itkImageToImageFilterVIF2IUS2)
itkImageToImageFilterVIF2IUS2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF2IUS2_GetDirectionTolerance, None, itkImageToImageFilterVIF2IUS2)
itkImageToImageFilterVIF2IUS2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterVIF2IUS2_swigregister
itkImageToImageFilterVIF2IUS2_swigregister(itkImageToImageFilterVIF2IUS2)

def itkImageToImageFilterVIF2IUS2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIF2IUS2 *":
    """itkImageToImageFilterVIF2IUS2_cast(itkLightObject obj) -> itkImageToImageFilterVIF2IUS2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterVIF2IUS2_cast(obj)

class itkImageToImageFilterVIF3ID3(itkImageSourcePython.itkImageSourceID3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterVIF3ID3 self, itkVectorImageF3 image)
        SetInput(itkImageToImageFilterVIF3ID3 self, unsigned int arg0, itkVectorImageF3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF3ID3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkVectorImageF3 const *":
        """
        GetInput(itkImageToImageFilterVIF3ID3 self) -> itkVectorImageF3
        GetInput(itkImageToImageFilterVIF3ID3 self, unsigned int idx) -> itkVectorImageF3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF3ID3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkVectorImageF3') -> "void":
        """
        PushBackInput(itkImageToImageFilterVIF3ID3 self, itkVectorImageF3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF3ID3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterVIF3ID3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF3ID3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkVectorImageF3') -> "void":
        """PushFrontInput(itkImageToImageFilterVIF3ID3 self, itkVectorImageF3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF3ID3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterVIF3ID3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF3ID3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterVIF3ID3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF3ID3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterVIF3ID3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF3ID3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterVIF3ID3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF3ID3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterVIF3ID3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF3ID3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterVIF3ID3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIF3ID3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterVIF3ID3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF3ID3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterVIF3ID3

        Create a new object of the class itkImageToImageFilterVIF3ID3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterVIF3ID3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterVIF3ID3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterVIF3ID3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterVIF3ID3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF3ID3_SetInput, None, itkImageToImageFilterVIF3ID3)
itkImageToImageFilterVIF3ID3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF3ID3_GetInput, None, itkImageToImageFilterVIF3ID3)
itkImageToImageFilterVIF3ID3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF3ID3_PushBackInput, None, itkImageToImageFilterVIF3ID3)
itkImageToImageFilterVIF3ID3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF3ID3_PopBackInput, None, itkImageToImageFilterVIF3ID3)
itkImageToImageFilterVIF3ID3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF3ID3_PushFrontInput, None, itkImageToImageFilterVIF3ID3)
itkImageToImageFilterVIF3ID3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF3ID3_PopFrontInput, None, itkImageToImageFilterVIF3ID3)
itkImageToImageFilterVIF3ID3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF3ID3_SetCoordinateTolerance, None, itkImageToImageFilterVIF3ID3)
itkImageToImageFilterVIF3ID3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF3ID3_GetCoordinateTolerance, None, itkImageToImageFilterVIF3ID3)
itkImageToImageFilterVIF3ID3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF3ID3_SetDirectionTolerance, None, itkImageToImageFilterVIF3ID3)
itkImageToImageFilterVIF3ID3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF3ID3_GetDirectionTolerance, None, itkImageToImageFilterVIF3ID3)
itkImageToImageFilterVIF3ID3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterVIF3ID3_swigregister
itkImageToImageFilterVIF3ID3_swigregister(itkImageToImageFilterVIF3ID3)

def itkImageToImageFilterVIF3ID3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIF3ID3 *":
    """itkImageToImageFilterVIF3ID3_cast(itkLightObject obj) -> itkImageToImageFilterVIF3ID3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterVIF3ID3_cast(obj)

class itkImageToImageFilterVIF3IF3(itkImageSourcePython.itkImageSourceIF3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterVIF3IF3 self, itkVectorImageF3 image)
        SetInput(itkImageToImageFilterVIF3IF3 self, unsigned int arg0, itkVectorImageF3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF3IF3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkVectorImageF3 const *":
        """
        GetInput(itkImageToImageFilterVIF3IF3 self) -> itkVectorImageF3
        GetInput(itkImageToImageFilterVIF3IF3 self, unsigned int idx) -> itkVectorImageF3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF3IF3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkVectorImageF3') -> "void":
        """
        PushBackInput(itkImageToImageFilterVIF3IF3 self, itkVectorImageF3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF3IF3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterVIF3IF3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF3IF3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkVectorImageF3') -> "void":
        """PushFrontInput(itkImageToImageFilterVIF3IF3 self, itkVectorImageF3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF3IF3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterVIF3IF3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF3IF3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterVIF3IF3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF3IF3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterVIF3IF3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF3IF3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterVIF3IF3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF3IF3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterVIF3IF3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF3IF3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterVIF3IF3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIF3IF3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterVIF3IF3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF3IF3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterVIF3IF3

        Create a new object of the class itkImageToImageFilterVIF3IF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterVIF3IF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterVIF3IF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterVIF3IF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterVIF3IF3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF3IF3_SetInput, None, itkImageToImageFilterVIF3IF3)
itkImageToImageFilterVIF3IF3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF3IF3_GetInput, None, itkImageToImageFilterVIF3IF3)
itkImageToImageFilterVIF3IF3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF3IF3_PushBackInput, None, itkImageToImageFilterVIF3IF3)
itkImageToImageFilterVIF3IF3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF3IF3_PopBackInput, None, itkImageToImageFilterVIF3IF3)
itkImageToImageFilterVIF3IF3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF3IF3_PushFrontInput, None, itkImageToImageFilterVIF3IF3)
itkImageToImageFilterVIF3IF3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF3IF3_PopFrontInput, None, itkImageToImageFilterVIF3IF3)
itkImageToImageFilterVIF3IF3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF3IF3_SetCoordinateTolerance, None, itkImageToImageFilterVIF3IF3)
itkImageToImageFilterVIF3IF3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF3IF3_GetCoordinateTolerance, None, itkImageToImageFilterVIF3IF3)
itkImageToImageFilterVIF3IF3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF3IF3_SetDirectionTolerance, None, itkImageToImageFilterVIF3IF3)
itkImageToImageFilterVIF3IF3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF3IF3_GetDirectionTolerance, None, itkImageToImageFilterVIF3IF3)
itkImageToImageFilterVIF3IF3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterVIF3IF3_swigregister
itkImageToImageFilterVIF3IF3_swigregister(itkImageToImageFilterVIF3IF3)

def itkImageToImageFilterVIF3IF3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIF3IF3 *":
    """itkImageToImageFilterVIF3IF3_cast(itkLightObject obj) -> itkImageToImageFilterVIF3IF3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterVIF3IF3_cast(obj)

class itkImageToImageFilterVIF3ISS3(itkImageSourcePython.itkImageSourceISS3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterVIF3ISS3 self, itkVectorImageF3 image)
        SetInput(itkImageToImageFilterVIF3ISS3 self, unsigned int arg0, itkVectorImageF3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF3ISS3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkVectorImageF3 const *":
        """
        GetInput(itkImageToImageFilterVIF3ISS3 self) -> itkVectorImageF3
        GetInput(itkImageToImageFilterVIF3ISS3 self, unsigned int idx) -> itkVectorImageF3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF3ISS3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkVectorImageF3') -> "void":
        """
        PushBackInput(itkImageToImageFilterVIF3ISS3 self, itkVectorImageF3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF3ISS3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterVIF3ISS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF3ISS3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkVectorImageF3') -> "void":
        """PushFrontInput(itkImageToImageFilterVIF3ISS3 self, itkVectorImageF3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF3ISS3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterVIF3ISS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF3ISS3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterVIF3ISS3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF3ISS3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterVIF3ISS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF3ISS3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterVIF3ISS3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF3ISS3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterVIF3ISS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF3ISS3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterVIF3ISS3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIF3ISS3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterVIF3ISS3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF3ISS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterVIF3ISS3

        Create a new object of the class itkImageToImageFilterVIF3ISS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterVIF3ISS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterVIF3ISS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterVIF3ISS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterVIF3ISS3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF3ISS3_SetInput, None, itkImageToImageFilterVIF3ISS3)
itkImageToImageFilterVIF3ISS3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF3ISS3_GetInput, None, itkImageToImageFilterVIF3ISS3)
itkImageToImageFilterVIF3ISS3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF3ISS3_PushBackInput, None, itkImageToImageFilterVIF3ISS3)
itkImageToImageFilterVIF3ISS3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF3ISS3_PopBackInput, None, itkImageToImageFilterVIF3ISS3)
itkImageToImageFilterVIF3ISS3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF3ISS3_PushFrontInput, None, itkImageToImageFilterVIF3ISS3)
itkImageToImageFilterVIF3ISS3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF3ISS3_PopFrontInput, None, itkImageToImageFilterVIF3ISS3)
itkImageToImageFilterVIF3ISS3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF3ISS3_SetCoordinateTolerance, None, itkImageToImageFilterVIF3ISS3)
itkImageToImageFilterVIF3ISS3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF3ISS3_GetCoordinateTolerance, None, itkImageToImageFilterVIF3ISS3)
itkImageToImageFilterVIF3ISS3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF3ISS3_SetDirectionTolerance, None, itkImageToImageFilterVIF3ISS3)
itkImageToImageFilterVIF3ISS3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF3ISS3_GetDirectionTolerance, None, itkImageToImageFilterVIF3ISS3)
itkImageToImageFilterVIF3ISS3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterVIF3ISS3_swigregister
itkImageToImageFilterVIF3ISS3_swigregister(itkImageToImageFilterVIF3ISS3)

def itkImageToImageFilterVIF3ISS3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIF3ISS3 *":
    """itkImageToImageFilterVIF3ISS3_cast(itkLightObject obj) -> itkImageToImageFilterVIF3ISS3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterVIF3ISS3_cast(obj)

class itkImageToImageFilterVIF3IUC3(itkImageSourcePython.itkImageSourceIUC3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterVIF3IUC3 self, itkVectorImageF3 image)
        SetInput(itkImageToImageFilterVIF3IUC3 self, unsigned int arg0, itkVectorImageF3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF3IUC3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkVectorImageF3 const *":
        """
        GetInput(itkImageToImageFilterVIF3IUC3 self) -> itkVectorImageF3
        GetInput(itkImageToImageFilterVIF3IUC3 self, unsigned int idx) -> itkVectorImageF3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF3IUC3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkVectorImageF3') -> "void":
        """
        PushBackInput(itkImageToImageFilterVIF3IUC3 self, itkVectorImageF3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF3IUC3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterVIF3IUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF3IUC3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkVectorImageF3') -> "void":
        """PushFrontInput(itkImageToImageFilterVIF3IUC3 self, itkVectorImageF3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF3IUC3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterVIF3IUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF3IUC3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterVIF3IUC3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF3IUC3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterVIF3IUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF3IUC3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterVIF3IUC3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF3IUC3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterVIF3IUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF3IUC3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterVIF3IUC3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIF3IUC3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterVIF3IUC3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF3IUC3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterVIF3IUC3

        Create a new object of the class itkImageToImageFilterVIF3IUC3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterVIF3IUC3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterVIF3IUC3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterVIF3IUC3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterVIF3IUC3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF3IUC3_SetInput, None, itkImageToImageFilterVIF3IUC3)
itkImageToImageFilterVIF3IUC3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF3IUC3_GetInput, None, itkImageToImageFilterVIF3IUC3)
itkImageToImageFilterVIF3IUC3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF3IUC3_PushBackInput, None, itkImageToImageFilterVIF3IUC3)
itkImageToImageFilterVIF3IUC3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF3IUC3_PopBackInput, None, itkImageToImageFilterVIF3IUC3)
itkImageToImageFilterVIF3IUC3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF3IUC3_PushFrontInput, None, itkImageToImageFilterVIF3IUC3)
itkImageToImageFilterVIF3IUC3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF3IUC3_PopFrontInput, None, itkImageToImageFilterVIF3IUC3)
itkImageToImageFilterVIF3IUC3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF3IUC3_SetCoordinateTolerance, None, itkImageToImageFilterVIF3IUC3)
itkImageToImageFilterVIF3IUC3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF3IUC3_GetCoordinateTolerance, None, itkImageToImageFilterVIF3IUC3)
itkImageToImageFilterVIF3IUC3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF3IUC3_SetDirectionTolerance, None, itkImageToImageFilterVIF3IUC3)
itkImageToImageFilterVIF3IUC3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF3IUC3_GetDirectionTolerance, None, itkImageToImageFilterVIF3IUC3)
itkImageToImageFilterVIF3IUC3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterVIF3IUC3_swigregister
itkImageToImageFilterVIF3IUC3_swigregister(itkImageToImageFilterVIF3IUC3)

def itkImageToImageFilterVIF3IUC3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIF3IUC3 *":
    """itkImageToImageFilterVIF3IUC3_cast(itkLightObject obj) -> itkImageToImageFilterVIF3IUC3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterVIF3IUC3_cast(obj)

class itkImageToImageFilterVIF3IUS3(itkImageSourcePython.itkImageSourceIUS3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterVIF3IUS3 self, itkVectorImageF3 image)
        SetInput(itkImageToImageFilterVIF3IUS3 self, unsigned int arg0, itkVectorImageF3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF3IUS3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkVectorImageF3 const *":
        """
        GetInput(itkImageToImageFilterVIF3IUS3 self) -> itkVectorImageF3
        GetInput(itkImageToImageFilterVIF3IUS3 self, unsigned int idx) -> itkVectorImageF3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF3IUS3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkVectorImageF3') -> "void":
        """
        PushBackInput(itkImageToImageFilterVIF3IUS3 self, itkVectorImageF3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF3IUS3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterVIF3IUS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF3IUS3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkVectorImageF3') -> "void":
        """PushFrontInput(itkImageToImageFilterVIF3IUS3 self, itkVectorImageF3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF3IUS3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterVIF3IUS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF3IUS3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterVIF3IUS3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF3IUS3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterVIF3IUS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF3IUS3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterVIF3IUS3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF3IUS3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterVIF3IUS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF3IUS3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterVIF3IUS3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIF3IUS3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterVIF3IUS3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIF3IUS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterVIF3IUS3

        Create a new object of the class itkImageToImageFilterVIF3IUS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterVIF3IUS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterVIF3IUS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterVIF3IUS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterVIF3IUS3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF3IUS3_SetInput, None, itkImageToImageFilterVIF3IUS3)
itkImageToImageFilterVIF3IUS3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF3IUS3_GetInput, None, itkImageToImageFilterVIF3IUS3)
itkImageToImageFilterVIF3IUS3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF3IUS3_PushBackInput, None, itkImageToImageFilterVIF3IUS3)
itkImageToImageFilterVIF3IUS3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF3IUS3_PopBackInput, None, itkImageToImageFilterVIF3IUS3)
itkImageToImageFilterVIF3IUS3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF3IUS3_PushFrontInput, None, itkImageToImageFilterVIF3IUS3)
itkImageToImageFilterVIF3IUS3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF3IUS3_PopFrontInput, None, itkImageToImageFilterVIF3IUS3)
itkImageToImageFilterVIF3IUS3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF3IUS3_SetCoordinateTolerance, None, itkImageToImageFilterVIF3IUS3)
itkImageToImageFilterVIF3IUS3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF3IUS3_GetCoordinateTolerance, None, itkImageToImageFilterVIF3IUS3)
itkImageToImageFilterVIF3IUS3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF3IUS3_SetDirectionTolerance, None, itkImageToImageFilterVIF3IUS3)
itkImageToImageFilterVIF3IUS3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIF3IUS3_GetDirectionTolerance, None, itkImageToImageFilterVIF3IUS3)
itkImageToImageFilterVIF3IUS3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterVIF3IUS3_swigregister
itkImageToImageFilterVIF3IUS3_swigregister(itkImageToImageFilterVIF3IUS3)

def itkImageToImageFilterVIF3IUS3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIF3IUS3 *":
    """itkImageToImageFilterVIF3IUS3_cast(itkLightObject obj) -> itkImageToImageFilterVIF3IUS3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterVIF3IUS3_cast(obj)

class itkImageToImageFilterVISS2ID2(itkImageSourcePython.itkImageSourceID2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterVISS2ID2 self, itkVectorImageSS2 image)
        SetInput(itkImageToImageFilterVISS2ID2 self, unsigned int arg0, itkVectorImageSS2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS2ID2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkVectorImageSS2 const *":
        """
        GetInput(itkImageToImageFilterVISS2ID2 self) -> itkVectorImageSS2
        GetInput(itkImageToImageFilterVISS2ID2 self, unsigned int idx) -> itkVectorImageSS2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS2ID2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkVectorImageSS2') -> "void":
        """
        PushBackInput(itkImageToImageFilterVISS2ID2 self, itkVectorImageSS2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS2ID2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterVISS2ID2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS2ID2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkVectorImageSS2') -> "void":
        """PushFrontInput(itkImageToImageFilterVISS2ID2 self, itkVectorImageSS2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS2ID2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterVISS2ID2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS2ID2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterVISS2ID2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS2ID2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterVISS2ID2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS2ID2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterVISS2ID2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS2ID2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterVISS2ID2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS2ID2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterVISS2ID2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterVISS2ID2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterVISS2ID2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS2ID2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterVISS2ID2

        Create a new object of the class itkImageToImageFilterVISS2ID2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterVISS2ID2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterVISS2ID2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterVISS2ID2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterVISS2ID2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS2ID2_SetInput, None, itkImageToImageFilterVISS2ID2)
itkImageToImageFilterVISS2ID2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS2ID2_GetInput, None, itkImageToImageFilterVISS2ID2)
itkImageToImageFilterVISS2ID2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS2ID2_PushBackInput, None, itkImageToImageFilterVISS2ID2)
itkImageToImageFilterVISS2ID2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS2ID2_PopBackInput, None, itkImageToImageFilterVISS2ID2)
itkImageToImageFilterVISS2ID2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS2ID2_PushFrontInput, None, itkImageToImageFilterVISS2ID2)
itkImageToImageFilterVISS2ID2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS2ID2_PopFrontInput, None, itkImageToImageFilterVISS2ID2)
itkImageToImageFilterVISS2ID2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS2ID2_SetCoordinateTolerance, None, itkImageToImageFilterVISS2ID2)
itkImageToImageFilterVISS2ID2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS2ID2_GetCoordinateTolerance, None, itkImageToImageFilterVISS2ID2)
itkImageToImageFilterVISS2ID2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS2ID2_SetDirectionTolerance, None, itkImageToImageFilterVISS2ID2)
itkImageToImageFilterVISS2ID2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS2ID2_GetDirectionTolerance, None, itkImageToImageFilterVISS2ID2)
itkImageToImageFilterVISS2ID2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterVISS2ID2_swigregister
itkImageToImageFilterVISS2ID2_swigregister(itkImageToImageFilterVISS2ID2)

def itkImageToImageFilterVISS2ID2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterVISS2ID2 *":
    """itkImageToImageFilterVISS2ID2_cast(itkLightObject obj) -> itkImageToImageFilterVISS2ID2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterVISS2ID2_cast(obj)

class itkImageToImageFilterVISS2IF2(itkImageSourcePython.itkImageSourceIF2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterVISS2IF2 self, itkVectorImageSS2 image)
        SetInput(itkImageToImageFilterVISS2IF2 self, unsigned int arg0, itkVectorImageSS2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS2IF2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkVectorImageSS2 const *":
        """
        GetInput(itkImageToImageFilterVISS2IF2 self) -> itkVectorImageSS2
        GetInput(itkImageToImageFilterVISS2IF2 self, unsigned int idx) -> itkVectorImageSS2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS2IF2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkVectorImageSS2') -> "void":
        """
        PushBackInput(itkImageToImageFilterVISS2IF2 self, itkVectorImageSS2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS2IF2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterVISS2IF2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS2IF2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkVectorImageSS2') -> "void":
        """PushFrontInput(itkImageToImageFilterVISS2IF2 self, itkVectorImageSS2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS2IF2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterVISS2IF2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS2IF2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterVISS2IF2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS2IF2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterVISS2IF2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS2IF2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterVISS2IF2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS2IF2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterVISS2IF2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS2IF2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterVISS2IF2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterVISS2IF2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterVISS2IF2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS2IF2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterVISS2IF2

        Create a new object of the class itkImageToImageFilterVISS2IF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterVISS2IF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterVISS2IF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterVISS2IF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterVISS2IF2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS2IF2_SetInput, None, itkImageToImageFilterVISS2IF2)
itkImageToImageFilterVISS2IF2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS2IF2_GetInput, None, itkImageToImageFilterVISS2IF2)
itkImageToImageFilterVISS2IF2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS2IF2_PushBackInput, None, itkImageToImageFilterVISS2IF2)
itkImageToImageFilterVISS2IF2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS2IF2_PopBackInput, None, itkImageToImageFilterVISS2IF2)
itkImageToImageFilterVISS2IF2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS2IF2_PushFrontInput, None, itkImageToImageFilterVISS2IF2)
itkImageToImageFilterVISS2IF2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS2IF2_PopFrontInput, None, itkImageToImageFilterVISS2IF2)
itkImageToImageFilterVISS2IF2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS2IF2_SetCoordinateTolerance, None, itkImageToImageFilterVISS2IF2)
itkImageToImageFilterVISS2IF2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS2IF2_GetCoordinateTolerance, None, itkImageToImageFilterVISS2IF2)
itkImageToImageFilterVISS2IF2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS2IF2_SetDirectionTolerance, None, itkImageToImageFilterVISS2IF2)
itkImageToImageFilterVISS2IF2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS2IF2_GetDirectionTolerance, None, itkImageToImageFilterVISS2IF2)
itkImageToImageFilterVISS2IF2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterVISS2IF2_swigregister
itkImageToImageFilterVISS2IF2_swigregister(itkImageToImageFilterVISS2IF2)

def itkImageToImageFilterVISS2IF2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterVISS2IF2 *":
    """itkImageToImageFilterVISS2IF2_cast(itkLightObject obj) -> itkImageToImageFilterVISS2IF2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterVISS2IF2_cast(obj)

class itkImageToImageFilterVISS2ISS2(itkImageSourcePython.itkImageSourceISS2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterVISS2ISS2 self, itkVectorImageSS2 image)
        SetInput(itkImageToImageFilterVISS2ISS2 self, unsigned int arg0, itkVectorImageSS2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS2ISS2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkVectorImageSS2 const *":
        """
        GetInput(itkImageToImageFilterVISS2ISS2 self) -> itkVectorImageSS2
        GetInput(itkImageToImageFilterVISS2ISS2 self, unsigned int idx) -> itkVectorImageSS2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS2ISS2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkVectorImageSS2') -> "void":
        """
        PushBackInput(itkImageToImageFilterVISS2ISS2 self, itkVectorImageSS2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS2ISS2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterVISS2ISS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS2ISS2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkVectorImageSS2') -> "void":
        """PushFrontInput(itkImageToImageFilterVISS2ISS2 self, itkVectorImageSS2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS2ISS2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterVISS2ISS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS2ISS2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterVISS2ISS2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS2ISS2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterVISS2ISS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS2ISS2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterVISS2ISS2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS2ISS2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterVISS2ISS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS2ISS2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterVISS2ISS2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterVISS2ISS2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterVISS2ISS2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS2ISS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterVISS2ISS2

        Create a new object of the class itkImageToImageFilterVISS2ISS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterVISS2ISS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterVISS2ISS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterVISS2ISS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterVISS2ISS2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS2ISS2_SetInput, None, itkImageToImageFilterVISS2ISS2)
itkImageToImageFilterVISS2ISS2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS2ISS2_GetInput, None, itkImageToImageFilterVISS2ISS2)
itkImageToImageFilterVISS2ISS2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS2ISS2_PushBackInput, None, itkImageToImageFilterVISS2ISS2)
itkImageToImageFilterVISS2ISS2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS2ISS2_PopBackInput, None, itkImageToImageFilterVISS2ISS2)
itkImageToImageFilterVISS2ISS2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS2ISS2_PushFrontInput, None, itkImageToImageFilterVISS2ISS2)
itkImageToImageFilterVISS2ISS2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS2ISS2_PopFrontInput, None, itkImageToImageFilterVISS2ISS2)
itkImageToImageFilterVISS2ISS2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS2ISS2_SetCoordinateTolerance, None, itkImageToImageFilterVISS2ISS2)
itkImageToImageFilterVISS2ISS2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS2ISS2_GetCoordinateTolerance, None, itkImageToImageFilterVISS2ISS2)
itkImageToImageFilterVISS2ISS2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS2ISS2_SetDirectionTolerance, None, itkImageToImageFilterVISS2ISS2)
itkImageToImageFilterVISS2ISS2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS2ISS2_GetDirectionTolerance, None, itkImageToImageFilterVISS2ISS2)
itkImageToImageFilterVISS2ISS2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterVISS2ISS2_swigregister
itkImageToImageFilterVISS2ISS2_swigregister(itkImageToImageFilterVISS2ISS2)

def itkImageToImageFilterVISS2ISS2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterVISS2ISS2 *":
    """itkImageToImageFilterVISS2ISS2_cast(itkLightObject obj) -> itkImageToImageFilterVISS2ISS2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterVISS2ISS2_cast(obj)

class itkImageToImageFilterVISS2IUC2(itkImageSourcePython.itkImageSourceIUC2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterVISS2IUC2 self, itkVectorImageSS2 image)
        SetInput(itkImageToImageFilterVISS2IUC2 self, unsigned int arg0, itkVectorImageSS2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS2IUC2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkVectorImageSS2 const *":
        """
        GetInput(itkImageToImageFilterVISS2IUC2 self) -> itkVectorImageSS2
        GetInput(itkImageToImageFilterVISS2IUC2 self, unsigned int idx) -> itkVectorImageSS2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS2IUC2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkVectorImageSS2') -> "void":
        """
        PushBackInput(itkImageToImageFilterVISS2IUC2 self, itkVectorImageSS2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS2IUC2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterVISS2IUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS2IUC2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkVectorImageSS2') -> "void":
        """PushFrontInput(itkImageToImageFilterVISS2IUC2 self, itkVectorImageSS2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS2IUC2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterVISS2IUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS2IUC2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterVISS2IUC2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS2IUC2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterVISS2IUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS2IUC2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterVISS2IUC2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS2IUC2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterVISS2IUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS2IUC2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterVISS2IUC2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterVISS2IUC2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterVISS2IUC2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS2IUC2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterVISS2IUC2

        Create a new object of the class itkImageToImageFilterVISS2IUC2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterVISS2IUC2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterVISS2IUC2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterVISS2IUC2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterVISS2IUC2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS2IUC2_SetInput, None, itkImageToImageFilterVISS2IUC2)
itkImageToImageFilterVISS2IUC2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS2IUC2_GetInput, None, itkImageToImageFilterVISS2IUC2)
itkImageToImageFilterVISS2IUC2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS2IUC2_PushBackInput, None, itkImageToImageFilterVISS2IUC2)
itkImageToImageFilterVISS2IUC2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS2IUC2_PopBackInput, None, itkImageToImageFilterVISS2IUC2)
itkImageToImageFilterVISS2IUC2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS2IUC2_PushFrontInput, None, itkImageToImageFilterVISS2IUC2)
itkImageToImageFilterVISS2IUC2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS2IUC2_PopFrontInput, None, itkImageToImageFilterVISS2IUC2)
itkImageToImageFilterVISS2IUC2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS2IUC2_SetCoordinateTolerance, None, itkImageToImageFilterVISS2IUC2)
itkImageToImageFilterVISS2IUC2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS2IUC2_GetCoordinateTolerance, None, itkImageToImageFilterVISS2IUC2)
itkImageToImageFilterVISS2IUC2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS2IUC2_SetDirectionTolerance, None, itkImageToImageFilterVISS2IUC2)
itkImageToImageFilterVISS2IUC2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS2IUC2_GetDirectionTolerance, None, itkImageToImageFilterVISS2IUC2)
itkImageToImageFilterVISS2IUC2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterVISS2IUC2_swigregister
itkImageToImageFilterVISS2IUC2_swigregister(itkImageToImageFilterVISS2IUC2)

def itkImageToImageFilterVISS2IUC2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterVISS2IUC2 *":
    """itkImageToImageFilterVISS2IUC2_cast(itkLightObject obj) -> itkImageToImageFilterVISS2IUC2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterVISS2IUC2_cast(obj)

class itkImageToImageFilterVISS2IUS2(itkImageSourcePython.itkImageSourceIUS2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterVISS2IUS2 self, itkVectorImageSS2 image)
        SetInput(itkImageToImageFilterVISS2IUS2 self, unsigned int arg0, itkVectorImageSS2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS2IUS2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkVectorImageSS2 const *":
        """
        GetInput(itkImageToImageFilterVISS2IUS2 self) -> itkVectorImageSS2
        GetInput(itkImageToImageFilterVISS2IUS2 self, unsigned int idx) -> itkVectorImageSS2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS2IUS2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkVectorImageSS2') -> "void":
        """
        PushBackInput(itkImageToImageFilterVISS2IUS2 self, itkVectorImageSS2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS2IUS2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterVISS2IUS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS2IUS2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkVectorImageSS2') -> "void":
        """PushFrontInput(itkImageToImageFilterVISS2IUS2 self, itkVectorImageSS2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS2IUS2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterVISS2IUS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS2IUS2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterVISS2IUS2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS2IUS2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterVISS2IUS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS2IUS2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterVISS2IUS2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS2IUS2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterVISS2IUS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS2IUS2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterVISS2IUS2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterVISS2IUS2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterVISS2IUS2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS2IUS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterVISS2IUS2

        Create a new object of the class itkImageToImageFilterVISS2IUS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterVISS2IUS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterVISS2IUS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterVISS2IUS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterVISS2IUS2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS2IUS2_SetInput, None, itkImageToImageFilterVISS2IUS2)
itkImageToImageFilterVISS2IUS2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS2IUS2_GetInput, None, itkImageToImageFilterVISS2IUS2)
itkImageToImageFilterVISS2IUS2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS2IUS2_PushBackInput, None, itkImageToImageFilterVISS2IUS2)
itkImageToImageFilterVISS2IUS2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS2IUS2_PopBackInput, None, itkImageToImageFilterVISS2IUS2)
itkImageToImageFilterVISS2IUS2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS2IUS2_PushFrontInput, None, itkImageToImageFilterVISS2IUS2)
itkImageToImageFilterVISS2IUS2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS2IUS2_PopFrontInput, None, itkImageToImageFilterVISS2IUS2)
itkImageToImageFilterVISS2IUS2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS2IUS2_SetCoordinateTolerance, None, itkImageToImageFilterVISS2IUS2)
itkImageToImageFilterVISS2IUS2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS2IUS2_GetCoordinateTolerance, None, itkImageToImageFilterVISS2IUS2)
itkImageToImageFilterVISS2IUS2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS2IUS2_SetDirectionTolerance, None, itkImageToImageFilterVISS2IUS2)
itkImageToImageFilterVISS2IUS2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS2IUS2_GetDirectionTolerance, None, itkImageToImageFilterVISS2IUS2)
itkImageToImageFilterVISS2IUS2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterVISS2IUS2_swigregister
itkImageToImageFilterVISS2IUS2_swigregister(itkImageToImageFilterVISS2IUS2)

def itkImageToImageFilterVISS2IUS2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterVISS2IUS2 *":
    """itkImageToImageFilterVISS2IUS2_cast(itkLightObject obj) -> itkImageToImageFilterVISS2IUS2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterVISS2IUS2_cast(obj)

class itkImageToImageFilterVISS3ID3(itkImageSourcePython.itkImageSourceID3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterVISS3ID3 self, itkVectorImageSS3 image)
        SetInput(itkImageToImageFilterVISS3ID3 self, unsigned int arg0, itkVectorImageSS3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS3ID3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkVectorImageSS3 const *":
        """
        GetInput(itkImageToImageFilterVISS3ID3 self) -> itkVectorImageSS3
        GetInput(itkImageToImageFilterVISS3ID3 self, unsigned int idx) -> itkVectorImageSS3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS3ID3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkVectorImageSS3') -> "void":
        """
        PushBackInput(itkImageToImageFilterVISS3ID3 self, itkVectorImageSS3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS3ID3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterVISS3ID3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS3ID3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkVectorImageSS3') -> "void":
        """PushFrontInput(itkImageToImageFilterVISS3ID3 self, itkVectorImageSS3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS3ID3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterVISS3ID3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS3ID3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterVISS3ID3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS3ID3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterVISS3ID3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS3ID3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterVISS3ID3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS3ID3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterVISS3ID3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS3ID3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterVISS3ID3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterVISS3ID3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterVISS3ID3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS3ID3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterVISS3ID3

        Create a new object of the class itkImageToImageFilterVISS3ID3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterVISS3ID3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterVISS3ID3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterVISS3ID3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterVISS3ID3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS3ID3_SetInput, None, itkImageToImageFilterVISS3ID3)
itkImageToImageFilterVISS3ID3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS3ID3_GetInput, None, itkImageToImageFilterVISS3ID3)
itkImageToImageFilterVISS3ID3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS3ID3_PushBackInput, None, itkImageToImageFilterVISS3ID3)
itkImageToImageFilterVISS3ID3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS3ID3_PopBackInput, None, itkImageToImageFilterVISS3ID3)
itkImageToImageFilterVISS3ID3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS3ID3_PushFrontInput, None, itkImageToImageFilterVISS3ID3)
itkImageToImageFilterVISS3ID3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS3ID3_PopFrontInput, None, itkImageToImageFilterVISS3ID3)
itkImageToImageFilterVISS3ID3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS3ID3_SetCoordinateTolerance, None, itkImageToImageFilterVISS3ID3)
itkImageToImageFilterVISS3ID3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS3ID3_GetCoordinateTolerance, None, itkImageToImageFilterVISS3ID3)
itkImageToImageFilterVISS3ID3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS3ID3_SetDirectionTolerance, None, itkImageToImageFilterVISS3ID3)
itkImageToImageFilterVISS3ID3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS3ID3_GetDirectionTolerance, None, itkImageToImageFilterVISS3ID3)
itkImageToImageFilterVISS3ID3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterVISS3ID3_swigregister
itkImageToImageFilterVISS3ID3_swigregister(itkImageToImageFilterVISS3ID3)

def itkImageToImageFilterVISS3ID3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterVISS3ID3 *":
    """itkImageToImageFilterVISS3ID3_cast(itkLightObject obj) -> itkImageToImageFilterVISS3ID3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterVISS3ID3_cast(obj)

class itkImageToImageFilterVISS3IF3(itkImageSourcePython.itkImageSourceIF3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterVISS3IF3 self, itkVectorImageSS3 image)
        SetInput(itkImageToImageFilterVISS3IF3 self, unsigned int arg0, itkVectorImageSS3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS3IF3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkVectorImageSS3 const *":
        """
        GetInput(itkImageToImageFilterVISS3IF3 self) -> itkVectorImageSS3
        GetInput(itkImageToImageFilterVISS3IF3 self, unsigned int idx) -> itkVectorImageSS3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS3IF3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkVectorImageSS3') -> "void":
        """
        PushBackInput(itkImageToImageFilterVISS3IF3 self, itkVectorImageSS3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS3IF3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterVISS3IF3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS3IF3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkVectorImageSS3') -> "void":
        """PushFrontInput(itkImageToImageFilterVISS3IF3 self, itkVectorImageSS3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS3IF3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterVISS3IF3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS3IF3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterVISS3IF3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS3IF3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterVISS3IF3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS3IF3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterVISS3IF3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS3IF3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterVISS3IF3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS3IF3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterVISS3IF3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterVISS3IF3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterVISS3IF3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS3IF3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterVISS3IF3

        Create a new object of the class itkImageToImageFilterVISS3IF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterVISS3IF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterVISS3IF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterVISS3IF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterVISS3IF3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS3IF3_SetInput, None, itkImageToImageFilterVISS3IF3)
itkImageToImageFilterVISS3IF3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS3IF3_GetInput, None, itkImageToImageFilterVISS3IF3)
itkImageToImageFilterVISS3IF3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS3IF3_PushBackInput, None, itkImageToImageFilterVISS3IF3)
itkImageToImageFilterVISS3IF3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS3IF3_PopBackInput, None, itkImageToImageFilterVISS3IF3)
itkImageToImageFilterVISS3IF3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS3IF3_PushFrontInput, None, itkImageToImageFilterVISS3IF3)
itkImageToImageFilterVISS3IF3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS3IF3_PopFrontInput, None, itkImageToImageFilterVISS3IF3)
itkImageToImageFilterVISS3IF3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS3IF3_SetCoordinateTolerance, None, itkImageToImageFilterVISS3IF3)
itkImageToImageFilterVISS3IF3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS3IF3_GetCoordinateTolerance, None, itkImageToImageFilterVISS3IF3)
itkImageToImageFilterVISS3IF3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS3IF3_SetDirectionTolerance, None, itkImageToImageFilterVISS3IF3)
itkImageToImageFilterVISS3IF3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS3IF3_GetDirectionTolerance, None, itkImageToImageFilterVISS3IF3)
itkImageToImageFilterVISS3IF3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterVISS3IF3_swigregister
itkImageToImageFilterVISS3IF3_swigregister(itkImageToImageFilterVISS3IF3)

def itkImageToImageFilterVISS3IF3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterVISS3IF3 *":
    """itkImageToImageFilterVISS3IF3_cast(itkLightObject obj) -> itkImageToImageFilterVISS3IF3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterVISS3IF3_cast(obj)

class itkImageToImageFilterVISS3ISS3(itkImageSourcePython.itkImageSourceISS3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterVISS3ISS3 self, itkVectorImageSS3 image)
        SetInput(itkImageToImageFilterVISS3ISS3 self, unsigned int arg0, itkVectorImageSS3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS3ISS3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkVectorImageSS3 const *":
        """
        GetInput(itkImageToImageFilterVISS3ISS3 self) -> itkVectorImageSS3
        GetInput(itkImageToImageFilterVISS3ISS3 self, unsigned int idx) -> itkVectorImageSS3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS3ISS3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkVectorImageSS3') -> "void":
        """
        PushBackInput(itkImageToImageFilterVISS3ISS3 self, itkVectorImageSS3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS3ISS3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterVISS3ISS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS3ISS3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkVectorImageSS3') -> "void":
        """PushFrontInput(itkImageToImageFilterVISS3ISS3 self, itkVectorImageSS3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS3ISS3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterVISS3ISS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS3ISS3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterVISS3ISS3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS3ISS3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterVISS3ISS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS3ISS3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterVISS3ISS3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS3ISS3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterVISS3ISS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS3ISS3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterVISS3ISS3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterVISS3ISS3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterVISS3ISS3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS3ISS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterVISS3ISS3

        Create a new object of the class itkImageToImageFilterVISS3ISS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterVISS3ISS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterVISS3ISS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterVISS3ISS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterVISS3ISS3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS3ISS3_SetInput, None, itkImageToImageFilterVISS3ISS3)
itkImageToImageFilterVISS3ISS3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS3ISS3_GetInput, None, itkImageToImageFilterVISS3ISS3)
itkImageToImageFilterVISS3ISS3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS3ISS3_PushBackInput, None, itkImageToImageFilterVISS3ISS3)
itkImageToImageFilterVISS3ISS3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS3ISS3_PopBackInput, None, itkImageToImageFilterVISS3ISS3)
itkImageToImageFilterVISS3ISS3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS3ISS3_PushFrontInput, None, itkImageToImageFilterVISS3ISS3)
itkImageToImageFilterVISS3ISS3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS3ISS3_PopFrontInput, None, itkImageToImageFilterVISS3ISS3)
itkImageToImageFilterVISS3ISS3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS3ISS3_SetCoordinateTolerance, None, itkImageToImageFilterVISS3ISS3)
itkImageToImageFilterVISS3ISS3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS3ISS3_GetCoordinateTolerance, None, itkImageToImageFilterVISS3ISS3)
itkImageToImageFilterVISS3ISS3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS3ISS3_SetDirectionTolerance, None, itkImageToImageFilterVISS3ISS3)
itkImageToImageFilterVISS3ISS3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS3ISS3_GetDirectionTolerance, None, itkImageToImageFilterVISS3ISS3)
itkImageToImageFilterVISS3ISS3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterVISS3ISS3_swigregister
itkImageToImageFilterVISS3ISS3_swigregister(itkImageToImageFilterVISS3ISS3)

def itkImageToImageFilterVISS3ISS3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterVISS3ISS3 *":
    """itkImageToImageFilterVISS3ISS3_cast(itkLightObject obj) -> itkImageToImageFilterVISS3ISS3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterVISS3ISS3_cast(obj)

class itkImageToImageFilterVISS3IUC3(itkImageSourcePython.itkImageSourceIUC3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterVISS3IUC3 self, itkVectorImageSS3 image)
        SetInput(itkImageToImageFilterVISS3IUC3 self, unsigned int arg0, itkVectorImageSS3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS3IUC3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkVectorImageSS3 const *":
        """
        GetInput(itkImageToImageFilterVISS3IUC3 self) -> itkVectorImageSS3
        GetInput(itkImageToImageFilterVISS3IUC3 self, unsigned int idx) -> itkVectorImageSS3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS3IUC3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkVectorImageSS3') -> "void":
        """
        PushBackInput(itkImageToImageFilterVISS3IUC3 self, itkVectorImageSS3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS3IUC3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterVISS3IUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS3IUC3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkVectorImageSS3') -> "void":
        """PushFrontInput(itkImageToImageFilterVISS3IUC3 self, itkVectorImageSS3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS3IUC3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterVISS3IUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS3IUC3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterVISS3IUC3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS3IUC3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterVISS3IUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS3IUC3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterVISS3IUC3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS3IUC3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterVISS3IUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS3IUC3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterVISS3IUC3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterVISS3IUC3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterVISS3IUC3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS3IUC3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterVISS3IUC3

        Create a new object of the class itkImageToImageFilterVISS3IUC3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterVISS3IUC3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterVISS3IUC3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterVISS3IUC3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterVISS3IUC3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS3IUC3_SetInput, None, itkImageToImageFilterVISS3IUC3)
itkImageToImageFilterVISS3IUC3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS3IUC3_GetInput, None, itkImageToImageFilterVISS3IUC3)
itkImageToImageFilterVISS3IUC3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS3IUC3_PushBackInput, None, itkImageToImageFilterVISS3IUC3)
itkImageToImageFilterVISS3IUC3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS3IUC3_PopBackInput, None, itkImageToImageFilterVISS3IUC3)
itkImageToImageFilterVISS3IUC3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS3IUC3_PushFrontInput, None, itkImageToImageFilterVISS3IUC3)
itkImageToImageFilterVISS3IUC3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS3IUC3_PopFrontInput, None, itkImageToImageFilterVISS3IUC3)
itkImageToImageFilterVISS3IUC3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS3IUC3_SetCoordinateTolerance, None, itkImageToImageFilterVISS3IUC3)
itkImageToImageFilterVISS3IUC3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS3IUC3_GetCoordinateTolerance, None, itkImageToImageFilterVISS3IUC3)
itkImageToImageFilterVISS3IUC3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS3IUC3_SetDirectionTolerance, None, itkImageToImageFilterVISS3IUC3)
itkImageToImageFilterVISS3IUC3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS3IUC3_GetDirectionTolerance, None, itkImageToImageFilterVISS3IUC3)
itkImageToImageFilterVISS3IUC3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterVISS3IUC3_swigregister
itkImageToImageFilterVISS3IUC3_swigregister(itkImageToImageFilterVISS3IUC3)

def itkImageToImageFilterVISS3IUC3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterVISS3IUC3 *":
    """itkImageToImageFilterVISS3IUC3_cast(itkLightObject obj) -> itkImageToImageFilterVISS3IUC3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterVISS3IUC3_cast(obj)

class itkImageToImageFilterVISS3IUS3(itkImageSourcePython.itkImageSourceIUS3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterVISS3IUS3 self, itkVectorImageSS3 image)
        SetInput(itkImageToImageFilterVISS3IUS3 self, unsigned int arg0, itkVectorImageSS3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS3IUS3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkVectorImageSS3 const *":
        """
        GetInput(itkImageToImageFilterVISS3IUS3 self) -> itkVectorImageSS3
        GetInput(itkImageToImageFilterVISS3IUS3 self, unsigned int idx) -> itkVectorImageSS3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS3IUS3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkVectorImageSS3') -> "void":
        """
        PushBackInput(itkImageToImageFilterVISS3IUS3 self, itkVectorImageSS3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS3IUS3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterVISS3IUS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS3IUS3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkVectorImageSS3') -> "void":
        """PushFrontInput(itkImageToImageFilterVISS3IUS3 self, itkVectorImageSS3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS3IUS3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterVISS3IUS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS3IUS3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterVISS3IUS3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS3IUS3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterVISS3IUS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS3IUS3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterVISS3IUS3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS3IUS3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterVISS3IUS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS3IUS3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterVISS3IUS3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterVISS3IUS3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterVISS3IUS3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVISS3IUS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterVISS3IUS3

        Create a new object of the class itkImageToImageFilterVISS3IUS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterVISS3IUS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterVISS3IUS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterVISS3IUS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterVISS3IUS3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS3IUS3_SetInput, None, itkImageToImageFilterVISS3IUS3)
itkImageToImageFilterVISS3IUS3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS3IUS3_GetInput, None, itkImageToImageFilterVISS3IUS3)
itkImageToImageFilterVISS3IUS3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS3IUS3_PushBackInput, None, itkImageToImageFilterVISS3IUS3)
itkImageToImageFilterVISS3IUS3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS3IUS3_PopBackInput, None, itkImageToImageFilterVISS3IUS3)
itkImageToImageFilterVISS3IUS3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS3IUS3_PushFrontInput, None, itkImageToImageFilterVISS3IUS3)
itkImageToImageFilterVISS3IUS3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS3IUS3_PopFrontInput, None, itkImageToImageFilterVISS3IUS3)
itkImageToImageFilterVISS3IUS3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS3IUS3_SetCoordinateTolerance, None, itkImageToImageFilterVISS3IUS3)
itkImageToImageFilterVISS3IUS3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS3IUS3_GetCoordinateTolerance, None, itkImageToImageFilterVISS3IUS3)
itkImageToImageFilterVISS3IUS3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS3IUS3_SetDirectionTolerance, None, itkImageToImageFilterVISS3IUS3)
itkImageToImageFilterVISS3IUS3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVISS3IUS3_GetDirectionTolerance, None, itkImageToImageFilterVISS3IUS3)
itkImageToImageFilterVISS3IUS3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterVISS3IUS3_swigregister
itkImageToImageFilterVISS3IUS3_swigregister(itkImageToImageFilterVISS3IUS3)

def itkImageToImageFilterVISS3IUS3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterVISS3IUS3 *":
    """itkImageToImageFilterVISS3IUS3_cast(itkLightObject obj) -> itkImageToImageFilterVISS3IUS3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterVISS3IUS3_cast(obj)

class itkImageToImageFilterVIUC2ID2(itkImageSourcePython.itkImageSourceID2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterVIUC2ID2 self, itkVectorImageUC2 image)
        SetInput(itkImageToImageFilterVIUC2ID2 self, unsigned int arg0, itkVectorImageUC2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2ID2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkVectorImageUC2 const *":
        """
        GetInput(itkImageToImageFilterVIUC2ID2 self) -> itkVectorImageUC2
        GetInput(itkImageToImageFilterVIUC2ID2 self, unsigned int idx) -> itkVectorImageUC2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2ID2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkVectorImageUC2') -> "void":
        """
        PushBackInput(itkImageToImageFilterVIUC2ID2 self, itkVectorImageUC2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2ID2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterVIUC2ID2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2ID2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkVectorImageUC2') -> "void":
        """PushFrontInput(itkImageToImageFilterVIUC2ID2 self, itkVectorImageUC2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2ID2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterVIUC2ID2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2ID2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterVIUC2ID2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2ID2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterVIUC2ID2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2ID2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterVIUC2ID2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2ID2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterVIUC2ID2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2ID2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterVIUC2ID2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIUC2ID2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterVIUC2ID2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2ID2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterVIUC2ID2

        Create a new object of the class itkImageToImageFilterVIUC2ID2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterVIUC2ID2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterVIUC2ID2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterVIUC2ID2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterVIUC2ID2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC2ID2_SetInput, None, itkImageToImageFilterVIUC2ID2)
itkImageToImageFilterVIUC2ID2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC2ID2_GetInput, None, itkImageToImageFilterVIUC2ID2)
itkImageToImageFilterVIUC2ID2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC2ID2_PushBackInput, None, itkImageToImageFilterVIUC2ID2)
itkImageToImageFilterVIUC2ID2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC2ID2_PopBackInput, None, itkImageToImageFilterVIUC2ID2)
itkImageToImageFilterVIUC2ID2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC2ID2_PushFrontInput, None, itkImageToImageFilterVIUC2ID2)
itkImageToImageFilterVIUC2ID2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC2ID2_PopFrontInput, None, itkImageToImageFilterVIUC2ID2)
itkImageToImageFilterVIUC2ID2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC2ID2_SetCoordinateTolerance, None, itkImageToImageFilterVIUC2ID2)
itkImageToImageFilterVIUC2ID2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC2ID2_GetCoordinateTolerance, None, itkImageToImageFilterVIUC2ID2)
itkImageToImageFilterVIUC2ID2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC2ID2_SetDirectionTolerance, None, itkImageToImageFilterVIUC2ID2)
itkImageToImageFilterVIUC2ID2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC2ID2_GetDirectionTolerance, None, itkImageToImageFilterVIUC2ID2)
itkImageToImageFilterVIUC2ID2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2ID2_swigregister
itkImageToImageFilterVIUC2ID2_swigregister(itkImageToImageFilterVIUC2ID2)

def itkImageToImageFilterVIUC2ID2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIUC2ID2 *":
    """itkImageToImageFilterVIUC2ID2_cast(itkLightObject obj) -> itkImageToImageFilterVIUC2ID2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2ID2_cast(obj)

class itkImageToImageFilterVIUC2IF2(itkImageSourcePython.itkImageSourceIF2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterVIUC2IF2 self, itkVectorImageUC2 image)
        SetInput(itkImageToImageFilterVIUC2IF2 self, unsigned int arg0, itkVectorImageUC2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IF2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkVectorImageUC2 const *":
        """
        GetInput(itkImageToImageFilterVIUC2IF2 self) -> itkVectorImageUC2
        GetInput(itkImageToImageFilterVIUC2IF2 self, unsigned int idx) -> itkVectorImageUC2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IF2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkVectorImageUC2') -> "void":
        """
        PushBackInput(itkImageToImageFilterVIUC2IF2 self, itkVectorImageUC2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IF2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterVIUC2IF2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IF2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkVectorImageUC2') -> "void":
        """PushFrontInput(itkImageToImageFilterVIUC2IF2 self, itkVectorImageUC2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IF2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterVIUC2IF2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IF2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterVIUC2IF2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IF2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterVIUC2IF2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IF2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterVIUC2IF2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IF2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterVIUC2IF2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IF2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterVIUC2IF2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIUC2IF2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterVIUC2IF2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IF2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterVIUC2IF2

        Create a new object of the class itkImageToImageFilterVIUC2IF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterVIUC2IF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterVIUC2IF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterVIUC2IF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterVIUC2IF2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IF2_SetInput, None, itkImageToImageFilterVIUC2IF2)
itkImageToImageFilterVIUC2IF2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IF2_GetInput, None, itkImageToImageFilterVIUC2IF2)
itkImageToImageFilterVIUC2IF2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IF2_PushBackInput, None, itkImageToImageFilterVIUC2IF2)
itkImageToImageFilterVIUC2IF2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IF2_PopBackInput, None, itkImageToImageFilterVIUC2IF2)
itkImageToImageFilterVIUC2IF2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IF2_PushFrontInput, None, itkImageToImageFilterVIUC2IF2)
itkImageToImageFilterVIUC2IF2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IF2_PopFrontInput, None, itkImageToImageFilterVIUC2IF2)
itkImageToImageFilterVIUC2IF2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IF2_SetCoordinateTolerance, None, itkImageToImageFilterVIUC2IF2)
itkImageToImageFilterVIUC2IF2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IF2_GetCoordinateTolerance, None, itkImageToImageFilterVIUC2IF2)
itkImageToImageFilterVIUC2IF2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IF2_SetDirectionTolerance, None, itkImageToImageFilterVIUC2IF2)
itkImageToImageFilterVIUC2IF2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IF2_GetDirectionTolerance, None, itkImageToImageFilterVIUC2IF2)
itkImageToImageFilterVIUC2IF2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IF2_swigregister
itkImageToImageFilterVIUC2IF2_swigregister(itkImageToImageFilterVIUC2IF2)

def itkImageToImageFilterVIUC2IF2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIUC2IF2 *":
    """itkImageToImageFilterVIUC2IF2_cast(itkLightObject obj) -> itkImageToImageFilterVIUC2IF2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IF2_cast(obj)

class itkImageToImageFilterVIUC2ISS2(itkImageSourcePython.itkImageSourceISS2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterVIUC2ISS2 self, itkVectorImageUC2 image)
        SetInput(itkImageToImageFilterVIUC2ISS2 self, unsigned int arg0, itkVectorImageUC2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2ISS2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkVectorImageUC2 const *":
        """
        GetInput(itkImageToImageFilterVIUC2ISS2 self) -> itkVectorImageUC2
        GetInput(itkImageToImageFilterVIUC2ISS2 self, unsigned int idx) -> itkVectorImageUC2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2ISS2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkVectorImageUC2') -> "void":
        """
        PushBackInput(itkImageToImageFilterVIUC2ISS2 self, itkVectorImageUC2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2ISS2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterVIUC2ISS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2ISS2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkVectorImageUC2') -> "void":
        """PushFrontInput(itkImageToImageFilterVIUC2ISS2 self, itkVectorImageUC2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2ISS2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterVIUC2ISS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2ISS2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterVIUC2ISS2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2ISS2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterVIUC2ISS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2ISS2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterVIUC2ISS2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2ISS2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterVIUC2ISS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2ISS2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterVIUC2ISS2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIUC2ISS2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterVIUC2ISS2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2ISS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterVIUC2ISS2

        Create a new object of the class itkImageToImageFilterVIUC2ISS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterVIUC2ISS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterVIUC2ISS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterVIUC2ISS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterVIUC2ISS2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC2ISS2_SetInput, None, itkImageToImageFilterVIUC2ISS2)
itkImageToImageFilterVIUC2ISS2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC2ISS2_GetInput, None, itkImageToImageFilterVIUC2ISS2)
itkImageToImageFilterVIUC2ISS2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC2ISS2_PushBackInput, None, itkImageToImageFilterVIUC2ISS2)
itkImageToImageFilterVIUC2ISS2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC2ISS2_PopBackInput, None, itkImageToImageFilterVIUC2ISS2)
itkImageToImageFilterVIUC2ISS2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC2ISS2_PushFrontInput, None, itkImageToImageFilterVIUC2ISS2)
itkImageToImageFilterVIUC2ISS2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC2ISS2_PopFrontInput, None, itkImageToImageFilterVIUC2ISS2)
itkImageToImageFilterVIUC2ISS2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC2ISS2_SetCoordinateTolerance, None, itkImageToImageFilterVIUC2ISS2)
itkImageToImageFilterVIUC2ISS2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC2ISS2_GetCoordinateTolerance, None, itkImageToImageFilterVIUC2ISS2)
itkImageToImageFilterVIUC2ISS2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC2ISS2_SetDirectionTolerance, None, itkImageToImageFilterVIUC2ISS2)
itkImageToImageFilterVIUC2ISS2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC2ISS2_GetDirectionTolerance, None, itkImageToImageFilterVIUC2ISS2)
itkImageToImageFilterVIUC2ISS2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2ISS2_swigregister
itkImageToImageFilterVIUC2ISS2_swigregister(itkImageToImageFilterVIUC2ISS2)

def itkImageToImageFilterVIUC2ISS2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIUC2ISS2 *":
    """itkImageToImageFilterVIUC2ISS2_cast(itkLightObject obj) -> itkImageToImageFilterVIUC2ISS2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2ISS2_cast(obj)

class itkImageToImageFilterVIUC2IUC2(itkImageSourcePython.itkImageSourceIUC2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterVIUC2IUC2 self, itkVectorImageUC2 image)
        SetInput(itkImageToImageFilterVIUC2IUC2 self, unsigned int arg0, itkVectorImageUC2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IUC2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkVectorImageUC2 const *":
        """
        GetInput(itkImageToImageFilterVIUC2IUC2 self) -> itkVectorImageUC2
        GetInput(itkImageToImageFilterVIUC2IUC2 self, unsigned int idx) -> itkVectorImageUC2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IUC2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkVectorImageUC2') -> "void":
        """
        PushBackInput(itkImageToImageFilterVIUC2IUC2 self, itkVectorImageUC2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IUC2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterVIUC2IUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IUC2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkVectorImageUC2') -> "void":
        """PushFrontInput(itkImageToImageFilterVIUC2IUC2 self, itkVectorImageUC2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IUC2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterVIUC2IUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IUC2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterVIUC2IUC2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IUC2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterVIUC2IUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IUC2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterVIUC2IUC2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IUC2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterVIUC2IUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IUC2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterVIUC2IUC2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIUC2IUC2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterVIUC2IUC2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IUC2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterVIUC2IUC2

        Create a new object of the class itkImageToImageFilterVIUC2IUC2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterVIUC2IUC2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterVIUC2IUC2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterVIUC2IUC2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterVIUC2IUC2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IUC2_SetInput, None, itkImageToImageFilterVIUC2IUC2)
itkImageToImageFilterVIUC2IUC2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IUC2_GetInput, None, itkImageToImageFilterVIUC2IUC2)
itkImageToImageFilterVIUC2IUC2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IUC2_PushBackInput, None, itkImageToImageFilterVIUC2IUC2)
itkImageToImageFilterVIUC2IUC2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IUC2_PopBackInput, None, itkImageToImageFilterVIUC2IUC2)
itkImageToImageFilterVIUC2IUC2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IUC2_PushFrontInput, None, itkImageToImageFilterVIUC2IUC2)
itkImageToImageFilterVIUC2IUC2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IUC2_PopFrontInput, None, itkImageToImageFilterVIUC2IUC2)
itkImageToImageFilterVIUC2IUC2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IUC2_SetCoordinateTolerance, None, itkImageToImageFilterVIUC2IUC2)
itkImageToImageFilterVIUC2IUC2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IUC2_GetCoordinateTolerance, None, itkImageToImageFilterVIUC2IUC2)
itkImageToImageFilterVIUC2IUC2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IUC2_SetDirectionTolerance, None, itkImageToImageFilterVIUC2IUC2)
itkImageToImageFilterVIUC2IUC2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IUC2_GetDirectionTolerance, None, itkImageToImageFilterVIUC2IUC2)
itkImageToImageFilterVIUC2IUC2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IUC2_swigregister
itkImageToImageFilterVIUC2IUC2_swigregister(itkImageToImageFilterVIUC2IUC2)

def itkImageToImageFilterVIUC2IUC2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIUC2IUC2 *":
    """itkImageToImageFilterVIUC2IUC2_cast(itkLightObject obj) -> itkImageToImageFilterVIUC2IUC2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IUC2_cast(obj)

class itkImageToImageFilterVIUC2IUS2(itkImageSourcePython.itkImageSourceIUS2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterVIUC2IUS2 self, itkVectorImageUC2 image)
        SetInput(itkImageToImageFilterVIUC2IUS2 self, unsigned int arg0, itkVectorImageUC2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IUS2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkVectorImageUC2 const *":
        """
        GetInput(itkImageToImageFilterVIUC2IUS2 self) -> itkVectorImageUC2
        GetInput(itkImageToImageFilterVIUC2IUS2 self, unsigned int idx) -> itkVectorImageUC2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IUS2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkVectorImageUC2') -> "void":
        """
        PushBackInput(itkImageToImageFilterVIUC2IUS2 self, itkVectorImageUC2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IUS2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterVIUC2IUS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IUS2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkVectorImageUC2') -> "void":
        """PushFrontInput(itkImageToImageFilterVIUC2IUS2 self, itkVectorImageUC2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IUS2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterVIUC2IUS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IUS2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterVIUC2IUS2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IUS2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterVIUC2IUS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IUS2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterVIUC2IUS2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IUS2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterVIUC2IUS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IUS2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterVIUC2IUS2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIUC2IUS2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterVIUC2IUS2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IUS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterVIUC2IUS2

        Create a new object of the class itkImageToImageFilterVIUC2IUS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterVIUC2IUS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterVIUC2IUS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterVIUC2IUS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterVIUC2IUS2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IUS2_SetInput, None, itkImageToImageFilterVIUC2IUS2)
itkImageToImageFilterVIUC2IUS2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IUS2_GetInput, None, itkImageToImageFilterVIUC2IUS2)
itkImageToImageFilterVIUC2IUS2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IUS2_PushBackInput, None, itkImageToImageFilterVIUC2IUS2)
itkImageToImageFilterVIUC2IUS2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IUS2_PopBackInput, None, itkImageToImageFilterVIUC2IUS2)
itkImageToImageFilterVIUC2IUS2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IUS2_PushFrontInput, None, itkImageToImageFilterVIUC2IUS2)
itkImageToImageFilterVIUC2IUS2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IUS2_PopFrontInput, None, itkImageToImageFilterVIUC2IUS2)
itkImageToImageFilterVIUC2IUS2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IUS2_SetCoordinateTolerance, None, itkImageToImageFilterVIUC2IUS2)
itkImageToImageFilterVIUC2IUS2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IUS2_GetCoordinateTolerance, None, itkImageToImageFilterVIUC2IUS2)
itkImageToImageFilterVIUC2IUS2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IUS2_SetDirectionTolerance, None, itkImageToImageFilterVIUC2IUS2)
itkImageToImageFilterVIUC2IUS2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IUS2_GetDirectionTolerance, None, itkImageToImageFilterVIUC2IUS2)
itkImageToImageFilterVIUC2IUS2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IUS2_swigregister
itkImageToImageFilterVIUC2IUS2_swigregister(itkImageToImageFilterVIUC2IUS2)

def itkImageToImageFilterVIUC2IUS2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIUC2IUS2 *":
    """itkImageToImageFilterVIUC2IUS2_cast(itkLightObject obj) -> itkImageToImageFilterVIUC2IUS2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC2IUS2_cast(obj)

class itkImageToImageFilterVIUC3ID3(itkImageSourcePython.itkImageSourceID3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterVIUC3ID3 self, itkVectorImageUC3 image)
        SetInput(itkImageToImageFilterVIUC3ID3 self, unsigned int arg0, itkVectorImageUC3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3ID3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkVectorImageUC3 const *":
        """
        GetInput(itkImageToImageFilterVIUC3ID3 self) -> itkVectorImageUC3
        GetInput(itkImageToImageFilterVIUC3ID3 self, unsigned int idx) -> itkVectorImageUC3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3ID3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkVectorImageUC3') -> "void":
        """
        PushBackInput(itkImageToImageFilterVIUC3ID3 self, itkVectorImageUC3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3ID3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterVIUC3ID3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3ID3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkVectorImageUC3') -> "void":
        """PushFrontInput(itkImageToImageFilterVIUC3ID3 self, itkVectorImageUC3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3ID3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterVIUC3ID3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3ID3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterVIUC3ID3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3ID3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterVIUC3ID3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3ID3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterVIUC3ID3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3ID3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterVIUC3ID3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3ID3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterVIUC3ID3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIUC3ID3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterVIUC3ID3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3ID3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterVIUC3ID3

        Create a new object of the class itkImageToImageFilterVIUC3ID3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterVIUC3ID3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterVIUC3ID3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterVIUC3ID3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterVIUC3ID3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC3ID3_SetInput, None, itkImageToImageFilterVIUC3ID3)
itkImageToImageFilterVIUC3ID3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC3ID3_GetInput, None, itkImageToImageFilterVIUC3ID3)
itkImageToImageFilterVIUC3ID3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC3ID3_PushBackInput, None, itkImageToImageFilterVIUC3ID3)
itkImageToImageFilterVIUC3ID3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC3ID3_PopBackInput, None, itkImageToImageFilterVIUC3ID3)
itkImageToImageFilterVIUC3ID3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC3ID3_PushFrontInput, None, itkImageToImageFilterVIUC3ID3)
itkImageToImageFilterVIUC3ID3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC3ID3_PopFrontInput, None, itkImageToImageFilterVIUC3ID3)
itkImageToImageFilterVIUC3ID3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC3ID3_SetCoordinateTolerance, None, itkImageToImageFilterVIUC3ID3)
itkImageToImageFilterVIUC3ID3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC3ID3_GetCoordinateTolerance, None, itkImageToImageFilterVIUC3ID3)
itkImageToImageFilterVIUC3ID3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC3ID3_SetDirectionTolerance, None, itkImageToImageFilterVIUC3ID3)
itkImageToImageFilterVIUC3ID3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC3ID3_GetDirectionTolerance, None, itkImageToImageFilterVIUC3ID3)
itkImageToImageFilterVIUC3ID3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3ID3_swigregister
itkImageToImageFilterVIUC3ID3_swigregister(itkImageToImageFilterVIUC3ID3)

def itkImageToImageFilterVIUC3ID3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIUC3ID3 *":
    """itkImageToImageFilterVIUC3ID3_cast(itkLightObject obj) -> itkImageToImageFilterVIUC3ID3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3ID3_cast(obj)

class itkImageToImageFilterVIUC3IF3(itkImageSourcePython.itkImageSourceIF3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterVIUC3IF3 self, itkVectorImageUC3 image)
        SetInput(itkImageToImageFilterVIUC3IF3 self, unsigned int arg0, itkVectorImageUC3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IF3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkVectorImageUC3 const *":
        """
        GetInput(itkImageToImageFilterVIUC3IF3 self) -> itkVectorImageUC3
        GetInput(itkImageToImageFilterVIUC3IF3 self, unsigned int idx) -> itkVectorImageUC3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IF3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkVectorImageUC3') -> "void":
        """
        PushBackInput(itkImageToImageFilterVIUC3IF3 self, itkVectorImageUC3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IF3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterVIUC3IF3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IF3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkVectorImageUC3') -> "void":
        """PushFrontInput(itkImageToImageFilterVIUC3IF3 self, itkVectorImageUC3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IF3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterVIUC3IF3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IF3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterVIUC3IF3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IF3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterVIUC3IF3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IF3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterVIUC3IF3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IF3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterVIUC3IF3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IF3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterVIUC3IF3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIUC3IF3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterVIUC3IF3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IF3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterVIUC3IF3

        Create a new object of the class itkImageToImageFilterVIUC3IF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterVIUC3IF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterVIUC3IF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterVIUC3IF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterVIUC3IF3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IF3_SetInput, None, itkImageToImageFilterVIUC3IF3)
itkImageToImageFilterVIUC3IF3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IF3_GetInput, None, itkImageToImageFilterVIUC3IF3)
itkImageToImageFilterVIUC3IF3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IF3_PushBackInput, None, itkImageToImageFilterVIUC3IF3)
itkImageToImageFilterVIUC3IF3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IF3_PopBackInput, None, itkImageToImageFilterVIUC3IF3)
itkImageToImageFilterVIUC3IF3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IF3_PushFrontInput, None, itkImageToImageFilterVIUC3IF3)
itkImageToImageFilterVIUC3IF3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IF3_PopFrontInput, None, itkImageToImageFilterVIUC3IF3)
itkImageToImageFilterVIUC3IF3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IF3_SetCoordinateTolerance, None, itkImageToImageFilterVIUC3IF3)
itkImageToImageFilterVIUC3IF3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IF3_GetCoordinateTolerance, None, itkImageToImageFilterVIUC3IF3)
itkImageToImageFilterVIUC3IF3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IF3_SetDirectionTolerance, None, itkImageToImageFilterVIUC3IF3)
itkImageToImageFilterVIUC3IF3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IF3_GetDirectionTolerance, None, itkImageToImageFilterVIUC3IF3)
itkImageToImageFilterVIUC3IF3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IF3_swigregister
itkImageToImageFilterVIUC3IF3_swigregister(itkImageToImageFilterVIUC3IF3)

def itkImageToImageFilterVIUC3IF3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIUC3IF3 *":
    """itkImageToImageFilterVIUC3IF3_cast(itkLightObject obj) -> itkImageToImageFilterVIUC3IF3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IF3_cast(obj)

class itkImageToImageFilterVIUC3ISS3(itkImageSourcePython.itkImageSourceISS3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterVIUC3ISS3 self, itkVectorImageUC3 image)
        SetInput(itkImageToImageFilterVIUC3ISS3 self, unsigned int arg0, itkVectorImageUC3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3ISS3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkVectorImageUC3 const *":
        """
        GetInput(itkImageToImageFilterVIUC3ISS3 self) -> itkVectorImageUC3
        GetInput(itkImageToImageFilterVIUC3ISS3 self, unsigned int idx) -> itkVectorImageUC3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3ISS3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkVectorImageUC3') -> "void":
        """
        PushBackInput(itkImageToImageFilterVIUC3ISS3 self, itkVectorImageUC3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3ISS3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterVIUC3ISS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3ISS3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkVectorImageUC3') -> "void":
        """PushFrontInput(itkImageToImageFilterVIUC3ISS3 self, itkVectorImageUC3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3ISS3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterVIUC3ISS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3ISS3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterVIUC3ISS3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3ISS3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterVIUC3ISS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3ISS3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterVIUC3ISS3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3ISS3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterVIUC3ISS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3ISS3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterVIUC3ISS3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIUC3ISS3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterVIUC3ISS3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3ISS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterVIUC3ISS3

        Create a new object of the class itkImageToImageFilterVIUC3ISS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterVIUC3ISS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterVIUC3ISS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterVIUC3ISS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterVIUC3ISS3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC3ISS3_SetInput, None, itkImageToImageFilterVIUC3ISS3)
itkImageToImageFilterVIUC3ISS3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC3ISS3_GetInput, None, itkImageToImageFilterVIUC3ISS3)
itkImageToImageFilterVIUC3ISS3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC3ISS3_PushBackInput, None, itkImageToImageFilterVIUC3ISS3)
itkImageToImageFilterVIUC3ISS3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC3ISS3_PopBackInput, None, itkImageToImageFilterVIUC3ISS3)
itkImageToImageFilterVIUC3ISS3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC3ISS3_PushFrontInput, None, itkImageToImageFilterVIUC3ISS3)
itkImageToImageFilterVIUC3ISS3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC3ISS3_PopFrontInput, None, itkImageToImageFilterVIUC3ISS3)
itkImageToImageFilterVIUC3ISS3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC3ISS3_SetCoordinateTolerance, None, itkImageToImageFilterVIUC3ISS3)
itkImageToImageFilterVIUC3ISS3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC3ISS3_GetCoordinateTolerance, None, itkImageToImageFilterVIUC3ISS3)
itkImageToImageFilterVIUC3ISS3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC3ISS3_SetDirectionTolerance, None, itkImageToImageFilterVIUC3ISS3)
itkImageToImageFilterVIUC3ISS3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC3ISS3_GetDirectionTolerance, None, itkImageToImageFilterVIUC3ISS3)
itkImageToImageFilterVIUC3ISS3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3ISS3_swigregister
itkImageToImageFilterVIUC3ISS3_swigregister(itkImageToImageFilterVIUC3ISS3)

def itkImageToImageFilterVIUC3ISS3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIUC3ISS3 *":
    """itkImageToImageFilterVIUC3ISS3_cast(itkLightObject obj) -> itkImageToImageFilterVIUC3ISS3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3ISS3_cast(obj)

class itkImageToImageFilterVIUC3IUC3(itkImageSourcePython.itkImageSourceIUC3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterVIUC3IUC3 self, itkVectorImageUC3 image)
        SetInput(itkImageToImageFilterVIUC3IUC3 self, unsigned int arg0, itkVectorImageUC3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IUC3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkVectorImageUC3 const *":
        """
        GetInput(itkImageToImageFilterVIUC3IUC3 self) -> itkVectorImageUC3
        GetInput(itkImageToImageFilterVIUC3IUC3 self, unsigned int idx) -> itkVectorImageUC3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IUC3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkVectorImageUC3') -> "void":
        """
        PushBackInput(itkImageToImageFilterVIUC3IUC3 self, itkVectorImageUC3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IUC3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterVIUC3IUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IUC3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkVectorImageUC3') -> "void":
        """PushFrontInput(itkImageToImageFilterVIUC3IUC3 self, itkVectorImageUC3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IUC3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterVIUC3IUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IUC3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterVIUC3IUC3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IUC3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterVIUC3IUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IUC3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterVIUC3IUC3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IUC3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterVIUC3IUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IUC3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterVIUC3IUC3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIUC3IUC3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterVIUC3IUC3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IUC3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterVIUC3IUC3

        Create a new object of the class itkImageToImageFilterVIUC3IUC3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterVIUC3IUC3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterVIUC3IUC3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterVIUC3IUC3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterVIUC3IUC3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IUC3_SetInput, None, itkImageToImageFilterVIUC3IUC3)
itkImageToImageFilterVIUC3IUC3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IUC3_GetInput, None, itkImageToImageFilterVIUC3IUC3)
itkImageToImageFilterVIUC3IUC3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IUC3_PushBackInput, None, itkImageToImageFilterVIUC3IUC3)
itkImageToImageFilterVIUC3IUC3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IUC3_PopBackInput, None, itkImageToImageFilterVIUC3IUC3)
itkImageToImageFilterVIUC3IUC3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IUC3_PushFrontInput, None, itkImageToImageFilterVIUC3IUC3)
itkImageToImageFilterVIUC3IUC3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IUC3_PopFrontInput, None, itkImageToImageFilterVIUC3IUC3)
itkImageToImageFilterVIUC3IUC3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IUC3_SetCoordinateTolerance, None, itkImageToImageFilterVIUC3IUC3)
itkImageToImageFilterVIUC3IUC3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IUC3_GetCoordinateTolerance, None, itkImageToImageFilterVIUC3IUC3)
itkImageToImageFilterVIUC3IUC3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IUC3_SetDirectionTolerance, None, itkImageToImageFilterVIUC3IUC3)
itkImageToImageFilterVIUC3IUC3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IUC3_GetDirectionTolerance, None, itkImageToImageFilterVIUC3IUC3)
itkImageToImageFilterVIUC3IUC3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IUC3_swigregister
itkImageToImageFilterVIUC3IUC3_swigregister(itkImageToImageFilterVIUC3IUC3)

def itkImageToImageFilterVIUC3IUC3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIUC3IUC3 *":
    """itkImageToImageFilterVIUC3IUC3_cast(itkLightObject obj) -> itkImageToImageFilterVIUC3IUC3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IUC3_cast(obj)

class itkImageToImageFilterVIUC3IUS3(itkImageSourcePython.itkImageSourceIUS3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterVIUC3IUS3 self, itkVectorImageUC3 image)
        SetInput(itkImageToImageFilterVIUC3IUS3 self, unsigned int arg0, itkVectorImageUC3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IUS3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkVectorImageUC3 const *":
        """
        GetInput(itkImageToImageFilterVIUC3IUS3 self) -> itkVectorImageUC3
        GetInput(itkImageToImageFilterVIUC3IUS3 self, unsigned int idx) -> itkVectorImageUC3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IUS3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkVectorImageUC3') -> "void":
        """
        PushBackInput(itkImageToImageFilterVIUC3IUS3 self, itkVectorImageUC3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IUS3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterVIUC3IUS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IUS3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkVectorImageUC3') -> "void":
        """PushFrontInput(itkImageToImageFilterVIUC3IUS3 self, itkVectorImageUC3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IUS3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterVIUC3IUS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IUS3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterVIUC3IUS3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IUS3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterVIUC3IUS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IUS3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterVIUC3IUS3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IUS3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterVIUC3IUS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IUS3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterVIUC3IUS3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIUC3IUS3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterVIUC3IUS3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IUS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterVIUC3IUS3

        Create a new object of the class itkImageToImageFilterVIUC3IUS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterVIUC3IUS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterVIUC3IUS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterVIUC3IUS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterVIUC3IUS3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IUS3_SetInput, None, itkImageToImageFilterVIUC3IUS3)
itkImageToImageFilterVIUC3IUS3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IUS3_GetInput, None, itkImageToImageFilterVIUC3IUS3)
itkImageToImageFilterVIUC3IUS3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IUS3_PushBackInput, None, itkImageToImageFilterVIUC3IUS3)
itkImageToImageFilterVIUC3IUS3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IUS3_PopBackInput, None, itkImageToImageFilterVIUC3IUS3)
itkImageToImageFilterVIUC3IUS3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IUS3_PushFrontInput, None, itkImageToImageFilterVIUC3IUS3)
itkImageToImageFilterVIUC3IUS3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IUS3_PopFrontInput, None, itkImageToImageFilterVIUC3IUS3)
itkImageToImageFilterVIUC3IUS3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IUS3_SetCoordinateTolerance, None, itkImageToImageFilterVIUC3IUS3)
itkImageToImageFilterVIUC3IUS3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IUS3_GetCoordinateTolerance, None, itkImageToImageFilterVIUC3IUS3)
itkImageToImageFilterVIUC3IUS3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IUS3_SetDirectionTolerance, None, itkImageToImageFilterVIUC3IUS3)
itkImageToImageFilterVIUC3IUS3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IUS3_GetDirectionTolerance, None, itkImageToImageFilterVIUC3IUS3)
itkImageToImageFilterVIUC3IUS3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IUS3_swigregister
itkImageToImageFilterVIUC3IUS3_swigregister(itkImageToImageFilterVIUC3IUS3)

def itkImageToImageFilterVIUC3IUS3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIUC3IUS3 *":
    """itkImageToImageFilterVIUC3IUS3_cast(itkLightObject obj) -> itkImageToImageFilterVIUC3IUS3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterVIUC3IUS3_cast(obj)

class itkImageToImageFilterVIUS2ID2(itkImageSourcePython.itkImageSourceID2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterVIUS2ID2 self, itkVectorImageUS2 image)
        SetInput(itkImageToImageFilterVIUS2ID2 self, unsigned int arg0, itkVectorImageUS2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2ID2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkVectorImageUS2 const *":
        """
        GetInput(itkImageToImageFilterVIUS2ID2 self) -> itkVectorImageUS2
        GetInput(itkImageToImageFilterVIUS2ID2 self, unsigned int idx) -> itkVectorImageUS2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2ID2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkVectorImageUS2') -> "void":
        """
        PushBackInput(itkImageToImageFilterVIUS2ID2 self, itkVectorImageUS2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2ID2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterVIUS2ID2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2ID2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkVectorImageUS2') -> "void":
        """PushFrontInput(itkImageToImageFilterVIUS2ID2 self, itkVectorImageUS2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2ID2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterVIUS2ID2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2ID2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterVIUS2ID2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2ID2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterVIUS2ID2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2ID2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterVIUS2ID2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2ID2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterVIUS2ID2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2ID2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterVIUS2ID2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIUS2ID2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterVIUS2ID2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2ID2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterVIUS2ID2

        Create a new object of the class itkImageToImageFilterVIUS2ID2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterVIUS2ID2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterVIUS2ID2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterVIUS2ID2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterVIUS2ID2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS2ID2_SetInput, None, itkImageToImageFilterVIUS2ID2)
itkImageToImageFilterVIUS2ID2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS2ID2_GetInput, None, itkImageToImageFilterVIUS2ID2)
itkImageToImageFilterVIUS2ID2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS2ID2_PushBackInput, None, itkImageToImageFilterVIUS2ID2)
itkImageToImageFilterVIUS2ID2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS2ID2_PopBackInput, None, itkImageToImageFilterVIUS2ID2)
itkImageToImageFilterVIUS2ID2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS2ID2_PushFrontInput, None, itkImageToImageFilterVIUS2ID2)
itkImageToImageFilterVIUS2ID2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS2ID2_PopFrontInput, None, itkImageToImageFilterVIUS2ID2)
itkImageToImageFilterVIUS2ID2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS2ID2_SetCoordinateTolerance, None, itkImageToImageFilterVIUS2ID2)
itkImageToImageFilterVIUS2ID2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS2ID2_GetCoordinateTolerance, None, itkImageToImageFilterVIUS2ID2)
itkImageToImageFilterVIUS2ID2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS2ID2_SetDirectionTolerance, None, itkImageToImageFilterVIUS2ID2)
itkImageToImageFilterVIUS2ID2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS2ID2_GetDirectionTolerance, None, itkImageToImageFilterVIUS2ID2)
itkImageToImageFilterVIUS2ID2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2ID2_swigregister
itkImageToImageFilterVIUS2ID2_swigregister(itkImageToImageFilterVIUS2ID2)

def itkImageToImageFilterVIUS2ID2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIUS2ID2 *":
    """itkImageToImageFilterVIUS2ID2_cast(itkLightObject obj) -> itkImageToImageFilterVIUS2ID2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2ID2_cast(obj)

class itkImageToImageFilterVIUS2IF2(itkImageSourcePython.itkImageSourceIF2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterVIUS2IF2 self, itkVectorImageUS2 image)
        SetInput(itkImageToImageFilterVIUS2IF2 self, unsigned int arg0, itkVectorImageUS2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IF2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkVectorImageUS2 const *":
        """
        GetInput(itkImageToImageFilterVIUS2IF2 self) -> itkVectorImageUS2
        GetInput(itkImageToImageFilterVIUS2IF2 self, unsigned int idx) -> itkVectorImageUS2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IF2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkVectorImageUS2') -> "void":
        """
        PushBackInput(itkImageToImageFilterVIUS2IF2 self, itkVectorImageUS2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IF2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterVIUS2IF2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IF2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkVectorImageUS2') -> "void":
        """PushFrontInput(itkImageToImageFilterVIUS2IF2 self, itkVectorImageUS2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IF2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterVIUS2IF2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IF2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterVIUS2IF2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IF2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterVIUS2IF2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IF2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterVIUS2IF2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IF2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterVIUS2IF2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IF2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterVIUS2IF2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIUS2IF2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterVIUS2IF2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IF2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterVIUS2IF2

        Create a new object of the class itkImageToImageFilterVIUS2IF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterVIUS2IF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterVIUS2IF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterVIUS2IF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterVIUS2IF2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IF2_SetInput, None, itkImageToImageFilterVIUS2IF2)
itkImageToImageFilterVIUS2IF2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IF2_GetInput, None, itkImageToImageFilterVIUS2IF2)
itkImageToImageFilterVIUS2IF2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IF2_PushBackInput, None, itkImageToImageFilterVIUS2IF2)
itkImageToImageFilterVIUS2IF2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IF2_PopBackInput, None, itkImageToImageFilterVIUS2IF2)
itkImageToImageFilterVIUS2IF2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IF2_PushFrontInput, None, itkImageToImageFilterVIUS2IF2)
itkImageToImageFilterVIUS2IF2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IF2_PopFrontInput, None, itkImageToImageFilterVIUS2IF2)
itkImageToImageFilterVIUS2IF2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IF2_SetCoordinateTolerance, None, itkImageToImageFilterVIUS2IF2)
itkImageToImageFilterVIUS2IF2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IF2_GetCoordinateTolerance, None, itkImageToImageFilterVIUS2IF2)
itkImageToImageFilterVIUS2IF2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IF2_SetDirectionTolerance, None, itkImageToImageFilterVIUS2IF2)
itkImageToImageFilterVIUS2IF2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IF2_GetDirectionTolerance, None, itkImageToImageFilterVIUS2IF2)
itkImageToImageFilterVIUS2IF2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IF2_swigregister
itkImageToImageFilterVIUS2IF2_swigregister(itkImageToImageFilterVIUS2IF2)

def itkImageToImageFilterVIUS2IF2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIUS2IF2 *":
    """itkImageToImageFilterVIUS2IF2_cast(itkLightObject obj) -> itkImageToImageFilterVIUS2IF2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IF2_cast(obj)

class itkImageToImageFilterVIUS2ISS2(itkImageSourcePython.itkImageSourceISS2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterVIUS2ISS2 self, itkVectorImageUS2 image)
        SetInput(itkImageToImageFilterVIUS2ISS2 self, unsigned int arg0, itkVectorImageUS2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2ISS2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkVectorImageUS2 const *":
        """
        GetInput(itkImageToImageFilterVIUS2ISS2 self) -> itkVectorImageUS2
        GetInput(itkImageToImageFilterVIUS2ISS2 self, unsigned int idx) -> itkVectorImageUS2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2ISS2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkVectorImageUS2') -> "void":
        """
        PushBackInput(itkImageToImageFilterVIUS2ISS2 self, itkVectorImageUS2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2ISS2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterVIUS2ISS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2ISS2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkVectorImageUS2') -> "void":
        """PushFrontInput(itkImageToImageFilterVIUS2ISS2 self, itkVectorImageUS2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2ISS2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterVIUS2ISS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2ISS2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterVIUS2ISS2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2ISS2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterVIUS2ISS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2ISS2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterVIUS2ISS2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2ISS2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterVIUS2ISS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2ISS2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterVIUS2ISS2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIUS2ISS2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterVIUS2ISS2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2ISS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterVIUS2ISS2

        Create a new object of the class itkImageToImageFilterVIUS2ISS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterVIUS2ISS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterVIUS2ISS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterVIUS2ISS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterVIUS2ISS2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS2ISS2_SetInput, None, itkImageToImageFilterVIUS2ISS2)
itkImageToImageFilterVIUS2ISS2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS2ISS2_GetInput, None, itkImageToImageFilterVIUS2ISS2)
itkImageToImageFilterVIUS2ISS2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS2ISS2_PushBackInput, None, itkImageToImageFilterVIUS2ISS2)
itkImageToImageFilterVIUS2ISS2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS2ISS2_PopBackInput, None, itkImageToImageFilterVIUS2ISS2)
itkImageToImageFilterVIUS2ISS2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS2ISS2_PushFrontInput, None, itkImageToImageFilterVIUS2ISS2)
itkImageToImageFilterVIUS2ISS2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS2ISS2_PopFrontInput, None, itkImageToImageFilterVIUS2ISS2)
itkImageToImageFilterVIUS2ISS2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS2ISS2_SetCoordinateTolerance, None, itkImageToImageFilterVIUS2ISS2)
itkImageToImageFilterVIUS2ISS2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS2ISS2_GetCoordinateTolerance, None, itkImageToImageFilterVIUS2ISS2)
itkImageToImageFilterVIUS2ISS2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS2ISS2_SetDirectionTolerance, None, itkImageToImageFilterVIUS2ISS2)
itkImageToImageFilterVIUS2ISS2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS2ISS2_GetDirectionTolerance, None, itkImageToImageFilterVIUS2ISS2)
itkImageToImageFilterVIUS2ISS2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2ISS2_swigregister
itkImageToImageFilterVIUS2ISS2_swigregister(itkImageToImageFilterVIUS2ISS2)

def itkImageToImageFilterVIUS2ISS2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIUS2ISS2 *":
    """itkImageToImageFilterVIUS2ISS2_cast(itkLightObject obj) -> itkImageToImageFilterVIUS2ISS2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2ISS2_cast(obj)

class itkImageToImageFilterVIUS2IUC2(itkImageSourcePython.itkImageSourceIUC2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterVIUS2IUC2 self, itkVectorImageUS2 image)
        SetInput(itkImageToImageFilterVIUS2IUC2 self, unsigned int arg0, itkVectorImageUS2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IUC2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkVectorImageUS2 const *":
        """
        GetInput(itkImageToImageFilterVIUS2IUC2 self) -> itkVectorImageUS2
        GetInput(itkImageToImageFilterVIUS2IUC2 self, unsigned int idx) -> itkVectorImageUS2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IUC2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkVectorImageUS2') -> "void":
        """
        PushBackInput(itkImageToImageFilterVIUS2IUC2 self, itkVectorImageUS2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IUC2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterVIUS2IUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IUC2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkVectorImageUS2') -> "void":
        """PushFrontInput(itkImageToImageFilterVIUS2IUC2 self, itkVectorImageUS2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IUC2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterVIUS2IUC2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IUC2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterVIUS2IUC2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IUC2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterVIUS2IUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IUC2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterVIUS2IUC2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IUC2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterVIUS2IUC2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IUC2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterVIUS2IUC2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIUS2IUC2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterVIUS2IUC2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IUC2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterVIUS2IUC2

        Create a new object of the class itkImageToImageFilterVIUS2IUC2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterVIUS2IUC2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterVIUS2IUC2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterVIUS2IUC2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterVIUS2IUC2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IUC2_SetInput, None, itkImageToImageFilterVIUS2IUC2)
itkImageToImageFilterVIUS2IUC2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IUC2_GetInput, None, itkImageToImageFilterVIUS2IUC2)
itkImageToImageFilterVIUS2IUC2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IUC2_PushBackInput, None, itkImageToImageFilterVIUS2IUC2)
itkImageToImageFilterVIUS2IUC2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IUC2_PopBackInput, None, itkImageToImageFilterVIUS2IUC2)
itkImageToImageFilterVIUS2IUC2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IUC2_PushFrontInput, None, itkImageToImageFilterVIUS2IUC2)
itkImageToImageFilterVIUS2IUC2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IUC2_PopFrontInput, None, itkImageToImageFilterVIUS2IUC2)
itkImageToImageFilterVIUS2IUC2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IUC2_SetCoordinateTolerance, None, itkImageToImageFilterVIUS2IUC2)
itkImageToImageFilterVIUS2IUC2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IUC2_GetCoordinateTolerance, None, itkImageToImageFilterVIUS2IUC2)
itkImageToImageFilterVIUS2IUC2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IUC2_SetDirectionTolerance, None, itkImageToImageFilterVIUS2IUC2)
itkImageToImageFilterVIUS2IUC2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IUC2_GetDirectionTolerance, None, itkImageToImageFilterVIUS2IUC2)
itkImageToImageFilterVIUS2IUC2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IUC2_swigregister
itkImageToImageFilterVIUS2IUC2_swigregister(itkImageToImageFilterVIUS2IUC2)

def itkImageToImageFilterVIUS2IUC2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIUS2IUC2 *":
    """itkImageToImageFilterVIUS2IUC2_cast(itkLightObject obj) -> itkImageToImageFilterVIUS2IUC2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IUC2_cast(obj)

class itkImageToImageFilterVIUS2IUS2(itkImageSourcePython.itkImageSourceIUS2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterVIUS2IUS2 self, itkVectorImageUS2 image)
        SetInput(itkImageToImageFilterVIUS2IUS2 self, unsigned int arg0, itkVectorImageUS2 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IUS2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkVectorImageUS2 const *":
        """
        GetInput(itkImageToImageFilterVIUS2IUS2 self) -> itkVectorImageUS2
        GetInput(itkImageToImageFilterVIUS2IUS2 self, unsigned int idx) -> itkVectorImageUS2
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IUS2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkVectorImageUS2') -> "void":
        """
        PushBackInput(itkImageToImageFilterVIUS2IUS2 self, itkVectorImageUS2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IUS2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterVIUS2IUS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IUS2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkVectorImageUS2') -> "void":
        """PushFrontInput(itkImageToImageFilterVIUS2IUS2 self, itkVectorImageUS2 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IUS2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterVIUS2IUS2 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IUS2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterVIUS2IUS2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IUS2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterVIUS2IUS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IUS2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterVIUS2IUS2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IUS2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterVIUS2IUS2 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IUS2_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterVIUS2IUS2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIUS2IUS2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterVIUS2IUS2"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IUS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterVIUS2IUS2

        Create a new object of the class itkImageToImageFilterVIUS2IUS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterVIUS2IUS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterVIUS2IUS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterVIUS2IUS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterVIUS2IUS2.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IUS2_SetInput, None, itkImageToImageFilterVIUS2IUS2)
itkImageToImageFilterVIUS2IUS2.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IUS2_GetInput, None, itkImageToImageFilterVIUS2IUS2)
itkImageToImageFilterVIUS2IUS2.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IUS2_PushBackInput, None, itkImageToImageFilterVIUS2IUS2)
itkImageToImageFilterVIUS2IUS2.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IUS2_PopBackInput, None, itkImageToImageFilterVIUS2IUS2)
itkImageToImageFilterVIUS2IUS2.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IUS2_PushFrontInput, None, itkImageToImageFilterVIUS2IUS2)
itkImageToImageFilterVIUS2IUS2.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IUS2_PopFrontInput, None, itkImageToImageFilterVIUS2IUS2)
itkImageToImageFilterVIUS2IUS2.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IUS2_SetCoordinateTolerance, None, itkImageToImageFilterVIUS2IUS2)
itkImageToImageFilterVIUS2IUS2.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IUS2_GetCoordinateTolerance, None, itkImageToImageFilterVIUS2IUS2)
itkImageToImageFilterVIUS2IUS2.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IUS2_SetDirectionTolerance, None, itkImageToImageFilterVIUS2IUS2)
itkImageToImageFilterVIUS2IUS2.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IUS2_GetDirectionTolerance, None, itkImageToImageFilterVIUS2IUS2)
itkImageToImageFilterVIUS2IUS2_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IUS2_swigregister
itkImageToImageFilterVIUS2IUS2_swigregister(itkImageToImageFilterVIUS2IUS2)

def itkImageToImageFilterVIUS2IUS2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIUS2IUS2 *":
    """itkImageToImageFilterVIUS2IUS2_cast(itkLightObject obj) -> itkImageToImageFilterVIUS2IUS2"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS2IUS2_cast(obj)

class itkImageToImageFilterVIUS3ID3(itkImageSourcePython.itkImageSourceID3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterVIUS3ID3 self, itkVectorImageUS3 image)
        SetInput(itkImageToImageFilterVIUS3ID3 self, unsigned int arg0, itkVectorImageUS3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3ID3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkVectorImageUS3 const *":
        """
        GetInput(itkImageToImageFilterVIUS3ID3 self) -> itkVectorImageUS3
        GetInput(itkImageToImageFilterVIUS3ID3 self, unsigned int idx) -> itkVectorImageUS3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3ID3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkVectorImageUS3') -> "void":
        """
        PushBackInput(itkImageToImageFilterVIUS3ID3 self, itkVectorImageUS3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3ID3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterVIUS3ID3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3ID3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkVectorImageUS3') -> "void":
        """PushFrontInput(itkImageToImageFilterVIUS3ID3 self, itkVectorImageUS3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3ID3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterVIUS3ID3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3ID3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterVIUS3ID3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3ID3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterVIUS3ID3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3ID3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterVIUS3ID3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3ID3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterVIUS3ID3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3ID3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterVIUS3ID3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIUS3ID3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterVIUS3ID3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3ID3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterVIUS3ID3

        Create a new object of the class itkImageToImageFilterVIUS3ID3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterVIUS3ID3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterVIUS3ID3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterVIUS3ID3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterVIUS3ID3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS3ID3_SetInput, None, itkImageToImageFilterVIUS3ID3)
itkImageToImageFilterVIUS3ID3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS3ID3_GetInput, None, itkImageToImageFilterVIUS3ID3)
itkImageToImageFilterVIUS3ID3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS3ID3_PushBackInput, None, itkImageToImageFilterVIUS3ID3)
itkImageToImageFilterVIUS3ID3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS3ID3_PopBackInput, None, itkImageToImageFilterVIUS3ID3)
itkImageToImageFilterVIUS3ID3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS3ID3_PushFrontInput, None, itkImageToImageFilterVIUS3ID3)
itkImageToImageFilterVIUS3ID3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS3ID3_PopFrontInput, None, itkImageToImageFilterVIUS3ID3)
itkImageToImageFilterVIUS3ID3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS3ID3_SetCoordinateTolerance, None, itkImageToImageFilterVIUS3ID3)
itkImageToImageFilterVIUS3ID3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS3ID3_GetCoordinateTolerance, None, itkImageToImageFilterVIUS3ID3)
itkImageToImageFilterVIUS3ID3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS3ID3_SetDirectionTolerance, None, itkImageToImageFilterVIUS3ID3)
itkImageToImageFilterVIUS3ID3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS3ID3_GetDirectionTolerance, None, itkImageToImageFilterVIUS3ID3)
itkImageToImageFilterVIUS3ID3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3ID3_swigregister
itkImageToImageFilterVIUS3ID3_swigregister(itkImageToImageFilterVIUS3ID3)

def itkImageToImageFilterVIUS3ID3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIUS3ID3 *":
    """itkImageToImageFilterVIUS3ID3_cast(itkLightObject obj) -> itkImageToImageFilterVIUS3ID3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3ID3_cast(obj)

class itkImageToImageFilterVIUS3IF3(itkImageSourcePython.itkImageSourceIF3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterVIUS3IF3 self, itkVectorImageUS3 image)
        SetInput(itkImageToImageFilterVIUS3IF3 self, unsigned int arg0, itkVectorImageUS3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IF3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkVectorImageUS3 const *":
        """
        GetInput(itkImageToImageFilterVIUS3IF3 self) -> itkVectorImageUS3
        GetInput(itkImageToImageFilterVIUS3IF3 self, unsigned int idx) -> itkVectorImageUS3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IF3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkVectorImageUS3') -> "void":
        """
        PushBackInput(itkImageToImageFilterVIUS3IF3 self, itkVectorImageUS3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IF3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterVIUS3IF3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IF3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkVectorImageUS3') -> "void":
        """PushFrontInput(itkImageToImageFilterVIUS3IF3 self, itkVectorImageUS3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IF3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterVIUS3IF3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IF3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterVIUS3IF3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IF3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterVIUS3IF3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IF3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterVIUS3IF3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IF3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterVIUS3IF3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IF3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterVIUS3IF3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIUS3IF3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterVIUS3IF3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IF3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterVIUS3IF3

        Create a new object of the class itkImageToImageFilterVIUS3IF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterVIUS3IF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterVIUS3IF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterVIUS3IF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterVIUS3IF3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IF3_SetInput, None, itkImageToImageFilterVIUS3IF3)
itkImageToImageFilterVIUS3IF3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IF3_GetInput, None, itkImageToImageFilterVIUS3IF3)
itkImageToImageFilterVIUS3IF3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IF3_PushBackInput, None, itkImageToImageFilterVIUS3IF3)
itkImageToImageFilterVIUS3IF3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IF3_PopBackInput, None, itkImageToImageFilterVIUS3IF3)
itkImageToImageFilterVIUS3IF3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IF3_PushFrontInput, None, itkImageToImageFilterVIUS3IF3)
itkImageToImageFilterVIUS3IF3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IF3_PopFrontInput, None, itkImageToImageFilterVIUS3IF3)
itkImageToImageFilterVIUS3IF3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IF3_SetCoordinateTolerance, None, itkImageToImageFilterVIUS3IF3)
itkImageToImageFilterVIUS3IF3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IF3_GetCoordinateTolerance, None, itkImageToImageFilterVIUS3IF3)
itkImageToImageFilterVIUS3IF3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IF3_SetDirectionTolerance, None, itkImageToImageFilterVIUS3IF3)
itkImageToImageFilterVIUS3IF3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IF3_GetDirectionTolerance, None, itkImageToImageFilterVIUS3IF3)
itkImageToImageFilterVIUS3IF3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IF3_swigregister
itkImageToImageFilterVIUS3IF3_swigregister(itkImageToImageFilterVIUS3IF3)

def itkImageToImageFilterVIUS3IF3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIUS3IF3 *":
    """itkImageToImageFilterVIUS3IF3_cast(itkLightObject obj) -> itkImageToImageFilterVIUS3IF3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IF3_cast(obj)

class itkImageToImageFilterVIUS3ISS3(itkImageSourcePython.itkImageSourceISS3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterVIUS3ISS3 self, itkVectorImageUS3 image)
        SetInput(itkImageToImageFilterVIUS3ISS3 self, unsigned int arg0, itkVectorImageUS3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3ISS3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkVectorImageUS3 const *":
        """
        GetInput(itkImageToImageFilterVIUS3ISS3 self) -> itkVectorImageUS3
        GetInput(itkImageToImageFilterVIUS3ISS3 self, unsigned int idx) -> itkVectorImageUS3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3ISS3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkVectorImageUS3') -> "void":
        """
        PushBackInput(itkImageToImageFilterVIUS3ISS3 self, itkVectorImageUS3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3ISS3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterVIUS3ISS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3ISS3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkVectorImageUS3') -> "void":
        """PushFrontInput(itkImageToImageFilterVIUS3ISS3 self, itkVectorImageUS3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3ISS3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterVIUS3ISS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3ISS3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterVIUS3ISS3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3ISS3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterVIUS3ISS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3ISS3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterVIUS3ISS3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3ISS3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterVIUS3ISS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3ISS3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterVIUS3ISS3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIUS3ISS3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterVIUS3ISS3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3ISS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterVIUS3ISS3

        Create a new object of the class itkImageToImageFilterVIUS3ISS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterVIUS3ISS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterVIUS3ISS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterVIUS3ISS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterVIUS3ISS3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS3ISS3_SetInput, None, itkImageToImageFilterVIUS3ISS3)
itkImageToImageFilterVIUS3ISS3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS3ISS3_GetInput, None, itkImageToImageFilterVIUS3ISS3)
itkImageToImageFilterVIUS3ISS3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS3ISS3_PushBackInput, None, itkImageToImageFilterVIUS3ISS3)
itkImageToImageFilterVIUS3ISS3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS3ISS3_PopBackInput, None, itkImageToImageFilterVIUS3ISS3)
itkImageToImageFilterVIUS3ISS3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS3ISS3_PushFrontInput, None, itkImageToImageFilterVIUS3ISS3)
itkImageToImageFilterVIUS3ISS3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS3ISS3_PopFrontInput, None, itkImageToImageFilterVIUS3ISS3)
itkImageToImageFilterVIUS3ISS3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS3ISS3_SetCoordinateTolerance, None, itkImageToImageFilterVIUS3ISS3)
itkImageToImageFilterVIUS3ISS3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS3ISS3_GetCoordinateTolerance, None, itkImageToImageFilterVIUS3ISS3)
itkImageToImageFilterVIUS3ISS3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS3ISS3_SetDirectionTolerance, None, itkImageToImageFilterVIUS3ISS3)
itkImageToImageFilterVIUS3ISS3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS3ISS3_GetDirectionTolerance, None, itkImageToImageFilterVIUS3ISS3)
itkImageToImageFilterVIUS3ISS3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3ISS3_swigregister
itkImageToImageFilterVIUS3ISS3_swigregister(itkImageToImageFilterVIUS3ISS3)

def itkImageToImageFilterVIUS3ISS3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIUS3ISS3 *":
    """itkImageToImageFilterVIUS3ISS3_cast(itkLightObject obj) -> itkImageToImageFilterVIUS3ISS3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3ISS3_cast(obj)

class itkImageToImageFilterVIUS3IUC3(itkImageSourcePython.itkImageSourceIUC3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterVIUS3IUC3 self, itkVectorImageUS3 image)
        SetInput(itkImageToImageFilterVIUS3IUC3 self, unsigned int arg0, itkVectorImageUS3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IUC3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkVectorImageUS3 const *":
        """
        GetInput(itkImageToImageFilterVIUS3IUC3 self) -> itkVectorImageUS3
        GetInput(itkImageToImageFilterVIUS3IUC3 self, unsigned int idx) -> itkVectorImageUS3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IUC3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkVectorImageUS3') -> "void":
        """
        PushBackInput(itkImageToImageFilterVIUS3IUC3 self, itkVectorImageUS3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IUC3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterVIUS3IUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IUC3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkVectorImageUS3') -> "void":
        """PushFrontInput(itkImageToImageFilterVIUS3IUC3 self, itkVectorImageUS3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IUC3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterVIUS3IUC3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IUC3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterVIUS3IUC3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IUC3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterVIUS3IUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IUC3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterVIUS3IUC3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IUC3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterVIUS3IUC3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IUC3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterVIUS3IUC3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIUS3IUC3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterVIUS3IUC3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IUC3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterVIUS3IUC3

        Create a new object of the class itkImageToImageFilterVIUS3IUC3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterVIUS3IUC3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterVIUS3IUC3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterVIUS3IUC3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterVIUS3IUC3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IUC3_SetInput, None, itkImageToImageFilterVIUS3IUC3)
itkImageToImageFilterVIUS3IUC3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IUC3_GetInput, None, itkImageToImageFilterVIUS3IUC3)
itkImageToImageFilterVIUS3IUC3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IUC3_PushBackInput, None, itkImageToImageFilterVIUS3IUC3)
itkImageToImageFilterVIUS3IUC3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IUC3_PopBackInput, None, itkImageToImageFilterVIUS3IUC3)
itkImageToImageFilterVIUS3IUC3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IUC3_PushFrontInput, None, itkImageToImageFilterVIUS3IUC3)
itkImageToImageFilterVIUS3IUC3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IUC3_PopFrontInput, None, itkImageToImageFilterVIUS3IUC3)
itkImageToImageFilterVIUS3IUC3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IUC3_SetCoordinateTolerance, None, itkImageToImageFilterVIUS3IUC3)
itkImageToImageFilterVIUS3IUC3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IUC3_GetCoordinateTolerance, None, itkImageToImageFilterVIUS3IUC3)
itkImageToImageFilterVIUS3IUC3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IUC3_SetDirectionTolerance, None, itkImageToImageFilterVIUS3IUC3)
itkImageToImageFilterVIUS3IUC3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IUC3_GetDirectionTolerance, None, itkImageToImageFilterVIUS3IUC3)
itkImageToImageFilterVIUS3IUC3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IUC3_swigregister
itkImageToImageFilterVIUS3IUC3_swigregister(itkImageToImageFilterVIUS3IUC3)

def itkImageToImageFilterVIUS3IUC3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIUS3IUC3 *":
    """itkImageToImageFilterVIUS3IUC3_cast(itkLightObject obj) -> itkImageToImageFilterVIUS3IUC3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IUC3_cast(obj)

class itkImageToImageFilterVIUS3IUS3(itkImageSourcePython.itkImageSourceIUS3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterVIUS3IUS3 self, itkVectorImageUS3 image)
        SetInput(itkImageToImageFilterVIUS3IUS3 self, unsigned int arg0, itkVectorImageUS3 image)
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IUS3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkVectorImageUS3 const *":
        """
        GetInput(itkImageToImageFilterVIUS3IUS3 self) -> itkVectorImageUS3
        GetInput(itkImageToImageFilterVIUS3IUS3 self, unsigned int idx) -> itkVectorImageUS3
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IUS3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkVectorImageUS3') -> "void":
        """
        PushBackInput(itkImageToImageFilterVIUS3IUS3 self, itkVectorImageUS3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IUS3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterVIUS3IUS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IUS3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkVectorImageUS3') -> "void":
        """PushFrontInput(itkImageToImageFilterVIUS3IUS3 self, itkVectorImageUS3 image)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IUS3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterVIUS3IUS3 self)"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IUS3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterVIUS3IUS3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IUS3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterVIUS3IUS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IUS3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterVIUS3IUS3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IUS3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterVIUS3IUS3 self) -> double"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IUS3_GetDirectionTolerance(self)

    __swig_destroy__ = _itkImageToImageFilterBPython.delete_itkImageToImageFilterVIUS3IUS3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIUS3IUS3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterVIUS3IUS3"""
        return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IUS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterVIUS3IUS3

        Create a new object of the class itkImageToImageFilterVIUS3IUS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterVIUS3IUS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterVIUS3IUS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterVIUS3IUS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterVIUS3IUS3.SetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IUS3_SetInput, None, itkImageToImageFilterVIUS3IUS3)
itkImageToImageFilterVIUS3IUS3.GetInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IUS3_GetInput, None, itkImageToImageFilterVIUS3IUS3)
itkImageToImageFilterVIUS3IUS3.PushBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IUS3_PushBackInput, None, itkImageToImageFilterVIUS3IUS3)
itkImageToImageFilterVIUS3IUS3.PopBackInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IUS3_PopBackInput, None, itkImageToImageFilterVIUS3IUS3)
itkImageToImageFilterVIUS3IUS3.PushFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IUS3_PushFrontInput, None, itkImageToImageFilterVIUS3IUS3)
itkImageToImageFilterVIUS3IUS3.PopFrontInput = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IUS3_PopFrontInput, None, itkImageToImageFilterVIUS3IUS3)
itkImageToImageFilterVIUS3IUS3.SetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IUS3_SetCoordinateTolerance, None, itkImageToImageFilterVIUS3IUS3)
itkImageToImageFilterVIUS3IUS3.GetCoordinateTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IUS3_GetCoordinateTolerance, None, itkImageToImageFilterVIUS3IUS3)
itkImageToImageFilterVIUS3IUS3.SetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IUS3_SetDirectionTolerance, None, itkImageToImageFilterVIUS3IUS3)
itkImageToImageFilterVIUS3IUS3.GetDirectionTolerance = new_instancemethod(_itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IUS3_GetDirectionTolerance, None, itkImageToImageFilterVIUS3IUS3)
itkImageToImageFilterVIUS3IUS3_swigregister = _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IUS3_swigregister
itkImageToImageFilterVIUS3IUS3_swigregister(itkImageToImageFilterVIUS3IUS3)

def itkImageToImageFilterVIUS3IUS3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterVIUS3IUS3 *":
    """itkImageToImageFilterVIUS3IUS3_cast(itkLightObject obj) -> itkImageToImageFilterVIUS3IUS3"""
    return _itkImageToImageFilterBPython.itkImageToImageFilterVIUS3IUS3_cast(obj)


import itkHelpers
@itkHelpers.accept_numpy_array_like_xarray
def image_to_image_filter(*args, **kwargs):
    """Procedural interface for ImageToImageFilter"""
    import itk
    instance = itk.ImageToImageFilter.New(*args, **kwargs)
    return instance.__internal_call__()

def image_to_image_filter_init_docstring():
    import itk
    import itkTemplate
    import itkHelpers
    if isinstance(itk.ImageToImageFilter, itkTemplate.itkTemplate):
        filter_object = itk.ImageToImageFilter.values()[0]
    else:
        filter_object = itk.ImageToImageFilter

    image_to_image_filter.__doc__ = filter_object.__doc__
    image_to_image_filter.__doc__ += "\n Args are Input(s) to the filter.\n"
    image_to_image_filter.__doc__ += "Available Keyword Arguments:\n"
    image_to_image_filter.__doc__ += "".join([
        "  " + itkHelpers.camel_to_snake_case(item[3:]) + "\n"
        for item in dir(filter_object)
        if item[:3] == "Set"])



