import os,random
import numpy as np
import pandas as pd
from .fun import ispump

class pump:

    def demo():
        '''demo is used to demonstrate typical examples about this class.'''
        
        demostr = '''
import clubear as cb
#clubear.csv is generated by cb.manager.demo()
pm=cb.pump('clubear.csv') #start a new pump
pm.keep #check the head lists
ck=cb.check(pm) #create a checker
ck.stats() #check the for stats
pm.qlist=['age','height','weight','logsales']
ck.stats() #check stats again
ck.table() #check table
pm.subsize=10000 #check the subsize
pm.seq=True #sequential sampling method
df=pm.go() #start to pump data
'''
        print(demostr)
    
    def __init__(self,pathfile):
        '''Initialization: check whether pathfile is correct.'''
        
        '''Very careful initial checking.'''
        if not isinstance(pathfile,str): print('pump: The pathfile must be a str.'); return
        if not os.path.exists(pathfile): print('pump: This file dose not exists!'); return
        if not os.path.isfile(pathfile): print('pump: This is not a file!'); return
        self.reader=open(pathfile,encoding='iso8859-1')    
        self.keep=self.reader.readline().replace('\n','').split(',')
        self.keep=[each.strip() for each in self.keep]
        if len(self.keep)==0: print('pump: Nothing found in the file!'); return 
        head_min_str_len=min([len(each) for each in self.keep])
        if head_min_str_len==0: print('pump: Empty head found in heads.'); return
        if len(self.keep)!=len(set(self.keep)): print('pump: Identical heads exist.'); return
        
        self.subsize=100
        self.drop=[];
        self.qlist=self.keep
        self.seq=False
        self.intercept=True
        
    def go(self):
        '''go is used to pump out data'''
        
        subsize=self.subsize
        '''Careful check all the inputs and pre-conditions'''                
        if not isinstance(subsize,int): print('pump.go: The subsize must be a int.'); return
        if not isinstance(self.keep,list): print('pump.go: The keep list must be a list.'); return
        if not isinstance(self.drop,list): print('pump.go: The drop list must be a list.'); return
        if not isinstance(self.qlist,list): print('pump.go: The qlist must be list.'); return
        if not isinstance(self.seq,bool): print('pump.go: The seq choice must be a bool.'); return
        if not isinstance(self.intercept,bool): print('pump.go: The intercept choice must be a bool.'); return
        
        self.drop=[each.strip() for each in self.drop]
        self.keep=[each.strip() for each in self.keep]
        self.qlist=[each.strip() for each in self.qlist]
        
        self.reader.seek(0,0)
        Heads=self.reader.readline().replace('\n','').split(',')
        Heads=[each.strip() for each in Heads]
        
        self.qlist=[each for each in self.qlist if each in Heads]
        self.drop=[each for each in self.drop if each in Heads]
        self.keep=[each for each in self.keep if each in Heads]
        self.keep=[each for each in self.keep if each not in self.drop]
        
        if len(self.keep)==0: print('pump.go: The heads list contains no valid heads.'); return
        select=[each for each in range(len(Heads)) if Heads[each] in self.keep]

        '''Find the file size'''
        self.reader.seek(0,2)
        file_size=self.reader.tell()
        
        '''start to generate the data'''
        oklines=0;data=[];self.reader.seek(0,0);ncolumns = len(Heads);
        if self.seq==False:
            while oklines<subsize:
                pos=int(random.random()*file_size)
                self.reader.seek(pos,0)
                skip_line=self.reader.readline()
                real_line=self.reader.readline()
                data.append(real_line)
                oklines=oklines+1
                
        if self.seq==True:
            pos=int(random.random()*file_size)
            self.reader.seek(pos,0)
            skip_line=self.reader.readline()
            trytime=0
            while oklines<subsize:
                if trytime>=100: print('pump.go: Try too many times and failed.'); return;
                real_line=self.reader.readline()
                if real_line=='':
                    trytime=trytime+1
                    pos=int(random.random()*file_size)
                    self.reader.seek(pos,0)
                    skip_line=self.reader.readline() 
                    continue
                data.append(real_line)
                oklines=oklines+1
                trytime=0
                
        data=[each.replace('\n','').split(',') for each in data]
        df=pd.DataFrame(data)
        if df.shape[1]!=len(Heads): print('pump: No. of columns not equal to No. of heads!'); return
        df.columns=Heads
        df=df[self.keep]
        
        '''create numerical values'''
        df=df.astype('object')
        self.qlist=[each for each in self.qlist if each in df.columns]
        if len(self.qlist)>0:
            for each in self.qlist: 
                df[each]=pd.to_numeric(df[each],errors='coerce')
                
        if self.intercept: df['_INTER_']=1.0 #include an intercept
        return df
    
class tank:
    def demo():
        '''demo is used to demonstrate typical examples about this class.'''
        
        demostr = '''
import clubear as cb
import numpy as np
#clubear.csv is generated by cb.manager.demo()
pm=cb.pump('clubear.csv')  #read in the demodata for illustration
pm.drop=['brand','company','weight'] #drop some varialbe for illustration
pm.qlist=['age','height','logsales','price'] #define the quant variables
ck=cb.check(pm); ck.table(tv=True); ck.levels #levels of quali variables

tk=cb.tank(pm); #create a new tank to hold the pump work for prepressing
tk.app(np.log,'age','logage') #app np.log transformation to age
tk.app(lambda x: x**2,'height') #app a user defined func to height
tk.App #check for the currently used app functions
tk.ady('gender',['Female']) #add dummy for gender
tk.ady('region',list(ck.levels[1])) #add dummy for region
check(tk).stats() #check the newly generated tank

tk.range('age',xmin=30.,xmax=60.0) #select by age range
tk.range('height',xmin=1.7) #select by height range
check(tk).stats() #check the stats for selected data samples

tk.select('gender',['Male']) #include according to gender
tk.select('region',['M','P','C'],inc=False) #exclude by region
check(tk).table(tv=True) #check the final table results
'''
        print(demostr)
    
    def __init__(self,pm):
        '''Initialization: check whether pm is a PUMP!.'''
        
        '''check whether the input is a pump first'''
        if not ispump(pm): print('check: The input seems not a valid pump.'); return
        
        self.pm=pm;df=self.pm.go();Heads=list(df.columns)        
        self.App=[];self.Ady=[];
        qHeads=[each for each in Heads if df.dtypes[each]!='object']
        self.Range=[[-np.inf,np.inf] for each in qHeads]
        self.Range=pd.Series(self.Range,qHeads)
        self.Select=[];self.drop=[];self.keep=[]
        
    def app(self,head,func,newhead=''):
        '''app is used to app func to the head column'''
        
        '''check the initial condition very carefully'''
        df=self.pm.go();Heads=list(df.columns)
        if not callable(func): print('tank.app: the input func *'+str(func)+'* is not a function.'); return
        if not isinstance(head,str): print('tank.app: the head *'+str(head)+'* must be a str.'); return
        if not isinstance(newhead,str): print('tank.app: the newhead *'+str(newhead)+'* must be a str.'); return
        head=head.strip();newhead=newhead.strip()
        if len(head)==0: print('tank.app: the head *'+str(head)+'* cannot be empty.'); return
        if not head in Heads: print('tank.app: the head *'+str(head)+'* not found in df heads.'); return
        if len(newhead)==0: newhead=head
        
        self.App.append([func,head,newhead])
        
    def ady(self,head,levels,drop=True):
        '''ady is used to add dumy varialbes for head according to levels.'''
        
        '''this part check the current parameters of the tank'''
        df=self.pm.go();Heads=list(df.columns)
        if not isinstance(head,str): print('tank.ady: the head *'+str(head)+'* must be a str.'); return
        head=head.strip()
        if len(head)==0: print('tank.ady: the head *'+str(head)+'* cannot be empty.'); return
        if not head in Heads: print('tank.ady: the head *'+str(head)+'* not found in df heads.'); return
        if not isinstance(levels,list): print('tank.ady: the input levels must be a list.'); return
        if len(levels)==0: print('tank.ady: the input levels cannot be empty'); return
        if not isinstance(drop,bool): print('tank.ady: the drop input should be a bool.'); return
        
        self.Ady.append([head,levels])
        self.drop.append(head)
        
    def range(self,head,xmin=-np.inf,xmax=np.inf):
        '''setmin is used to set min value for the head variable'''
        
        '''this part check the current parameters of the tank'''
        df=self.pm.go();Heads=list(df.columns)
        if not isinstance(head,str): print('tank.range: the head *'+str(head)+'* must be a str.'); return
        head=head.strip()
        if len(head)==0: print('tank.range: the head *'+str(head)+'* cannot be empty.'); return
        if not head in Heads: print('tank.range: the head *'+str(head)+'* not found in df heads.'); return
        if not isinstance(xmin,float): print('tank.range: the input xmin must be a float.'); return
        if not isinstance(xmax,float): print('tank.range: the input xmax must be a float.'); return
        if np.isnan(xmin): print('tank.range: the input xmin cannot be np.nan.'); return
        if np.isnan(xmax): print('tank.range: the input xmax cannot be np.nan.'); return
        if xmax<xmin: print('tank.range: the input xmax should be no less than xmin.'); return
        
        self.Range[head]=[xmin,xmax]   
        
    def select(self,head,levels,inc=True):
        '''select is used to select samples by head according to levels.'''
        
        '''this part check the current parameters of the tank'''
        df=self.pm.go();Heads=list(df.columns)
        if not isinstance(head,str): print('tank.select: the head *'+str(head)+'* must be a str.'); return
        head=head.strip()
        if len(head)==0: print('tank.select: the head *'+str(head)+'* cannot be empty.'); return
        if not head in Heads: print('tank.select: the head *'+str(head)+'* not found in df heads.'); return
        if not isinstance(levels,list): print('tank.select: the input levels must be a list.'); return
        if len(levels)==0: print('tank.select: the input levels cannot be empty'); return
        if not isinstance(inc,bool): print('tank.select: the inc input should be a bool.'); return
        
        self.Select.append([head,levels,inc])
        
    def go(self):
        '''go is used to pump out data'''

        '''this part check the current parameters of the tank'''
        df=self.pm.go();Heads=list(df.columns)
                
        '''this part is used to do app transformation'''
        if not isinstance(self.App,list): print('tank.go: The App list must be a list.'); return
        self.App=[each for each in self.App if isinstance(each,list)]
        self.App=[each for each in self.App if len(each)==3]
        self.App=[each for each in self.App if callable(each[0])]
        self.App=[each for each in self.App if each[1] in Heads]
        self.App=[each for each in self.App if isinstance(each[2],str)]
        for each in self.App: df[each[2]]=list(map(each[0],df[each[1]]))
            
        
        '''this part is used to add dummy variable'''
        if not isinstance(self.Ady,list): print('tank.go: The Ady list must be a list.'); return
        self.Ady=[each for each in self.Ady if isinstance(each,list)]
        self.Ady=[each for each in self.Ady if len(each)==2]
        self.Ady=[each for each in self.Ady if each[0] in Heads]
        for each in self.Ady:
            head=each[0];levels=each[1]
            nlevels=len(levels)
            strlevels=[str(each) for each in levels]
            strvalues=[str(each) for each in df[head]]
            newname=[head+'.'+str(each) for each in levels]
            for j in range(nlevels): 
                dummys=[1.0*(each==strlevels[j]) for each in strvalues]
                df[newname[j]]=dummys

        '''this part is used to set normal range'''
        if not isinstance(self.Range,pd.Series): print('tank.go: The Range must be a pd.Series.'); return
        ss=df.shape[0]
        flag=[True for each in range(ss)]
        for each in self.Range.index: 
            flag=flag&(df[each]>=self.Range[each][0])
            flag=flag&(df[each]<=self.Range[each][1])        
        df=df.iloc[list(flag)]       
            
        '''this part is used to select according to levels'''
        if not isinstance(self.Select,list): print('tank.go: The Select must be a list.'); return
        self.Select=[each for each in self.Select if each[0] in Heads]
        self.Select=[each for each in self.Select if isinstance(each[1],list)]
        self.Select=[each for each in self.Select if isinstance(each[2],bool)]
        
        ss=df.shape[0]
        flag=[True for each in range(ss)]
        for each in self.Select: 
            valist=list(df[each[0]])
            if each[2]==True: valist=[eachx in each[1] for eachx in valist]
            if each[2]==False: valist=[not eachx in each[1] for eachx in valist]
            flag=[flag[each]&valist[each] for each in range(ss)]
        df=df.iloc[flag]
        
        '''this part is used to handle drop and keep list'''
        if not isinstance(self.drop,list): print('tank.go: The drop list must be a list.'); return
        self.drop=[each for each in self.drop if each in df.columns]
        df=df.drop(self.drop,axis=1)
        
        if not isinstance(self.keep,list): print('tank.go: The keep list must be a list.'); return
        self.keep=[each for each in self.keep if each in df.columns]
        if len(self.keep)>0: df=df[self.keep]
        
        return df