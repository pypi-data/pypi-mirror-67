import os,random
import numpy as np
import pandas as pd

class pump:

    def demo():
        '''demo is used to demonstrate typical examples about this class.'''
        
        demostr = '''
import clubear as cb
#clubear.csv is generated by cb.manager.demo()
pm=cb.pump('clubear.csv') #start a new pump
pm.keep #check the head lists
ck=cb.check(pm) #create a checker
ck.stats() #check the for stats
pm.qlist=['age','height','weight','logsales']
ck.stats() #check stats again
ck.table() #check table
pm.subsize=10000 #check the subsize
pm.seq=True #sequential sampling method
df=pm.go() #start to pump data
'''
        print(demostr)
    
    def __init__(self,pathfile):
        '''Initialization: check whether pathfile is correct.'''
        
        '''Very careful initial checking.'''
        if not isinstance(pathfile,str): print('pump: The pathfile must be a str.'); return
        if not os.path.exists(pathfile): print('pump: This file dose not exists!'); return
        if not os.path.isfile(pathfile): print('pump: This is not a file!'); return
        self.reader=open(pathfile,encoding='iso8859-1')    
        self.keep=self.reader.readline().replace('\n','').split(',')
        self.keep=[each.strip() for each in self.keep]
        if len(self.keep)==0: print('pump: Nothing found in the file!'); return 
        head_min_str_len=min([len(each) for each in self.keep])
        if head_min_str_len==0: print('pump: Empty head found in heads.'); return
        if len(self.keep)!=len(set(self.keep)): print('pump: Identical heads exist.'); return
        
        self.subsize=1000
        self.drop=[];
        self.qlist=self.keep
        self.seq=False
        
    def go(self):
        '''go is used to start pumpping out data.'''
        
        subsize=self.subsize
        '''Careful check all the inputs and pre-conditions'''                
        if not isinstance(subsize,int): print('pump.go: The subsize must be a int.'); return
        if not isinstance(self.keep,list): print('pump.go: The heads list must be a list.'); return
        if not isinstance(self.drop,list): print('pump.go: The drop list must be a list.'); return
        if not isinstance(self.qlist,list): print('pump.go: The qlist must be list.'); return
        if not isinstance(self.seq,bool): print('pump.go: The seq choice must be a bool.'); return
        
        self.drop=[each.strip() for each in self.drop]
        self.keep=[each.strip() for each in self.keep]
        self.qlist=[each.strip() for each in self.qlist]
        
        self.reader.seek(0,0)
        Heads=self.reader.readline().replace('\n','').split(',')
        Heads=[each.strip() for each in Heads]
        
        self.qlist=[each for each in self.qlist if each in Heads]
        self.drop=[each for each in self.drop if each in Heads]
        self.keep=[each for each in self.keep if each in Heads]
        self.keep=[each for each in self.keep if each not in self.drop]
        
        if len(self.keep)==0: print('pump.go: The heads list contains no valid heads.'); return
        select=[each for each in range(len(Heads)) if Heads[each] in self.keep]

        '''Find the file size'''
        self.reader.seek(0,2)
        file_size=self.reader.tell()
        
        '''start to generate the data'''
        oklines=0;data=[];self.reader.seek(0,0);ncolumns = len(Heads);
        if self.seq==False:
            while oklines<subsize:
                pos=int(random.random()*file_size)
                self.reader.seek(pos,0)
                skip_line=self.reader.readline()
                real_line=self.reader.readline()
                data.append(real_line)
                oklines=oklines+1
                
        if self.seq==True:
            pos=int(random.random()*file_size)
            self.reader.seek(pos,0)
            skip_line=self.reader.readline()
            while oklines<subsize:
                real_line=self.reader.readline()
                if real_line=='':
                    pos=int(random.random()*file_size)
                    self.reader.seek(pos,0)
                    skip_line=self.reader.readline() 
                    continue
                data.append(real_line)
                oklines=oklines+1
                
        data=[each.replace('\n','').split(',') for each in data]
        df=pd.DataFrame(data)
        if df.shape[1]!=len(Heads): print('pump: No. of columns not equal to No. of heads!'); return
        df.columns=Heads
        df=df[self.keep]
        
        '''create numerical values'''
        df=df.astype('object')
        self.qlist=[each for each in self.qlist if each in df.columns]
        if len(self.qlist)>0:
            for each in self.qlist: 
                df[each]=pd.to_numeric(df[each],errors='coerce')
        return df