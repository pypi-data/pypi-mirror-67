from .fun import ispump
from .fun import auc

import IPython,os,time,copy
import pandas as pd
import numpy as np
import seaborn as sns
import warnings; warnings.filterwarnings("ignore")
from matplotlib import pyplot as plt
import matplotlib.cm as cm
import scipy.stats as sps

class model(object):

    def demo():
        '''demo is used to demonstrate typical examples about this class.'''
        demostr = '''
import clubear as cb
#clubear.csv is generated by cb.manager.demo()
pm=cb.pump('clubear.csv')
pm.qlist=['age','height','logsales','price']
cb.model(pm).ols('logsales',tv=False)
'''
        print(demostr)

    def __init__(self, pm):
        '''Initialization: check whether pm is a PUMP!.'''
        self.pm = pm
        
        '''check whether the input is a pump first'''
        if not ispump(pm): print('model: The input seems not a valid pump.'); return
        
        self.Ols='model: To get Ols please run ols() first.'
        self.Logit='model: To get Logit please run logit() first.'
        
    def ols(self,y='',niter=10,tv=False):
        '''ols is used to produce ols estimate for a linear model.'''
        
        '''check whether the input is a pump first'''
        df=self.pm.go();heads=list(df.columns) 
        if not isinstance(niter,int): print('model.ols: The niter must be an int.'); return
        if niter<1: print('model.ols: The niter should be no less than 1.'); return
        if not isinstance(y,str): print('model.ols: The input y should be str.'); return
        y=y.strip()
        if len(y)==0: print('model.ols: The input y cannot be empty.'); return
        if y not in heads: print('model.ols: The input y was not found in pump df.'); return
        if df.dtypes[y]=='object': print('model.ols: The input y is found to be non-numeric.'); return
        if not isinstance(tv,bool): print('model.ols: The input tv should be a bool.'); return
        
        xlist=df.columns
        xlist=[each.strip() for each in xlist if df.dtypes[each] != 'object']
        xlist=[each for each in xlist if each != y]
        if len(xlist)==0: print('model.ols: At least one x should be included.'); return
        
        ncov=len(xlist) #without intercept
        XXS=np.eye(ncov)*1.0e-12;XYS=np.zeros(ncov)
        NS=0;RSS=0;start_time=time.time()
        for n in range(niter):
            df=self.pm.go()

            '''eliminate nan observations'''
            flag=np.mean(np.array(df[xlist+[y]]),axis=1)
            flag=np.isnan(flag)
            df=df.iloc[flag==False]
                        
            SDX=np.array(df[xlist].std())+1.0e-12;MUX=np.array(df[xlist].mean())
            SDY=np.array(df[y].std())+1.0e-12;MUY=np.array(df[y].mean())
            
            if df.shape[0]==0: print('model.ols: Too many NaN found in data.'); return
            
            X=np.array(df[xlist]);Y=np.array(df[y])
            X=(X-MUX)/SDX;Y=(Y-MUY)/SDY;
                        
            XXS=XXS+np.matmul(X.T,X)+np.eye(ncov)*1.0e-12
            XYS=XYS+np.matmul(X.T,Y)
            NS=NS+len(Y)
            INV=np.linalg.inv(XXS/NS)
            beta=np.matmul(INV,XYS/NS)
            
            
            resid=Y-np.matmul(X,beta)
            RSS=RSS+np.sum(resid**2)            
            stde=np.sqrt(RSS/NS)
            R2=100*(1-stde**2)
            SE=np.sqrt(np.diag(INV)/NS)*stde
            tstat=beta/SE
            pvalue=2*(1-sps.norm.cdf(np.abs(tstat)))
            
            out=pd.DataFrame(list(zip(beta,SE*100,tstat,pvalue*100)))
            out.index=xlist
            out.columns=['Estimate','StandErr','tStat','pValue']
            
            end_time=time.time();elapse_time=end_time-start_time            
            IPython.display.clear_output(wait=True)
            pd.set_option('display.float_format', lambda x: '%.3f' % x)
            pd.set_option('display.max_columns',100)
            pd.set_option('display.width',100)
            progress = np.round((n+1)/niter*100, 2)
            
            '''output to screen for interactive analysis'''
            if tv:
                print('Time elapsed:',('%.1f'%elapse_time),'seconds',end=' ')
                print('with averaged subsample sizes', ('%.1f'%(NS/(n+1))), 'and R.Squared = ',('%.1f'%R2),'%')
                print('Task accomplished: ', ('%.1f'%progress),
                      '% for a total of ', niter, 'random replications.')
                print('');print(np.round(out, 3));print('')
                print('* Estimate: the ordinary least squares estimate for standardized x variables.')
                print('* StandErr: the standard error in %; t.Stat: the t-statistics = Estimate/Stand.Err.')
                print('* pValue: the p-value computed by normal approximation in %.')
            else:   
                fig,ax = plt.subplots(); fig.set_figwidth(15); fig.set_figheight(7.5)
                yval=list(out.Estimate); xval=xlist
                titlestr='Task accomplished = ['+str(n+1)+'/'+str(niter)+']; '
                titlestr=titlestr+'    Time elapsed = ['+('%.1f'%elapse_time)+'] seconds;'
                titlestr=titlestr+'    R.Squared = ['+('%.1f'%R2)+'%].'
                ax.set_title(titlestr)
                ax.set_ylabel(y)
                ax.set_xlabel('ols estimates')
                colors = cm.rainbow(1-out['pValue'])
                sns.barplot(yval,xval,palette=colors)
                plt.show() 
            
        self.Ols=out     
        
    def logit(self,y='',niter=10,tv=False):
        '''loigt is used to produce MLE for a logistic regression model.'''

        df=self.pm.go();heads=list(df.columns) 
        if not isinstance(niter,int): print('model.logit: The niter must be an int.'); return
        if niter<1: print('model.logit: The niter should be no less than 1.'); return
        if not isinstance(y,str): print('model.logit: The input y should be str.'); return
        y=y.strip()
        if len(y)==0: print('model.logit: The input y cannot be empty.'); return
        if y not in heads: print('model.logit: The input y was not found in pump df.'); return
        if df.dtypes[y]=='object': print('model.logit: The input y is found to be non-numeric.'); return
        if not isinstance(tv,bool): print('model.logit: The input tv should be a bool.'); return

        xlist=df.columns
        xlist=[each.strip() for each in xlist if df.dtypes[each] != 'object']
        xlist=[each for each in xlist if each != y]
        if len(xlist)==0: print('model.logit: At least one x should be included.'); return

        ncov=len(xlist); NS=0;auc_total=0
        beta0=[0]*ncov; BETA=[0]*ncov;SE=[0]*ncov
        start_time=time.time()
        for n in range(niter):
            df=self.pm.go()

            '''eliminate nan observations'''
            flag=np.mean(np.array(df[xlist+[y]]),axis=1)
            flag=np.isnan(flag)
            df=df.iloc[flag==False]
            if df.shape[0]==0: print('model.logit: Too many NaN found in data.'); return
            ss=df.shape[0]

            '''get X and Y, and then normalize X'''                 
            SDX=np.array(df[xlist].std())+1.0e-12;MUX=np.array(df[xlist].mean())
            X=np.array(df[xlist]);X=(X-MUX)/SDX; Y=np.array(df[y]); NS=NS+len(Y)

            '''initialize for Newton Raphson'''  
            max_iter_count=100;dist=1;miter=0
            while((miter<=max_iter_count) and (dist>1.0e-6)):
                linear=X.dot(beta0)
                pp=1./ (1 + np.exp(-linear))
                L1=X.T.dot(Y-pp)/ss
                temp=np.mat(np.diag(pp*(1-pp)))
                L22=-X.T.dot(temp)
                L2=np.matrix(L22).dot(X)/ss+np.eye(ncov)*1.0e-12
                step=np.linalg.solve(L2,L1)
                beta0=beta0-step
                miter=miter+1
                dist=sum(abs(step))/ncov

            BETA=BETA+beta0
            linear=X.dot(beta0)
            pp=1./ (1 + np.exp(-linear))
            temp=np.mat(np.diag(pp*(1-pp)))
            L22=X.T.dot(temp)
            L2=np.matrix(L22).dot(X)/ss+np.eye(ncov)*1.0e-12
            SE=SE+np.diag(np.linalg.inv(L2))/ss
            
            MyBeta=BETA/(n+1);MySE=np.sqrt(SE/(n+1)+1.0e-12)/np.sqrt(n+1)
            tstat = MyBeta/MySE
            pvalue = 2*(1-sps.norm.cdf(np.abs(tstat)))
            
            auc_total=auc_total+auc(list(X.dot(MyBeta)),list(Y))
            AUC=100*auc_total/(n+1)

            '''output results'''
            out=pd.DataFrame(list(zip(MyBeta,MySE*100,tstat,pvalue*100)))
            out.index=xlist
            out.columns=['Estimate','StandErr','tStat','pValue']      
            end_time=time.time();elapse_time=end_time-start_time            

            IPython.display.clear_output(wait=True)
            pd.set_option('display.float_format', lambda x: '%.3f' % x)
            pd.set_option('display.max_columns',100)
            pd.set_option('display.width',100)
            progress = np.round((n+1)/niter*100, 2)

            '''output to screen for interactive analysis'''
            if tv:
                print('Time elapsed:',('%.1f'%elapse_time),'seconds',end=' ')
                print('with averaged subsample sizes', ('%.1f'%(NS/(n+1))), 'and AUC = ',('%.1f'%AUC),'%')
                print('Task accomplished: ', ('%.1f'%progress),'% for a total of ', niter, 'random replications.')
                print('');print(np.round(out, 3));print('')
                print('* Estimate: the ordinary least squares estimate for standardized x variables.')
                print('* StandErr: the standard error in %; t.Stat: the t-statistics = Estimate/Stand.Err.')
                print('* pValue: the p-value computed by normal approximation in %.')
            else:
                fig,ax = plt.subplots(); fig.set_figwidth(15); fig.set_figheight(7.5)
                yval=list(out.Estimate); xval=xlist
                titlestr='Task accomplished = ['+str(n+1)+'/'+str(niter)+']; '
                titlestr=titlestr+'Time elapsed = ['+('%.1f'%elapse_time)+'] seconds;'
                titlestr=titlestr+'    AUC = ['+('%.1f'%AUC)+'%].'
                ax.set_title(titlestr)
                ax.set_ylabel(y)
                ax.set_xlabel('the averaged mle estimates')
                colors = cm.rainbow(1-out['pValue'])
                sns.barplot(yval,xval,palette=colors)
                plt.show() 

        self.Logit=out