# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.8
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _itkAntiAliasBinaryImageFilterPython.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_itkAntiAliasBinaryImageFilterPython', [dirname(__file__)])
        except ImportError:
            import _itkAntiAliasBinaryImageFilterPython
            return _itkAntiAliasBinaryImageFilterPython
        if fp is not None:
            try:
                _mod = imp.load_module('_itkAntiAliasBinaryImageFilterPython', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _itkAntiAliasBinaryImageFilterPython = swig_import_helper()
    del swig_import_helper
else:
    import _itkAntiAliasBinaryImageFilterPython
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0



def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


import ITKCommonBasePython
import pyBasePython
import itkSparseFieldLevelSetImageFilterPython
import itkFiniteDifferenceImageFilterPython
import itkFiniteDifferenceFunctionPython
import itkVectorPython
import vnl_vectorPython
import vnl_matrixPython
import stdcomplexPython
import vnl_vector_refPython
import itkFixedArrayPython
import itkCovariantVectorPython
import itkSizePython
import itkInPlaceImageFilterAPython
import itkImageToImageFilterAPython
import itkImagePython
import itkImageRegionPython
import itkIndexPython
import itkOffsetPython
import itkRGBAPixelPython
import itkRGBPixelPython
import itkMatrixPython
import vnl_matrix_fixedPython
import itkPointPython
import itkSymmetricSecondRankTensorPython
import itkImageSourcePython
import itkImageSourceCommonPython
import itkVectorImagePython
import itkVariableLengthVectorPython
import itkImageToImageFilterCommonPython
import itkImageToImageFilterBPython

def itkAntiAliasBinaryImageFilterID3ID3_New():
  return itkAntiAliasBinaryImageFilterID3ID3.New()


def itkAntiAliasBinaryImageFilterID2ID2_New():
  return itkAntiAliasBinaryImageFilterID2ID2.New()


def itkAntiAliasBinaryImageFilterIF3IF3_New():
  return itkAntiAliasBinaryImageFilterIF3IF3.New()


def itkAntiAliasBinaryImageFilterIF2IF2_New():
  return itkAntiAliasBinaryImageFilterIF2IF2.New()

class itkAntiAliasBinaryImageFilterID2ID2(itkSparseFieldLevelSetImageFilterPython.itkSparseFieldLevelSetImageFilterID2ID2):
    """


    A method for estimation of a surface from a binary volume.

    This filter implements a surface-fitting method for estimation of a
    surface from a binary volume. This process can be used to reduce
    aliasing artifacts which result in visualization of binary partitioned
    surfaces.

    The binary volume (filter input) is used as a set of constraints in an
    iterative relaxation process of an estimated ND surface. The surface
    is described implicitly as the zero level set of a volume $ \\phi $
    and allowed to deform under curvature flow. A set of constraints is
    imposed on this movement as follows:

    \\[ u_{i,j,k}^{n+1} = \\left\\{ \\begin{array}{ll}
    \\mbox{max} (u_{i,j,k}^{n} + \\Delta t H_{i,j,k}^{n}, 0) &
    \\mbox{$B_{i,j,k} = 1$} \\\\ \\mbox{min} (u_{i,j,k}^{n} +
    \\Delta t H_{i,j,k}^{n}, 0) & \\mbox{$B_{i,j,k} = -1$}
    \\end{array}\\right. \\]

    where $ u_{i,j,k}^{n} $ is the value of $ \\phi $ at discrete index
    $ (i,j,k) $ and iteration $ n $, $ H $ is the gradient magnitude times
    mean curvature of $ \\phi $, and $ B $ is the binary input volume,
    with 1 denoting an inside pixel and -1 denoting an outside pixel.
    NOTES This implementation uses a sparse field level set solver instead
    of the narrow band implementation described in the reference below,
    which may introduce some differences in how fast and how accurately
    (in terms of RMS error) the solution converges. REFERENCES Whitaker,
    Ross. "Reducing Aliasing Artifacts In Iso-Surfaces of Binary
    Volumes" IEEE Volume Visualization and Graphics Symposium, October
    2000, pp.23-32. PARAMETERS The MaximumRMSChange parameter is used to
    determine when the solution has converged. A lower value will result
    in a tighter-fitting solution, but will require more computations. Too
    low a value could put the solver into an infinite loop. Values should
    always be less than 1.0. A value of 0.07 is a good starting estimate.

    The MaximumIterations parameter can be used to halt the solution after
    a specified number of iterations. INPUT The input is an N-dimensional
    image of any type. It is assumed to be a binary image. The filter will
    use an isosurface value that is halfway between the min and max values
    in the image. A signed data type is not necessary for the input.
    OUTPUT The filter will output a level set image of real, signed
    values. The zero crossings of this (N-dimensional) image represent the
    position of the isosurface value of interest. Values outside the zero
    level set are negative and values inside the zero level set are
    positive values. IMPORTANT! The output image type you use to
    instantiate this filter should be a real valued scalar type. In other
    words: doubles or floats. USING THIS FILTER The filter is relatively
    straightforward to use. Tests and examples exist to illustrate. The
    important thing is to understand the input and output types so you can
    properly interpret your results.

    In the common case, the only parameter that will need to be set is the
    MaximumRMSChange parameter, which determines when the solver halts.
    \\sphinx \\sphinxexample{Filtering/AntiAlias/SmoothBinaryImageBef
    oreSurfaceExtraction,Smooth Binary Image Before Surface Extraction}
    \\endsphinx

    C++ includes: itkAntiAliasBinaryImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkAntiAliasBinaryImageFilterID2ID2_Pointer":
        """__New_orig__() -> itkAntiAliasBinaryImageFilterID2ID2_Pointer"""
        return _itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterID2ID2___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkAntiAliasBinaryImageFilterID2ID2_Pointer":
        """Clone(itkAntiAliasBinaryImageFilterID2ID2 self) -> itkAntiAliasBinaryImageFilterID2ID2_Pointer"""
        return _itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterID2ID2_Clone(self)


    def GetUpperBinaryValue(self) -> "double":
        """
        GetUpperBinaryValue(itkAntiAliasBinaryImageFilterID2ID2 self) -> double

        Get the upper
        and lower binary values in the input image. 
        """
        return _itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterID2ID2_GetUpperBinaryValue(self)


    def GetLowerBinaryValue(self) -> "double":
        """GetLowerBinaryValue(itkAntiAliasBinaryImageFilterID2ID2 self) -> double"""
        return _itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterID2ID2_GetLowerBinaryValue(self)


    def SetMaximumIterations(self, i: 'unsigned int') -> "void":
        """
        SetMaximumIterations(itkAntiAliasBinaryImageFilterID2ID2 self, unsigned int i)

        Set/Get the
        maximum number of iterations allowed for the solver. This prevents
        infinite loops if a solution "bounces". 
        """
        return _itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterID2ID2_SetMaximumIterations(self, i)


    def GetMaximumIterations(self) -> "unsigned int":
        """GetMaximumIterations(itkAntiAliasBinaryImageFilterID2ID2 self) -> unsigned int"""
        return _itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterID2ID2_GetMaximumIterations(self)

    DoubleConvertibleToOutputCheck = _itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterID2ID2_DoubleConvertibleToOutputCheck
    InputOStreamWritableCheck = _itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterID2ID2_InputOStreamWritableCheck
    __swig_destroy__ = _itkAntiAliasBinaryImageFilterPython.delete_itkAntiAliasBinaryImageFilterID2ID2

    def cast(obj: 'itkLightObject') -> "itkAntiAliasBinaryImageFilterID2ID2 *":
        """cast(itkLightObject obj) -> itkAntiAliasBinaryImageFilterID2ID2"""
        return _itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterID2ID2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkAntiAliasBinaryImageFilterID2ID2

        Create a new object of the class itkAntiAliasBinaryImageFilterID2ID2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkAntiAliasBinaryImageFilterID2ID2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkAntiAliasBinaryImageFilterID2ID2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkAntiAliasBinaryImageFilterID2ID2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkAntiAliasBinaryImageFilterID2ID2.Clone = new_instancemethod(_itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterID2ID2_Clone, None, itkAntiAliasBinaryImageFilterID2ID2)
itkAntiAliasBinaryImageFilterID2ID2.GetUpperBinaryValue = new_instancemethod(_itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterID2ID2_GetUpperBinaryValue, None, itkAntiAliasBinaryImageFilterID2ID2)
itkAntiAliasBinaryImageFilterID2ID2.GetLowerBinaryValue = new_instancemethod(_itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterID2ID2_GetLowerBinaryValue, None, itkAntiAliasBinaryImageFilterID2ID2)
itkAntiAliasBinaryImageFilterID2ID2.SetMaximumIterations = new_instancemethod(_itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterID2ID2_SetMaximumIterations, None, itkAntiAliasBinaryImageFilterID2ID2)
itkAntiAliasBinaryImageFilterID2ID2.GetMaximumIterations = new_instancemethod(_itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterID2ID2_GetMaximumIterations, None, itkAntiAliasBinaryImageFilterID2ID2)
itkAntiAliasBinaryImageFilterID2ID2_swigregister = _itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterID2ID2_swigregister
itkAntiAliasBinaryImageFilterID2ID2_swigregister(itkAntiAliasBinaryImageFilterID2ID2)

def itkAntiAliasBinaryImageFilterID2ID2___New_orig__() -> "itkAntiAliasBinaryImageFilterID2ID2_Pointer":
    """itkAntiAliasBinaryImageFilterID2ID2___New_orig__() -> itkAntiAliasBinaryImageFilterID2ID2_Pointer"""
    return _itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterID2ID2___New_orig__()

def itkAntiAliasBinaryImageFilterID2ID2_cast(obj: 'itkLightObject') -> "itkAntiAliasBinaryImageFilterID2ID2 *":
    """itkAntiAliasBinaryImageFilterID2ID2_cast(itkLightObject obj) -> itkAntiAliasBinaryImageFilterID2ID2"""
    return _itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterID2ID2_cast(obj)

class itkAntiAliasBinaryImageFilterID3ID3(itkSparseFieldLevelSetImageFilterPython.itkSparseFieldLevelSetImageFilterID3ID3):
    """


    A method for estimation of a surface from a binary volume.

    This filter implements a surface-fitting method for estimation of a
    surface from a binary volume. This process can be used to reduce
    aliasing artifacts which result in visualization of binary partitioned
    surfaces.

    The binary volume (filter input) is used as a set of constraints in an
    iterative relaxation process of an estimated ND surface. The surface
    is described implicitly as the zero level set of a volume $ \\phi $
    and allowed to deform under curvature flow. A set of constraints is
    imposed on this movement as follows:

    \\[ u_{i,j,k}^{n+1} = \\left\\{ \\begin{array}{ll}
    \\mbox{max} (u_{i,j,k}^{n} + \\Delta t H_{i,j,k}^{n}, 0) &
    \\mbox{$B_{i,j,k} = 1$} \\\\ \\mbox{min} (u_{i,j,k}^{n} +
    \\Delta t H_{i,j,k}^{n}, 0) & \\mbox{$B_{i,j,k} = -1$}
    \\end{array}\\right. \\]

    where $ u_{i,j,k}^{n} $ is the value of $ \\phi $ at discrete index
    $ (i,j,k) $ and iteration $ n $, $ H $ is the gradient magnitude times
    mean curvature of $ \\phi $, and $ B $ is the binary input volume,
    with 1 denoting an inside pixel and -1 denoting an outside pixel.
    NOTES This implementation uses a sparse field level set solver instead
    of the narrow band implementation described in the reference below,
    which may introduce some differences in how fast and how accurately
    (in terms of RMS error) the solution converges. REFERENCES Whitaker,
    Ross. "Reducing Aliasing Artifacts In Iso-Surfaces of Binary
    Volumes" IEEE Volume Visualization and Graphics Symposium, October
    2000, pp.23-32. PARAMETERS The MaximumRMSChange parameter is used to
    determine when the solution has converged. A lower value will result
    in a tighter-fitting solution, but will require more computations. Too
    low a value could put the solver into an infinite loop. Values should
    always be less than 1.0. A value of 0.07 is a good starting estimate.

    The MaximumIterations parameter can be used to halt the solution after
    a specified number of iterations. INPUT The input is an N-dimensional
    image of any type. It is assumed to be a binary image. The filter will
    use an isosurface value that is halfway between the min and max values
    in the image. A signed data type is not necessary for the input.
    OUTPUT The filter will output a level set image of real, signed
    values. The zero crossings of this (N-dimensional) image represent the
    position of the isosurface value of interest. Values outside the zero
    level set are negative and values inside the zero level set are
    positive values. IMPORTANT! The output image type you use to
    instantiate this filter should be a real valued scalar type. In other
    words: doubles or floats. USING THIS FILTER The filter is relatively
    straightforward to use. Tests and examples exist to illustrate. The
    important thing is to understand the input and output types so you can
    properly interpret your results.

    In the common case, the only parameter that will need to be set is the
    MaximumRMSChange parameter, which determines when the solver halts.
    \\sphinx \\sphinxexample{Filtering/AntiAlias/SmoothBinaryImageBef
    oreSurfaceExtraction,Smooth Binary Image Before Surface Extraction}
    \\endsphinx

    C++ includes: itkAntiAliasBinaryImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkAntiAliasBinaryImageFilterID3ID3_Pointer":
        """__New_orig__() -> itkAntiAliasBinaryImageFilterID3ID3_Pointer"""
        return _itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterID3ID3___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkAntiAliasBinaryImageFilterID3ID3_Pointer":
        """Clone(itkAntiAliasBinaryImageFilterID3ID3 self) -> itkAntiAliasBinaryImageFilterID3ID3_Pointer"""
        return _itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterID3ID3_Clone(self)


    def GetUpperBinaryValue(self) -> "double":
        """
        GetUpperBinaryValue(itkAntiAliasBinaryImageFilterID3ID3 self) -> double

        Get the upper
        and lower binary values in the input image. 
        """
        return _itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterID3ID3_GetUpperBinaryValue(self)


    def GetLowerBinaryValue(self) -> "double":
        """GetLowerBinaryValue(itkAntiAliasBinaryImageFilterID3ID3 self) -> double"""
        return _itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterID3ID3_GetLowerBinaryValue(self)


    def SetMaximumIterations(self, i: 'unsigned int') -> "void":
        """
        SetMaximumIterations(itkAntiAliasBinaryImageFilterID3ID3 self, unsigned int i)

        Set/Get the
        maximum number of iterations allowed for the solver. This prevents
        infinite loops if a solution "bounces". 
        """
        return _itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterID3ID3_SetMaximumIterations(self, i)


    def GetMaximumIterations(self) -> "unsigned int":
        """GetMaximumIterations(itkAntiAliasBinaryImageFilterID3ID3 self) -> unsigned int"""
        return _itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterID3ID3_GetMaximumIterations(self)

    DoubleConvertibleToOutputCheck = _itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterID3ID3_DoubleConvertibleToOutputCheck
    InputOStreamWritableCheck = _itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterID3ID3_InputOStreamWritableCheck
    __swig_destroy__ = _itkAntiAliasBinaryImageFilterPython.delete_itkAntiAliasBinaryImageFilterID3ID3

    def cast(obj: 'itkLightObject') -> "itkAntiAliasBinaryImageFilterID3ID3 *":
        """cast(itkLightObject obj) -> itkAntiAliasBinaryImageFilterID3ID3"""
        return _itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterID3ID3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkAntiAliasBinaryImageFilterID3ID3

        Create a new object of the class itkAntiAliasBinaryImageFilterID3ID3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkAntiAliasBinaryImageFilterID3ID3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkAntiAliasBinaryImageFilterID3ID3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkAntiAliasBinaryImageFilterID3ID3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkAntiAliasBinaryImageFilterID3ID3.Clone = new_instancemethod(_itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterID3ID3_Clone, None, itkAntiAliasBinaryImageFilterID3ID3)
itkAntiAliasBinaryImageFilterID3ID3.GetUpperBinaryValue = new_instancemethod(_itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterID3ID3_GetUpperBinaryValue, None, itkAntiAliasBinaryImageFilterID3ID3)
itkAntiAliasBinaryImageFilterID3ID3.GetLowerBinaryValue = new_instancemethod(_itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterID3ID3_GetLowerBinaryValue, None, itkAntiAliasBinaryImageFilterID3ID3)
itkAntiAliasBinaryImageFilterID3ID3.SetMaximumIterations = new_instancemethod(_itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterID3ID3_SetMaximumIterations, None, itkAntiAliasBinaryImageFilterID3ID3)
itkAntiAliasBinaryImageFilterID3ID3.GetMaximumIterations = new_instancemethod(_itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterID3ID3_GetMaximumIterations, None, itkAntiAliasBinaryImageFilterID3ID3)
itkAntiAliasBinaryImageFilterID3ID3_swigregister = _itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterID3ID3_swigregister
itkAntiAliasBinaryImageFilterID3ID3_swigregister(itkAntiAliasBinaryImageFilterID3ID3)

def itkAntiAliasBinaryImageFilterID3ID3___New_orig__() -> "itkAntiAliasBinaryImageFilterID3ID3_Pointer":
    """itkAntiAliasBinaryImageFilterID3ID3___New_orig__() -> itkAntiAliasBinaryImageFilterID3ID3_Pointer"""
    return _itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterID3ID3___New_orig__()

def itkAntiAliasBinaryImageFilterID3ID3_cast(obj: 'itkLightObject') -> "itkAntiAliasBinaryImageFilterID3ID3 *":
    """itkAntiAliasBinaryImageFilterID3ID3_cast(itkLightObject obj) -> itkAntiAliasBinaryImageFilterID3ID3"""
    return _itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterID3ID3_cast(obj)

class itkAntiAliasBinaryImageFilterIF2IF2(itkSparseFieldLevelSetImageFilterPython.itkSparseFieldLevelSetImageFilterIF2IF2):
    """


    A method for estimation of a surface from a binary volume.

    This filter implements a surface-fitting method for estimation of a
    surface from a binary volume. This process can be used to reduce
    aliasing artifacts which result in visualization of binary partitioned
    surfaces.

    The binary volume (filter input) is used as a set of constraints in an
    iterative relaxation process of an estimated ND surface. The surface
    is described implicitly as the zero level set of a volume $ \\phi $
    and allowed to deform under curvature flow. A set of constraints is
    imposed on this movement as follows:

    \\[ u_{i,j,k}^{n+1} = \\left\\{ \\begin{array}{ll}
    \\mbox{max} (u_{i,j,k}^{n} + \\Delta t H_{i,j,k}^{n}, 0) &
    \\mbox{$B_{i,j,k} = 1$} \\\\ \\mbox{min} (u_{i,j,k}^{n} +
    \\Delta t H_{i,j,k}^{n}, 0) & \\mbox{$B_{i,j,k} = -1$}
    \\end{array}\\right. \\]

    where $ u_{i,j,k}^{n} $ is the value of $ \\phi $ at discrete index
    $ (i,j,k) $ and iteration $ n $, $ H $ is the gradient magnitude times
    mean curvature of $ \\phi $, and $ B $ is the binary input volume,
    with 1 denoting an inside pixel and -1 denoting an outside pixel.
    NOTES This implementation uses a sparse field level set solver instead
    of the narrow band implementation described in the reference below,
    which may introduce some differences in how fast and how accurately
    (in terms of RMS error) the solution converges. REFERENCES Whitaker,
    Ross. "Reducing Aliasing Artifacts In Iso-Surfaces of Binary
    Volumes" IEEE Volume Visualization and Graphics Symposium, October
    2000, pp.23-32. PARAMETERS The MaximumRMSChange parameter is used to
    determine when the solution has converged. A lower value will result
    in a tighter-fitting solution, but will require more computations. Too
    low a value could put the solver into an infinite loop. Values should
    always be less than 1.0. A value of 0.07 is a good starting estimate.

    The MaximumIterations parameter can be used to halt the solution after
    a specified number of iterations. INPUT The input is an N-dimensional
    image of any type. It is assumed to be a binary image. The filter will
    use an isosurface value that is halfway between the min and max values
    in the image. A signed data type is not necessary for the input.
    OUTPUT The filter will output a level set image of real, signed
    values. The zero crossings of this (N-dimensional) image represent the
    position of the isosurface value of interest. Values outside the zero
    level set are negative and values inside the zero level set are
    positive values. IMPORTANT! The output image type you use to
    instantiate this filter should be a real valued scalar type. In other
    words: doubles or floats. USING THIS FILTER The filter is relatively
    straightforward to use. Tests and examples exist to illustrate. The
    important thing is to understand the input and output types so you can
    properly interpret your results.

    In the common case, the only parameter that will need to be set is the
    MaximumRMSChange parameter, which determines when the solver halts.
    \\sphinx \\sphinxexample{Filtering/AntiAlias/SmoothBinaryImageBef
    oreSurfaceExtraction,Smooth Binary Image Before Surface Extraction}
    \\endsphinx

    C++ includes: itkAntiAliasBinaryImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkAntiAliasBinaryImageFilterIF2IF2_Pointer":
        """__New_orig__() -> itkAntiAliasBinaryImageFilterIF2IF2_Pointer"""
        return _itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterIF2IF2___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkAntiAliasBinaryImageFilterIF2IF2_Pointer":
        """Clone(itkAntiAliasBinaryImageFilterIF2IF2 self) -> itkAntiAliasBinaryImageFilterIF2IF2_Pointer"""
        return _itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterIF2IF2_Clone(self)


    def GetUpperBinaryValue(self) -> "float":
        """
        GetUpperBinaryValue(itkAntiAliasBinaryImageFilterIF2IF2 self) -> float

        Get the upper
        and lower binary values in the input image. 
        """
        return _itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterIF2IF2_GetUpperBinaryValue(self)


    def GetLowerBinaryValue(self) -> "float":
        """GetLowerBinaryValue(itkAntiAliasBinaryImageFilterIF2IF2 self) -> float"""
        return _itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterIF2IF2_GetLowerBinaryValue(self)


    def SetMaximumIterations(self, i: 'unsigned int') -> "void":
        """
        SetMaximumIterations(itkAntiAliasBinaryImageFilterIF2IF2 self, unsigned int i)

        Set/Get the
        maximum number of iterations allowed for the solver. This prevents
        infinite loops if a solution "bounces". 
        """
        return _itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterIF2IF2_SetMaximumIterations(self, i)


    def GetMaximumIterations(self) -> "unsigned int":
        """GetMaximumIterations(itkAntiAliasBinaryImageFilterIF2IF2 self) -> unsigned int"""
        return _itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterIF2IF2_GetMaximumIterations(self)

    DoubleConvertibleToOutputCheck = _itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterIF2IF2_DoubleConvertibleToOutputCheck
    InputOStreamWritableCheck = _itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterIF2IF2_InputOStreamWritableCheck
    __swig_destroy__ = _itkAntiAliasBinaryImageFilterPython.delete_itkAntiAliasBinaryImageFilterIF2IF2

    def cast(obj: 'itkLightObject') -> "itkAntiAliasBinaryImageFilterIF2IF2 *":
        """cast(itkLightObject obj) -> itkAntiAliasBinaryImageFilterIF2IF2"""
        return _itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterIF2IF2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkAntiAliasBinaryImageFilterIF2IF2

        Create a new object of the class itkAntiAliasBinaryImageFilterIF2IF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkAntiAliasBinaryImageFilterIF2IF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkAntiAliasBinaryImageFilterIF2IF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkAntiAliasBinaryImageFilterIF2IF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkAntiAliasBinaryImageFilterIF2IF2.Clone = new_instancemethod(_itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterIF2IF2_Clone, None, itkAntiAliasBinaryImageFilterIF2IF2)
itkAntiAliasBinaryImageFilterIF2IF2.GetUpperBinaryValue = new_instancemethod(_itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterIF2IF2_GetUpperBinaryValue, None, itkAntiAliasBinaryImageFilterIF2IF2)
itkAntiAliasBinaryImageFilterIF2IF2.GetLowerBinaryValue = new_instancemethod(_itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterIF2IF2_GetLowerBinaryValue, None, itkAntiAliasBinaryImageFilterIF2IF2)
itkAntiAliasBinaryImageFilterIF2IF2.SetMaximumIterations = new_instancemethod(_itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterIF2IF2_SetMaximumIterations, None, itkAntiAliasBinaryImageFilterIF2IF2)
itkAntiAliasBinaryImageFilterIF2IF2.GetMaximumIterations = new_instancemethod(_itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterIF2IF2_GetMaximumIterations, None, itkAntiAliasBinaryImageFilterIF2IF2)
itkAntiAliasBinaryImageFilterIF2IF2_swigregister = _itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterIF2IF2_swigregister
itkAntiAliasBinaryImageFilterIF2IF2_swigregister(itkAntiAliasBinaryImageFilterIF2IF2)

def itkAntiAliasBinaryImageFilterIF2IF2___New_orig__() -> "itkAntiAliasBinaryImageFilterIF2IF2_Pointer":
    """itkAntiAliasBinaryImageFilterIF2IF2___New_orig__() -> itkAntiAliasBinaryImageFilterIF2IF2_Pointer"""
    return _itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterIF2IF2___New_orig__()

def itkAntiAliasBinaryImageFilterIF2IF2_cast(obj: 'itkLightObject') -> "itkAntiAliasBinaryImageFilterIF2IF2 *":
    """itkAntiAliasBinaryImageFilterIF2IF2_cast(itkLightObject obj) -> itkAntiAliasBinaryImageFilterIF2IF2"""
    return _itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterIF2IF2_cast(obj)

class itkAntiAliasBinaryImageFilterIF3IF3(itkSparseFieldLevelSetImageFilterPython.itkSparseFieldLevelSetImageFilterIF3IF3):
    """


    A method for estimation of a surface from a binary volume.

    This filter implements a surface-fitting method for estimation of a
    surface from a binary volume. This process can be used to reduce
    aliasing artifacts which result in visualization of binary partitioned
    surfaces.

    The binary volume (filter input) is used as a set of constraints in an
    iterative relaxation process of an estimated ND surface. The surface
    is described implicitly as the zero level set of a volume $ \\phi $
    and allowed to deform under curvature flow. A set of constraints is
    imposed on this movement as follows:

    \\[ u_{i,j,k}^{n+1} = \\left\\{ \\begin{array}{ll}
    \\mbox{max} (u_{i,j,k}^{n} + \\Delta t H_{i,j,k}^{n}, 0) &
    \\mbox{$B_{i,j,k} = 1$} \\\\ \\mbox{min} (u_{i,j,k}^{n} +
    \\Delta t H_{i,j,k}^{n}, 0) & \\mbox{$B_{i,j,k} = -1$}
    \\end{array}\\right. \\]

    where $ u_{i,j,k}^{n} $ is the value of $ \\phi $ at discrete index
    $ (i,j,k) $ and iteration $ n $, $ H $ is the gradient magnitude times
    mean curvature of $ \\phi $, and $ B $ is the binary input volume,
    with 1 denoting an inside pixel and -1 denoting an outside pixel.
    NOTES This implementation uses a sparse field level set solver instead
    of the narrow band implementation described in the reference below,
    which may introduce some differences in how fast and how accurately
    (in terms of RMS error) the solution converges. REFERENCES Whitaker,
    Ross. "Reducing Aliasing Artifacts In Iso-Surfaces of Binary
    Volumes" IEEE Volume Visualization and Graphics Symposium, October
    2000, pp.23-32. PARAMETERS The MaximumRMSChange parameter is used to
    determine when the solution has converged. A lower value will result
    in a tighter-fitting solution, but will require more computations. Too
    low a value could put the solver into an infinite loop. Values should
    always be less than 1.0. A value of 0.07 is a good starting estimate.

    The MaximumIterations parameter can be used to halt the solution after
    a specified number of iterations. INPUT The input is an N-dimensional
    image of any type. It is assumed to be a binary image. The filter will
    use an isosurface value that is halfway between the min and max values
    in the image. A signed data type is not necessary for the input.
    OUTPUT The filter will output a level set image of real, signed
    values. The zero crossings of this (N-dimensional) image represent the
    position of the isosurface value of interest. Values outside the zero
    level set are negative and values inside the zero level set are
    positive values. IMPORTANT! The output image type you use to
    instantiate this filter should be a real valued scalar type. In other
    words: doubles or floats. USING THIS FILTER The filter is relatively
    straightforward to use. Tests and examples exist to illustrate. The
    important thing is to understand the input and output types so you can
    properly interpret your results.

    In the common case, the only parameter that will need to be set is the
    MaximumRMSChange parameter, which determines when the solver halts.
    \\sphinx \\sphinxexample{Filtering/AntiAlias/SmoothBinaryImageBef
    oreSurfaceExtraction,Smooth Binary Image Before Surface Extraction}
    \\endsphinx

    C++ includes: itkAntiAliasBinaryImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkAntiAliasBinaryImageFilterIF3IF3_Pointer":
        """__New_orig__() -> itkAntiAliasBinaryImageFilterIF3IF3_Pointer"""
        return _itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterIF3IF3___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkAntiAliasBinaryImageFilterIF3IF3_Pointer":
        """Clone(itkAntiAliasBinaryImageFilterIF3IF3 self) -> itkAntiAliasBinaryImageFilterIF3IF3_Pointer"""
        return _itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterIF3IF3_Clone(self)


    def GetUpperBinaryValue(self) -> "float":
        """
        GetUpperBinaryValue(itkAntiAliasBinaryImageFilterIF3IF3 self) -> float

        Get the upper
        and lower binary values in the input image. 
        """
        return _itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterIF3IF3_GetUpperBinaryValue(self)


    def GetLowerBinaryValue(self) -> "float":
        """GetLowerBinaryValue(itkAntiAliasBinaryImageFilterIF3IF3 self) -> float"""
        return _itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterIF3IF3_GetLowerBinaryValue(self)


    def SetMaximumIterations(self, i: 'unsigned int') -> "void":
        """
        SetMaximumIterations(itkAntiAliasBinaryImageFilterIF3IF3 self, unsigned int i)

        Set/Get the
        maximum number of iterations allowed for the solver. This prevents
        infinite loops if a solution "bounces". 
        """
        return _itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterIF3IF3_SetMaximumIterations(self, i)


    def GetMaximumIterations(self) -> "unsigned int":
        """GetMaximumIterations(itkAntiAliasBinaryImageFilterIF3IF3 self) -> unsigned int"""
        return _itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterIF3IF3_GetMaximumIterations(self)

    DoubleConvertibleToOutputCheck = _itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterIF3IF3_DoubleConvertibleToOutputCheck
    InputOStreamWritableCheck = _itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterIF3IF3_InputOStreamWritableCheck
    __swig_destroy__ = _itkAntiAliasBinaryImageFilterPython.delete_itkAntiAliasBinaryImageFilterIF3IF3

    def cast(obj: 'itkLightObject') -> "itkAntiAliasBinaryImageFilterIF3IF3 *":
        """cast(itkLightObject obj) -> itkAntiAliasBinaryImageFilterIF3IF3"""
        return _itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterIF3IF3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkAntiAliasBinaryImageFilterIF3IF3

        Create a new object of the class itkAntiAliasBinaryImageFilterIF3IF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkAntiAliasBinaryImageFilterIF3IF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkAntiAliasBinaryImageFilterIF3IF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkAntiAliasBinaryImageFilterIF3IF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkAntiAliasBinaryImageFilterIF3IF3.Clone = new_instancemethod(_itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterIF3IF3_Clone, None, itkAntiAliasBinaryImageFilterIF3IF3)
itkAntiAliasBinaryImageFilterIF3IF3.GetUpperBinaryValue = new_instancemethod(_itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterIF3IF3_GetUpperBinaryValue, None, itkAntiAliasBinaryImageFilterIF3IF3)
itkAntiAliasBinaryImageFilterIF3IF3.GetLowerBinaryValue = new_instancemethod(_itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterIF3IF3_GetLowerBinaryValue, None, itkAntiAliasBinaryImageFilterIF3IF3)
itkAntiAliasBinaryImageFilterIF3IF3.SetMaximumIterations = new_instancemethod(_itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterIF3IF3_SetMaximumIterations, None, itkAntiAliasBinaryImageFilterIF3IF3)
itkAntiAliasBinaryImageFilterIF3IF3.GetMaximumIterations = new_instancemethod(_itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterIF3IF3_GetMaximumIterations, None, itkAntiAliasBinaryImageFilterIF3IF3)
itkAntiAliasBinaryImageFilterIF3IF3_swigregister = _itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterIF3IF3_swigregister
itkAntiAliasBinaryImageFilterIF3IF3_swigregister(itkAntiAliasBinaryImageFilterIF3IF3)

def itkAntiAliasBinaryImageFilterIF3IF3___New_orig__() -> "itkAntiAliasBinaryImageFilterIF3IF3_Pointer":
    """itkAntiAliasBinaryImageFilterIF3IF3___New_orig__() -> itkAntiAliasBinaryImageFilterIF3IF3_Pointer"""
    return _itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterIF3IF3___New_orig__()

def itkAntiAliasBinaryImageFilterIF3IF3_cast(obj: 'itkLightObject') -> "itkAntiAliasBinaryImageFilterIF3IF3 *":
    """itkAntiAliasBinaryImageFilterIF3IF3_cast(itkLightObject obj) -> itkAntiAliasBinaryImageFilterIF3IF3"""
    return _itkAntiAliasBinaryImageFilterPython.itkAntiAliasBinaryImageFilterIF3IF3_cast(obj)


import itkHelpers
@itkHelpers.accept_numpy_array_like_xarray
def anti_alias_binary_image_filter(*args, **kwargs):
    """Procedural interface for AntiAliasBinaryImageFilter"""
    import itk
    instance = itk.AntiAliasBinaryImageFilter.New(*args, **kwargs)
    return instance.__internal_call__()

def anti_alias_binary_image_filter_init_docstring():
    import itk
    import itkTemplate
    import itkHelpers
    if isinstance(itk.AntiAliasBinaryImageFilter, itkTemplate.itkTemplate):
        filter_object = itk.AntiAliasBinaryImageFilter.values()[0]
    else:
        filter_object = itk.AntiAliasBinaryImageFilter

    anti_alias_binary_image_filter.__doc__ = filter_object.__doc__
    anti_alias_binary_image_filter.__doc__ += "\n Args are Input(s) to the filter.\n"
    anti_alias_binary_image_filter.__doc__ += "Available Keyword Arguments:\n"
    anti_alias_binary_image_filter.__doc__ += "".join([
        "  " + itkHelpers.camel_to_snake_case(item[3:]) + "\n"
        for item in dir(filter_object)
        if item[:3] == "Set"])



