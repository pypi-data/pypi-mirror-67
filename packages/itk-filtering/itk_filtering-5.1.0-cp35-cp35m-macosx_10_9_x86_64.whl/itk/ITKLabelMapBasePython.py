# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.8
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _ITKLabelMapBasePython.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_ITKLabelMapBasePython', [dirname(__file__)])
        except ImportError:
            import _ITKLabelMapBasePython
            return _ITKLabelMapBasePython
        if fp is not None:
            try:
                _mod = imp.load_module('_ITKLabelMapBasePython', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _ITKLabelMapBasePython = swig_import_helper()
    del swig_import_helper
else:
    import _ITKLabelMapBasePython
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0



def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


import ITKCommonBasePython
import pyBasePython
import itkImagePython
import itkImageRegionPython
import itkSizePython
import itkIndexPython
import itkOffsetPython
import itkRGBAPixelPython
import itkFixedArrayPython
import stdcomplexPython
import itkRGBPixelPython
import itkMatrixPython
import vnl_matrix_fixedPython
import vnl_matrixPython
import vnl_vectorPython
import itkVectorPython
import vnl_vector_refPython
import itkCovariantVectorPython
import itkPointPython
import itkSymmetricSecondRankTensorPython
import itkImageSourcePython
import itkImageSourceCommonPython
import itkVectorImagePython
import itkVariableLengthVectorPython
import itkImageToImageFilterCommonPython
import itkStatisticsLabelObjectPython
import itkShapeLabelObjectPython
import itkLabelObjectPython
import itkLabelObjectLinePython
import itkAffineTransformPython
import itkTransformBasePython
import itkDiffusionTensor3DPython
import itkArray2DPython
import itkOptimizerParametersPython
import itkArrayPython
import itkMatrixOffsetTransformBasePython
import itkHistogramPython
import itkSamplePython

def itkImageToImageFilterLM3IRGBUC3_New():
  return itkImageToImageFilterLM3IRGBUC3.New()


def itkImageToImageFilterLM3ID3_New():
  return itkImageToImageFilterLM3ID3.New()


def itkImageToImageFilterID3LM3_New():
  return itkImageToImageFilterID3LM3.New()


def itkImageToImageFilterLM3IF3_New():
  return itkImageToImageFilterLM3IF3.New()


def itkImageToImageFilterIF3LM3_New():
  return itkImageToImageFilterIF3LM3.New()


def itkImageToImageFilterLM3IUS3_New():
  return itkImageToImageFilterLM3IUS3.New()


def itkImageToImageFilterIUS3LM3_New():
  return itkImageToImageFilterIUS3LM3.New()


def itkImageToImageFilterLM3IUC3_New():
  return itkImageToImageFilterLM3IUC3.New()


def itkImageToImageFilterIUC3LM3_New():
  return itkImageToImageFilterIUC3LM3.New()


def itkImageToImageFilterLM3ISS3_New():
  return itkImageToImageFilterLM3ISS3.New()


def itkImageToImageFilterISS3LM3_New():
  return itkImageToImageFilterISS3LM3.New()


def itkImageToImageFilterLM3LM3_New():
  return itkImageToImageFilterLM3LM3.New()


def itkImageToImageFilterLM2IRGBUC2_New():
  return itkImageToImageFilterLM2IRGBUC2.New()


def itkImageToImageFilterLM2ID2_New():
  return itkImageToImageFilterLM2ID2.New()


def itkImageToImageFilterID2LM2_New():
  return itkImageToImageFilterID2LM2.New()


def itkImageToImageFilterLM2IF2_New():
  return itkImageToImageFilterLM2IF2.New()


def itkImageToImageFilterIF2LM2_New():
  return itkImageToImageFilterIF2LM2.New()


def itkImageToImageFilterLM2IUS2_New():
  return itkImageToImageFilterLM2IUS2.New()


def itkImageToImageFilterIUS2LM2_New():
  return itkImageToImageFilterIUS2LM2.New()


def itkImageToImageFilterLM2IUC2_New():
  return itkImageToImageFilterLM2IUC2.New()


def itkImageToImageFilterIUC2LM2_New():
  return itkImageToImageFilterIUC2LM2.New()


def itkImageToImageFilterLM2ISS2_New():
  return itkImageToImageFilterLM2ISS2.New()


def itkImageToImageFilterISS2LM2_New():
  return itkImageToImageFilterISS2LM2.New()


def itkImageToImageFilterLM2LM2_New():
  return itkImageToImageFilterLM2LM2.New()


def itkImageSourceLM3_New():
  return itkImageSourceLM3.New()


def itkImageSourceLM2_New():
  return itkImageSourceLM2.New()


def itkLabelMap3_New():
  return itkLabelMap3.New()


def itkLabelMap2_New():
  return itkLabelMap2.New()


def itkLabelMap2_New():
  return itkLabelMap2.New()

class itkImageSourceLM2(ITKCommonBasePython.itkProcessObject):
    """


    Base class for all process objects that output image data.

    ImageSource is the base class for all process objects that output
    image data. Specifically, this class defines the GetOutput() method
    that returns a pointer to the output image. The class also defines
    some internal private data members that are used to manage streaming
    of data.

    Memory management in an ImageSource is slightly different than a
    standard ProcessObject. ProcessObject's always release the bulk data
    associated with their output prior to GenerateData() being called.
    ImageSources default to not releasing the bulk data incase that
    particular memory block is large enough to hold the new output values.
    This avoids unnecessary deallocation/allocation sequences.
    ImageSource's can be forced to use a memory management model similar
    to the default ProcessObject behaviour by calling
    ProcessObject::ReleaseDataBeforeUpdateFlagOn(). A user may want to set
    this flag to limit peak memory usage during a pipeline update.

    \\sphinx
    \\sphinxexample{Core/Common/ProduceImageProgrammatically,Produce
    Image Programmatically} \\endsphinx

    C++ includes: itkImageSource.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def GetOutput(self, *args) -> "itkLabelMap2 *":
        """
        GetOutput(itkImageSourceLM2 self) -> itkLabelMap2
        GetOutput(itkImageSourceLM2 self) -> itkLabelMap2
        GetOutput(itkImageSourceLM2 self, unsigned int idx) -> itkLabelMap2

        Get the output data of
        this process object. The output of this function is not valid until an
        appropriate Update() method has been called, either explicitly or
        implicitly. Both the filter itself and the data object have Update()
        methods, and both methods update the data. Here are three ways to use
        GetOutput() and make sure the data is valid. In these examples, image
        is a pointer to some Image object, and the particular ProcessObjects
        involved are filters. The same examples apply to non-image (e.g. Mesh)
        data as well.

        In this situation, someFilter and anotherFilter are said to constitute
        a pipeline.

        (In the above example, the two lines of code can be in either order.)

        Note that Update() is not called automatically except within a
        pipeline as in the first example. When streaming (using a
        StreamingImageFilter) is activated, it may be more efficient to use a
        pipeline than to call Update() once for each filter in turn.

        For an image, the data generated is for the requested Region, which
        can be set using ImageBase::SetRequestedRegion(). By default, the
        largest possible region is requested.

        For Filters which have multiple outputs of different types, the
        GetOutput() method assumes the output is of OutputImageType. For the
        GetOutput(unsigned int) method, a dynamic_cast is performed incase the
        filter has outputs of different types or image types. Derived classes
        should have names get methods for these outputs. 
        """
        return _ITKLabelMapBasePython.itkImageSourceLM2_GetOutput(self, *args)


    def GraftOutput(self, *args) -> "void":
        """
        GraftOutput(itkImageSourceLM2 self, itkDataObject output)
        GraftOutput(itkImageSourceLM2 self, std::string const & key, itkDataObject output)

        Graft the specified
        data object onto this ProcessObject's named output. This is similar to
        the GraftOutput method except it allows you to specify which output is
        affected. See the GraftOutput for general usage information. 
        """
        return _ITKLabelMapBasePython.itkImageSourceLM2_GraftOutput(self, *args)


    def GraftNthOutput(self, idx: 'unsigned int', output: 'itkDataObject') -> "void":
        """
        GraftNthOutput(itkImageSourceLM2 self, unsigned int idx, itkDataObject output)

        Graft the specified
        data object onto this ProcessObject's idx'th output. This is similar
        to the GraftOutput method except it allows you to specify which output
        is affected. The specified index must be a valid output number (less
        than ProcessObject::GetNumberOfIndexedOutputs()). See the GraftOutput
        for general usage information. 
        """
        return _ITKLabelMapBasePython.itkImageSourceLM2_GraftNthOutput(self, idx, output)


    def MakeOutput(self, *args) -> "itkDataObject_Pointer":
        """
        MakeOutput(itkImageSourceLM2 self, unsigned long idx) -> itkDataObject_Pointer
        MakeOutput(itkImageSourceLM2 self, std::string const & arg0) -> itkDataObject_Pointer

        Make a DataObject of the
        correct type to used as the specified output. Every ProcessObject
        subclass must be able to create a DataObject that can be used as a
        specified output. This method is automatically called when
        DataObject::DisconnectPipeline() is called.
        DataObject::DisconnectPipeline, disconnects a data object from being
        an output of its current source. When the data object is disconnected,
        the ProcessObject needs to construct a replacement output data object
        so that the ProcessObject is in a valid state. So
        DataObject::DisconnectPipeline eventually calls
        ProcessObject::MakeOutput. Note that MakeOutput always returns a
        SmartPointer to a DataObject. If a subclass of ImageSource has
        multiple outputs of different types, then that class must provide an
        implementation of MakeOutput(). 
        """
        return _ITKLabelMapBasePython.itkImageSourceLM2_MakeOutput(self, *args)

    __swig_destroy__ = _ITKLabelMapBasePython.delete_itkImageSourceLM2

    def cast(obj: 'itkLightObject') -> "itkImageSourceLM2 *":
        """cast(itkLightObject obj) -> itkImageSourceLM2"""
        return _ITKLabelMapBasePython.itkImageSourceLM2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageSourceLM2

        Create a new object of the class itkImageSourceLM2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageSourceLM2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageSourceLM2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageSourceLM2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageSourceLM2.GetOutput = new_instancemethod(_ITKLabelMapBasePython.itkImageSourceLM2_GetOutput, None, itkImageSourceLM2)
itkImageSourceLM2.GraftOutput = new_instancemethod(_ITKLabelMapBasePython.itkImageSourceLM2_GraftOutput, None, itkImageSourceLM2)
itkImageSourceLM2.GraftNthOutput = new_instancemethod(_ITKLabelMapBasePython.itkImageSourceLM2_GraftNthOutput, None, itkImageSourceLM2)
itkImageSourceLM2.MakeOutput = new_instancemethod(_ITKLabelMapBasePython.itkImageSourceLM2_MakeOutput, None, itkImageSourceLM2)
itkImageSourceLM2_swigregister = _ITKLabelMapBasePython.itkImageSourceLM2_swigregister
itkImageSourceLM2_swigregister(itkImageSourceLM2)

def itkImageSourceLM2_cast(obj: 'itkLightObject') -> "itkImageSourceLM2 *":
    """itkImageSourceLM2_cast(itkLightObject obj) -> itkImageSourceLM2"""
    return _ITKLabelMapBasePython.itkImageSourceLM2_cast(obj)

class itkImageSourceLM3(ITKCommonBasePython.itkProcessObject):
    """


    Base class for all process objects that output image data.

    ImageSource is the base class for all process objects that output
    image data. Specifically, this class defines the GetOutput() method
    that returns a pointer to the output image. The class also defines
    some internal private data members that are used to manage streaming
    of data.

    Memory management in an ImageSource is slightly different than a
    standard ProcessObject. ProcessObject's always release the bulk data
    associated with their output prior to GenerateData() being called.
    ImageSources default to not releasing the bulk data incase that
    particular memory block is large enough to hold the new output values.
    This avoids unnecessary deallocation/allocation sequences.
    ImageSource's can be forced to use a memory management model similar
    to the default ProcessObject behaviour by calling
    ProcessObject::ReleaseDataBeforeUpdateFlagOn(). A user may want to set
    this flag to limit peak memory usage during a pipeline update.

    \\sphinx
    \\sphinxexample{Core/Common/ProduceImageProgrammatically,Produce
    Image Programmatically} \\endsphinx

    C++ includes: itkImageSource.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def GetOutput(self, *args) -> "itkLabelMap3 *":
        """
        GetOutput(itkImageSourceLM3 self) -> itkLabelMap3
        GetOutput(itkImageSourceLM3 self) -> itkLabelMap3
        GetOutput(itkImageSourceLM3 self, unsigned int idx) -> itkLabelMap3

        Get the output data of
        this process object. The output of this function is not valid until an
        appropriate Update() method has been called, either explicitly or
        implicitly. Both the filter itself and the data object have Update()
        methods, and both methods update the data. Here are three ways to use
        GetOutput() and make sure the data is valid. In these examples, image
        is a pointer to some Image object, and the particular ProcessObjects
        involved are filters. The same examples apply to non-image (e.g. Mesh)
        data as well.

        In this situation, someFilter and anotherFilter are said to constitute
        a pipeline.

        (In the above example, the two lines of code can be in either order.)

        Note that Update() is not called automatically except within a
        pipeline as in the first example. When streaming (using a
        StreamingImageFilter) is activated, it may be more efficient to use a
        pipeline than to call Update() once for each filter in turn.

        For an image, the data generated is for the requested Region, which
        can be set using ImageBase::SetRequestedRegion(). By default, the
        largest possible region is requested.

        For Filters which have multiple outputs of different types, the
        GetOutput() method assumes the output is of OutputImageType. For the
        GetOutput(unsigned int) method, a dynamic_cast is performed incase the
        filter has outputs of different types or image types. Derived classes
        should have names get methods for these outputs. 
        """
        return _ITKLabelMapBasePython.itkImageSourceLM3_GetOutput(self, *args)


    def GraftOutput(self, *args) -> "void":
        """
        GraftOutput(itkImageSourceLM3 self, itkDataObject output)
        GraftOutput(itkImageSourceLM3 self, std::string const & key, itkDataObject output)

        Graft the specified
        data object onto this ProcessObject's named output. This is similar to
        the GraftOutput method except it allows you to specify which output is
        affected. See the GraftOutput for general usage information. 
        """
        return _ITKLabelMapBasePython.itkImageSourceLM3_GraftOutput(self, *args)


    def GraftNthOutput(self, idx: 'unsigned int', output: 'itkDataObject') -> "void":
        """
        GraftNthOutput(itkImageSourceLM3 self, unsigned int idx, itkDataObject output)

        Graft the specified
        data object onto this ProcessObject's idx'th output. This is similar
        to the GraftOutput method except it allows you to specify which output
        is affected. The specified index must be a valid output number (less
        than ProcessObject::GetNumberOfIndexedOutputs()). See the GraftOutput
        for general usage information. 
        """
        return _ITKLabelMapBasePython.itkImageSourceLM3_GraftNthOutput(self, idx, output)


    def MakeOutput(self, *args) -> "itkDataObject_Pointer":
        """
        MakeOutput(itkImageSourceLM3 self, unsigned long idx) -> itkDataObject_Pointer
        MakeOutput(itkImageSourceLM3 self, std::string const & arg0) -> itkDataObject_Pointer

        Make a DataObject of the
        correct type to used as the specified output. Every ProcessObject
        subclass must be able to create a DataObject that can be used as a
        specified output. This method is automatically called when
        DataObject::DisconnectPipeline() is called.
        DataObject::DisconnectPipeline, disconnects a data object from being
        an output of its current source. When the data object is disconnected,
        the ProcessObject needs to construct a replacement output data object
        so that the ProcessObject is in a valid state. So
        DataObject::DisconnectPipeline eventually calls
        ProcessObject::MakeOutput. Note that MakeOutput always returns a
        SmartPointer to a DataObject. If a subclass of ImageSource has
        multiple outputs of different types, then that class must provide an
        implementation of MakeOutput(). 
        """
        return _ITKLabelMapBasePython.itkImageSourceLM3_MakeOutput(self, *args)

    __swig_destroy__ = _ITKLabelMapBasePython.delete_itkImageSourceLM3

    def cast(obj: 'itkLightObject') -> "itkImageSourceLM3 *":
        """cast(itkLightObject obj) -> itkImageSourceLM3"""
        return _ITKLabelMapBasePython.itkImageSourceLM3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageSourceLM3

        Create a new object of the class itkImageSourceLM3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageSourceLM3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageSourceLM3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageSourceLM3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageSourceLM3.GetOutput = new_instancemethod(_ITKLabelMapBasePython.itkImageSourceLM3_GetOutput, None, itkImageSourceLM3)
itkImageSourceLM3.GraftOutput = new_instancemethod(_ITKLabelMapBasePython.itkImageSourceLM3_GraftOutput, None, itkImageSourceLM3)
itkImageSourceLM3.GraftNthOutput = new_instancemethod(_ITKLabelMapBasePython.itkImageSourceLM3_GraftNthOutput, None, itkImageSourceLM3)
itkImageSourceLM3.MakeOutput = new_instancemethod(_ITKLabelMapBasePython.itkImageSourceLM3_MakeOutput, None, itkImageSourceLM3)
itkImageSourceLM3_swigregister = _ITKLabelMapBasePython.itkImageSourceLM3_swigregister
itkImageSourceLM3_swigregister(itkImageSourceLM3)

def itkImageSourceLM3_cast(obj: 'itkLightObject') -> "itkImageSourceLM3 *":
    """itkImageSourceLM3_cast(itkLightObject obj) -> itkImageSourceLM3"""
    return _ITKLabelMapBasePython.itkImageSourceLM3_cast(obj)

class itkImageToImageFilterID2LM2(itkImageSourceLM2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterID2LM2 self, itkImageD2 image)
        SetInput(itkImageToImageFilterID2LM2 self, unsigned int arg0, itkImageD2 image)
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterID2LM2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageD2 const *":
        """
        GetInput(itkImageToImageFilterID2LM2 self) -> itkImageD2
        GetInput(itkImageToImageFilterID2LM2 self, unsigned int idx) -> itkImageD2
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterID2LM2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageD2') -> "void":
        """
        PushBackInput(itkImageToImageFilterID2LM2 self, itkImageD2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterID2LM2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterID2LM2 self)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterID2LM2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageD2') -> "void":
        """PushFrontInput(itkImageToImageFilterID2LM2 self, itkImageD2 image)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterID2LM2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterID2LM2 self)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterID2LM2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterID2LM2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterID2LM2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterID2LM2 self) -> double"""
        return _ITKLabelMapBasePython.itkImageToImageFilterID2LM2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterID2LM2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterID2LM2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterID2LM2 self) -> double"""
        return _ITKLabelMapBasePython.itkImageToImageFilterID2LM2_GetDirectionTolerance(self)

    __swig_destroy__ = _ITKLabelMapBasePython.delete_itkImageToImageFilterID2LM2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterID2LM2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterID2LM2"""
        return _ITKLabelMapBasePython.itkImageToImageFilterID2LM2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterID2LM2

        Create a new object of the class itkImageToImageFilterID2LM2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterID2LM2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterID2LM2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterID2LM2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterID2LM2.SetInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterID2LM2_SetInput, None, itkImageToImageFilterID2LM2)
itkImageToImageFilterID2LM2.GetInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterID2LM2_GetInput, None, itkImageToImageFilterID2LM2)
itkImageToImageFilterID2LM2.PushBackInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterID2LM2_PushBackInput, None, itkImageToImageFilterID2LM2)
itkImageToImageFilterID2LM2.PopBackInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterID2LM2_PopBackInput, None, itkImageToImageFilterID2LM2)
itkImageToImageFilterID2LM2.PushFrontInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterID2LM2_PushFrontInput, None, itkImageToImageFilterID2LM2)
itkImageToImageFilterID2LM2.PopFrontInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterID2LM2_PopFrontInput, None, itkImageToImageFilterID2LM2)
itkImageToImageFilterID2LM2.SetCoordinateTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterID2LM2_SetCoordinateTolerance, None, itkImageToImageFilterID2LM2)
itkImageToImageFilterID2LM2.GetCoordinateTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterID2LM2_GetCoordinateTolerance, None, itkImageToImageFilterID2LM2)
itkImageToImageFilterID2LM2.SetDirectionTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterID2LM2_SetDirectionTolerance, None, itkImageToImageFilterID2LM2)
itkImageToImageFilterID2LM2.GetDirectionTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterID2LM2_GetDirectionTolerance, None, itkImageToImageFilterID2LM2)
itkImageToImageFilterID2LM2_swigregister = _ITKLabelMapBasePython.itkImageToImageFilterID2LM2_swigregister
itkImageToImageFilterID2LM2_swigregister(itkImageToImageFilterID2LM2)

def itkImageToImageFilterID2LM2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterID2LM2 *":
    """itkImageToImageFilterID2LM2_cast(itkLightObject obj) -> itkImageToImageFilterID2LM2"""
    return _ITKLabelMapBasePython.itkImageToImageFilterID2LM2_cast(obj)

class itkImageToImageFilterID3LM3(itkImageSourceLM3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterID3LM3 self, itkImageD3 image)
        SetInput(itkImageToImageFilterID3LM3 self, unsigned int arg0, itkImageD3 image)
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterID3LM3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageD3 const *":
        """
        GetInput(itkImageToImageFilterID3LM3 self) -> itkImageD3
        GetInput(itkImageToImageFilterID3LM3 self, unsigned int idx) -> itkImageD3
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterID3LM3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageD3') -> "void":
        """
        PushBackInput(itkImageToImageFilterID3LM3 self, itkImageD3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterID3LM3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterID3LM3 self)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterID3LM3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageD3') -> "void":
        """PushFrontInput(itkImageToImageFilterID3LM3 self, itkImageD3 image)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterID3LM3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterID3LM3 self)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterID3LM3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterID3LM3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterID3LM3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterID3LM3 self) -> double"""
        return _ITKLabelMapBasePython.itkImageToImageFilterID3LM3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterID3LM3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterID3LM3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterID3LM3 self) -> double"""
        return _ITKLabelMapBasePython.itkImageToImageFilterID3LM3_GetDirectionTolerance(self)

    __swig_destroy__ = _ITKLabelMapBasePython.delete_itkImageToImageFilterID3LM3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterID3LM3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterID3LM3"""
        return _ITKLabelMapBasePython.itkImageToImageFilterID3LM3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterID3LM3

        Create a new object of the class itkImageToImageFilterID3LM3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterID3LM3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterID3LM3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterID3LM3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterID3LM3.SetInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterID3LM3_SetInput, None, itkImageToImageFilterID3LM3)
itkImageToImageFilterID3LM3.GetInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterID3LM3_GetInput, None, itkImageToImageFilterID3LM3)
itkImageToImageFilterID3LM3.PushBackInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterID3LM3_PushBackInput, None, itkImageToImageFilterID3LM3)
itkImageToImageFilterID3LM3.PopBackInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterID3LM3_PopBackInput, None, itkImageToImageFilterID3LM3)
itkImageToImageFilterID3LM3.PushFrontInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterID3LM3_PushFrontInput, None, itkImageToImageFilterID3LM3)
itkImageToImageFilterID3LM3.PopFrontInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterID3LM3_PopFrontInput, None, itkImageToImageFilterID3LM3)
itkImageToImageFilterID3LM3.SetCoordinateTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterID3LM3_SetCoordinateTolerance, None, itkImageToImageFilterID3LM3)
itkImageToImageFilterID3LM3.GetCoordinateTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterID3LM3_GetCoordinateTolerance, None, itkImageToImageFilterID3LM3)
itkImageToImageFilterID3LM3.SetDirectionTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterID3LM3_SetDirectionTolerance, None, itkImageToImageFilterID3LM3)
itkImageToImageFilterID3LM3.GetDirectionTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterID3LM3_GetDirectionTolerance, None, itkImageToImageFilterID3LM3)
itkImageToImageFilterID3LM3_swigregister = _ITKLabelMapBasePython.itkImageToImageFilterID3LM3_swigregister
itkImageToImageFilterID3LM3_swigregister(itkImageToImageFilterID3LM3)

def itkImageToImageFilterID3LM3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterID3LM3 *":
    """itkImageToImageFilterID3LM3_cast(itkLightObject obj) -> itkImageToImageFilterID3LM3"""
    return _ITKLabelMapBasePython.itkImageToImageFilterID3LM3_cast(obj)

class itkImageToImageFilterIF2LM2(itkImageSourceLM2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIF2LM2 self, itkImageF2 image)
        SetInput(itkImageToImageFilterIF2LM2 self, unsigned int arg0, itkImageF2 image)
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterIF2LM2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageF2 const *":
        """
        GetInput(itkImageToImageFilterIF2LM2 self) -> itkImageF2
        GetInput(itkImageToImageFilterIF2LM2 self, unsigned int idx) -> itkImageF2
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterIF2LM2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageF2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIF2LM2 self, itkImageF2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterIF2LM2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIF2LM2 self)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterIF2LM2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageF2') -> "void":
        """PushFrontInput(itkImageToImageFilterIF2LM2 self, itkImageF2 image)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterIF2LM2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIF2LM2 self)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterIF2LM2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIF2LM2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterIF2LM2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIF2LM2 self) -> double"""
        return _ITKLabelMapBasePython.itkImageToImageFilterIF2LM2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIF2LM2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterIF2LM2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIF2LM2 self) -> double"""
        return _ITKLabelMapBasePython.itkImageToImageFilterIF2LM2_GetDirectionTolerance(self)

    __swig_destroy__ = _ITKLabelMapBasePython.delete_itkImageToImageFilterIF2LM2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF2LM2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIF2LM2"""
        return _ITKLabelMapBasePython.itkImageToImageFilterIF2LM2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIF2LM2

        Create a new object of the class itkImageToImageFilterIF2LM2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIF2LM2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIF2LM2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIF2LM2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIF2LM2.SetInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterIF2LM2_SetInput, None, itkImageToImageFilterIF2LM2)
itkImageToImageFilterIF2LM2.GetInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterIF2LM2_GetInput, None, itkImageToImageFilterIF2LM2)
itkImageToImageFilterIF2LM2.PushBackInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterIF2LM2_PushBackInput, None, itkImageToImageFilterIF2LM2)
itkImageToImageFilterIF2LM2.PopBackInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterIF2LM2_PopBackInput, None, itkImageToImageFilterIF2LM2)
itkImageToImageFilterIF2LM2.PushFrontInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterIF2LM2_PushFrontInput, None, itkImageToImageFilterIF2LM2)
itkImageToImageFilterIF2LM2.PopFrontInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterIF2LM2_PopFrontInput, None, itkImageToImageFilterIF2LM2)
itkImageToImageFilterIF2LM2.SetCoordinateTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterIF2LM2_SetCoordinateTolerance, None, itkImageToImageFilterIF2LM2)
itkImageToImageFilterIF2LM2.GetCoordinateTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterIF2LM2_GetCoordinateTolerance, None, itkImageToImageFilterIF2LM2)
itkImageToImageFilterIF2LM2.SetDirectionTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterIF2LM2_SetDirectionTolerance, None, itkImageToImageFilterIF2LM2)
itkImageToImageFilterIF2LM2.GetDirectionTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterIF2LM2_GetDirectionTolerance, None, itkImageToImageFilterIF2LM2)
itkImageToImageFilterIF2LM2_swigregister = _ITKLabelMapBasePython.itkImageToImageFilterIF2LM2_swigregister
itkImageToImageFilterIF2LM2_swigregister(itkImageToImageFilterIF2LM2)

def itkImageToImageFilterIF2LM2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF2LM2 *":
    """itkImageToImageFilterIF2LM2_cast(itkLightObject obj) -> itkImageToImageFilterIF2LM2"""
    return _ITKLabelMapBasePython.itkImageToImageFilterIF2LM2_cast(obj)

class itkImageToImageFilterIF3LM3(itkImageSourceLM3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIF3LM3 self, itkImageF3 image)
        SetInput(itkImageToImageFilterIF3LM3 self, unsigned int arg0, itkImageF3 image)
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterIF3LM3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageF3 const *":
        """
        GetInput(itkImageToImageFilterIF3LM3 self) -> itkImageF3
        GetInput(itkImageToImageFilterIF3LM3 self, unsigned int idx) -> itkImageF3
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterIF3LM3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageF3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIF3LM3 self, itkImageF3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterIF3LM3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIF3LM3 self)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterIF3LM3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageF3') -> "void":
        """PushFrontInput(itkImageToImageFilterIF3LM3 self, itkImageF3 image)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterIF3LM3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIF3LM3 self)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterIF3LM3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIF3LM3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterIF3LM3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIF3LM3 self) -> double"""
        return _ITKLabelMapBasePython.itkImageToImageFilterIF3LM3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIF3LM3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterIF3LM3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIF3LM3 self) -> double"""
        return _ITKLabelMapBasePython.itkImageToImageFilterIF3LM3_GetDirectionTolerance(self)

    __swig_destroy__ = _ITKLabelMapBasePython.delete_itkImageToImageFilterIF3LM3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF3LM3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIF3LM3"""
        return _ITKLabelMapBasePython.itkImageToImageFilterIF3LM3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIF3LM3

        Create a new object of the class itkImageToImageFilterIF3LM3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIF3LM3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIF3LM3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIF3LM3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIF3LM3.SetInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterIF3LM3_SetInput, None, itkImageToImageFilterIF3LM3)
itkImageToImageFilterIF3LM3.GetInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterIF3LM3_GetInput, None, itkImageToImageFilterIF3LM3)
itkImageToImageFilterIF3LM3.PushBackInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterIF3LM3_PushBackInput, None, itkImageToImageFilterIF3LM3)
itkImageToImageFilterIF3LM3.PopBackInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterIF3LM3_PopBackInput, None, itkImageToImageFilterIF3LM3)
itkImageToImageFilterIF3LM3.PushFrontInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterIF3LM3_PushFrontInput, None, itkImageToImageFilterIF3LM3)
itkImageToImageFilterIF3LM3.PopFrontInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterIF3LM3_PopFrontInput, None, itkImageToImageFilterIF3LM3)
itkImageToImageFilterIF3LM3.SetCoordinateTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterIF3LM3_SetCoordinateTolerance, None, itkImageToImageFilterIF3LM3)
itkImageToImageFilterIF3LM3.GetCoordinateTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterIF3LM3_GetCoordinateTolerance, None, itkImageToImageFilterIF3LM3)
itkImageToImageFilterIF3LM3.SetDirectionTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterIF3LM3_SetDirectionTolerance, None, itkImageToImageFilterIF3LM3)
itkImageToImageFilterIF3LM3.GetDirectionTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterIF3LM3_GetDirectionTolerance, None, itkImageToImageFilterIF3LM3)
itkImageToImageFilterIF3LM3_swigregister = _ITKLabelMapBasePython.itkImageToImageFilterIF3LM3_swigregister
itkImageToImageFilterIF3LM3_swigregister(itkImageToImageFilterIF3LM3)

def itkImageToImageFilterIF3LM3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIF3LM3 *":
    """itkImageToImageFilterIF3LM3_cast(itkLightObject obj) -> itkImageToImageFilterIF3LM3"""
    return _ITKLabelMapBasePython.itkImageToImageFilterIF3LM3_cast(obj)

class itkImageToImageFilterISS2LM2(itkImageSourceLM2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterISS2LM2 self, itkImageSS2 image)
        SetInput(itkImageToImageFilterISS2LM2 self, unsigned int arg0, itkImageSS2 image)
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterISS2LM2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageSS2 const *":
        """
        GetInput(itkImageToImageFilterISS2LM2 self) -> itkImageSS2
        GetInput(itkImageToImageFilterISS2LM2 self, unsigned int idx) -> itkImageSS2
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterISS2LM2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageSS2') -> "void":
        """
        PushBackInput(itkImageToImageFilterISS2LM2 self, itkImageSS2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterISS2LM2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterISS2LM2 self)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterISS2LM2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageSS2') -> "void":
        """PushFrontInput(itkImageToImageFilterISS2LM2 self, itkImageSS2 image)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterISS2LM2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterISS2LM2 self)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterISS2LM2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterISS2LM2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterISS2LM2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterISS2LM2 self) -> double"""
        return _ITKLabelMapBasePython.itkImageToImageFilterISS2LM2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterISS2LM2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterISS2LM2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterISS2LM2 self) -> double"""
        return _ITKLabelMapBasePython.itkImageToImageFilterISS2LM2_GetDirectionTolerance(self)

    __swig_destroy__ = _ITKLabelMapBasePython.delete_itkImageToImageFilterISS2LM2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS2LM2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterISS2LM2"""
        return _ITKLabelMapBasePython.itkImageToImageFilterISS2LM2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterISS2LM2

        Create a new object of the class itkImageToImageFilterISS2LM2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterISS2LM2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterISS2LM2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterISS2LM2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterISS2LM2.SetInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterISS2LM2_SetInput, None, itkImageToImageFilterISS2LM2)
itkImageToImageFilterISS2LM2.GetInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterISS2LM2_GetInput, None, itkImageToImageFilterISS2LM2)
itkImageToImageFilterISS2LM2.PushBackInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterISS2LM2_PushBackInput, None, itkImageToImageFilterISS2LM2)
itkImageToImageFilterISS2LM2.PopBackInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterISS2LM2_PopBackInput, None, itkImageToImageFilterISS2LM2)
itkImageToImageFilterISS2LM2.PushFrontInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterISS2LM2_PushFrontInput, None, itkImageToImageFilterISS2LM2)
itkImageToImageFilterISS2LM2.PopFrontInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterISS2LM2_PopFrontInput, None, itkImageToImageFilterISS2LM2)
itkImageToImageFilterISS2LM2.SetCoordinateTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterISS2LM2_SetCoordinateTolerance, None, itkImageToImageFilterISS2LM2)
itkImageToImageFilterISS2LM2.GetCoordinateTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterISS2LM2_GetCoordinateTolerance, None, itkImageToImageFilterISS2LM2)
itkImageToImageFilterISS2LM2.SetDirectionTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterISS2LM2_SetDirectionTolerance, None, itkImageToImageFilterISS2LM2)
itkImageToImageFilterISS2LM2.GetDirectionTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterISS2LM2_GetDirectionTolerance, None, itkImageToImageFilterISS2LM2)
itkImageToImageFilterISS2LM2_swigregister = _ITKLabelMapBasePython.itkImageToImageFilterISS2LM2_swigregister
itkImageToImageFilterISS2LM2_swigregister(itkImageToImageFilterISS2LM2)

def itkImageToImageFilterISS2LM2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS2LM2 *":
    """itkImageToImageFilterISS2LM2_cast(itkLightObject obj) -> itkImageToImageFilterISS2LM2"""
    return _ITKLabelMapBasePython.itkImageToImageFilterISS2LM2_cast(obj)

class itkImageToImageFilterISS3LM3(itkImageSourceLM3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterISS3LM3 self, itkImageSS3 image)
        SetInput(itkImageToImageFilterISS3LM3 self, unsigned int arg0, itkImageSS3 image)
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterISS3LM3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageSS3 const *":
        """
        GetInput(itkImageToImageFilterISS3LM3 self) -> itkImageSS3
        GetInput(itkImageToImageFilterISS3LM3 self, unsigned int idx) -> itkImageSS3
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterISS3LM3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageSS3') -> "void":
        """
        PushBackInput(itkImageToImageFilterISS3LM3 self, itkImageSS3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterISS3LM3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterISS3LM3 self)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterISS3LM3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageSS3') -> "void":
        """PushFrontInput(itkImageToImageFilterISS3LM3 self, itkImageSS3 image)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterISS3LM3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterISS3LM3 self)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterISS3LM3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterISS3LM3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterISS3LM3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterISS3LM3 self) -> double"""
        return _ITKLabelMapBasePython.itkImageToImageFilterISS3LM3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterISS3LM3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterISS3LM3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterISS3LM3 self) -> double"""
        return _ITKLabelMapBasePython.itkImageToImageFilterISS3LM3_GetDirectionTolerance(self)

    __swig_destroy__ = _ITKLabelMapBasePython.delete_itkImageToImageFilterISS3LM3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS3LM3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterISS3LM3"""
        return _ITKLabelMapBasePython.itkImageToImageFilterISS3LM3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterISS3LM3

        Create a new object of the class itkImageToImageFilterISS3LM3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterISS3LM3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterISS3LM3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterISS3LM3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterISS3LM3.SetInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterISS3LM3_SetInput, None, itkImageToImageFilterISS3LM3)
itkImageToImageFilterISS3LM3.GetInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterISS3LM3_GetInput, None, itkImageToImageFilterISS3LM3)
itkImageToImageFilterISS3LM3.PushBackInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterISS3LM3_PushBackInput, None, itkImageToImageFilterISS3LM3)
itkImageToImageFilterISS3LM3.PopBackInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterISS3LM3_PopBackInput, None, itkImageToImageFilterISS3LM3)
itkImageToImageFilterISS3LM3.PushFrontInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterISS3LM3_PushFrontInput, None, itkImageToImageFilterISS3LM3)
itkImageToImageFilterISS3LM3.PopFrontInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterISS3LM3_PopFrontInput, None, itkImageToImageFilterISS3LM3)
itkImageToImageFilterISS3LM3.SetCoordinateTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterISS3LM3_SetCoordinateTolerance, None, itkImageToImageFilterISS3LM3)
itkImageToImageFilterISS3LM3.GetCoordinateTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterISS3LM3_GetCoordinateTolerance, None, itkImageToImageFilterISS3LM3)
itkImageToImageFilterISS3LM3.SetDirectionTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterISS3LM3_SetDirectionTolerance, None, itkImageToImageFilterISS3LM3)
itkImageToImageFilterISS3LM3.GetDirectionTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterISS3LM3_GetDirectionTolerance, None, itkImageToImageFilterISS3LM3)
itkImageToImageFilterISS3LM3_swigregister = _ITKLabelMapBasePython.itkImageToImageFilterISS3LM3_swigregister
itkImageToImageFilterISS3LM3_swigregister(itkImageToImageFilterISS3LM3)

def itkImageToImageFilterISS3LM3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterISS3LM3 *":
    """itkImageToImageFilterISS3LM3_cast(itkLightObject obj) -> itkImageToImageFilterISS3LM3"""
    return _ITKLabelMapBasePython.itkImageToImageFilterISS3LM3_cast(obj)

class itkImageToImageFilterIUC2LM2(itkImageSourceLM2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUC2LM2 self, itkImageUC2 image)
        SetInput(itkImageToImageFilterIUC2LM2 self, unsigned int arg0, itkImageUC2 image)
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterIUC2LM2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUC2 const *":
        """
        GetInput(itkImageToImageFilterIUC2LM2 self) -> itkImageUC2
        GetInput(itkImageToImageFilterIUC2LM2 self, unsigned int idx) -> itkImageUC2
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterIUC2LM2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUC2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUC2LM2 self, itkImageUC2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterIUC2LM2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUC2LM2 self)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterIUC2LM2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUC2') -> "void":
        """PushFrontInput(itkImageToImageFilterIUC2LM2 self, itkImageUC2 image)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterIUC2LM2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUC2LM2 self)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterIUC2LM2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUC2LM2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterIUC2LM2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUC2LM2 self) -> double"""
        return _ITKLabelMapBasePython.itkImageToImageFilterIUC2LM2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUC2LM2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterIUC2LM2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUC2LM2 self) -> double"""
        return _ITKLabelMapBasePython.itkImageToImageFilterIUC2LM2_GetDirectionTolerance(self)

    __swig_destroy__ = _ITKLabelMapBasePython.delete_itkImageToImageFilterIUC2LM2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC2LM2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUC2LM2"""
        return _ITKLabelMapBasePython.itkImageToImageFilterIUC2LM2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUC2LM2

        Create a new object of the class itkImageToImageFilterIUC2LM2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUC2LM2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUC2LM2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUC2LM2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUC2LM2.SetInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterIUC2LM2_SetInput, None, itkImageToImageFilterIUC2LM2)
itkImageToImageFilterIUC2LM2.GetInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterIUC2LM2_GetInput, None, itkImageToImageFilterIUC2LM2)
itkImageToImageFilterIUC2LM2.PushBackInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterIUC2LM2_PushBackInput, None, itkImageToImageFilterIUC2LM2)
itkImageToImageFilterIUC2LM2.PopBackInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterIUC2LM2_PopBackInput, None, itkImageToImageFilterIUC2LM2)
itkImageToImageFilterIUC2LM2.PushFrontInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterIUC2LM2_PushFrontInput, None, itkImageToImageFilterIUC2LM2)
itkImageToImageFilterIUC2LM2.PopFrontInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterIUC2LM2_PopFrontInput, None, itkImageToImageFilterIUC2LM2)
itkImageToImageFilterIUC2LM2.SetCoordinateTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterIUC2LM2_SetCoordinateTolerance, None, itkImageToImageFilterIUC2LM2)
itkImageToImageFilterIUC2LM2.GetCoordinateTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterIUC2LM2_GetCoordinateTolerance, None, itkImageToImageFilterIUC2LM2)
itkImageToImageFilterIUC2LM2.SetDirectionTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterIUC2LM2_SetDirectionTolerance, None, itkImageToImageFilterIUC2LM2)
itkImageToImageFilterIUC2LM2.GetDirectionTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterIUC2LM2_GetDirectionTolerance, None, itkImageToImageFilterIUC2LM2)
itkImageToImageFilterIUC2LM2_swigregister = _ITKLabelMapBasePython.itkImageToImageFilterIUC2LM2_swigregister
itkImageToImageFilterIUC2LM2_swigregister(itkImageToImageFilterIUC2LM2)

def itkImageToImageFilterIUC2LM2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC2LM2 *":
    """itkImageToImageFilterIUC2LM2_cast(itkLightObject obj) -> itkImageToImageFilterIUC2LM2"""
    return _ITKLabelMapBasePython.itkImageToImageFilterIUC2LM2_cast(obj)

class itkImageToImageFilterIUC3LM3(itkImageSourceLM3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUC3LM3 self, itkImageUC3 image)
        SetInput(itkImageToImageFilterIUC3LM3 self, unsigned int arg0, itkImageUC3 image)
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterIUC3LM3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUC3 const *":
        """
        GetInput(itkImageToImageFilterIUC3LM3 self) -> itkImageUC3
        GetInput(itkImageToImageFilterIUC3LM3 self, unsigned int idx) -> itkImageUC3
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterIUC3LM3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUC3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUC3LM3 self, itkImageUC3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterIUC3LM3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUC3LM3 self)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterIUC3LM3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUC3') -> "void":
        """PushFrontInput(itkImageToImageFilterIUC3LM3 self, itkImageUC3 image)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterIUC3LM3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUC3LM3 self)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterIUC3LM3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUC3LM3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterIUC3LM3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUC3LM3 self) -> double"""
        return _ITKLabelMapBasePython.itkImageToImageFilterIUC3LM3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUC3LM3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterIUC3LM3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUC3LM3 self) -> double"""
        return _ITKLabelMapBasePython.itkImageToImageFilterIUC3LM3_GetDirectionTolerance(self)

    __swig_destroy__ = _ITKLabelMapBasePython.delete_itkImageToImageFilterIUC3LM3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC3LM3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUC3LM3"""
        return _ITKLabelMapBasePython.itkImageToImageFilterIUC3LM3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUC3LM3

        Create a new object of the class itkImageToImageFilterIUC3LM3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUC3LM3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUC3LM3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUC3LM3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUC3LM3.SetInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterIUC3LM3_SetInput, None, itkImageToImageFilterIUC3LM3)
itkImageToImageFilterIUC3LM3.GetInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterIUC3LM3_GetInput, None, itkImageToImageFilterIUC3LM3)
itkImageToImageFilterIUC3LM3.PushBackInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterIUC3LM3_PushBackInput, None, itkImageToImageFilterIUC3LM3)
itkImageToImageFilterIUC3LM3.PopBackInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterIUC3LM3_PopBackInput, None, itkImageToImageFilterIUC3LM3)
itkImageToImageFilterIUC3LM3.PushFrontInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterIUC3LM3_PushFrontInput, None, itkImageToImageFilterIUC3LM3)
itkImageToImageFilterIUC3LM3.PopFrontInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterIUC3LM3_PopFrontInput, None, itkImageToImageFilterIUC3LM3)
itkImageToImageFilterIUC3LM3.SetCoordinateTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterIUC3LM3_SetCoordinateTolerance, None, itkImageToImageFilterIUC3LM3)
itkImageToImageFilterIUC3LM3.GetCoordinateTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterIUC3LM3_GetCoordinateTolerance, None, itkImageToImageFilterIUC3LM3)
itkImageToImageFilterIUC3LM3.SetDirectionTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterIUC3LM3_SetDirectionTolerance, None, itkImageToImageFilterIUC3LM3)
itkImageToImageFilterIUC3LM3.GetDirectionTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterIUC3LM3_GetDirectionTolerance, None, itkImageToImageFilterIUC3LM3)
itkImageToImageFilterIUC3LM3_swigregister = _ITKLabelMapBasePython.itkImageToImageFilterIUC3LM3_swigregister
itkImageToImageFilterIUC3LM3_swigregister(itkImageToImageFilterIUC3LM3)

def itkImageToImageFilterIUC3LM3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUC3LM3 *":
    """itkImageToImageFilterIUC3LM3_cast(itkLightObject obj) -> itkImageToImageFilterIUC3LM3"""
    return _ITKLabelMapBasePython.itkImageToImageFilterIUC3LM3_cast(obj)

class itkImageToImageFilterIUS2LM2(itkImageSourceLM2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUS2LM2 self, itkImageUS2 image)
        SetInput(itkImageToImageFilterIUS2LM2 self, unsigned int arg0, itkImageUS2 image)
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterIUS2LM2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUS2 const *":
        """
        GetInput(itkImageToImageFilterIUS2LM2 self) -> itkImageUS2
        GetInput(itkImageToImageFilterIUS2LM2 self, unsigned int idx) -> itkImageUS2
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterIUS2LM2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUS2') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUS2LM2 self, itkImageUS2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterIUS2LM2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUS2LM2 self)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterIUS2LM2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUS2') -> "void":
        """PushFrontInput(itkImageToImageFilterIUS2LM2 self, itkImageUS2 image)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterIUS2LM2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUS2LM2 self)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterIUS2LM2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUS2LM2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterIUS2LM2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUS2LM2 self) -> double"""
        return _ITKLabelMapBasePython.itkImageToImageFilterIUS2LM2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUS2LM2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterIUS2LM2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUS2LM2 self) -> double"""
        return _ITKLabelMapBasePython.itkImageToImageFilterIUS2LM2_GetDirectionTolerance(self)

    __swig_destroy__ = _ITKLabelMapBasePython.delete_itkImageToImageFilterIUS2LM2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS2LM2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUS2LM2"""
        return _ITKLabelMapBasePython.itkImageToImageFilterIUS2LM2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUS2LM2

        Create a new object of the class itkImageToImageFilterIUS2LM2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUS2LM2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUS2LM2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUS2LM2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUS2LM2.SetInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterIUS2LM2_SetInput, None, itkImageToImageFilterIUS2LM2)
itkImageToImageFilterIUS2LM2.GetInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterIUS2LM2_GetInput, None, itkImageToImageFilterIUS2LM2)
itkImageToImageFilterIUS2LM2.PushBackInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterIUS2LM2_PushBackInput, None, itkImageToImageFilterIUS2LM2)
itkImageToImageFilterIUS2LM2.PopBackInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterIUS2LM2_PopBackInput, None, itkImageToImageFilterIUS2LM2)
itkImageToImageFilterIUS2LM2.PushFrontInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterIUS2LM2_PushFrontInput, None, itkImageToImageFilterIUS2LM2)
itkImageToImageFilterIUS2LM2.PopFrontInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterIUS2LM2_PopFrontInput, None, itkImageToImageFilterIUS2LM2)
itkImageToImageFilterIUS2LM2.SetCoordinateTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterIUS2LM2_SetCoordinateTolerance, None, itkImageToImageFilterIUS2LM2)
itkImageToImageFilterIUS2LM2.GetCoordinateTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterIUS2LM2_GetCoordinateTolerance, None, itkImageToImageFilterIUS2LM2)
itkImageToImageFilterIUS2LM2.SetDirectionTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterIUS2LM2_SetDirectionTolerance, None, itkImageToImageFilterIUS2LM2)
itkImageToImageFilterIUS2LM2.GetDirectionTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterIUS2LM2_GetDirectionTolerance, None, itkImageToImageFilterIUS2LM2)
itkImageToImageFilterIUS2LM2_swigregister = _ITKLabelMapBasePython.itkImageToImageFilterIUS2LM2_swigregister
itkImageToImageFilterIUS2LM2_swigregister(itkImageToImageFilterIUS2LM2)

def itkImageToImageFilterIUS2LM2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS2LM2 *":
    """itkImageToImageFilterIUS2LM2_cast(itkLightObject obj) -> itkImageToImageFilterIUS2LM2"""
    return _ITKLabelMapBasePython.itkImageToImageFilterIUS2LM2_cast(obj)

class itkImageToImageFilterIUS3LM3(itkImageSourceLM3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterIUS3LM3 self, itkImageUS3 image)
        SetInput(itkImageToImageFilterIUS3LM3 self, unsigned int arg0, itkImageUS3 image)
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterIUS3LM3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkImageUS3 const *":
        """
        GetInput(itkImageToImageFilterIUS3LM3 self) -> itkImageUS3
        GetInput(itkImageToImageFilterIUS3LM3 self, unsigned int idx) -> itkImageUS3
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterIUS3LM3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkImageUS3') -> "void":
        """
        PushBackInput(itkImageToImageFilterIUS3LM3 self, itkImageUS3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterIUS3LM3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterIUS3LM3 self)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterIUS3LM3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkImageUS3') -> "void":
        """PushFrontInput(itkImageToImageFilterIUS3LM3 self, itkImageUS3 image)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterIUS3LM3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterIUS3LM3 self)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterIUS3LM3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterIUS3LM3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterIUS3LM3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterIUS3LM3 self) -> double"""
        return _ITKLabelMapBasePython.itkImageToImageFilterIUS3LM3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterIUS3LM3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterIUS3LM3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterIUS3LM3 self) -> double"""
        return _ITKLabelMapBasePython.itkImageToImageFilterIUS3LM3_GetDirectionTolerance(self)

    __swig_destroy__ = _ITKLabelMapBasePython.delete_itkImageToImageFilterIUS3LM3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS3LM3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterIUS3LM3"""
        return _ITKLabelMapBasePython.itkImageToImageFilterIUS3LM3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterIUS3LM3

        Create a new object of the class itkImageToImageFilterIUS3LM3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterIUS3LM3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterIUS3LM3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterIUS3LM3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterIUS3LM3.SetInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterIUS3LM3_SetInput, None, itkImageToImageFilterIUS3LM3)
itkImageToImageFilterIUS3LM3.GetInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterIUS3LM3_GetInput, None, itkImageToImageFilterIUS3LM3)
itkImageToImageFilterIUS3LM3.PushBackInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterIUS3LM3_PushBackInput, None, itkImageToImageFilterIUS3LM3)
itkImageToImageFilterIUS3LM3.PopBackInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterIUS3LM3_PopBackInput, None, itkImageToImageFilterIUS3LM3)
itkImageToImageFilterIUS3LM3.PushFrontInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterIUS3LM3_PushFrontInput, None, itkImageToImageFilterIUS3LM3)
itkImageToImageFilterIUS3LM3.PopFrontInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterIUS3LM3_PopFrontInput, None, itkImageToImageFilterIUS3LM3)
itkImageToImageFilterIUS3LM3.SetCoordinateTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterIUS3LM3_SetCoordinateTolerance, None, itkImageToImageFilterIUS3LM3)
itkImageToImageFilterIUS3LM3.GetCoordinateTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterIUS3LM3_GetCoordinateTolerance, None, itkImageToImageFilterIUS3LM3)
itkImageToImageFilterIUS3LM3.SetDirectionTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterIUS3LM3_SetDirectionTolerance, None, itkImageToImageFilterIUS3LM3)
itkImageToImageFilterIUS3LM3.GetDirectionTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterIUS3LM3_GetDirectionTolerance, None, itkImageToImageFilterIUS3LM3)
itkImageToImageFilterIUS3LM3_swigregister = _ITKLabelMapBasePython.itkImageToImageFilterIUS3LM3_swigregister
itkImageToImageFilterIUS3LM3_swigregister(itkImageToImageFilterIUS3LM3)

def itkImageToImageFilterIUS3LM3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterIUS3LM3 *":
    """itkImageToImageFilterIUS3LM3_cast(itkLightObject obj) -> itkImageToImageFilterIUS3LM3"""
    return _ITKLabelMapBasePython.itkImageToImageFilterIUS3LM3_cast(obj)

class itkImageToImageFilterLM2ID2(itkImageSourcePython.itkImageSourceID2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterLM2ID2 self, itkLabelMap2 image)
        SetInput(itkImageToImageFilterLM2ID2 self, unsigned int arg0, itkLabelMap2 image)
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2ID2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkLabelMap2 const *":
        """
        GetInput(itkImageToImageFilterLM2ID2 self) -> itkLabelMap2
        GetInput(itkImageToImageFilterLM2ID2 self, unsigned int idx) -> itkLabelMap2
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2ID2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkLabelMap2') -> "void":
        """
        PushBackInput(itkImageToImageFilterLM2ID2 self, itkLabelMap2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2ID2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterLM2ID2 self)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2ID2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkLabelMap2') -> "void":
        """PushFrontInput(itkImageToImageFilterLM2ID2 self, itkLabelMap2 image)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2ID2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterLM2ID2 self)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2ID2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterLM2ID2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2ID2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterLM2ID2 self) -> double"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2ID2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterLM2ID2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2ID2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterLM2ID2 self) -> double"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2ID2_GetDirectionTolerance(self)

    __swig_destroy__ = _ITKLabelMapBasePython.delete_itkImageToImageFilterLM2ID2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterLM2ID2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterLM2ID2"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2ID2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterLM2ID2

        Create a new object of the class itkImageToImageFilterLM2ID2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterLM2ID2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterLM2ID2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterLM2ID2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterLM2ID2.SetInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2ID2_SetInput, None, itkImageToImageFilterLM2ID2)
itkImageToImageFilterLM2ID2.GetInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2ID2_GetInput, None, itkImageToImageFilterLM2ID2)
itkImageToImageFilterLM2ID2.PushBackInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2ID2_PushBackInput, None, itkImageToImageFilterLM2ID2)
itkImageToImageFilterLM2ID2.PopBackInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2ID2_PopBackInput, None, itkImageToImageFilterLM2ID2)
itkImageToImageFilterLM2ID2.PushFrontInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2ID2_PushFrontInput, None, itkImageToImageFilterLM2ID2)
itkImageToImageFilterLM2ID2.PopFrontInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2ID2_PopFrontInput, None, itkImageToImageFilterLM2ID2)
itkImageToImageFilterLM2ID2.SetCoordinateTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2ID2_SetCoordinateTolerance, None, itkImageToImageFilterLM2ID2)
itkImageToImageFilterLM2ID2.GetCoordinateTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2ID2_GetCoordinateTolerance, None, itkImageToImageFilterLM2ID2)
itkImageToImageFilterLM2ID2.SetDirectionTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2ID2_SetDirectionTolerance, None, itkImageToImageFilterLM2ID2)
itkImageToImageFilterLM2ID2.GetDirectionTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2ID2_GetDirectionTolerance, None, itkImageToImageFilterLM2ID2)
itkImageToImageFilterLM2ID2_swigregister = _ITKLabelMapBasePython.itkImageToImageFilterLM2ID2_swigregister
itkImageToImageFilterLM2ID2_swigregister(itkImageToImageFilterLM2ID2)

def itkImageToImageFilterLM2ID2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterLM2ID2 *":
    """itkImageToImageFilterLM2ID2_cast(itkLightObject obj) -> itkImageToImageFilterLM2ID2"""
    return _ITKLabelMapBasePython.itkImageToImageFilterLM2ID2_cast(obj)

class itkImageToImageFilterLM2IF2(itkImageSourcePython.itkImageSourceIF2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterLM2IF2 self, itkLabelMap2 image)
        SetInput(itkImageToImageFilterLM2IF2 self, unsigned int arg0, itkLabelMap2 image)
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2IF2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkLabelMap2 const *":
        """
        GetInput(itkImageToImageFilterLM2IF2 self) -> itkLabelMap2
        GetInput(itkImageToImageFilterLM2IF2 self, unsigned int idx) -> itkLabelMap2
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2IF2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkLabelMap2') -> "void":
        """
        PushBackInput(itkImageToImageFilterLM2IF2 self, itkLabelMap2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2IF2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterLM2IF2 self)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2IF2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkLabelMap2') -> "void":
        """PushFrontInput(itkImageToImageFilterLM2IF2 self, itkLabelMap2 image)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2IF2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterLM2IF2 self)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2IF2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterLM2IF2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2IF2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterLM2IF2 self) -> double"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2IF2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterLM2IF2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2IF2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterLM2IF2 self) -> double"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2IF2_GetDirectionTolerance(self)

    __swig_destroy__ = _ITKLabelMapBasePython.delete_itkImageToImageFilterLM2IF2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterLM2IF2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterLM2IF2"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2IF2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterLM2IF2

        Create a new object of the class itkImageToImageFilterLM2IF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterLM2IF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterLM2IF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterLM2IF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterLM2IF2.SetInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2IF2_SetInput, None, itkImageToImageFilterLM2IF2)
itkImageToImageFilterLM2IF2.GetInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2IF2_GetInput, None, itkImageToImageFilterLM2IF2)
itkImageToImageFilterLM2IF2.PushBackInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2IF2_PushBackInput, None, itkImageToImageFilterLM2IF2)
itkImageToImageFilterLM2IF2.PopBackInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2IF2_PopBackInput, None, itkImageToImageFilterLM2IF2)
itkImageToImageFilterLM2IF2.PushFrontInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2IF2_PushFrontInput, None, itkImageToImageFilterLM2IF2)
itkImageToImageFilterLM2IF2.PopFrontInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2IF2_PopFrontInput, None, itkImageToImageFilterLM2IF2)
itkImageToImageFilterLM2IF2.SetCoordinateTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2IF2_SetCoordinateTolerance, None, itkImageToImageFilterLM2IF2)
itkImageToImageFilterLM2IF2.GetCoordinateTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2IF2_GetCoordinateTolerance, None, itkImageToImageFilterLM2IF2)
itkImageToImageFilterLM2IF2.SetDirectionTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2IF2_SetDirectionTolerance, None, itkImageToImageFilterLM2IF2)
itkImageToImageFilterLM2IF2.GetDirectionTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2IF2_GetDirectionTolerance, None, itkImageToImageFilterLM2IF2)
itkImageToImageFilterLM2IF2_swigregister = _ITKLabelMapBasePython.itkImageToImageFilterLM2IF2_swigregister
itkImageToImageFilterLM2IF2_swigregister(itkImageToImageFilterLM2IF2)

def itkImageToImageFilterLM2IF2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterLM2IF2 *":
    """itkImageToImageFilterLM2IF2_cast(itkLightObject obj) -> itkImageToImageFilterLM2IF2"""
    return _ITKLabelMapBasePython.itkImageToImageFilterLM2IF2_cast(obj)

class itkImageToImageFilterLM2IRGBUC2(itkImageSourcePython.itkImageSourceIRGBUC2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterLM2IRGBUC2 self, itkLabelMap2 image)
        SetInput(itkImageToImageFilterLM2IRGBUC2 self, unsigned int arg0, itkLabelMap2 image)
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2IRGBUC2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkLabelMap2 const *":
        """
        GetInput(itkImageToImageFilterLM2IRGBUC2 self) -> itkLabelMap2
        GetInput(itkImageToImageFilterLM2IRGBUC2 self, unsigned int idx) -> itkLabelMap2
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2IRGBUC2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkLabelMap2') -> "void":
        """
        PushBackInput(itkImageToImageFilterLM2IRGBUC2 self, itkLabelMap2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2IRGBUC2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterLM2IRGBUC2 self)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2IRGBUC2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkLabelMap2') -> "void":
        """PushFrontInput(itkImageToImageFilterLM2IRGBUC2 self, itkLabelMap2 image)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2IRGBUC2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterLM2IRGBUC2 self)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2IRGBUC2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterLM2IRGBUC2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2IRGBUC2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterLM2IRGBUC2 self) -> double"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2IRGBUC2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterLM2IRGBUC2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2IRGBUC2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterLM2IRGBUC2 self) -> double"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2IRGBUC2_GetDirectionTolerance(self)

    __swig_destroy__ = _ITKLabelMapBasePython.delete_itkImageToImageFilterLM2IRGBUC2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterLM2IRGBUC2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterLM2IRGBUC2"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2IRGBUC2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterLM2IRGBUC2

        Create a new object of the class itkImageToImageFilterLM2IRGBUC2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterLM2IRGBUC2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterLM2IRGBUC2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterLM2IRGBUC2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterLM2IRGBUC2.SetInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2IRGBUC2_SetInput, None, itkImageToImageFilterLM2IRGBUC2)
itkImageToImageFilterLM2IRGBUC2.GetInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2IRGBUC2_GetInput, None, itkImageToImageFilterLM2IRGBUC2)
itkImageToImageFilterLM2IRGBUC2.PushBackInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2IRGBUC2_PushBackInput, None, itkImageToImageFilterLM2IRGBUC2)
itkImageToImageFilterLM2IRGBUC2.PopBackInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2IRGBUC2_PopBackInput, None, itkImageToImageFilterLM2IRGBUC2)
itkImageToImageFilterLM2IRGBUC2.PushFrontInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2IRGBUC2_PushFrontInput, None, itkImageToImageFilterLM2IRGBUC2)
itkImageToImageFilterLM2IRGBUC2.PopFrontInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2IRGBUC2_PopFrontInput, None, itkImageToImageFilterLM2IRGBUC2)
itkImageToImageFilterLM2IRGBUC2.SetCoordinateTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2IRGBUC2_SetCoordinateTolerance, None, itkImageToImageFilterLM2IRGBUC2)
itkImageToImageFilterLM2IRGBUC2.GetCoordinateTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2IRGBUC2_GetCoordinateTolerance, None, itkImageToImageFilterLM2IRGBUC2)
itkImageToImageFilterLM2IRGBUC2.SetDirectionTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2IRGBUC2_SetDirectionTolerance, None, itkImageToImageFilterLM2IRGBUC2)
itkImageToImageFilterLM2IRGBUC2.GetDirectionTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2IRGBUC2_GetDirectionTolerance, None, itkImageToImageFilterLM2IRGBUC2)
itkImageToImageFilterLM2IRGBUC2_swigregister = _ITKLabelMapBasePython.itkImageToImageFilterLM2IRGBUC2_swigregister
itkImageToImageFilterLM2IRGBUC2_swigregister(itkImageToImageFilterLM2IRGBUC2)

def itkImageToImageFilterLM2IRGBUC2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterLM2IRGBUC2 *":
    """itkImageToImageFilterLM2IRGBUC2_cast(itkLightObject obj) -> itkImageToImageFilterLM2IRGBUC2"""
    return _ITKLabelMapBasePython.itkImageToImageFilterLM2IRGBUC2_cast(obj)

class itkImageToImageFilterLM2ISS2(itkImageSourcePython.itkImageSourceISS2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterLM2ISS2 self, itkLabelMap2 image)
        SetInput(itkImageToImageFilterLM2ISS2 self, unsigned int arg0, itkLabelMap2 image)
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2ISS2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkLabelMap2 const *":
        """
        GetInput(itkImageToImageFilterLM2ISS2 self) -> itkLabelMap2
        GetInput(itkImageToImageFilterLM2ISS2 self, unsigned int idx) -> itkLabelMap2
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2ISS2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkLabelMap2') -> "void":
        """
        PushBackInput(itkImageToImageFilterLM2ISS2 self, itkLabelMap2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2ISS2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterLM2ISS2 self)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2ISS2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkLabelMap2') -> "void":
        """PushFrontInput(itkImageToImageFilterLM2ISS2 self, itkLabelMap2 image)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2ISS2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterLM2ISS2 self)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2ISS2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterLM2ISS2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2ISS2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterLM2ISS2 self) -> double"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2ISS2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterLM2ISS2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2ISS2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterLM2ISS2 self) -> double"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2ISS2_GetDirectionTolerance(self)

    __swig_destroy__ = _ITKLabelMapBasePython.delete_itkImageToImageFilterLM2ISS2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterLM2ISS2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterLM2ISS2"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2ISS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterLM2ISS2

        Create a new object of the class itkImageToImageFilterLM2ISS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterLM2ISS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterLM2ISS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterLM2ISS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterLM2ISS2.SetInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2ISS2_SetInput, None, itkImageToImageFilterLM2ISS2)
itkImageToImageFilterLM2ISS2.GetInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2ISS2_GetInput, None, itkImageToImageFilterLM2ISS2)
itkImageToImageFilterLM2ISS2.PushBackInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2ISS2_PushBackInput, None, itkImageToImageFilterLM2ISS2)
itkImageToImageFilterLM2ISS2.PopBackInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2ISS2_PopBackInput, None, itkImageToImageFilterLM2ISS2)
itkImageToImageFilterLM2ISS2.PushFrontInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2ISS2_PushFrontInput, None, itkImageToImageFilterLM2ISS2)
itkImageToImageFilterLM2ISS2.PopFrontInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2ISS2_PopFrontInput, None, itkImageToImageFilterLM2ISS2)
itkImageToImageFilterLM2ISS2.SetCoordinateTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2ISS2_SetCoordinateTolerance, None, itkImageToImageFilterLM2ISS2)
itkImageToImageFilterLM2ISS2.GetCoordinateTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2ISS2_GetCoordinateTolerance, None, itkImageToImageFilterLM2ISS2)
itkImageToImageFilterLM2ISS2.SetDirectionTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2ISS2_SetDirectionTolerance, None, itkImageToImageFilterLM2ISS2)
itkImageToImageFilterLM2ISS2.GetDirectionTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2ISS2_GetDirectionTolerance, None, itkImageToImageFilterLM2ISS2)
itkImageToImageFilterLM2ISS2_swigregister = _ITKLabelMapBasePython.itkImageToImageFilterLM2ISS2_swigregister
itkImageToImageFilterLM2ISS2_swigregister(itkImageToImageFilterLM2ISS2)

def itkImageToImageFilterLM2ISS2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterLM2ISS2 *":
    """itkImageToImageFilterLM2ISS2_cast(itkLightObject obj) -> itkImageToImageFilterLM2ISS2"""
    return _ITKLabelMapBasePython.itkImageToImageFilterLM2ISS2_cast(obj)

class itkImageToImageFilterLM2IUC2(itkImageSourcePython.itkImageSourceIUC2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterLM2IUC2 self, itkLabelMap2 image)
        SetInput(itkImageToImageFilterLM2IUC2 self, unsigned int arg0, itkLabelMap2 image)
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2IUC2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkLabelMap2 const *":
        """
        GetInput(itkImageToImageFilterLM2IUC2 self) -> itkLabelMap2
        GetInput(itkImageToImageFilterLM2IUC2 self, unsigned int idx) -> itkLabelMap2
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2IUC2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkLabelMap2') -> "void":
        """
        PushBackInput(itkImageToImageFilterLM2IUC2 self, itkLabelMap2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2IUC2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterLM2IUC2 self)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2IUC2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkLabelMap2') -> "void":
        """PushFrontInput(itkImageToImageFilterLM2IUC2 self, itkLabelMap2 image)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2IUC2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterLM2IUC2 self)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2IUC2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterLM2IUC2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2IUC2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterLM2IUC2 self) -> double"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2IUC2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterLM2IUC2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2IUC2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterLM2IUC2 self) -> double"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2IUC2_GetDirectionTolerance(self)

    __swig_destroy__ = _ITKLabelMapBasePython.delete_itkImageToImageFilterLM2IUC2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterLM2IUC2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterLM2IUC2"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2IUC2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterLM2IUC2

        Create a new object of the class itkImageToImageFilterLM2IUC2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterLM2IUC2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterLM2IUC2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterLM2IUC2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterLM2IUC2.SetInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2IUC2_SetInput, None, itkImageToImageFilterLM2IUC2)
itkImageToImageFilterLM2IUC2.GetInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2IUC2_GetInput, None, itkImageToImageFilterLM2IUC2)
itkImageToImageFilterLM2IUC2.PushBackInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2IUC2_PushBackInput, None, itkImageToImageFilterLM2IUC2)
itkImageToImageFilterLM2IUC2.PopBackInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2IUC2_PopBackInput, None, itkImageToImageFilterLM2IUC2)
itkImageToImageFilterLM2IUC2.PushFrontInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2IUC2_PushFrontInput, None, itkImageToImageFilterLM2IUC2)
itkImageToImageFilterLM2IUC2.PopFrontInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2IUC2_PopFrontInput, None, itkImageToImageFilterLM2IUC2)
itkImageToImageFilterLM2IUC2.SetCoordinateTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2IUC2_SetCoordinateTolerance, None, itkImageToImageFilterLM2IUC2)
itkImageToImageFilterLM2IUC2.GetCoordinateTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2IUC2_GetCoordinateTolerance, None, itkImageToImageFilterLM2IUC2)
itkImageToImageFilterLM2IUC2.SetDirectionTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2IUC2_SetDirectionTolerance, None, itkImageToImageFilterLM2IUC2)
itkImageToImageFilterLM2IUC2.GetDirectionTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2IUC2_GetDirectionTolerance, None, itkImageToImageFilterLM2IUC2)
itkImageToImageFilterLM2IUC2_swigregister = _ITKLabelMapBasePython.itkImageToImageFilterLM2IUC2_swigregister
itkImageToImageFilterLM2IUC2_swigregister(itkImageToImageFilterLM2IUC2)

def itkImageToImageFilterLM2IUC2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterLM2IUC2 *":
    """itkImageToImageFilterLM2IUC2_cast(itkLightObject obj) -> itkImageToImageFilterLM2IUC2"""
    return _ITKLabelMapBasePython.itkImageToImageFilterLM2IUC2_cast(obj)

class itkImageToImageFilterLM2IUS2(itkImageSourcePython.itkImageSourceIUS2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterLM2IUS2 self, itkLabelMap2 image)
        SetInput(itkImageToImageFilterLM2IUS2 self, unsigned int arg0, itkLabelMap2 image)
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2IUS2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkLabelMap2 const *":
        """
        GetInput(itkImageToImageFilterLM2IUS2 self) -> itkLabelMap2
        GetInput(itkImageToImageFilterLM2IUS2 self, unsigned int idx) -> itkLabelMap2
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2IUS2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkLabelMap2') -> "void":
        """
        PushBackInput(itkImageToImageFilterLM2IUS2 self, itkLabelMap2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2IUS2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterLM2IUS2 self)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2IUS2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkLabelMap2') -> "void":
        """PushFrontInput(itkImageToImageFilterLM2IUS2 self, itkLabelMap2 image)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2IUS2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterLM2IUS2 self)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2IUS2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterLM2IUS2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2IUS2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterLM2IUS2 self) -> double"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2IUS2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterLM2IUS2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2IUS2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterLM2IUS2 self) -> double"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2IUS2_GetDirectionTolerance(self)

    __swig_destroy__ = _ITKLabelMapBasePython.delete_itkImageToImageFilterLM2IUS2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterLM2IUS2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterLM2IUS2"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2IUS2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterLM2IUS2

        Create a new object of the class itkImageToImageFilterLM2IUS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterLM2IUS2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterLM2IUS2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterLM2IUS2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterLM2IUS2.SetInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2IUS2_SetInput, None, itkImageToImageFilterLM2IUS2)
itkImageToImageFilterLM2IUS2.GetInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2IUS2_GetInput, None, itkImageToImageFilterLM2IUS2)
itkImageToImageFilterLM2IUS2.PushBackInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2IUS2_PushBackInput, None, itkImageToImageFilterLM2IUS2)
itkImageToImageFilterLM2IUS2.PopBackInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2IUS2_PopBackInput, None, itkImageToImageFilterLM2IUS2)
itkImageToImageFilterLM2IUS2.PushFrontInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2IUS2_PushFrontInput, None, itkImageToImageFilterLM2IUS2)
itkImageToImageFilterLM2IUS2.PopFrontInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2IUS2_PopFrontInput, None, itkImageToImageFilterLM2IUS2)
itkImageToImageFilterLM2IUS2.SetCoordinateTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2IUS2_SetCoordinateTolerance, None, itkImageToImageFilterLM2IUS2)
itkImageToImageFilterLM2IUS2.GetCoordinateTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2IUS2_GetCoordinateTolerance, None, itkImageToImageFilterLM2IUS2)
itkImageToImageFilterLM2IUS2.SetDirectionTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2IUS2_SetDirectionTolerance, None, itkImageToImageFilterLM2IUS2)
itkImageToImageFilterLM2IUS2.GetDirectionTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2IUS2_GetDirectionTolerance, None, itkImageToImageFilterLM2IUS2)
itkImageToImageFilterLM2IUS2_swigregister = _ITKLabelMapBasePython.itkImageToImageFilterLM2IUS2_swigregister
itkImageToImageFilterLM2IUS2_swigregister(itkImageToImageFilterLM2IUS2)

def itkImageToImageFilterLM2IUS2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterLM2IUS2 *":
    """itkImageToImageFilterLM2IUS2_cast(itkLightObject obj) -> itkImageToImageFilterLM2IUS2"""
    return _ITKLabelMapBasePython.itkImageToImageFilterLM2IUS2_cast(obj)

class itkImageToImageFilterLM2LM2(itkImageSourceLM2):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterLM2LM2 self, itkLabelMap2 image)
        SetInput(itkImageToImageFilterLM2LM2 self, unsigned int arg0, itkLabelMap2 image)
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2LM2_SetInput(self, *args)


    def GetInput(self, *args) -> "itkLabelMap2 const *":
        """
        GetInput(itkImageToImageFilterLM2LM2 self) -> itkLabelMap2
        GetInput(itkImageToImageFilterLM2LM2 self, unsigned int idx) -> itkLabelMap2
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2LM2_GetInput(self, *args)


    def PushBackInput(self, image: 'itkLabelMap2') -> "void":
        """
        PushBackInput(itkImageToImageFilterLM2LM2 self, itkLabelMap2 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2LM2_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterLM2LM2 self)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2LM2_PopBackInput(self)


    def PushFrontInput(self, image: 'itkLabelMap2') -> "void":
        """PushFrontInput(itkImageToImageFilterLM2LM2 self, itkLabelMap2 image)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2LM2_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterLM2LM2 self)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2LM2_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterLM2LM2 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2LM2_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterLM2LM2 self) -> double"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2LM2_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterLM2LM2 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2LM2_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterLM2LM2 self) -> double"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2LM2_GetDirectionTolerance(self)

    __swig_destroy__ = _ITKLabelMapBasePython.delete_itkImageToImageFilterLM2LM2

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterLM2LM2 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterLM2LM2"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM2LM2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterLM2LM2

        Create a new object of the class itkImageToImageFilterLM2LM2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterLM2LM2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterLM2LM2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterLM2LM2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterLM2LM2.SetInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2LM2_SetInput, None, itkImageToImageFilterLM2LM2)
itkImageToImageFilterLM2LM2.GetInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2LM2_GetInput, None, itkImageToImageFilterLM2LM2)
itkImageToImageFilterLM2LM2.PushBackInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2LM2_PushBackInput, None, itkImageToImageFilterLM2LM2)
itkImageToImageFilterLM2LM2.PopBackInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2LM2_PopBackInput, None, itkImageToImageFilterLM2LM2)
itkImageToImageFilterLM2LM2.PushFrontInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2LM2_PushFrontInput, None, itkImageToImageFilterLM2LM2)
itkImageToImageFilterLM2LM2.PopFrontInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2LM2_PopFrontInput, None, itkImageToImageFilterLM2LM2)
itkImageToImageFilterLM2LM2.SetCoordinateTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2LM2_SetCoordinateTolerance, None, itkImageToImageFilterLM2LM2)
itkImageToImageFilterLM2LM2.GetCoordinateTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2LM2_GetCoordinateTolerance, None, itkImageToImageFilterLM2LM2)
itkImageToImageFilterLM2LM2.SetDirectionTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2LM2_SetDirectionTolerance, None, itkImageToImageFilterLM2LM2)
itkImageToImageFilterLM2LM2.GetDirectionTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM2LM2_GetDirectionTolerance, None, itkImageToImageFilterLM2LM2)
itkImageToImageFilterLM2LM2_swigregister = _ITKLabelMapBasePython.itkImageToImageFilterLM2LM2_swigregister
itkImageToImageFilterLM2LM2_swigregister(itkImageToImageFilterLM2LM2)

def itkImageToImageFilterLM2LM2_cast(obj: 'itkLightObject') -> "itkImageToImageFilterLM2LM2 *":
    """itkImageToImageFilterLM2LM2_cast(itkLightObject obj) -> itkImageToImageFilterLM2LM2"""
    return _ITKLabelMapBasePython.itkImageToImageFilterLM2LM2_cast(obj)

class itkImageToImageFilterLM3ID3(itkImageSourcePython.itkImageSourceID3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterLM3ID3 self, itkLabelMap3 image)
        SetInput(itkImageToImageFilterLM3ID3 self, unsigned int arg0, itkLabelMap3 image)
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3ID3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkLabelMap3 const *":
        """
        GetInput(itkImageToImageFilterLM3ID3 self) -> itkLabelMap3
        GetInput(itkImageToImageFilterLM3ID3 self, unsigned int idx) -> itkLabelMap3
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3ID3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkLabelMap3') -> "void":
        """
        PushBackInput(itkImageToImageFilterLM3ID3 self, itkLabelMap3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3ID3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterLM3ID3 self)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3ID3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkLabelMap3') -> "void":
        """PushFrontInput(itkImageToImageFilterLM3ID3 self, itkLabelMap3 image)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3ID3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterLM3ID3 self)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3ID3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterLM3ID3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3ID3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterLM3ID3 self) -> double"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3ID3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterLM3ID3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3ID3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterLM3ID3 self) -> double"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3ID3_GetDirectionTolerance(self)

    __swig_destroy__ = _ITKLabelMapBasePython.delete_itkImageToImageFilterLM3ID3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterLM3ID3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterLM3ID3"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3ID3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterLM3ID3

        Create a new object of the class itkImageToImageFilterLM3ID3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterLM3ID3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterLM3ID3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterLM3ID3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterLM3ID3.SetInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3ID3_SetInput, None, itkImageToImageFilterLM3ID3)
itkImageToImageFilterLM3ID3.GetInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3ID3_GetInput, None, itkImageToImageFilterLM3ID3)
itkImageToImageFilterLM3ID3.PushBackInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3ID3_PushBackInput, None, itkImageToImageFilterLM3ID3)
itkImageToImageFilterLM3ID3.PopBackInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3ID3_PopBackInput, None, itkImageToImageFilterLM3ID3)
itkImageToImageFilterLM3ID3.PushFrontInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3ID3_PushFrontInput, None, itkImageToImageFilterLM3ID3)
itkImageToImageFilterLM3ID3.PopFrontInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3ID3_PopFrontInput, None, itkImageToImageFilterLM3ID3)
itkImageToImageFilterLM3ID3.SetCoordinateTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3ID3_SetCoordinateTolerance, None, itkImageToImageFilterLM3ID3)
itkImageToImageFilterLM3ID3.GetCoordinateTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3ID3_GetCoordinateTolerance, None, itkImageToImageFilterLM3ID3)
itkImageToImageFilterLM3ID3.SetDirectionTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3ID3_SetDirectionTolerance, None, itkImageToImageFilterLM3ID3)
itkImageToImageFilterLM3ID3.GetDirectionTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3ID3_GetDirectionTolerance, None, itkImageToImageFilterLM3ID3)
itkImageToImageFilterLM3ID3_swigregister = _ITKLabelMapBasePython.itkImageToImageFilterLM3ID3_swigregister
itkImageToImageFilterLM3ID3_swigregister(itkImageToImageFilterLM3ID3)

def itkImageToImageFilterLM3ID3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterLM3ID3 *":
    """itkImageToImageFilterLM3ID3_cast(itkLightObject obj) -> itkImageToImageFilterLM3ID3"""
    return _ITKLabelMapBasePython.itkImageToImageFilterLM3ID3_cast(obj)

class itkImageToImageFilterLM3IF3(itkImageSourcePython.itkImageSourceIF3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterLM3IF3 self, itkLabelMap3 image)
        SetInput(itkImageToImageFilterLM3IF3 self, unsigned int arg0, itkLabelMap3 image)
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3IF3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkLabelMap3 const *":
        """
        GetInput(itkImageToImageFilterLM3IF3 self) -> itkLabelMap3
        GetInput(itkImageToImageFilterLM3IF3 self, unsigned int idx) -> itkLabelMap3
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3IF3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkLabelMap3') -> "void":
        """
        PushBackInput(itkImageToImageFilterLM3IF3 self, itkLabelMap3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3IF3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterLM3IF3 self)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3IF3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkLabelMap3') -> "void":
        """PushFrontInput(itkImageToImageFilterLM3IF3 self, itkLabelMap3 image)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3IF3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterLM3IF3 self)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3IF3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterLM3IF3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3IF3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterLM3IF3 self) -> double"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3IF3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterLM3IF3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3IF3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterLM3IF3 self) -> double"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3IF3_GetDirectionTolerance(self)

    __swig_destroy__ = _ITKLabelMapBasePython.delete_itkImageToImageFilterLM3IF3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterLM3IF3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterLM3IF3"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3IF3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterLM3IF3

        Create a new object of the class itkImageToImageFilterLM3IF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterLM3IF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterLM3IF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterLM3IF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterLM3IF3.SetInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3IF3_SetInput, None, itkImageToImageFilterLM3IF3)
itkImageToImageFilterLM3IF3.GetInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3IF3_GetInput, None, itkImageToImageFilterLM3IF3)
itkImageToImageFilterLM3IF3.PushBackInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3IF3_PushBackInput, None, itkImageToImageFilterLM3IF3)
itkImageToImageFilterLM3IF3.PopBackInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3IF3_PopBackInput, None, itkImageToImageFilterLM3IF3)
itkImageToImageFilterLM3IF3.PushFrontInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3IF3_PushFrontInput, None, itkImageToImageFilterLM3IF3)
itkImageToImageFilterLM3IF3.PopFrontInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3IF3_PopFrontInput, None, itkImageToImageFilterLM3IF3)
itkImageToImageFilterLM3IF3.SetCoordinateTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3IF3_SetCoordinateTolerance, None, itkImageToImageFilterLM3IF3)
itkImageToImageFilterLM3IF3.GetCoordinateTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3IF3_GetCoordinateTolerance, None, itkImageToImageFilterLM3IF3)
itkImageToImageFilterLM3IF3.SetDirectionTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3IF3_SetDirectionTolerance, None, itkImageToImageFilterLM3IF3)
itkImageToImageFilterLM3IF3.GetDirectionTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3IF3_GetDirectionTolerance, None, itkImageToImageFilterLM3IF3)
itkImageToImageFilterLM3IF3_swigregister = _ITKLabelMapBasePython.itkImageToImageFilterLM3IF3_swigregister
itkImageToImageFilterLM3IF3_swigregister(itkImageToImageFilterLM3IF3)

def itkImageToImageFilterLM3IF3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterLM3IF3 *":
    """itkImageToImageFilterLM3IF3_cast(itkLightObject obj) -> itkImageToImageFilterLM3IF3"""
    return _ITKLabelMapBasePython.itkImageToImageFilterLM3IF3_cast(obj)

class itkImageToImageFilterLM3IRGBUC3(itkImageSourcePython.itkImageSourceIRGBUC3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterLM3IRGBUC3 self, itkLabelMap3 image)
        SetInput(itkImageToImageFilterLM3IRGBUC3 self, unsigned int arg0, itkLabelMap3 image)
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3IRGBUC3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkLabelMap3 const *":
        """
        GetInput(itkImageToImageFilterLM3IRGBUC3 self) -> itkLabelMap3
        GetInput(itkImageToImageFilterLM3IRGBUC3 self, unsigned int idx) -> itkLabelMap3
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3IRGBUC3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkLabelMap3') -> "void":
        """
        PushBackInput(itkImageToImageFilterLM3IRGBUC3 self, itkLabelMap3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3IRGBUC3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterLM3IRGBUC3 self)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3IRGBUC3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkLabelMap3') -> "void":
        """PushFrontInput(itkImageToImageFilterLM3IRGBUC3 self, itkLabelMap3 image)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3IRGBUC3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterLM3IRGBUC3 self)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3IRGBUC3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterLM3IRGBUC3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3IRGBUC3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterLM3IRGBUC3 self) -> double"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3IRGBUC3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterLM3IRGBUC3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3IRGBUC3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterLM3IRGBUC3 self) -> double"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3IRGBUC3_GetDirectionTolerance(self)

    __swig_destroy__ = _ITKLabelMapBasePython.delete_itkImageToImageFilterLM3IRGBUC3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterLM3IRGBUC3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterLM3IRGBUC3"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3IRGBUC3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterLM3IRGBUC3

        Create a new object of the class itkImageToImageFilterLM3IRGBUC3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterLM3IRGBUC3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterLM3IRGBUC3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterLM3IRGBUC3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterLM3IRGBUC3.SetInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3IRGBUC3_SetInput, None, itkImageToImageFilterLM3IRGBUC3)
itkImageToImageFilterLM3IRGBUC3.GetInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3IRGBUC3_GetInput, None, itkImageToImageFilterLM3IRGBUC3)
itkImageToImageFilterLM3IRGBUC3.PushBackInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3IRGBUC3_PushBackInput, None, itkImageToImageFilterLM3IRGBUC3)
itkImageToImageFilterLM3IRGBUC3.PopBackInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3IRGBUC3_PopBackInput, None, itkImageToImageFilterLM3IRGBUC3)
itkImageToImageFilterLM3IRGBUC3.PushFrontInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3IRGBUC3_PushFrontInput, None, itkImageToImageFilterLM3IRGBUC3)
itkImageToImageFilterLM3IRGBUC3.PopFrontInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3IRGBUC3_PopFrontInput, None, itkImageToImageFilterLM3IRGBUC3)
itkImageToImageFilterLM3IRGBUC3.SetCoordinateTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3IRGBUC3_SetCoordinateTolerance, None, itkImageToImageFilterLM3IRGBUC3)
itkImageToImageFilterLM3IRGBUC3.GetCoordinateTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3IRGBUC3_GetCoordinateTolerance, None, itkImageToImageFilterLM3IRGBUC3)
itkImageToImageFilterLM3IRGBUC3.SetDirectionTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3IRGBUC3_SetDirectionTolerance, None, itkImageToImageFilterLM3IRGBUC3)
itkImageToImageFilterLM3IRGBUC3.GetDirectionTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3IRGBUC3_GetDirectionTolerance, None, itkImageToImageFilterLM3IRGBUC3)
itkImageToImageFilterLM3IRGBUC3_swigregister = _ITKLabelMapBasePython.itkImageToImageFilterLM3IRGBUC3_swigregister
itkImageToImageFilterLM3IRGBUC3_swigregister(itkImageToImageFilterLM3IRGBUC3)

def itkImageToImageFilterLM3IRGBUC3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterLM3IRGBUC3 *":
    """itkImageToImageFilterLM3IRGBUC3_cast(itkLightObject obj) -> itkImageToImageFilterLM3IRGBUC3"""
    return _ITKLabelMapBasePython.itkImageToImageFilterLM3IRGBUC3_cast(obj)

class itkImageToImageFilterLM3ISS3(itkImageSourcePython.itkImageSourceISS3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterLM3ISS3 self, itkLabelMap3 image)
        SetInput(itkImageToImageFilterLM3ISS3 self, unsigned int arg0, itkLabelMap3 image)
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3ISS3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkLabelMap3 const *":
        """
        GetInput(itkImageToImageFilterLM3ISS3 self) -> itkLabelMap3
        GetInput(itkImageToImageFilterLM3ISS3 self, unsigned int idx) -> itkLabelMap3
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3ISS3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkLabelMap3') -> "void":
        """
        PushBackInput(itkImageToImageFilterLM3ISS3 self, itkLabelMap3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3ISS3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterLM3ISS3 self)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3ISS3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkLabelMap3') -> "void":
        """PushFrontInput(itkImageToImageFilterLM3ISS3 self, itkLabelMap3 image)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3ISS3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterLM3ISS3 self)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3ISS3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterLM3ISS3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3ISS3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterLM3ISS3 self) -> double"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3ISS3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterLM3ISS3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3ISS3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterLM3ISS3 self) -> double"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3ISS3_GetDirectionTolerance(self)

    __swig_destroy__ = _ITKLabelMapBasePython.delete_itkImageToImageFilterLM3ISS3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterLM3ISS3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterLM3ISS3"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3ISS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterLM3ISS3

        Create a new object of the class itkImageToImageFilterLM3ISS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterLM3ISS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterLM3ISS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterLM3ISS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterLM3ISS3.SetInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3ISS3_SetInput, None, itkImageToImageFilterLM3ISS3)
itkImageToImageFilterLM3ISS3.GetInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3ISS3_GetInput, None, itkImageToImageFilterLM3ISS3)
itkImageToImageFilterLM3ISS3.PushBackInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3ISS3_PushBackInput, None, itkImageToImageFilterLM3ISS3)
itkImageToImageFilterLM3ISS3.PopBackInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3ISS3_PopBackInput, None, itkImageToImageFilterLM3ISS3)
itkImageToImageFilterLM3ISS3.PushFrontInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3ISS3_PushFrontInput, None, itkImageToImageFilterLM3ISS3)
itkImageToImageFilterLM3ISS3.PopFrontInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3ISS3_PopFrontInput, None, itkImageToImageFilterLM3ISS3)
itkImageToImageFilterLM3ISS3.SetCoordinateTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3ISS3_SetCoordinateTolerance, None, itkImageToImageFilterLM3ISS3)
itkImageToImageFilterLM3ISS3.GetCoordinateTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3ISS3_GetCoordinateTolerance, None, itkImageToImageFilterLM3ISS3)
itkImageToImageFilterLM3ISS3.SetDirectionTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3ISS3_SetDirectionTolerance, None, itkImageToImageFilterLM3ISS3)
itkImageToImageFilterLM3ISS3.GetDirectionTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3ISS3_GetDirectionTolerance, None, itkImageToImageFilterLM3ISS3)
itkImageToImageFilterLM3ISS3_swigregister = _ITKLabelMapBasePython.itkImageToImageFilterLM3ISS3_swigregister
itkImageToImageFilterLM3ISS3_swigregister(itkImageToImageFilterLM3ISS3)

def itkImageToImageFilterLM3ISS3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterLM3ISS3 *":
    """itkImageToImageFilterLM3ISS3_cast(itkLightObject obj) -> itkImageToImageFilterLM3ISS3"""
    return _ITKLabelMapBasePython.itkImageToImageFilterLM3ISS3_cast(obj)

class itkImageToImageFilterLM3IUC3(itkImageSourcePython.itkImageSourceIUC3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterLM3IUC3 self, itkLabelMap3 image)
        SetInput(itkImageToImageFilterLM3IUC3 self, unsigned int arg0, itkLabelMap3 image)
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3IUC3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkLabelMap3 const *":
        """
        GetInput(itkImageToImageFilterLM3IUC3 self) -> itkLabelMap3
        GetInput(itkImageToImageFilterLM3IUC3 self, unsigned int idx) -> itkLabelMap3
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3IUC3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkLabelMap3') -> "void":
        """
        PushBackInput(itkImageToImageFilterLM3IUC3 self, itkLabelMap3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3IUC3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterLM3IUC3 self)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3IUC3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkLabelMap3') -> "void":
        """PushFrontInput(itkImageToImageFilterLM3IUC3 self, itkLabelMap3 image)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3IUC3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterLM3IUC3 self)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3IUC3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterLM3IUC3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3IUC3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterLM3IUC3 self) -> double"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3IUC3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterLM3IUC3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3IUC3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterLM3IUC3 self) -> double"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3IUC3_GetDirectionTolerance(self)

    __swig_destroy__ = _ITKLabelMapBasePython.delete_itkImageToImageFilterLM3IUC3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterLM3IUC3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterLM3IUC3"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3IUC3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterLM3IUC3

        Create a new object of the class itkImageToImageFilterLM3IUC3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterLM3IUC3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterLM3IUC3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterLM3IUC3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterLM3IUC3.SetInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3IUC3_SetInput, None, itkImageToImageFilterLM3IUC3)
itkImageToImageFilterLM3IUC3.GetInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3IUC3_GetInput, None, itkImageToImageFilterLM3IUC3)
itkImageToImageFilterLM3IUC3.PushBackInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3IUC3_PushBackInput, None, itkImageToImageFilterLM3IUC3)
itkImageToImageFilterLM3IUC3.PopBackInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3IUC3_PopBackInput, None, itkImageToImageFilterLM3IUC3)
itkImageToImageFilterLM3IUC3.PushFrontInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3IUC3_PushFrontInput, None, itkImageToImageFilterLM3IUC3)
itkImageToImageFilterLM3IUC3.PopFrontInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3IUC3_PopFrontInput, None, itkImageToImageFilterLM3IUC3)
itkImageToImageFilterLM3IUC3.SetCoordinateTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3IUC3_SetCoordinateTolerance, None, itkImageToImageFilterLM3IUC3)
itkImageToImageFilterLM3IUC3.GetCoordinateTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3IUC3_GetCoordinateTolerance, None, itkImageToImageFilterLM3IUC3)
itkImageToImageFilterLM3IUC3.SetDirectionTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3IUC3_SetDirectionTolerance, None, itkImageToImageFilterLM3IUC3)
itkImageToImageFilterLM3IUC3.GetDirectionTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3IUC3_GetDirectionTolerance, None, itkImageToImageFilterLM3IUC3)
itkImageToImageFilterLM3IUC3_swigregister = _ITKLabelMapBasePython.itkImageToImageFilterLM3IUC3_swigregister
itkImageToImageFilterLM3IUC3_swigregister(itkImageToImageFilterLM3IUC3)

def itkImageToImageFilterLM3IUC3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterLM3IUC3 *":
    """itkImageToImageFilterLM3IUC3_cast(itkLightObject obj) -> itkImageToImageFilterLM3IUC3"""
    return _ITKLabelMapBasePython.itkImageToImageFilterLM3IUC3_cast(obj)

class itkImageToImageFilterLM3IUS3(itkImageSourcePython.itkImageSourceIUS3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterLM3IUS3 self, itkLabelMap3 image)
        SetInput(itkImageToImageFilterLM3IUS3 self, unsigned int arg0, itkLabelMap3 image)
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3IUS3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkLabelMap3 const *":
        """
        GetInput(itkImageToImageFilterLM3IUS3 self) -> itkLabelMap3
        GetInput(itkImageToImageFilterLM3IUS3 self, unsigned int idx) -> itkLabelMap3
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3IUS3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkLabelMap3') -> "void":
        """
        PushBackInput(itkImageToImageFilterLM3IUS3 self, itkLabelMap3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3IUS3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterLM3IUS3 self)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3IUS3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkLabelMap3') -> "void":
        """PushFrontInput(itkImageToImageFilterLM3IUS3 self, itkLabelMap3 image)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3IUS3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterLM3IUS3 self)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3IUS3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterLM3IUS3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3IUS3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterLM3IUS3 self) -> double"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3IUS3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterLM3IUS3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3IUS3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterLM3IUS3 self) -> double"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3IUS3_GetDirectionTolerance(self)

    __swig_destroy__ = _ITKLabelMapBasePython.delete_itkImageToImageFilterLM3IUS3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterLM3IUS3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterLM3IUS3"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3IUS3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterLM3IUS3

        Create a new object of the class itkImageToImageFilterLM3IUS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterLM3IUS3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterLM3IUS3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterLM3IUS3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterLM3IUS3.SetInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3IUS3_SetInput, None, itkImageToImageFilterLM3IUS3)
itkImageToImageFilterLM3IUS3.GetInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3IUS3_GetInput, None, itkImageToImageFilterLM3IUS3)
itkImageToImageFilterLM3IUS3.PushBackInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3IUS3_PushBackInput, None, itkImageToImageFilterLM3IUS3)
itkImageToImageFilterLM3IUS3.PopBackInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3IUS3_PopBackInput, None, itkImageToImageFilterLM3IUS3)
itkImageToImageFilterLM3IUS3.PushFrontInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3IUS3_PushFrontInput, None, itkImageToImageFilterLM3IUS3)
itkImageToImageFilterLM3IUS3.PopFrontInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3IUS3_PopFrontInput, None, itkImageToImageFilterLM3IUS3)
itkImageToImageFilterLM3IUS3.SetCoordinateTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3IUS3_SetCoordinateTolerance, None, itkImageToImageFilterLM3IUS3)
itkImageToImageFilterLM3IUS3.GetCoordinateTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3IUS3_GetCoordinateTolerance, None, itkImageToImageFilterLM3IUS3)
itkImageToImageFilterLM3IUS3.SetDirectionTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3IUS3_SetDirectionTolerance, None, itkImageToImageFilterLM3IUS3)
itkImageToImageFilterLM3IUS3.GetDirectionTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3IUS3_GetDirectionTolerance, None, itkImageToImageFilterLM3IUS3)
itkImageToImageFilterLM3IUS3_swigregister = _ITKLabelMapBasePython.itkImageToImageFilterLM3IUS3_swigregister
itkImageToImageFilterLM3IUS3_swigregister(itkImageToImageFilterLM3IUS3)

def itkImageToImageFilterLM3IUS3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterLM3IUS3 *":
    """itkImageToImageFilterLM3IUS3_cast(itkLightObject obj) -> itkImageToImageFilterLM3IUS3"""
    return _ITKLabelMapBasePython.itkImageToImageFilterLM3IUS3_cast(obj)

class itkImageToImageFilterLM3LM3(itkImageSourceLM3):
    """


    Base class for filters that take an image as input and produce an
    image as output.

    ImageToImageFilter is the base class for all process objects that
    output image data and require image data as input. Specifically, this
    class defines the SetInput() method for defining the input to a
    filter.

    This class provides the infrastructure for supporting multithreaded
    processing of images. If a filter provides an implementation of
    GenerateData(), the image processing will run in a single thread and
    the implementation is responsible for allocating its output data. If a
    filter provides an implementation of ThreadedGenerateData() instead,
    the image will be divided into a number of work units, a number of
    threads will be spawned, and ThreadedGenerateData() will be called in
    each thread. Here, the output memory will be allocated by this
    superclass prior to calling ThreadedGenerateData().

    ImageToImageFilter provides an implementation of
    GenerateInputRequestedRegion(). The base assumption to this point in
    the hierarchy is that a process object would ask for the largest
    possible region on input in order to produce any output. Imaging
    filters, however, can usually answer this question more precisely. The
    default implementation of GenerateInputRequestedRegion() in this class
    is to request an input that matches the size of the requested output.
    If a filter requires more input (say a filter that uses neighborhood
    information) or less input (for instance a magnify filter), then these
    filters will have to provide another implementation of this method. By
    convention, such implementations should call the Superclass' method
    first.

    All inputs to ImageToImageFilter (if there is more than one) are
    checked in the VerifyInputInformation method to verify that they
    occupy the same physical space. If the input images are in the same
    physical space, then the location of each voxel is identical, and the
    filter can operate voxel-by-voxel in index space. Some filters
    registration filters, for example will violate this precondition, in
    which case they should redefine VerifyInputInformation to relax or
    eliminate this requirement.

    Access methods Set/GetCoordinateTolerance and
    Set/GetDirectionTolerance are provided for cases where the default
    spatial-congruency tolerances are too fine, and images that are almost
    in the same space should be regard as being in the same space. This
    has come up, for example when comparing different on-disk image
    formats with differing digits of precision in the position, spacing,
    and orientation.

    The default tolerance is govern by the
    GlobalDefaultCoordinateTolerance and the
    GlobalDefaultDirectionTolerance properties, defaulting to 1.0e-6. The
    default tolerance for spatial comparison is then scaled by the
    voxelSpacing for coordinates (i.e. the coordinates must be the same to
    within one part per million). For the direction cosines the values
    must be within the current absolute tolerance.

    \\sphinx \\sphinxexample{Core/Common/FilterImage,Filter Image}
    \\sphinxexample{Core/Common/MultipleInputsOfSameType,Multiple Inputs
    Of Same Type}
    \\sphinxexample{Core/Common/MultipleInputsOfDifferentType,Multiple
    Inputs Of Different Type}
    \\sphinxexample{Core/Common/MultipleOutputsOfSameType,Multiple
    Outputs Of Same Type}
    \\sphinxexample{Core/Common/MultThreadOilPainting,Mult-thread Oil
    Painting}
    \\sphinxexample{Core/Common/MultipleOutputsOfDifferentType,Multiple
    Outputs Of Different Type}
    \\sphinxexample{Core/Common/FilterImageUsingMultipleThreads,Filter
    Image Using Multiple Threads} \\endsphinx

    C++ includes: itkImageToImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetInput(self, *args) -> "void":
        """
        SetInput(itkImageToImageFilterLM3LM3 self, itkLabelMap3 image)
        SetInput(itkImageToImageFilterLM3LM3 self, unsigned int arg0, itkLabelMap3 image)
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3LM3_SetInput(self, *args)


    def GetInput(self, *args) -> "itkLabelMap3 const *":
        """
        GetInput(itkImageToImageFilterLM3LM3 self) -> itkLabelMap3
        GetInput(itkImageToImageFilterLM3LM3 self, unsigned int idx) -> itkLabelMap3
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3LM3_GetInput(self, *args)


    def PushBackInput(self, image: 'itkLabelMap3') -> "void":
        """
        PushBackInput(itkImageToImageFilterLM3LM3 self, itkLabelMap3 image)

        Push/Pop the input of
        this process object. These methods allow a filter to model its input
        vector as a queue or stack. These routines may not be appropriate for
        all filters, especially filters with different types of inputs. These
        routines follow the semantics of STL.

        The routines are useful for applications that need to process
        "rolling" sets of images. For instance, if an application has 10
        images and they need to run a filter on images 1, 2, 3, 4, then run
        the filter on images 2, 3, 4, 5, then run the filter on images 3, 4,
        5, 6, the application can accomplish this by popping an input off the
        front of the input list and push a new image onto the back of input
        list. Again, this only makes sense for filters that single type of
        input.

        Other uses are also possible. For a single input filter, pushing and
        popping inputs allow the application to temporarily replace an input
        to a filter. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3LM3_PushBackInput(self, image)


    def PopBackInput(self) -> "void":
        """PopBackInput(itkImageToImageFilterLM3LM3 self)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3LM3_PopBackInput(self)


    def PushFrontInput(self, image: 'itkLabelMap3') -> "void":
        """PushFrontInput(itkImageToImageFilterLM3LM3 self, itkLabelMap3 image)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3LM3_PushFrontInput(self, image)


    def PopFrontInput(self) -> "void":
        """PopFrontInput(itkImageToImageFilterLM3LM3 self)"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3LM3_PopFrontInput(self)


    def SetCoordinateTolerance(self, _arg: 'double const') -> "void":
        """
        SetCoordinateTolerance(itkImageToImageFilterLM3LM3 self, double const _arg)

        get/set the
        Coordinate tolerance This tolerance is used when comparing the space
        defined by the input images. ITK has a requirement that multiple input
        images be congruent in space by default. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3LM3_SetCoordinateTolerance(self, _arg)


    def GetCoordinateTolerance(self) -> "double":
        """GetCoordinateTolerance(itkImageToImageFilterLM3LM3 self) -> double"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3LM3_GetCoordinateTolerance(self)


    def SetDirectionTolerance(self, _arg: 'double const') -> "void":
        """
        SetDirectionTolerance(itkImageToImageFilterLM3LM3 self, double const _arg)

        get/set the
        direction tolerance This tolerance is used to make sure that all input
        images are oriented the same before performing the filter's
        transformations. 
        """
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3LM3_SetDirectionTolerance(self, _arg)


    def GetDirectionTolerance(self) -> "double":
        """GetDirectionTolerance(itkImageToImageFilterLM3LM3 self) -> double"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3LM3_GetDirectionTolerance(self)

    __swig_destroy__ = _ITKLabelMapBasePython.delete_itkImageToImageFilterLM3LM3

    def cast(obj: 'itkLightObject') -> "itkImageToImageFilterLM3LM3 *":
        """cast(itkLightObject obj) -> itkImageToImageFilterLM3LM3"""
        return _ITKLabelMapBasePython.itkImageToImageFilterLM3LM3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkImageToImageFilterLM3LM3

        Create a new object of the class itkImageToImageFilterLM3LM3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageToImageFilterLM3LM3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkImageToImageFilterLM3LM3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkImageToImageFilterLM3LM3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkImageToImageFilterLM3LM3.SetInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3LM3_SetInput, None, itkImageToImageFilterLM3LM3)
itkImageToImageFilterLM3LM3.GetInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3LM3_GetInput, None, itkImageToImageFilterLM3LM3)
itkImageToImageFilterLM3LM3.PushBackInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3LM3_PushBackInput, None, itkImageToImageFilterLM3LM3)
itkImageToImageFilterLM3LM3.PopBackInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3LM3_PopBackInput, None, itkImageToImageFilterLM3LM3)
itkImageToImageFilterLM3LM3.PushFrontInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3LM3_PushFrontInput, None, itkImageToImageFilterLM3LM3)
itkImageToImageFilterLM3LM3.PopFrontInput = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3LM3_PopFrontInput, None, itkImageToImageFilterLM3LM3)
itkImageToImageFilterLM3LM3.SetCoordinateTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3LM3_SetCoordinateTolerance, None, itkImageToImageFilterLM3LM3)
itkImageToImageFilterLM3LM3.GetCoordinateTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3LM3_GetCoordinateTolerance, None, itkImageToImageFilterLM3LM3)
itkImageToImageFilterLM3LM3.SetDirectionTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3LM3_SetDirectionTolerance, None, itkImageToImageFilterLM3LM3)
itkImageToImageFilterLM3LM3.GetDirectionTolerance = new_instancemethod(_ITKLabelMapBasePython.itkImageToImageFilterLM3LM3_GetDirectionTolerance, None, itkImageToImageFilterLM3LM3)
itkImageToImageFilterLM3LM3_swigregister = _ITKLabelMapBasePython.itkImageToImageFilterLM3LM3_swigregister
itkImageToImageFilterLM3LM3_swigregister(itkImageToImageFilterLM3LM3)

def itkImageToImageFilterLM3LM3_cast(obj: 'itkLightObject') -> "itkImageToImageFilterLM3LM3 *":
    """itkImageToImageFilterLM3LM3_cast(itkLightObject obj) -> itkImageToImageFilterLM3LM3"""
    return _ITKLabelMapBasePython.itkImageToImageFilterLM3LM3_cast(obj)

class itkLabelMap2(itkImagePython.itkImageBase2):
    """


    Templated n-dimensional image to store labeled objects.

    LabelMap is an image class specialized in storing the labeled images.
    It represent the image in a different way than itk::Image. Instead of
    storing the content of the image in an array of pixels values, it
    store the a collection of labeled objects, and a background value.
    This way of storing the content of the image allow an easy and
    efficient manipulation of the objects in the image.

    The LabelMap shares a lot of methods with the itk::Image class. it
    make it usable as input or output of the itk::ImageToImageFilter for
    example. However the methods don't have the same complexity in the 2
    classes, because of the different way to store the data. GetPixel() is
    run in constant time for example in itk::Image, but have a worst case
    complexity of O(L), where L is the number of lines in the image
    (imageSize[1] * imageSize[2] for a 3D image).

    To iterate over the LabelObjects in the map, use:

    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.  This implementation was taken from the
    Insight Journal paper:https://hdl.handle.net/1926/584
    orhttp://www.insight-journal.org/browse/publication/176

    \\sphinx
    \\sphinxexample{Filtering/LabelMap/RemoveLabelsFromLabelMa,Remove
    Labels From Label Map} \\endsphinx

    C++ includes: itkLabelMap.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkLabelMap2_Pointer":
        """__New_orig__() -> itkLabelMap2_Pointer"""
        return _ITKLabelMapBasePython.itkLabelMap2___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkLabelMap2_Pointer":
        """Clone(itkLabelMap2 self) -> itkLabelMap2_Pointer"""
        return _ITKLabelMapBasePython.itkLabelMap2_Clone(self)


    def Allocate(self, initialize: 'bool'=False) -> "void":
        """
        Allocate(itkLabelMap2 self, bool initialize=False)
        Allocate(itkLabelMap2 self)

        Allocate the image memory.
        The size of the image must already be set, e.g. by calling
        SetRegions() or SetBufferedRegion().

        This method should be pure virtual, if backwards compatibility was not
        required. 
        """
        return _ITKLabelMapBasePython.itkLabelMap2_Allocate(self, initialize)


    def Graft(self, imgData: 'itkLabelMap2') -> "void":
        """
        Graft(itkLabelMap2 self, itkLabelMap2 imgData)

        Graft the data and
        information from one image to another. This is a convenience method to
        setup a second image with all the meta information of another image
        and use the same pixel container. Note that this method is different
        than just using two SmartPointers to the same image since separate
        DataObjects are still maintained. This method is similar to
        ImageSource::GraftOutput(). The implementation in ImageBase simply
        calls CopyInformation() and copies the region ivars. Subclasses of
        ImageBase are responsible for copying the pixel container. 
        """
        return _ITKLabelMapBasePython.itkLabelMap2_Graft(self, imgData)


    def HasLabel(self, label: 'unsigned long const') -> "bool":
        """
        HasLabel(itkLabelMap2 self, unsigned long const label) -> bool

        Return true is the image
        contains the label given in parameter and false otherwise. If the
        label is the background one, true is also returned, so this method may
        not be a good enough test before calling GetLabelObject(). 
        """
        return _ITKLabelMapBasePython.itkLabelMap2_HasLabel(self, label)


    def GetNthLabelObject(self, *args) -> "itkStatisticsLabelObjectUL2 const *":
        """
        GetNthLabelObject(itkLabelMap2 self, unsigned long const & pos) -> itkStatisticsLabelObjectUL2
        GetNthLabelObject(itkLabelMap2 self, unsigned long const & pos) -> itkStatisticsLabelObjectUL2

        Return the
        LabelObject with at the position given in parameter. This method can
        be useful when the labels are not consecutives, but is quite
        inefficient. This method throws an exception if the index doesn't
        exist in this image. 
        """
        return _ITKLabelMapBasePython.itkLabelMap2_GetNthLabelObject(self, *args)


    def GetPixel(self, idx: 'itkIndex2') -> "unsigned long const &":
        """
        GetPixel(itkLabelMap2 self, itkIndex2 idx) -> unsigned long const &

        Return the pixel value at
        a given index in the image. If the given index is contained in several
        objects, only the smallest label of those objects is returned. This
        method has a worst case complexity of O(L) where L is the number of
        lines in the image - use it with care. 
        """
        return _ITKLabelMapBasePython.itkLabelMap2_GetPixel(self, idx)


    def SetPixel(self, idx: 'itkIndex2', label: 'unsigned long const &') -> "void":
        """
        SetPixel(itkLabelMap2 self, itkIndex2 idx, unsigned long const & label)

        Set the pixel value at a
        given index in the image.

        As for itk::Image, this method ensure that the pixel at the position
        idx has a unique value.

        The complexity of this method is at best O(L) where L is the number of
        lines in the image - usit with care. 
        """
        return _ITKLabelMapBasePython.itkLabelMap2_SetPixel(self, idx, label)


    def AddPixel(self, idx: 'itkIndex2', label: 'unsigned long const &') -> "void":
        """
        AddPixel(itkLabelMap2 self, itkIndex2 idx, unsigned long const & label)

        Add index idx to the label
        object whose label is label. If no label object has the label label,
        the corresponding label object is created. The worst case complexity
        of this method is O(L) where L is the number of lines in the image.
        However, the execution time will be quite low if the pixels are set in
        the image in raster mode. 
        """
        return _ITKLabelMapBasePython.itkLabelMap2_AddPixel(self, idx, label)


    def RemovePixel(self, idx: 'itkIndex2', label: 'unsigned long const &') -> "void":
        """
        RemovePixel(itkLabelMap2 self, itkIndex2 idx, unsigned long const & label)

        Remove index idx from
        the label object which has the label label. If the label object gets
        empty, it is being removed from the container. 
        """
        return _ITKLabelMapBasePython.itkLabelMap2_RemovePixel(self, idx, label)


    def SetLine(self, idx: 'itkIndex2', length: 'unsigned long const &', label: 'unsigned long const &') -> "void":
        """
        SetLine(itkLabelMap2 self, itkIndex2 idx, unsigned long const & length, unsigned long const & label)

        Set a full line in the
        image. If no label object has this label in the image, a new object is
        created. If a label object already exist with that label, the line is
        added to it WITHOUT any check - it means that if the label object may
        contain several time the same pixel after have run that method. This
        method runs in constant time. 
        """
        return _ITKLabelMapBasePython.itkLabelMap2_SetLine(self, idx, length, label)


    def GetLabelObject(self, *args) -> "itkStatisticsLabelObjectUL2 *":
        """
        GetLabelObject(itkLabelMap2 self, unsigned long const & label) -> itkStatisticsLabelObjectUL2
        GetLabelObject(itkLabelMap2 self, unsigned long const & label) -> itkStatisticsLabelObjectUL2
        GetLabelObject(itkLabelMap2 self, itkIndex2 idx) -> itkStatisticsLabelObjectUL2

        Return the label
        object at a given index. This method has a worst case complexity of
        O(L) where L is the number of lines in the image - use it with care.

        """
        return _ITKLabelMapBasePython.itkLabelMap2_GetLabelObject(self, *args)


    def AddLabelObject(self, labelObject: 'itkStatisticsLabelObjectUL2') -> "void":
        """
        AddLabelObject(itkLabelMap2 self, itkStatisticsLabelObjectUL2 labelObject)

        Add a label object
        to the image. If a label object already has the label, it is
        overriden. 
        """
        return _ITKLabelMapBasePython.itkLabelMap2_AddLabelObject(self, labelObject)


    def PushLabelObject(self, labelObject: 'itkStatisticsLabelObjectUL2') -> "void":
        """
        PushLabelObject(itkLabelMap2 self, itkStatisticsLabelObjectUL2 labelObject)

        Add a label object
        to the image. The label of the label object is ignored, and a new
        label is given to the label object. 
        """
        return _ITKLabelMapBasePython.itkLabelMap2_PushLabelObject(self, labelObject)


    def RemoveLabelObject(self, labelObject: 'itkStatisticsLabelObjectUL2') -> "void":
        """
        RemoveLabelObject(itkLabelMap2 self, itkStatisticsLabelObjectUL2 labelObject)

        Remove a label
        object. 
        """
        return _ITKLabelMapBasePython.itkLabelMap2_RemoveLabelObject(self, labelObject)


    def RemoveLabel(self, label: 'unsigned long const &') -> "void":
        """
        RemoveLabel(itkLabelMap2 self, unsigned long const & label)

        Remove a label object.

        """
        return _ITKLabelMapBasePython.itkLabelMap2_RemoveLabel(self, label)


    def ClearLabels(self) -> "void":
        """
        ClearLabels(itkLabelMap2 self)

        Remove all the labels
        in the image 
        """
        return _ITKLabelMapBasePython.itkLabelMap2_ClearLabels(self)


    def GetNumberOfLabelObjects(self) -> "unsigned long":
        """
        GetNumberOfLabelObjects(itkLabelMap2 self) -> unsigned long

        Return the
        number of label objects in the image 
        """
        return _ITKLabelMapBasePython.itkLabelMap2_GetNumberOfLabelObjects(self)


    def GetLabels(self) -> "std::vector< unsigned long,std::allocator< unsigned long > >":
        """
        GetLabels(itkLabelMap2 self) -> vectorUL

        Return the labels of the
        label objects available in the label map 
        """
        return _ITKLabelMapBasePython.itkLabelMap2_GetLabels(self)


    def GetLabelObjects(self) -> "std::vector< itkStatisticsLabelObjectUL2_Pointer,std::allocator< itkStatisticsLabelObjectUL2_Pointer > >":
        """
        GetLabelObjects(itkLabelMap2 self) -> vectoritkStatisticsLabelObjectUL2

        Return the the
        label objects available in the label map 
        """
        return _ITKLabelMapBasePython.itkLabelMap2_GetLabelObjects(self)


    def GetBackgroundValue(self) -> "unsigned long":
        """
        GetBackgroundValue(itkLabelMap2 self) -> unsigned long

        Set/Get the
        background label 
        """
        return _ITKLabelMapBasePython.itkLabelMap2_GetBackgroundValue(self)


    def SetBackgroundValue(self, _arg: 'unsigned long const') -> "void":
        """SetBackgroundValue(itkLabelMap2 self, unsigned long const _arg)"""
        return _ITKLabelMapBasePython.itkLabelMap2_SetBackgroundValue(self, _arg)


    def PrintLabelObjects(self, *args) -> "void":
        """
        PrintLabelObjects(itkLabelMap2 self, ostream os)
        PrintLabelObjects(itkLabelMap2 self)

        Print all the
        objects stored in that collection - a convenient method for
        prototyping. 
        """
        return _ITKLabelMapBasePython.itkLabelMap2_PrintLabelObjects(self, *args)


    def Optimize(self) -> "void":
        """
        Optimize(itkLabelMap2 self)

        Optimize the line
        representation of all the label objects referenced in the LabelMap 
        """
        return _ITKLabelMapBasePython.itkLabelMap2_Optimize(self)

    __swig_destroy__ = _ITKLabelMapBasePython.delete_itkLabelMap2

    def cast(obj: 'itkLightObject') -> "itkLabelMap2 *":
        """cast(itkLightObject obj) -> itkLabelMap2"""
        return _ITKLabelMapBasePython.itkLabelMap2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkLabelMap2

        Create a new object of the class itkLabelMap2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkLabelMap2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkLabelMap2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkLabelMap2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


    def __len__(self):
        return self.GetNumberOfLabelObjects()
    def __getitem__(self, label):
        return self.GetLabelObject(label)
    def __iter__(self):
        labels = self.GetLabels()
        for label in labels:
            yield self.GetLabelObject(label)


    def New(*args, **kargs):
        """New() -> itkLabelMap2

        Create a new object of the class itkLabelMap2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkLabelMap2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkLabelMap2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkLabelMap2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


    def __len__(self):
        return self.GetNumberOfLabelObjects()
    def __getitem__(self, label):
        return self.GetLabelObject(label)
    def __iter__(self):
        labels = self.GetLabels()
        for label in labels:
            yield self.GetLabelObject(label)

itkLabelMap2.Clone = new_instancemethod(_ITKLabelMapBasePython.itkLabelMap2_Clone, None, itkLabelMap2)
itkLabelMap2.Allocate = new_instancemethod(_ITKLabelMapBasePython.itkLabelMap2_Allocate, None, itkLabelMap2)
itkLabelMap2.Graft = new_instancemethod(_ITKLabelMapBasePython.itkLabelMap2_Graft, None, itkLabelMap2)
itkLabelMap2.HasLabel = new_instancemethod(_ITKLabelMapBasePython.itkLabelMap2_HasLabel, None, itkLabelMap2)
itkLabelMap2.GetNthLabelObject = new_instancemethod(_ITKLabelMapBasePython.itkLabelMap2_GetNthLabelObject, None, itkLabelMap2)
itkLabelMap2.GetPixel = new_instancemethod(_ITKLabelMapBasePython.itkLabelMap2_GetPixel, None, itkLabelMap2)
itkLabelMap2.SetPixel = new_instancemethod(_ITKLabelMapBasePython.itkLabelMap2_SetPixel, None, itkLabelMap2)
itkLabelMap2.AddPixel = new_instancemethod(_ITKLabelMapBasePython.itkLabelMap2_AddPixel, None, itkLabelMap2)
itkLabelMap2.RemovePixel = new_instancemethod(_ITKLabelMapBasePython.itkLabelMap2_RemovePixel, None, itkLabelMap2)
itkLabelMap2.SetLine = new_instancemethod(_ITKLabelMapBasePython.itkLabelMap2_SetLine, None, itkLabelMap2)
itkLabelMap2.GetLabelObject = new_instancemethod(_ITKLabelMapBasePython.itkLabelMap2_GetLabelObject, None, itkLabelMap2)
itkLabelMap2.AddLabelObject = new_instancemethod(_ITKLabelMapBasePython.itkLabelMap2_AddLabelObject, None, itkLabelMap2)
itkLabelMap2.PushLabelObject = new_instancemethod(_ITKLabelMapBasePython.itkLabelMap2_PushLabelObject, None, itkLabelMap2)
itkLabelMap2.RemoveLabelObject = new_instancemethod(_ITKLabelMapBasePython.itkLabelMap2_RemoveLabelObject, None, itkLabelMap2)
itkLabelMap2.RemoveLabel = new_instancemethod(_ITKLabelMapBasePython.itkLabelMap2_RemoveLabel, None, itkLabelMap2)
itkLabelMap2.ClearLabels = new_instancemethod(_ITKLabelMapBasePython.itkLabelMap2_ClearLabels, None, itkLabelMap2)
itkLabelMap2.GetNumberOfLabelObjects = new_instancemethod(_ITKLabelMapBasePython.itkLabelMap2_GetNumberOfLabelObjects, None, itkLabelMap2)
itkLabelMap2.GetLabels = new_instancemethod(_ITKLabelMapBasePython.itkLabelMap2_GetLabels, None, itkLabelMap2)
itkLabelMap2.GetLabelObjects = new_instancemethod(_ITKLabelMapBasePython.itkLabelMap2_GetLabelObjects, None, itkLabelMap2)
itkLabelMap2.GetBackgroundValue = new_instancemethod(_ITKLabelMapBasePython.itkLabelMap2_GetBackgroundValue, None, itkLabelMap2)
itkLabelMap2.SetBackgroundValue = new_instancemethod(_ITKLabelMapBasePython.itkLabelMap2_SetBackgroundValue, None, itkLabelMap2)
itkLabelMap2.PrintLabelObjects = new_instancemethod(_ITKLabelMapBasePython.itkLabelMap2_PrintLabelObjects, None, itkLabelMap2)
itkLabelMap2.Optimize = new_instancemethod(_ITKLabelMapBasePython.itkLabelMap2_Optimize, None, itkLabelMap2)
itkLabelMap2_swigregister = _ITKLabelMapBasePython.itkLabelMap2_swigregister
itkLabelMap2_swigregister(itkLabelMap2)

def itkLabelMap2___New_orig__() -> "itkLabelMap2_Pointer":
    """itkLabelMap2___New_orig__() -> itkLabelMap2_Pointer"""
    return _ITKLabelMapBasePython.itkLabelMap2___New_orig__()

def itkLabelMap2_cast(obj: 'itkLightObject') -> "itkLabelMap2 *":
    """itkLabelMap2_cast(itkLightObject obj) -> itkLabelMap2"""
    return _ITKLabelMapBasePython.itkLabelMap2_cast(obj)

class itkLabelMap3(itkImagePython.itkImageBase3):
    """


    Templated n-dimensional image to store labeled objects.

    LabelMap is an image class specialized in storing the labeled images.
    It represent the image in a different way than itk::Image. Instead of
    storing the content of the image in an array of pixels values, it
    store the a collection of labeled objects, and a background value.
    This way of storing the content of the image allow an easy and
    efficient manipulation of the objects in the image.

    The LabelMap shares a lot of methods with the itk::Image class. it
    make it usable as input or output of the itk::ImageToImageFilter for
    example. However the methods don't have the same complexity in the 2
    classes, because of the different way to store the data. GetPixel() is
    run in constant time for example in itk::Image, but have a worst case
    complexity of O(L), where L is the number of lines in the image
    (imageSize[1] * imageSize[2] for a 3D image).

    To iterate over the LabelObjects in the map, use:

    Gaetan Lehmann. Biologie du Developpement et de la Reproduction, INRA
    de Jouy-en-Josas, France.  This implementation was taken from the
    Insight Journal paper:https://hdl.handle.net/1926/584
    orhttp://www.insight-journal.org/browse/publication/176

    \\sphinx
    \\sphinxexample{Filtering/LabelMap/RemoveLabelsFromLabelMa,Remove
    Labels From Label Map} \\endsphinx

    C++ includes: itkLabelMap.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkLabelMap3_Pointer":
        """__New_orig__() -> itkLabelMap3_Pointer"""
        return _ITKLabelMapBasePython.itkLabelMap3___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkLabelMap3_Pointer":
        """Clone(itkLabelMap3 self) -> itkLabelMap3_Pointer"""
        return _ITKLabelMapBasePython.itkLabelMap3_Clone(self)


    def Allocate(self, initialize: 'bool'=False) -> "void":
        """
        Allocate(itkLabelMap3 self, bool initialize=False)
        Allocate(itkLabelMap3 self)

        Allocate the image memory.
        The size of the image must already be set, e.g. by calling
        SetRegions() or SetBufferedRegion().

        This method should be pure virtual, if backwards compatibility was not
        required. 
        """
        return _ITKLabelMapBasePython.itkLabelMap3_Allocate(self, initialize)


    def Graft(self, imgData: 'itkLabelMap3') -> "void":
        """
        Graft(itkLabelMap3 self, itkLabelMap3 imgData)

        Graft the data and
        information from one image to another. This is a convenience method to
        setup a second image with all the meta information of another image
        and use the same pixel container. Note that this method is different
        than just using two SmartPointers to the same image since separate
        DataObjects are still maintained. This method is similar to
        ImageSource::GraftOutput(). The implementation in ImageBase simply
        calls CopyInformation() and copies the region ivars. Subclasses of
        ImageBase are responsible for copying the pixel container. 
        """
        return _ITKLabelMapBasePython.itkLabelMap3_Graft(self, imgData)


    def HasLabel(self, label: 'unsigned long const') -> "bool":
        """
        HasLabel(itkLabelMap3 self, unsigned long const label) -> bool

        Return true is the image
        contains the label given in parameter and false otherwise. If the
        label is the background one, true is also returned, so this method may
        not be a good enough test before calling GetLabelObject(). 
        """
        return _ITKLabelMapBasePython.itkLabelMap3_HasLabel(self, label)


    def GetNthLabelObject(self, *args) -> "itkStatisticsLabelObjectUL3 const *":
        """
        GetNthLabelObject(itkLabelMap3 self, unsigned long const & pos) -> itkStatisticsLabelObjectUL3
        GetNthLabelObject(itkLabelMap3 self, unsigned long const & pos) -> itkStatisticsLabelObjectUL3

        Return the
        LabelObject with at the position given in parameter. This method can
        be useful when the labels are not consecutives, but is quite
        inefficient. This method throws an exception if the index doesn't
        exist in this image. 
        """
        return _ITKLabelMapBasePython.itkLabelMap3_GetNthLabelObject(self, *args)


    def GetPixel(self, idx: 'itkIndex3') -> "unsigned long const &":
        """
        GetPixel(itkLabelMap3 self, itkIndex3 idx) -> unsigned long const &

        Return the pixel value at
        a given index in the image. If the given index is contained in several
        objects, only the smallest label of those objects is returned. This
        method has a worst case complexity of O(L) where L is the number of
        lines in the image - use it with care. 
        """
        return _ITKLabelMapBasePython.itkLabelMap3_GetPixel(self, idx)


    def SetPixel(self, idx: 'itkIndex3', label: 'unsigned long const &') -> "void":
        """
        SetPixel(itkLabelMap3 self, itkIndex3 idx, unsigned long const & label)

        Set the pixel value at a
        given index in the image.

        As for itk::Image, this method ensure that the pixel at the position
        idx has a unique value.

        The complexity of this method is at best O(L) where L is the number of
        lines in the image - usit with care. 
        """
        return _ITKLabelMapBasePython.itkLabelMap3_SetPixel(self, idx, label)


    def AddPixel(self, idx: 'itkIndex3', label: 'unsigned long const &') -> "void":
        """
        AddPixel(itkLabelMap3 self, itkIndex3 idx, unsigned long const & label)

        Add index idx to the label
        object whose label is label. If no label object has the label label,
        the corresponding label object is created. The worst case complexity
        of this method is O(L) where L is the number of lines in the image.
        However, the execution time will be quite low if the pixels are set in
        the image in raster mode. 
        """
        return _ITKLabelMapBasePython.itkLabelMap3_AddPixel(self, idx, label)


    def RemovePixel(self, idx: 'itkIndex3', label: 'unsigned long const &') -> "void":
        """
        RemovePixel(itkLabelMap3 self, itkIndex3 idx, unsigned long const & label)

        Remove index idx from
        the label object which has the label label. If the label object gets
        empty, it is being removed from the container. 
        """
        return _ITKLabelMapBasePython.itkLabelMap3_RemovePixel(self, idx, label)


    def SetLine(self, idx: 'itkIndex3', length: 'unsigned long const &', label: 'unsigned long const &') -> "void":
        """
        SetLine(itkLabelMap3 self, itkIndex3 idx, unsigned long const & length, unsigned long const & label)

        Set a full line in the
        image. If no label object has this label in the image, a new object is
        created. If a label object already exist with that label, the line is
        added to it WITHOUT any check - it means that if the label object may
        contain several time the same pixel after have run that method. This
        method runs in constant time. 
        """
        return _ITKLabelMapBasePython.itkLabelMap3_SetLine(self, idx, length, label)


    def GetLabelObject(self, *args) -> "itkStatisticsLabelObjectUL3 *":
        """
        GetLabelObject(itkLabelMap3 self, unsigned long const & label) -> itkStatisticsLabelObjectUL3
        GetLabelObject(itkLabelMap3 self, unsigned long const & label) -> itkStatisticsLabelObjectUL3
        GetLabelObject(itkLabelMap3 self, itkIndex3 idx) -> itkStatisticsLabelObjectUL3

        Return the label
        object at a given index. This method has a worst case complexity of
        O(L) where L is the number of lines in the image - use it with care.

        """
        return _ITKLabelMapBasePython.itkLabelMap3_GetLabelObject(self, *args)


    def AddLabelObject(self, labelObject: 'itkStatisticsLabelObjectUL3') -> "void":
        """
        AddLabelObject(itkLabelMap3 self, itkStatisticsLabelObjectUL3 labelObject)

        Add a label object
        to the image. If a label object already has the label, it is
        overriden. 
        """
        return _ITKLabelMapBasePython.itkLabelMap3_AddLabelObject(self, labelObject)


    def PushLabelObject(self, labelObject: 'itkStatisticsLabelObjectUL3') -> "void":
        """
        PushLabelObject(itkLabelMap3 self, itkStatisticsLabelObjectUL3 labelObject)

        Add a label object
        to the image. The label of the label object is ignored, and a new
        label is given to the label object. 
        """
        return _ITKLabelMapBasePython.itkLabelMap3_PushLabelObject(self, labelObject)


    def RemoveLabelObject(self, labelObject: 'itkStatisticsLabelObjectUL3') -> "void":
        """
        RemoveLabelObject(itkLabelMap3 self, itkStatisticsLabelObjectUL3 labelObject)

        Remove a label
        object. 
        """
        return _ITKLabelMapBasePython.itkLabelMap3_RemoveLabelObject(self, labelObject)


    def RemoveLabel(self, label: 'unsigned long const &') -> "void":
        """
        RemoveLabel(itkLabelMap3 self, unsigned long const & label)

        Remove a label object.

        """
        return _ITKLabelMapBasePython.itkLabelMap3_RemoveLabel(self, label)


    def ClearLabels(self) -> "void":
        """
        ClearLabels(itkLabelMap3 self)

        Remove all the labels
        in the image 
        """
        return _ITKLabelMapBasePython.itkLabelMap3_ClearLabels(self)


    def GetNumberOfLabelObjects(self) -> "unsigned long":
        """
        GetNumberOfLabelObjects(itkLabelMap3 self) -> unsigned long

        Return the
        number of label objects in the image 
        """
        return _ITKLabelMapBasePython.itkLabelMap3_GetNumberOfLabelObjects(self)


    def GetLabels(self) -> "std::vector< unsigned long,std::allocator< unsigned long > >":
        """
        GetLabels(itkLabelMap3 self) -> vectorUL

        Return the labels of the
        label objects available in the label map 
        """
        return _ITKLabelMapBasePython.itkLabelMap3_GetLabels(self)


    def GetLabelObjects(self) -> "std::vector< itkStatisticsLabelObjectUL3_Pointer,std::allocator< itkStatisticsLabelObjectUL3_Pointer > >":
        """
        GetLabelObjects(itkLabelMap3 self) -> vectoritkStatisticsLabelObjectUL3

        Return the the
        label objects available in the label map 
        """
        return _ITKLabelMapBasePython.itkLabelMap3_GetLabelObjects(self)


    def GetBackgroundValue(self) -> "unsigned long":
        """
        GetBackgroundValue(itkLabelMap3 self) -> unsigned long

        Set/Get the
        background label 
        """
        return _ITKLabelMapBasePython.itkLabelMap3_GetBackgroundValue(self)


    def SetBackgroundValue(self, _arg: 'unsigned long const') -> "void":
        """SetBackgroundValue(itkLabelMap3 self, unsigned long const _arg)"""
        return _ITKLabelMapBasePython.itkLabelMap3_SetBackgroundValue(self, _arg)


    def PrintLabelObjects(self, *args) -> "void":
        """
        PrintLabelObjects(itkLabelMap3 self, ostream os)
        PrintLabelObjects(itkLabelMap3 self)

        Print all the
        objects stored in that collection - a convenient method for
        prototyping. 
        """
        return _ITKLabelMapBasePython.itkLabelMap3_PrintLabelObjects(self, *args)


    def Optimize(self) -> "void":
        """
        Optimize(itkLabelMap3 self)

        Optimize the line
        representation of all the label objects referenced in the LabelMap 
        """
        return _ITKLabelMapBasePython.itkLabelMap3_Optimize(self)

    __swig_destroy__ = _ITKLabelMapBasePython.delete_itkLabelMap3

    def cast(obj: 'itkLightObject') -> "itkLabelMap3 *":
        """cast(itkLightObject obj) -> itkLabelMap3"""
        return _ITKLabelMapBasePython.itkLabelMap3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkLabelMap3

        Create a new object of the class itkLabelMap3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkLabelMap3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkLabelMap3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkLabelMap3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


    def __len__(self):
        return self.GetNumberOfLabelObjects()
    def __getitem__(self, label):
        return self.GetLabelObject(label)
    def __iter__(self):
        labels = self.GetLabels()
        for label in labels:
            yield self.GetLabelObject(label)

itkLabelMap3.Clone = new_instancemethod(_ITKLabelMapBasePython.itkLabelMap3_Clone, None, itkLabelMap3)
itkLabelMap3.Allocate = new_instancemethod(_ITKLabelMapBasePython.itkLabelMap3_Allocate, None, itkLabelMap3)
itkLabelMap3.Graft = new_instancemethod(_ITKLabelMapBasePython.itkLabelMap3_Graft, None, itkLabelMap3)
itkLabelMap3.HasLabel = new_instancemethod(_ITKLabelMapBasePython.itkLabelMap3_HasLabel, None, itkLabelMap3)
itkLabelMap3.GetNthLabelObject = new_instancemethod(_ITKLabelMapBasePython.itkLabelMap3_GetNthLabelObject, None, itkLabelMap3)
itkLabelMap3.GetPixel = new_instancemethod(_ITKLabelMapBasePython.itkLabelMap3_GetPixel, None, itkLabelMap3)
itkLabelMap3.SetPixel = new_instancemethod(_ITKLabelMapBasePython.itkLabelMap3_SetPixel, None, itkLabelMap3)
itkLabelMap3.AddPixel = new_instancemethod(_ITKLabelMapBasePython.itkLabelMap3_AddPixel, None, itkLabelMap3)
itkLabelMap3.RemovePixel = new_instancemethod(_ITKLabelMapBasePython.itkLabelMap3_RemovePixel, None, itkLabelMap3)
itkLabelMap3.SetLine = new_instancemethod(_ITKLabelMapBasePython.itkLabelMap3_SetLine, None, itkLabelMap3)
itkLabelMap3.GetLabelObject = new_instancemethod(_ITKLabelMapBasePython.itkLabelMap3_GetLabelObject, None, itkLabelMap3)
itkLabelMap3.AddLabelObject = new_instancemethod(_ITKLabelMapBasePython.itkLabelMap3_AddLabelObject, None, itkLabelMap3)
itkLabelMap3.PushLabelObject = new_instancemethod(_ITKLabelMapBasePython.itkLabelMap3_PushLabelObject, None, itkLabelMap3)
itkLabelMap3.RemoveLabelObject = new_instancemethod(_ITKLabelMapBasePython.itkLabelMap3_RemoveLabelObject, None, itkLabelMap3)
itkLabelMap3.RemoveLabel = new_instancemethod(_ITKLabelMapBasePython.itkLabelMap3_RemoveLabel, None, itkLabelMap3)
itkLabelMap3.ClearLabels = new_instancemethod(_ITKLabelMapBasePython.itkLabelMap3_ClearLabels, None, itkLabelMap3)
itkLabelMap3.GetNumberOfLabelObjects = new_instancemethod(_ITKLabelMapBasePython.itkLabelMap3_GetNumberOfLabelObjects, None, itkLabelMap3)
itkLabelMap3.GetLabels = new_instancemethod(_ITKLabelMapBasePython.itkLabelMap3_GetLabels, None, itkLabelMap3)
itkLabelMap3.GetLabelObjects = new_instancemethod(_ITKLabelMapBasePython.itkLabelMap3_GetLabelObjects, None, itkLabelMap3)
itkLabelMap3.GetBackgroundValue = new_instancemethod(_ITKLabelMapBasePython.itkLabelMap3_GetBackgroundValue, None, itkLabelMap3)
itkLabelMap3.SetBackgroundValue = new_instancemethod(_ITKLabelMapBasePython.itkLabelMap3_SetBackgroundValue, None, itkLabelMap3)
itkLabelMap3.PrintLabelObjects = new_instancemethod(_ITKLabelMapBasePython.itkLabelMap3_PrintLabelObjects, None, itkLabelMap3)
itkLabelMap3.Optimize = new_instancemethod(_ITKLabelMapBasePython.itkLabelMap3_Optimize, None, itkLabelMap3)
itkLabelMap3_swigregister = _ITKLabelMapBasePython.itkLabelMap3_swigregister
itkLabelMap3_swigregister(itkLabelMap3)

def itkLabelMap3___New_orig__() -> "itkLabelMap3_Pointer":
    """itkLabelMap3___New_orig__() -> itkLabelMap3_Pointer"""
    return _ITKLabelMapBasePython.itkLabelMap3___New_orig__()

def itkLabelMap3_cast(obj: 'itkLightObject') -> "itkLabelMap3 *":
    """itkLabelMap3_cast(itkLightObject obj) -> itkLabelMap3"""
    return _ITKLabelMapBasePython.itkLabelMap3_cast(obj)


import itkHelpers
@itkHelpers.accept_numpy_array_like_xarray
def image_source(*args, **kwargs):
    """Procedural interface for ImageSource"""
    import itk
    instance = itk.ImageSource.New(*args, **kwargs)
    return instance.__internal_call__()

def image_source_init_docstring():
    import itk
    import itkTemplate
    import itkHelpers
    if isinstance(itk.ImageSource, itkTemplate.itkTemplate):
        filter_object = itk.ImageSource.values()[0]
    else:
        filter_object = itk.ImageSource

    image_source.__doc__ = filter_object.__doc__
    image_source.__doc__ += "\n Args are Input(s) to the filter.\n"
    image_source.__doc__ += "Available Keyword Arguments:\n"
    image_source.__doc__ += "".join([
        "  " + itkHelpers.camel_to_snake_case(item[3:]) + "\n"
        for item in dir(filter_object)
        if item[:3] == "Set"])
import itkHelpers
@itkHelpers.accept_numpy_array_like_xarray
def image_to_image_filter(*args, **kwargs):
    """Procedural interface for ImageToImageFilter"""
    import itk
    instance = itk.ImageToImageFilter.New(*args, **kwargs)
    return instance.__internal_call__()

def image_to_image_filter_init_docstring():
    import itk
    import itkTemplate
    import itkHelpers
    if isinstance(itk.ImageToImageFilter, itkTemplate.itkTemplate):
        filter_object = itk.ImageToImageFilter.values()[0]
    else:
        filter_object = itk.ImageToImageFilter

    image_to_image_filter.__doc__ = filter_object.__doc__
    image_to_image_filter.__doc__ += "\n Args are Input(s) to the filter.\n"
    image_to_image_filter.__doc__ += "Available Keyword Arguments:\n"
    image_to_image_filter.__doc__ += "".join([
        "  " + itkHelpers.camel_to_snake_case(item[3:]) + "\n"
        for item in dir(filter_object)
        if item[:3] == "Set"])



