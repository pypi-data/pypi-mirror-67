# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.8
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _itkFFTNormalizedCorrelationImageFilterPython.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_itkFFTNormalizedCorrelationImageFilterPython', [dirname(__file__)])
        except ImportError:
            import _itkFFTNormalizedCorrelationImageFilterPython
            return _itkFFTNormalizedCorrelationImageFilterPython
        if fp is not None:
            try:
                _mod = imp.load_module('_itkFFTNormalizedCorrelationImageFilterPython', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _itkFFTNormalizedCorrelationImageFilterPython = swig_import_helper()
    del swig_import_helper
else:
    import _itkFFTNormalizedCorrelationImageFilterPython
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0



def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


import ITKCommonBasePython
import pyBasePython
import itkMaskedFFTNormalizedCorrelationImageFilterPython
import itkImagePython
import itkImageRegionPython
import itkSizePython
import itkIndexPython
import itkOffsetPython
import itkRGBPixelPython
import itkFixedArrayPython
import stdcomplexPython
import itkSymmetricSecondRankTensorPython
import itkMatrixPython
import vnl_vectorPython
import vnl_matrixPython
import itkPointPython
import vnl_vector_refPython
import itkVectorPython
import vnl_matrix_fixedPython
import itkCovariantVectorPython
import itkRGBAPixelPython
import itkImageToImageFilterAPython
import itkImageSourcePython
import itkVectorImagePython
import itkVariableLengthVectorPython
import itkImageSourceCommonPython
import itkImageToImageFilterCommonPython

def itkFFTNormalizedCorrelationImageFilterID3ID3_New():
  return itkFFTNormalizedCorrelationImageFilterID3ID3.New()


def itkFFTNormalizedCorrelationImageFilterID2ID2_New():
  return itkFFTNormalizedCorrelationImageFilterID2ID2.New()


def itkFFTNormalizedCorrelationImageFilterID3IF3_New():
  return itkFFTNormalizedCorrelationImageFilterID3IF3.New()


def itkFFTNormalizedCorrelationImageFilterID2IF2_New():
  return itkFFTNormalizedCorrelationImageFilterID2IF2.New()


def itkFFTNormalizedCorrelationImageFilterIF3ID3_New():
  return itkFFTNormalizedCorrelationImageFilterIF3ID3.New()


def itkFFTNormalizedCorrelationImageFilterIF2ID2_New():
  return itkFFTNormalizedCorrelationImageFilterIF2ID2.New()


def itkFFTNormalizedCorrelationImageFilterIF3IF3_New():
  return itkFFTNormalizedCorrelationImageFilterIF3IF3.New()


def itkFFTNormalizedCorrelationImageFilterIF2IF2_New():
  return itkFFTNormalizedCorrelationImageFilterIF2IF2.New()


def itkFFTNormalizedCorrelationImageFilterIUS3ID3_New():
  return itkFFTNormalizedCorrelationImageFilterIUS3ID3.New()


def itkFFTNormalizedCorrelationImageFilterIUS2ID2_New():
  return itkFFTNormalizedCorrelationImageFilterIUS2ID2.New()


def itkFFTNormalizedCorrelationImageFilterIUS3IF3_New():
  return itkFFTNormalizedCorrelationImageFilterIUS3IF3.New()


def itkFFTNormalizedCorrelationImageFilterIUS2IF2_New():
  return itkFFTNormalizedCorrelationImageFilterIUS2IF2.New()


def itkFFTNormalizedCorrelationImageFilterIUC3ID3_New():
  return itkFFTNormalizedCorrelationImageFilterIUC3ID3.New()


def itkFFTNormalizedCorrelationImageFilterIUC2ID2_New():
  return itkFFTNormalizedCorrelationImageFilterIUC2ID2.New()


def itkFFTNormalizedCorrelationImageFilterIUC3IF3_New():
  return itkFFTNormalizedCorrelationImageFilterIUC3IF3.New()


def itkFFTNormalizedCorrelationImageFilterIUC2IF2_New():
  return itkFFTNormalizedCorrelationImageFilterIUC2IF2.New()


def itkFFTNormalizedCorrelationImageFilterISS3ID3_New():
  return itkFFTNormalizedCorrelationImageFilterISS3ID3.New()


def itkFFTNormalizedCorrelationImageFilterISS2ID2_New():
  return itkFFTNormalizedCorrelationImageFilterISS2ID2.New()


def itkFFTNormalizedCorrelationImageFilterISS3IF3_New():
  return itkFFTNormalizedCorrelationImageFilterISS3IF3.New()


def itkFFTNormalizedCorrelationImageFilterISS2IF2_New():
  return itkFFTNormalizedCorrelationImageFilterISS2IF2.New()

class itkFFTNormalizedCorrelationImageFilterID2ID2(itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID2ID2):
    """


    Calculate normalized cross correlation using FFTs.

    This filter calculates the normalized cross correlation (NCC) of two
    images using FFTs instead of spatial correlation. It is much faster
    than spatial correlation for reasonably large structuring elements.
    This filter is a subclass of the more general
    MaskedFFTNormalizedCorrelationImageFilter and operates by essentially
    setting the masks in that algorithm to images of ones. As described in
    detail in the references below, there is no computational overhead to
    utilizing the more general masked algorithm because the FFTs of the
    images of ones are still necessary for the computations.

    Inputs: Two images are required as inputs, fixedImage and movingImage.
    In the context of correlation, inputs are often defined as: "image"
    and "template". In this filter, the fixedImage plays the role of the
    image, and the movingImage plays the role of the template. However,
    this filter is capable of correlating any two images and is not
    restricted to small movingImages (templates).

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify how many voxels of the two images must overlap; any
    location in the correlation map that results from fewer than this
    number of voxels will be set to zero. Larger values zero-out pixels on
    a larger border around the correlation image. Thus, larger values
    remove less stable computations but also limit the capture range. If
    RequiredNumberOfOverlappingPixels is set to 0, the default, no zeroing
    will take place.

    Image size: fixedImage and movingImage need not be the same size.
    Furthermore, whereas some algorithms require that the "template" be
    smaller than the "image" because of errors in the regions where the
    two are not fully overlapping, this filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain,
    all input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the NCC of
    the two images and its values range from -1.0 to 1.0. The size of this
    NCC image is, by definition, size(fixedImage) + size(movingImage) - 1.

    Example filter usage:

    WARNING:  The pixel type of the output image must be of real type
    (float or double). ConceptChecking is used to enforce the output pixel
    type. You will get a compilation error if the pixel type of the output
    image is not float or double.  References: 1) D. Padfield. "Masked
    object registration in the Fourier domain." Transactions on Image
    Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.

    : Dirk Padfield, GE Global Research, padfield@research.ge.com

    C++ includes: itkFFTNormalizedCorrelationImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkFFTNormalizedCorrelationImageFilterID2ID2_Pointer":
        """__New_orig__() -> itkFFTNormalizedCorrelationImageFilterID2ID2_Pointer"""
        return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterID2ID2___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkFFTNormalizedCorrelationImageFilterID2ID2_Pointer":
        """Clone(itkFFTNormalizedCorrelationImageFilterID2ID2 self) -> itkFFTNormalizedCorrelationImageFilterID2ID2_Pointer"""
        return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterID2ID2_Clone(self)

    __swig_destroy__ = _itkFFTNormalizedCorrelationImageFilterPython.delete_itkFFTNormalizedCorrelationImageFilterID2ID2

    def cast(obj: 'itkLightObject') -> "itkFFTNormalizedCorrelationImageFilterID2ID2 *":
        """cast(itkLightObject obj) -> itkFFTNormalizedCorrelationImageFilterID2ID2"""
        return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterID2ID2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkFFTNormalizedCorrelationImageFilterID2ID2

        Create a new object of the class itkFFTNormalizedCorrelationImageFilterID2ID2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkFFTNormalizedCorrelationImageFilterID2ID2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkFFTNormalizedCorrelationImageFilterID2ID2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkFFTNormalizedCorrelationImageFilterID2ID2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkFFTNormalizedCorrelationImageFilterID2ID2.Clone = new_instancemethod(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterID2ID2_Clone, None, itkFFTNormalizedCorrelationImageFilterID2ID2)
itkFFTNormalizedCorrelationImageFilterID2ID2_swigregister = _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterID2ID2_swigregister
itkFFTNormalizedCorrelationImageFilterID2ID2_swigregister(itkFFTNormalizedCorrelationImageFilterID2ID2)

def itkFFTNormalizedCorrelationImageFilterID2ID2___New_orig__() -> "itkFFTNormalizedCorrelationImageFilterID2ID2_Pointer":
    """itkFFTNormalizedCorrelationImageFilterID2ID2___New_orig__() -> itkFFTNormalizedCorrelationImageFilterID2ID2_Pointer"""
    return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterID2ID2___New_orig__()

def itkFFTNormalizedCorrelationImageFilterID2ID2_cast(obj: 'itkLightObject') -> "itkFFTNormalizedCorrelationImageFilterID2ID2 *":
    """itkFFTNormalizedCorrelationImageFilterID2ID2_cast(itkLightObject obj) -> itkFFTNormalizedCorrelationImageFilterID2ID2"""
    return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterID2ID2_cast(obj)

class itkFFTNormalizedCorrelationImageFilterID2IF2(itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID2IF2):
    """


    Calculate normalized cross correlation using FFTs.

    This filter calculates the normalized cross correlation (NCC) of two
    images using FFTs instead of spatial correlation. It is much faster
    than spatial correlation for reasonably large structuring elements.
    This filter is a subclass of the more general
    MaskedFFTNormalizedCorrelationImageFilter and operates by essentially
    setting the masks in that algorithm to images of ones. As described in
    detail in the references below, there is no computational overhead to
    utilizing the more general masked algorithm because the FFTs of the
    images of ones are still necessary for the computations.

    Inputs: Two images are required as inputs, fixedImage and movingImage.
    In the context of correlation, inputs are often defined as: "image"
    and "template". In this filter, the fixedImage plays the role of the
    image, and the movingImage plays the role of the template. However,
    this filter is capable of correlating any two images and is not
    restricted to small movingImages (templates).

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify how many voxels of the two images must overlap; any
    location in the correlation map that results from fewer than this
    number of voxels will be set to zero. Larger values zero-out pixels on
    a larger border around the correlation image. Thus, larger values
    remove less stable computations but also limit the capture range. If
    RequiredNumberOfOverlappingPixels is set to 0, the default, no zeroing
    will take place.

    Image size: fixedImage and movingImage need not be the same size.
    Furthermore, whereas some algorithms require that the "template" be
    smaller than the "image" because of errors in the regions where the
    two are not fully overlapping, this filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain,
    all input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the NCC of
    the two images and its values range from -1.0 to 1.0. The size of this
    NCC image is, by definition, size(fixedImage) + size(movingImage) - 1.

    Example filter usage:

    WARNING:  The pixel type of the output image must be of real type
    (float or double). ConceptChecking is used to enforce the output pixel
    type. You will get a compilation error if the pixel type of the output
    image is not float or double.  References: 1) D. Padfield. "Masked
    object registration in the Fourier domain." Transactions on Image
    Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.

    : Dirk Padfield, GE Global Research, padfield@research.ge.com

    C++ includes: itkFFTNormalizedCorrelationImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkFFTNormalizedCorrelationImageFilterID2IF2_Pointer":
        """__New_orig__() -> itkFFTNormalizedCorrelationImageFilterID2IF2_Pointer"""
        return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterID2IF2___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkFFTNormalizedCorrelationImageFilterID2IF2_Pointer":
        """Clone(itkFFTNormalizedCorrelationImageFilterID2IF2 self) -> itkFFTNormalizedCorrelationImageFilterID2IF2_Pointer"""
        return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterID2IF2_Clone(self)

    __swig_destroy__ = _itkFFTNormalizedCorrelationImageFilterPython.delete_itkFFTNormalizedCorrelationImageFilterID2IF2

    def cast(obj: 'itkLightObject') -> "itkFFTNormalizedCorrelationImageFilterID2IF2 *":
        """cast(itkLightObject obj) -> itkFFTNormalizedCorrelationImageFilterID2IF2"""
        return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterID2IF2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkFFTNormalizedCorrelationImageFilterID2IF2

        Create a new object of the class itkFFTNormalizedCorrelationImageFilterID2IF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkFFTNormalizedCorrelationImageFilterID2IF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkFFTNormalizedCorrelationImageFilterID2IF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkFFTNormalizedCorrelationImageFilterID2IF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkFFTNormalizedCorrelationImageFilterID2IF2.Clone = new_instancemethod(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterID2IF2_Clone, None, itkFFTNormalizedCorrelationImageFilterID2IF2)
itkFFTNormalizedCorrelationImageFilterID2IF2_swigregister = _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterID2IF2_swigregister
itkFFTNormalizedCorrelationImageFilterID2IF2_swigregister(itkFFTNormalizedCorrelationImageFilterID2IF2)

def itkFFTNormalizedCorrelationImageFilterID2IF2___New_orig__() -> "itkFFTNormalizedCorrelationImageFilterID2IF2_Pointer":
    """itkFFTNormalizedCorrelationImageFilterID2IF2___New_orig__() -> itkFFTNormalizedCorrelationImageFilterID2IF2_Pointer"""
    return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterID2IF2___New_orig__()

def itkFFTNormalizedCorrelationImageFilterID2IF2_cast(obj: 'itkLightObject') -> "itkFFTNormalizedCorrelationImageFilterID2IF2 *":
    """itkFFTNormalizedCorrelationImageFilterID2IF2_cast(itkLightObject obj) -> itkFFTNormalizedCorrelationImageFilterID2IF2"""
    return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterID2IF2_cast(obj)

class itkFFTNormalizedCorrelationImageFilterID3ID3(itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID3ID3):
    """


    Calculate normalized cross correlation using FFTs.

    This filter calculates the normalized cross correlation (NCC) of two
    images using FFTs instead of spatial correlation. It is much faster
    than spatial correlation for reasonably large structuring elements.
    This filter is a subclass of the more general
    MaskedFFTNormalizedCorrelationImageFilter and operates by essentially
    setting the masks in that algorithm to images of ones. As described in
    detail in the references below, there is no computational overhead to
    utilizing the more general masked algorithm because the FFTs of the
    images of ones are still necessary for the computations.

    Inputs: Two images are required as inputs, fixedImage and movingImage.
    In the context of correlation, inputs are often defined as: "image"
    and "template". In this filter, the fixedImage plays the role of the
    image, and the movingImage plays the role of the template. However,
    this filter is capable of correlating any two images and is not
    restricted to small movingImages (templates).

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify how many voxels of the two images must overlap; any
    location in the correlation map that results from fewer than this
    number of voxels will be set to zero. Larger values zero-out pixels on
    a larger border around the correlation image. Thus, larger values
    remove less stable computations but also limit the capture range. If
    RequiredNumberOfOverlappingPixels is set to 0, the default, no zeroing
    will take place.

    Image size: fixedImage and movingImage need not be the same size.
    Furthermore, whereas some algorithms require that the "template" be
    smaller than the "image" because of errors in the regions where the
    two are not fully overlapping, this filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain,
    all input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the NCC of
    the two images and its values range from -1.0 to 1.0. The size of this
    NCC image is, by definition, size(fixedImage) + size(movingImage) - 1.

    Example filter usage:

    WARNING:  The pixel type of the output image must be of real type
    (float or double). ConceptChecking is used to enforce the output pixel
    type. You will get a compilation error if the pixel type of the output
    image is not float or double.  References: 1) D. Padfield. "Masked
    object registration in the Fourier domain." Transactions on Image
    Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.

    : Dirk Padfield, GE Global Research, padfield@research.ge.com

    C++ includes: itkFFTNormalizedCorrelationImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkFFTNormalizedCorrelationImageFilterID3ID3_Pointer":
        """__New_orig__() -> itkFFTNormalizedCorrelationImageFilterID3ID3_Pointer"""
        return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterID3ID3___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkFFTNormalizedCorrelationImageFilterID3ID3_Pointer":
        """Clone(itkFFTNormalizedCorrelationImageFilterID3ID3 self) -> itkFFTNormalizedCorrelationImageFilterID3ID3_Pointer"""
        return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterID3ID3_Clone(self)

    __swig_destroy__ = _itkFFTNormalizedCorrelationImageFilterPython.delete_itkFFTNormalizedCorrelationImageFilterID3ID3

    def cast(obj: 'itkLightObject') -> "itkFFTNormalizedCorrelationImageFilterID3ID3 *":
        """cast(itkLightObject obj) -> itkFFTNormalizedCorrelationImageFilterID3ID3"""
        return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterID3ID3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkFFTNormalizedCorrelationImageFilterID3ID3

        Create a new object of the class itkFFTNormalizedCorrelationImageFilterID3ID3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkFFTNormalizedCorrelationImageFilterID3ID3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkFFTNormalizedCorrelationImageFilterID3ID3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkFFTNormalizedCorrelationImageFilterID3ID3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkFFTNormalizedCorrelationImageFilterID3ID3.Clone = new_instancemethod(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterID3ID3_Clone, None, itkFFTNormalizedCorrelationImageFilterID3ID3)
itkFFTNormalizedCorrelationImageFilterID3ID3_swigregister = _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterID3ID3_swigregister
itkFFTNormalizedCorrelationImageFilterID3ID3_swigregister(itkFFTNormalizedCorrelationImageFilterID3ID3)

def itkFFTNormalizedCorrelationImageFilterID3ID3___New_orig__() -> "itkFFTNormalizedCorrelationImageFilterID3ID3_Pointer":
    """itkFFTNormalizedCorrelationImageFilterID3ID3___New_orig__() -> itkFFTNormalizedCorrelationImageFilterID3ID3_Pointer"""
    return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterID3ID3___New_orig__()

def itkFFTNormalizedCorrelationImageFilterID3ID3_cast(obj: 'itkLightObject') -> "itkFFTNormalizedCorrelationImageFilterID3ID3 *":
    """itkFFTNormalizedCorrelationImageFilterID3ID3_cast(itkLightObject obj) -> itkFFTNormalizedCorrelationImageFilterID3ID3"""
    return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterID3ID3_cast(obj)

class itkFFTNormalizedCorrelationImageFilterID3IF3(itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID3IF3):
    """


    Calculate normalized cross correlation using FFTs.

    This filter calculates the normalized cross correlation (NCC) of two
    images using FFTs instead of spatial correlation. It is much faster
    than spatial correlation for reasonably large structuring elements.
    This filter is a subclass of the more general
    MaskedFFTNormalizedCorrelationImageFilter and operates by essentially
    setting the masks in that algorithm to images of ones. As described in
    detail in the references below, there is no computational overhead to
    utilizing the more general masked algorithm because the FFTs of the
    images of ones are still necessary for the computations.

    Inputs: Two images are required as inputs, fixedImage and movingImage.
    In the context of correlation, inputs are often defined as: "image"
    and "template". In this filter, the fixedImage plays the role of the
    image, and the movingImage plays the role of the template. However,
    this filter is capable of correlating any two images and is not
    restricted to small movingImages (templates).

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify how many voxels of the two images must overlap; any
    location in the correlation map that results from fewer than this
    number of voxels will be set to zero. Larger values zero-out pixels on
    a larger border around the correlation image. Thus, larger values
    remove less stable computations but also limit the capture range. If
    RequiredNumberOfOverlappingPixels is set to 0, the default, no zeroing
    will take place.

    Image size: fixedImage and movingImage need not be the same size.
    Furthermore, whereas some algorithms require that the "template" be
    smaller than the "image" because of errors in the regions where the
    two are not fully overlapping, this filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain,
    all input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the NCC of
    the two images and its values range from -1.0 to 1.0. The size of this
    NCC image is, by definition, size(fixedImage) + size(movingImage) - 1.

    Example filter usage:

    WARNING:  The pixel type of the output image must be of real type
    (float or double). ConceptChecking is used to enforce the output pixel
    type. You will get a compilation error if the pixel type of the output
    image is not float or double.  References: 1) D. Padfield. "Masked
    object registration in the Fourier domain." Transactions on Image
    Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.

    : Dirk Padfield, GE Global Research, padfield@research.ge.com

    C++ includes: itkFFTNormalizedCorrelationImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkFFTNormalizedCorrelationImageFilterID3IF3_Pointer":
        """__New_orig__() -> itkFFTNormalizedCorrelationImageFilterID3IF3_Pointer"""
        return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterID3IF3___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkFFTNormalizedCorrelationImageFilterID3IF3_Pointer":
        """Clone(itkFFTNormalizedCorrelationImageFilterID3IF3 self) -> itkFFTNormalizedCorrelationImageFilterID3IF3_Pointer"""
        return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterID3IF3_Clone(self)

    __swig_destroy__ = _itkFFTNormalizedCorrelationImageFilterPython.delete_itkFFTNormalizedCorrelationImageFilterID3IF3

    def cast(obj: 'itkLightObject') -> "itkFFTNormalizedCorrelationImageFilterID3IF3 *":
        """cast(itkLightObject obj) -> itkFFTNormalizedCorrelationImageFilterID3IF3"""
        return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterID3IF3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkFFTNormalizedCorrelationImageFilterID3IF3

        Create a new object of the class itkFFTNormalizedCorrelationImageFilterID3IF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkFFTNormalizedCorrelationImageFilterID3IF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkFFTNormalizedCorrelationImageFilterID3IF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkFFTNormalizedCorrelationImageFilterID3IF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkFFTNormalizedCorrelationImageFilterID3IF3.Clone = new_instancemethod(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterID3IF3_Clone, None, itkFFTNormalizedCorrelationImageFilterID3IF3)
itkFFTNormalizedCorrelationImageFilterID3IF3_swigregister = _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterID3IF3_swigregister
itkFFTNormalizedCorrelationImageFilterID3IF3_swigregister(itkFFTNormalizedCorrelationImageFilterID3IF3)

def itkFFTNormalizedCorrelationImageFilterID3IF3___New_orig__() -> "itkFFTNormalizedCorrelationImageFilterID3IF3_Pointer":
    """itkFFTNormalizedCorrelationImageFilterID3IF3___New_orig__() -> itkFFTNormalizedCorrelationImageFilterID3IF3_Pointer"""
    return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterID3IF3___New_orig__()

def itkFFTNormalizedCorrelationImageFilterID3IF3_cast(obj: 'itkLightObject') -> "itkFFTNormalizedCorrelationImageFilterID3IF3 *":
    """itkFFTNormalizedCorrelationImageFilterID3IF3_cast(itkLightObject obj) -> itkFFTNormalizedCorrelationImageFilterID3IF3"""
    return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterID3IF3_cast(obj)

class itkFFTNormalizedCorrelationImageFilterIF2ID2(itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF2ID2):
    """


    Calculate normalized cross correlation using FFTs.

    This filter calculates the normalized cross correlation (NCC) of two
    images using FFTs instead of spatial correlation. It is much faster
    than spatial correlation for reasonably large structuring elements.
    This filter is a subclass of the more general
    MaskedFFTNormalizedCorrelationImageFilter and operates by essentially
    setting the masks in that algorithm to images of ones. As described in
    detail in the references below, there is no computational overhead to
    utilizing the more general masked algorithm because the FFTs of the
    images of ones are still necessary for the computations.

    Inputs: Two images are required as inputs, fixedImage and movingImage.
    In the context of correlation, inputs are often defined as: "image"
    and "template". In this filter, the fixedImage plays the role of the
    image, and the movingImage plays the role of the template. However,
    this filter is capable of correlating any two images and is not
    restricted to small movingImages (templates).

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify how many voxels of the two images must overlap; any
    location in the correlation map that results from fewer than this
    number of voxels will be set to zero. Larger values zero-out pixels on
    a larger border around the correlation image. Thus, larger values
    remove less stable computations but also limit the capture range. If
    RequiredNumberOfOverlappingPixels is set to 0, the default, no zeroing
    will take place.

    Image size: fixedImage and movingImage need not be the same size.
    Furthermore, whereas some algorithms require that the "template" be
    smaller than the "image" because of errors in the regions where the
    two are not fully overlapping, this filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain,
    all input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the NCC of
    the two images and its values range from -1.0 to 1.0. The size of this
    NCC image is, by definition, size(fixedImage) + size(movingImage) - 1.

    Example filter usage:

    WARNING:  The pixel type of the output image must be of real type
    (float or double). ConceptChecking is used to enforce the output pixel
    type. You will get a compilation error if the pixel type of the output
    image is not float or double.  References: 1) D. Padfield. "Masked
    object registration in the Fourier domain." Transactions on Image
    Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.

    : Dirk Padfield, GE Global Research, padfield@research.ge.com

    C++ includes: itkFFTNormalizedCorrelationImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkFFTNormalizedCorrelationImageFilterIF2ID2_Pointer":
        """__New_orig__() -> itkFFTNormalizedCorrelationImageFilterIF2ID2_Pointer"""
        return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIF2ID2___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkFFTNormalizedCorrelationImageFilterIF2ID2_Pointer":
        """Clone(itkFFTNormalizedCorrelationImageFilterIF2ID2 self) -> itkFFTNormalizedCorrelationImageFilterIF2ID2_Pointer"""
        return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIF2ID2_Clone(self)

    __swig_destroy__ = _itkFFTNormalizedCorrelationImageFilterPython.delete_itkFFTNormalizedCorrelationImageFilterIF2ID2

    def cast(obj: 'itkLightObject') -> "itkFFTNormalizedCorrelationImageFilterIF2ID2 *":
        """cast(itkLightObject obj) -> itkFFTNormalizedCorrelationImageFilterIF2ID2"""
        return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIF2ID2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkFFTNormalizedCorrelationImageFilterIF2ID2

        Create a new object of the class itkFFTNormalizedCorrelationImageFilterIF2ID2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkFFTNormalizedCorrelationImageFilterIF2ID2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkFFTNormalizedCorrelationImageFilterIF2ID2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkFFTNormalizedCorrelationImageFilterIF2ID2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkFFTNormalizedCorrelationImageFilterIF2ID2.Clone = new_instancemethod(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIF2ID2_Clone, None, itkFFTNormalizedCorrelationImageFilterIF2ID2)
itkFFTNormalizedCorrelationImageFilterIF2ID2_swigregister = _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIF2ID2_swigregister
itkFFTNormalizedCorrelationImageFilterIF2ID2_swigregister(itkFFTNormalizedCorrelationImageFilterIF2ID2)

def itkFFTNormalizedCorrelationImageFilterIF2ID2___New_orig__() -> "itkFFTNormalizedCorrelationImageFilterIF2ID2_Pointer":
    """itkFFTNormalizedCorrelationImageFilterIF2ID2___New_orig__() -> itkFFTNormalizedCorrelationImageFilterIF2ID2_Pointer"""
    return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIF2ID2___New_orig__()

def itkFFTNormalizedCorrelationImageFilterIF2ID2_cast(obj: 'itkLightObject') -> "itkFFTNormalizedCorrelationImageFilterIF2ID2 *":
    """itkFFTNormalizedCorrelationImageFilterIF2ID2_cast(itkLightObject obj) -> itkFFTNormalizedCorrelationImageFilterIF2ID2"""
    return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIF2ID2_cast(obj)

class itkFFTNormalizedCorrelationImageFilterIF2IF2(itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF2IF2):
    """


    Calculate normalized cross correlation using FFTs.

    This filter calculates the normalized cross correlation (NCC) of two
    images using FFTs instead of spatial correlation. It is much faster
    than spatial correlation for reasonably large structuring elements.
    This filter is a subclass of the more general
    MaskedFFTNormalizedCorrelationImageFilter and operates by essentially
    setting the masks in that algorithm to images of ones. As described in
    detail in the references below, there is no computational overhead to
    utilizing the more general masked algorithm because the FFTs of the
    images of ones are still necessary for the computations.

    Inputs: Two images are required as inputs, fixedImage and movingImage.
    In the context of correlation, inputs are often defined as: "image"
    and "template". In this filter, the fixedImage plays the role of the
    image, and the movingImage plays the role of the template. However,
    this filter is capable of correlating any two images and is not
    restricted to small movingImages (templates).

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify how many voxels of the two images must overlap; any
    location in the correlation map that results from fewer than this
    number of voxels will be set to zero. Larger values zero-out pixels on
    a larger border around the correlation image. Thus, larger values
    remove less stable computations but also limit the capture range. If
    RequiredNumberOfOverlappingPixels is set to 0, the default, no zeroing
    will take place.

    Image size: fixedImage and movingImage need not be the same size.
    Furthermore, whereas some algorithms require that the "template" be
    smaller than the "image" because of errors in the regions where the
    two are not fully overlapping, this filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain,
    all input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the NCC of
    the two images and its values range from -1.0 to 1.0. The size of this
    NCC image is, by definition, size(fixedImage) + size(movingImage) - 1.

    Example filter usage:

    WARNING:  The pixel type of the output image must be of real type
    (float or double). ConceptChecking is used to enforce the output pixel
    type. You will get a compilation error if the pixel type of the output
    image is not float or double.  References: 1) D. Padfield. "Masked
    object registration in the Fourier domain." Transactions on Image
    Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.

    : Dirk Padfield, GE Global Research, padfield@research.ge.com

    C++ includes: itkFFTNormalizedCorrelationImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkFFTNormalizedCorrelationImageFilterIF2IF2_Pointer":
        """__New_orig__() -> itkFFTNormalizedCorrelationImageFilterIF2IF2_Pointer"""
        return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIF2IF2___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkFFTNormalizedCorrelationImageFilterIF2IF2_Pointer":
        """Clone(itkFFTNormalizedCorrelationImageFilterIF2IF2 self) -> itkFFTNormalizedCorrelationImageFilterIF2IF2_Pointer"""
        return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIF2IF2_Clone(self)

    __swig_destroy__ = _itkFFTNormalizedCorrelationImageFilterPython.delete_itkFFTNormalizedCorrelationImageFilterIF2IF2

    def cast(obj: 'itkLightObject') -> "itkFFTNormalizedCorrelationImageFilterIF2IF2 *":
        """cast(itkLightObject obj) -> itkFFTNormalizedCorrelationImageFilterIF2IF2"""
        return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIF2IF2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkFFTNormalizedCorrelationImageFilterIF2IF2

        Create a new object of the class itkFFTNormalizedCorrelationImageFilterIF2IF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkFFTNormalizedCorrelationImageFilterIF2IF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkFFTNormalizedCorrelationImageFilterIF2IF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkFFTNormalizedCorrelationImageFilterIF2IF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkFFTNormalizedCorrelationImageFilterIF2IF2.Clone = new_instancemethod(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIF2IF2_Clone, None, itkFFTNormalizedCorrelationImageFilterIF2IF2)
itkFFTNormalizedCorrelationImageFilterIF2IF2_swigregister = _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIF2IF2_swigregister
itkFFTNormalizedCorrelationImageFilterIF2IF2_swigregister(itkFFTNormalizedCorrelationImageFilterIF2IF2)

def itkFFTNormalizedCorrelationImageFilterIF2IF2___New_orig__() -> "itkFFTNormalizedCorrelationImageFilterIF2IF2_Pointer":
    """itkFFTNormalizedCorrelationImageFilterIF2IF2___New_orig__() -> itkFFTNormalizedCorrelationImageFilterIF2IF2_Pointer"""
    return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIF2IF2___New_orig__()

def itkFFTNormalizedCorrelationImageFilterIF2IF2_cast(obj: 'itkLightObject') -> "itkFFTNormalizedCorrelationImageFilterIF2IF2 *":
    """itkFFTNormalizedCorrelationImageFilterIF2IF2_cast(itkLightObject obj) -> itkFFTNormalizedCorrelationImageFilterIF2IF2"""
    return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIF2IF2_cast(obj)

class itkFFTNormalizedCorrelationImageFilterIF3ID3(itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF3ID3):
    """


    Calculate normalized cross correlation using FFTs.

    This filter calculates the normalized cross correlation (NCC) of two
    images using FFTs instead of spatial correlation. It is much faster
    than spatial correlation for reasonably large structuring elements.
    This filter is a subclass of the more general
    MaskedFFTNormalizedCorrelationImageFilter and operates by essentially
    setting the masks in that algorithm to images of ones. As described in
    detail in the references below, there is no computational overhead to
    utilizing the more general masked algorithm because the FFTs of the
    images of ones are still necessary for the computations.

    Inputs: Two images are required as inputs, fixedImage and movingImage.
    In the context of correlation, inputs are often defined as: "image"
    and "template". In this filter, the fixedImage plays the role of the
    image, and the movingImage plays the role of the template. However,
    this filter is capable of correlating any two images and is not
    restricted to small movingImages (templates).

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify how many voxels of the two images must overlap; any
    location in the correlation map that results from fewer than this
    number of voxels will be set to zero. Larger values zero-out pixels on
    a larger border around the correlation image. Thus, larger values
    remove less stable computations but also limit the capture range. If
    RequiredNumberOfOverlappingPixels is set to 0, the default, no zeroing
    will take place.

    Image size: fixedImage and movingImage need not be the same size.
    Furthermore, whereas some algorithms require that the "template" be
    smaller than the "image" because of errors in the regions where the
    two are not fully overlapping, this filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain,
    all input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the NCC of
    the two images and its values range from -1.0 to 1.0. The size of this
    NCC image is, by definition, size(fixedImage) + size(movingImage) - 1.

    Example filter usage:

    WARNING:  The pixel type of the output image must be of real type
    (float or double). ConceptChecking is used to enforce the output pixel
    type. You will get a compilation error if the pixel type of the output
    image is not float or double.  References: 1) D. Padfield. "Masked
    object registration in the Fourier domain." Transactions on Image
    Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.

    : Dirk Padfield, GE Global Research, padfield@research.ge.com

    C++ includes: itkFFTNormalizedCorrelationImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkFFTNormalizedCorrelationImageFilterIF3ID3_Pointer":
        """__New_orig__() -> itkFFTNormalizedCorrelationImageFilterIF3ID3_Pointer"""
        return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIF3ID3___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkFFTNormalizedCorrelationImageFilterIF3ID3_Pointer":
        """Clone(itkFFTNormalizedCorrelationImageFilterIF3ID3 self) -> itkFFTNormalizedCorrelationImageFilterIF3ID3_Pointer"""
        return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIF3ID3_Clone(self)

    __swig_destroy__ = _itkFFTNormalizedCorrelationImageFilterPython.delete_itkFFTNormalizedCorrelationImageFilterIF3ID3

    def cast(obj: 'itkLightObject') -> "itkFFTNormalizedCorrelationImageFilterIF3ID3 *":
        """cast(itkLightObject obj) -> itkFFTNormalizedCorrelationImageFilterIF3ID3"""
        return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIF3ID3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkFFTNormalizedCorrelationImageFilterIF3ID3

        Create a new object of the class itkFFTNormalizedCorrelationImageFilterIF3ID3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkFFTNormalizedCorrelationImageFilterIF3ID3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkFFTNormalizedCorrelationImageFilterIF3ID3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkFFTNormalizedCorrelationImageFilterIF3ID3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkFFTNormalizedCorrelationImageFilterIF3ID3.Clone = new_instancemethod(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIF3ID3_Clone, None, itkFFTNormalizedCorrelationImageFilterIF3ID3)
itkFFTNormalizedCorrelationImageFilterIF3ID3_swigregister = _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIF3ID3_swigregister
itkFFTNormalizedCorrelationImageFilterIF3ID3_swigregister(itkFFTNormalizedCorrelationImageFilterIF3ID3)

def itkFFTNormalizedCorrelationImageFilterIF3ID3___New_orig__() -> "itkFFTNormalizedCorrelationImageFilterIF3ID3_Pointer":
    """itkFFTNormalizedCorrelationImageFilterIF3ID3___New_orig__() -> itkFFTNormalizedCorrelationImageFilterIF3ID3_Pointer"""
    return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIF3ID3___New_orig__()

def itkFFTNormalizedCorrelationImageFilterIF3ID3_cast(obj: 'itkLightObject') -> "itkFFTNormalizedCorrelationImageFilterIF3ID3 *":
    """itkFFTNormalizedCorrelationImageFilterIF3ID3_cast(itkLightObject obj) -> itkFFTNormalizedCorrelationImageFilterIF3ID3"""
    return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIF3ID3_cast(obj)

class itkFFTNormalizedCorrelationImageFilterIF3IF3(itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF3IF3):
    """


    Calculate normalized cross correlation using FFTs.

    This filter calculates the normalized cross correlation (NCC) of two
    images using FFTs instead of spatial correlation. It is much faster
    than spatial correlation for reasonably large structuring elements.
    This filter is a subclass of the more general
    MaskedFFTNormalizedCorrelationImageFilter and operates by essentially
    setting the masks in that algorithm to images of ones. As described in
    detail in the references below, there is no computational overhead to
    utilizing the more general masked algorithm because the FFTs of the
    images of ones are still necessary for the computations.

    Inputs: Two images are required as inputs, fixedImage and movingImage.
    In the context of correlation, inputs are often defined as: "image"
    and "template". In this filter, the fixedImage plays the role of the
    image, and the movingImage plays the role of the template. However,
    this filter is capable of correlating any two images and is not
    restricted to small movingImages (templates).

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify how many voxels of the two images must overlap; any
    location in the correlation map that results from fewer than this
    number of voxels will be set to zero. Larger values zero-out pixels on
    a larger border around the correlation image. Thus, larger values
    remove less stable computations but also limit the capture range. If
    RequiredNumberOfOverlappingPixels is set to 0, the default, no zeroing
    will take place.

    Image size: fixedImage and movingImage need not be the same size.
    Furthermore, whereas some algorithms require that the "template" be
    smaller than the "image" because of errors in the regions where the
    two are not fully overlapping, this filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain,
    all input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the NCC of
    the two images and its values range from -1.0 to 1.0. The size of this
    NCC image is, by definition, size(fixedImage) + size(movingImage) - 1.

    Example filter usage:

    WARNING:  The pixel type of the output image must be of real type
    (float or double). ConceptChecking is used to enforce the output pixel
    type. You will get a compilation error if the pixel type of the output
    image is not float or double.  References: 1) D. Padfield. "Masked
    object registration in the Fourier domain." Transactions on Image
    Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.

    : Dirk Padfield, GE Global Research, padfield@research.ge.com

    C++ includes: itkFFTNormalizedCorrelationImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkFFTNormalizedCorrelationImageFilterIF3IF3_Pointer":
        """__New_orig__() -> itkFFTNormalizedCorrelationImageFilterIF3IF3_Pointer"""
        return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIF3IF3___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkFFTNormalizedCorrelationImageFilterIF3IF3_Pointer":
        """Clone(itkFFTNormalizedCorrelationImageFilterIF3IF3 self) -> itkFFTNormalizedCorrelationImageFilterIF3IF3_Pointer"""
        return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIF3IF3_Clone(self)

    __swig_destroy__ = _itkFFTNormalizedCorrelationImageFilterPython.delete_itkFFTNormalizedCorrelationImageFilterIF3IF3

    def cast(obj: 'itkLightObject') -> "itkFFTNormalizedCorrelationImageFilterIF3IF3 *":
        """cast(itkLightObject obj) -> itkFFTNormalizedCorrelationImageFilterIF3IF3"""
        return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIF3IF3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkFFTNormalizedCorrelationImageFilterIF3IF3

        Create a new object of the class itkFFTNormalizedCorrelationImageFilterIF3IF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkFFTNormalizedCorrelationImageFilterIF3IF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkFFTNormalizedCorrelationImageFilterIF3IF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkFFTNormalizedCorrelationImageFilterIF3IF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkFFTNormalizedCorrelationImageFilterIF3IF3.Clone = new_instancemethod(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIF3IF3_Clone, None, itkFFTNormalizedCorrelationImageFilterIF3IF3)
itkFFTNormalizedCorrelationImageFilterIF3IF3_swigregister = _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIF3IF3_swigregister
itkFFTNormalizedCorrelationImageFilterIF3IF3_swigregister(itkFFTNormalizedCorrelationImageFilterIF3IF3)

def itkFFTNormalizedCorrelationImageFilterIF3IF3___New_orig__() -> "itkFFTNormalizedCorrelationImageFilterIF3IF3_Pointer":
    """itkFFTNormalizedCorrelationImageFilterIF3IF3___New_orig__() -> itkFFTNormalizedCorrelationImageFilterIF3IF3_Pointer"""
    return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIF3IF3___New_orig__()

def itkFFTNormalizedCorrelationImageFilterIF3IF3_cast(obj: 'itkLightObject') -> "itkFFTNormalizedCorrelationImageFilterIF3IF3 *":
    """itkFFTNormalizedCorrelationImageFilterIF3IF3_cast(itkLightObject obj) -> itkFFTNormalizedCorrelationImageFilterIF3IF3"""
    return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIF3IF3_cast(obj)

class itkFFTNormalizedCorrelationImageFilterISS2ID2(itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS2ID2):
    """


    Calculate normalized cross correlation using FFTs.

    This filter calculates the normalized cross correlation (NCC) of two
    images using FFTs instead of spatial correlation. It is much faster
    than spatial correlation for reasonably large structuring elements.
    This filter is a subclass of the more general
    MaskedFFTNormalizedCorrelationImageFilter and operates by essentially
    setting the masks in that algorithm to images of ones. As described in
    detail in the references below, there is no computational overhead to
    utilizing the more general masked algorithm because the FFTs of the
    images of ones are still necessary for the computations.

    Inputs: Two images are required as inputs, fixedImage and movingImage.
    In the context of correlation, inputs are often defined as: "image"
    and "template". In this filter, the fixedImage plays the role of the
    image, and the movingImage plays the role of the template. However,
    this filter is capable of correlating any two images and is not
    restricted to small movingImages (templates).

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify how many voxels of the two images must overlap; any
    location in the correlation map that results from fewer than this
    number of voxels will be set to zero. Larger values zero-out pixels on
    a larger border around the correlation image. Thus, larger values
    remove less stable computations but also limit the capture range. If
    RequiredNumberOfOverlappingPixels is set to 0, the default, no zeroing
    will take place.

    Image size: fixedImage and movingImage need not be the same size.
    Furthermore, whereas some algorithms require that the "template" be
    smaller than the "image" because of errors in the regions where the
    two are not fully overlapping, this filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain,
    all input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the NCC of
    the two images and its values range from -1.0 to 1.0. The size of this
    NCC image is, by definition, size(fixedImage) + size(movingImage) - 1.

    Example filter usage:

    WARNING:  The pixel type of the output image must be of real type
    (float or double). ConceptChecking is used to enforce the output pixel
    type. You will get a compilation error if the pixel type of the output
    image is not float or double.  References: 1) D. Padfield. "Masked
    object registration in the Fourier domain." Transactions on Image
    Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.

    : Dirk Padfield, GE Global Research, padfield@research.ge.com

    C++ includes: itkFFTNormalizedCorrelationImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkFFTNormalizedCorrelationImageFilterISS2ID2_Pointer":
        """__New_orig__() -> itkFFTNormalizedCorrelationImageFilterISS2ID2_Pointer"""
        return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterISS2ID2___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkFFTNormalizedCorrelationImageFilterISS2ID2_Pointer":
        """Clone(itkFFTNormalizedCorrelationImageFilterISS2ID2 self) -> itkFFTNormalizedCorrelationImageFilterISS2ID2_Pointer"""
        return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterISS2ID2_Clone(self)

    __swig_destroy__ = _itkFFTNormalizedCorrelationImageFilterPython.delete_itkFFTNormalizedCorrelationImageFilterISS2ID2

    def cast(obj: 'itkLightObject') -> "itkFFTNormalizedCorrelationImageFilterISS2ID2 *":
        """cast(itkLightObject obj) -> itkFFTNormalizedCorrelationImageFilterISS2ID2"""
        return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterISS2ID2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkFFTNormalizedCorrelationImageFilterISS2ID2

        Create a new object of the class itkFFTNormalizedCorrelationImageFilterISS2ID2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkFFTNormalizedCorrelationImageFilterISS2ID2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkFFTNormalizedCorrelationImageFilterISS2ID2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkFFTNormalizedCorrelationImageFilterISS2ID2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkFFTNormalizedCorrelationImageFilterISS2ID2.Clone = new_instancemethod(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterISS2ID2_Clone, None, itkFFTNormalizedCorrelationImageFilterISS2ID2)
itkFFTNormalizedCorrelationImageFilterISS2ID2_swigregister = _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterISS2ID2_swigregister
itkFFTNormalizedCorrelationImageFilterISS2ID2_swigregister(itkFFTNormalizedCorrelationImageFilterISS2ID2)

def itkFFTNormalizedCorrelationImageFilterISS2ID2___New_orig__() -> "itkFFTNormalizedCorrelationImageFilterISS2ID2_Pointer":
    """itkFFTNormalizedCorrelationImageFilterISS2ID2___New_orig__() -> itkFFTNormalizedCorrelationImageFilterISS2ID2_Pointer"""
    return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterISS2ID2___New_orig__()

def itkFFTNormalizedCorrelationImageFilterISS2ID2_cast(obj: 'itkLightObject') -> "itkFFTNormalizedCorrelationImageFilterISS2ID2 *":
    """itkFFTNormalizedCorrelationImageFilterISS2ID2_cast(itkLightObject obj) -> itkFFTNormalizedCorrelationImageFilterISS2ID2"""
    return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterISS2ID2_cast(obj)

class itkFFTNormalizedCorrelationImageFilterISS2IF2(itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS2IF2):
    """


    Calculate normalized cross correlation using FFTs.

    This filter calculates the normalized cross correlation (NCC) of two
    images using FFTs instead of spatial correlation. It is much faster
    than spatial correlation for reasonably large structuring elements.
    This filter is a subclass of the more general
    MaskedFFTNormalizedCorrelationImageFilter and operates by essentially
    setting the masks in that algorithm to images of ones. As described in
    detail in the references below, there is no computational overhead to
    utilizing the more general masked algorithm because the FFTs of the
    images of ones are still necessary for the computations.

    Inputs: Two images are required as inputs, fixedImage and movingImage.
    In the context of correlation, inputs are often defined as: "image"
    and "template". In this filter, the fixedImage plays the role of the
    image, and the movingImage plays the role of the template. However,
    this filter is capable of correlating any two images and is not
    restricted to small movingImages (templates).

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify how many voxels of the two images must overlap; any
    location in the correlation map that results from fewer than this
    number of voxels will be set to zero. Larger values zero-out pixels on
    a larger border around the correlation image. Thus, larger values
    remove less stable computations but also limit the capture range. If
    RequiredNumberOfOverlappingPixels is set to 0, the default, no zeroing
    will take place.

    Image size: fixedImage and movingImage need not be the same size.
    Furthermore, whereas some algorithms require that the "template" be
    smaller than the "image" because of errors in the regions where the
    two are not fully overlapping, this filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain,
    all input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the NCC of
    the two images and its values range from -1.0 to 1.0. The size of this
    NCC image is, by definition, size(fixedImage) + size(movingImage) - 1.

    Example filter usage:

    WARNING:  The pixel type of the output image must be of real type
    (float or double). ConceptChecking is used to enforce the output pixel
    type. You will get a compilation error if the pixel type of the output
    image is not float or double.  References: 1) D. Padfield. "Masked
    object registration in the Fourier domain." Transactions on Image
    Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.

    : Dirk Padfield, GE Global Research, padfield@research.ge.com

    C++ includes: itkFFTNormalizedCorrelationImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkFFTNormalizedCorrelationImageFilterISS2IF2_Pointer":
        """__New_orig__() -> itkFFTNormalizedCorrelationImageFilterISS2IF2_Pointer"""
        return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterISS2IF2___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkFFTNormalizedCorrelationImageFilterISS2IF2_Pointer":
        """Clone(itkFFTNormalizedCorrelationImageFilterISS2IF2 self) -> itkFFTNormalizedCorrelationImageFilterISS2IF2_Pointer"""
        return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterISS2IF2_Clone(self)

    __swig_destroy__ = _itkFFTNormalizedCorrelationImageFilterPython.delete_itkFFTNormalizedCorrelationImageFilterISS2IF2

    def cast(obj: 'itkLightObject') -> "itkFFTNormalizedCorrelationImageFilterISS2IF2 *":
        """cast(itkLightObject obj) -> itkFFTNormalizedCorrelationImageFilterISS2IF2"""
        return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterISS2IF2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkFFTNormalizedCorrelationImageFilterISS2IF2

        Create a new object of the class itkFFTNormalizedCorrelationImageFilterISS2IF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkFFTNormalizedCorrelationImageFilterISS2IF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkFFTNormalizedCorrelationImageFilterISS2IF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkFFTNormalizedCorrelationImageFilterISS2IF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkFFTNormalizedCorrelationImageFilterISS2IF2.Clone = new_instancemethod(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterISS2IF2_Clone, None, itkFFTNormalizedCorrelationImageFilterISS2IF2)
itkFFTNormalizedCorrelationImageFilterISS2IF2_swigregister = _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterISS2IF2_swigregister
itkFFTNormalizedCorrelationImageFilterISS2IF2_swigregister(itkFFTNormalizedCorrelationImageFilterISS2IF2)

def itkFFTNormalizedCorrelationImageFilterISS2IF2___New_orig__() -> "itkFFTNormalizedCorrelationImageFilterISS2IF2_Pointer":
    """itkFFTNormalizedCorrelationImageFilterISS2IF2___New_orig__() -> itkFFTNormalizedCorrelationImageFilterISS2IF2_Pointer"""
    return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterISS2IF2___New_orig__()

def itkFFTNormalizedCorrelationImageFilterISS2IF2_cast(obj: 'itkLightObject') -> "itkFFTNormalizedCorrelationImageFilterISS2IF2 *":
    """itkFFTNormalizedCorrelationImageFilterISS2IF2_cast(itkLightObject obj) -> itkFFTNormalizedCorrelationImageFilterISS2IF2"""
    return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterISS2IF2_cast(obj)

class itkFFTNormalizedCorrelationImageFilterISS3ID3(itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS3ID3):
    """


    Calculate normalized cross correlation using FFTs.

    This filter calculates the normalized cross correlation (NCC) of two
    images using FFTs instead of spatial correlation. It is much faster
    than spatial correlation for reasonably large structuring elements.
    This filter is a subclass of the more general
    MaskedFFTNormalizedCorrelationImageFilter and operates by essentially
    setting the masks in that algorithm to images of ones. As described in
    detail in the references below, there is no computational overhead to
    utilizing the more general masked algorithm because the FFTs of the
    images of ones are still necessary for the computations.

    Inputs: Two images are required as inputs, fixedImage and movingImage.
    In the context of correlation, inputs are often defined as: "image"
    and "template". In this filter, the fixedImage plays the role of the
    image, and the movingImage plays the role of the template. However,
    this filter is capable of correlating any two images and is not
    restricted to small movingImages (templates).

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify how many voxels of the two images must overlap; any
    location in the correlation map that results from fewer than this
    number of voxels will be set to zero. Larger values zero-out pixels on
    a larger border around the correlation image. Thus, larger values
    remove less stable computations but also limit the capture range. If
    RequiredNumberOfOverlappingPixels is set to 0, the default, no zeroing
    will take place.

    Image size: fixedImage and movingImage need not be the same size.
    Furthermore, whereas some algorithms require that the "template" be
    smaller than the "image" because of errors in the regions where the
    two are not fully overlapping, this filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain,
    all input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the NCC of
    the two images and its values range from -1.0 to 1.0. The size of this
    NCC image is, by definition, size(fixedImage) + size(movingImage) - 1.

    Example filter usage:

    WARNING:  The pixel type of the output image must be of real type
    (float or double). ConceptChecking is used to enforce the output pixel
    type. You will get a compilation error if the pixel type of the output
    image is not float or double.  References: 1) D. Padfield. "Masked
    object registration in the Fourier domain." Transactions on Image
    Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.

    : Dirk Padfield, GE Global Research, padfield@research.ge.com

    C++ includes: itkFFTNormalizedCorrelationImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkFFTNormalizedCorrelationImageFilterISS3ID3_Pointer":
        """__New_orig__() -> itkFFTNormalizedCorrelationImageFilterISS3ID3_Pointer"""
        return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterISS3ID3___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkFFTNormalizedCorrelationImageFilterISS3ID3_Pointer":
        """Clone(itkFFTNormalizedCorrelationImageFilterISS3ID3 self) -> itkFFTNormalizedCorrelationImageFilterISS3ID3_Pointer"""
        return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterISS3ID3_Clone(self)

    __swig_destroy__ = _itkFFTNormalizedCorrelationImageFilterPython.delete_itkFFTNormalizedCorrelationImageFilterISS3ID3

    def cast(obj: 'itkLightObject') -> "itkFFTNormalizedCorrelationImageFilterISS3ID3 *":
        """cast(itkLightObject obj) -> itkFFTNormalizedCorrelationImageFilterISS3ID3"""
        return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterISS3ID3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkFFTNormalizedCorrelationImageFilterISS3ID3

        Create a new object of the class itkFFTNormalizedCorrelationImageFilterISS3ID3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkFFTNormalizedCorrelationImageFilterISS3ID3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkFFTNormalizedCorrelationImageFilterISS3ID3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkFFTNormalizedCorrelationImageFilterISS3ID3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkFFTNormalizedCorrelationImageFilterISS3ID3.Clone = new_instancemethod(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterISS3ID3_Clone, None, itkFFTNormalizedCorrelationImageFilterISS3ID3)
itkFFTNormalizedCorrelationImageFilterISS3ID3_swigregister = _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterISS3ID3_swigregister
itkFFTNormalizedCorrelationImageFilterISS3ID3_swigregister(itkFFTNormalizedCorrelationImageFilterISS3ID3)

def itkFFTNormalizedCorrelationImageFilterISS3ID3___New_orig__() -> "itkFFTNormalizedCorrelationImageFilterISS3ID3_Pointer":
    """itkFFTNormalizedCorrelationImageFilterISS3ID3___New_orig__() -> itkFFTNormalizedCorrelationImageFilterISS3ID3_Pointer"""
    return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterISS3ID3___New_orig__()

def itkFFTNormalizedCorrelationImageFilterISS3ID3_cast(obj: 'itkLightObject') -> "itkFFTNormalizedCorrelationImageFilterISS3ID3 *":
    """itkFFTNormalizedCorrelationImageFilterISS3ID3_cast(itkLightObject obj) -> itkFFTNormalizedCorrelationImageFilterISS3ID3"""
    return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterISS3ID3_cast(obj)

class itkFFTNormalizedCorrelationImageFilterISS3IF3(itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS3IF3):
    """


    Calculate normalized cross correlation using FFTs.

    This filter calculates the normalized cross correlation (NCC) of two
    images using FFTs instead of spatial correlation. It is much faster
    than spatial correlation for reasonably large structuring elements.
    This filter is a subclass of the more general
    MaskedFFTNormalizedCorrelationImageFilter and operates by essentially
    setting the masks in that algorithm to images of ones. As described in
    detail in the references below, there is no computational overhead to
    utilizing the more general masked algorithm because the FFTs of the
    images of ones are still necessary for the computations.

    Inputs: Two images are required as inputs, fixedImage and movingImage.
    In the context of correlation, inputs are often defined as: "image"
    and "template". In this filter, the fixedImage plays the role of the
    image, and the movingImage plays the role of the template. However,
    this filter is capable of correlating any two images and is not
    restricted to small movingImages (templates).

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify how many voxels of the two images must overlap; any
    location in the correlation map that results from fewer than this
    number of voxels will be set to zero. Larger values zero-out pixels on
    a larger border around the correlation image. Thus, larger values
    remove less stable computations but also limit the capture range. If
    RequiredNumberOfOverlappingPixels is set to 0, the default, no zeroing
    will take place.

    Image size: fixedImage and movingImage need not be the same size.
    Furthermore, whereas some algorithms require that the "template" be
    smaller than the "image" because of errors in the regions where the
    two are not fully overlapping, this filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain,
    all input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the NCC of
    the two images and its values range from -1.0 to 1.0. The size of this
    NCC image is, by definition, size(fixedImage) + size(movingImage) - 1.

    Example filter usage:

    WARNING:  The pixel type of the output image must be of real type
    (float or double). ConceptChecking is used to enforce the output pixel
    type. You will get a compilation error if the pixel type of the output
    image is not float or double.  References: 1) D. Padfield. "Masked
    object registration in the Fourier domain." Transactions on Image
    Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.

    : Dirk Padfield, GE Global Research, padfield@research.ge.com

    C++ includes: itkFFTNormalizedCorrelationImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkFFTNormalizedCorrelationImageFilterISS3IF3_Pointer":
        """__New_orig__() -> itkFFTNormalizedCorrelationImageFilterISS3IF3_Pointer"""
        return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterISS3IF3___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkFFTNormalizedCorrelationImageFilterISS3IF3_Pointer":
        """Clone(itkFFTNormalizedCorrelationImageFilterISS3IF3 self) -> itkFFTNormalizedCorrelationImageFilterISS3IF3_Pointer"""
        return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterISS3IF3_Clone(self)

    __swig_destroy__ = _itkFFTNormalizedCorrelationImageFilterPython.delete_itkFFTNormalizedCorrelationImageFilterISS3IF3

    def cast(obj: 'itkLightObject') -> "itkFFTNormalizedCorrelationImageFilterISS3IF3 *":
        """cast(itkLightObject obj) -> itkFFTNormalizedCorrelationImageFilterISS3IF3"""
        return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterISS3IF3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkFFTNormalizedCorrelationImageFilterISS3IF3

        Create a new object of the class itkFFTNormalizedCorrelationImageFilterISS3IF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkFFTNormalizedCorrelationImageFilterISS3IF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkFFTNormalizedCorrelationImageFilterISS3IF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkFFTNormalizedCorrelationImageFilterISS3IF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkFFTNormalizedCorrelationImageFilterISS3IF3.Clone = new_instancemethod(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterISS3IF3_Clone, None, itkFFTNormalizedCorrelationImageFilterISS3IF3)
itkFFTNormalizedCorrelationImageFilterISS3IF3_swigregister = _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterISS3IF3_swigregister
itkFFTNormalizedCorrelationImageFilterISS3IF3_swigregister(itkFFTNormalizedCorrelationImageFilterISS3IF3)

def itkFFTNormalizedCorrelationImageFilterISS3IF3___New_orig__() -> "itkFFTNormalizedCorrelationImageFilterISS3IF3_Pointer":
    """itkFFTNormalizedCorrelationImageFilterISS3IF3___New_orig__() -> itkFFTNormalizedCorrelationImageFilterISS3IF3_Pointer"""
    return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterISS3IF3___New_orig__()

def itkFFTNormalizedCorrelationImageFilterISS3IF3_cast(obj: 'itkLightObject') -> "itkFFTNormalizedCorrelationImageFilterISS3IF3 *":
    """itkFFTNormalizedCorrelationImageFilterISS3IF3_cast(itkLightObject obj) -> itkFFTNormalizedCorrelationImageFilterISS3IF3"""
    return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterISS3IF3_cast(obj)

class itkFFTNormalizedCorrelationImageFilterIUC2ID2(itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC2ID2):
    """


    Calculate normalized cross correlation using FFTs.

    This filter calculates the normalized cross correlation (NCC) of two
    images using FFTs instead of spatial correlation. It is much faster
    than spatial correlation for reasonably large structuring elements.
    This filter is a subclass of the more general
    MaskedFFTNormalizedCorrelationImageFilter and operates by essentially
    setting the masks in that algorithm to images of ones. As described in
    detail in the references below, there is no computational overhead to
    utilizing the more general masked algorithm because the FFTs of the
    images of ones are still necessary for the computations.

    Inputs: Two images are required as inputs, fixedImage and movingImage.
    In the context of correlation, inputs are often defined as: "image"
    and "template". In this filter, the fixedImage plays the role of the
    image, and the movingImage plays the role of the template. However,
    this filter is capable of correlating any two images and is not
    restricted to small movingImages (templates).

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify how many voxels of the two images must overlap; any
    location in the correlation map that results from fewer than this
    number of voxels will be set to zero. Larger values zero-out pixels on
    a larger border around the correlation image. Thus, larger values
    remove less stable computations but also limit the capture range. If
    RequiredNumberOfOverlappingPixels is set to 0, the default, no zeroing
    will take place.

    Image size: fixedImage and movingImage need not be the same size.
    Furthermore, whereas some algorithms require that the "template" be
    smaller than the "image" because of errors in the regions where the
    two are not fully overlapping, this filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain,
    all input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the NCC of
    the two images and its values range from -1.0 to 1.0. The size of this
    NCC image is, by definition, size(fixedImage) + size(movingImage) - 1.

    Example filter usage:

    WARNING:  The pixel type of the output image must be of real type
    (float or double). ConceptChecking is used to enforce the output pixel
    type. You will get a compilation error if the pixel type of the output
    image is not float or double.  References: 1) D. Padfield. "Masked
    object registration in the Fourier domain." Transactions on Image
    Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.

    : Dirk Padfield, GE Global Research, padfield@research.ge.com

    C++ includes: itkFFTNormalizedCorrelationImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkFFTNormalizedCorrelationImageFilterIUC2ID2_Pointer":
        """__New_orig__() -> itkFFTNormalizedCorrelationImageFilterIUC2ID2_Pointer"""
        return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUC2ID2___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkFFTNormalizedCorrelationImageFilterIUC2ID2_Pointer":
        """Clone(itkFFTNormalizedCorrelationImageFilterIUC2ID2 self) -> itkFFTNormalizedCorrelationImageFilterIUC2ID2_Pointer"""
        return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUC2ID2_Clone(self)

    __swig_destroy__ = _itkFFTNormalizedCorrelationImageFilterPython.delete_itkFFTNormalizedCorrelationImageFilterIUC2ID2

    def cast(obj: 'itkLightObject') -> "itkFFTNormalizedCorrelationImageFilterIUC2ID2 *":
        """cast(itkLightObject obj) -> itkFFTNormalizedCorrelationImageFilterIUC2ID2"""
        return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUC2ID2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkFFTNormalizedCorrelationImageFilterIUC2ID2

        Create a new object of the class itkFFTNormalizedCorrelationImageFilterIUC2ID2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkFFTNormalizedCorrelationImageFilterIUC2ID2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkFFTNormalizedCorrelationImageFilterIUC2ID2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkFFTNormalizedCorrelationImageFilterIUC2ID2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkFFTNormalizedCorrelationImageFilterIUC2ID2.Clone = new_instancemethod(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUC2ID2_Clone, None, itkFFTNormalizedCorrelationImageFilterIUC2ID2)
itkFFTNormalizedCorrelationImageFilterIUC2ID2_swigregister = _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUC2ID2_swigregister
itkFFTNormalizedCorrelationImageFilterIUC2ID2_swigregister(itkFFTNormalizedCorrelationImageFilterIUC2ID2)

def itkFFTNormalizedCorrelationImageFilterIUC2ID2___New_orig__() -> "itkFFTNormalizedCorrelationImageFilterIUC2ID2_Pointer":
    """itkFFTNormalizedCorrelationImageFilterIUC2ID2___New_orig__() -> itkFFTNormalizedCorrelationImageFilterIUC2ID2_Pointer"""
    return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUC2ID2___New_orig__()

def itkFFTNormalizedCorrelationImageFilterIUC2ID2_cast(obj: 'itkLightObject') -> "itkFFTNormalizedCorrelationImageFilterIUC2ID2 *":
    """itkFFTNormalizedCorrelationImageFilterIUC2ID2_cast(itkLightObject obj) -> itkFFTNormalizedCorrelationImageFilterIUC2ID2"""
    return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUC2ID2_cast(obj)

class itkFFTNormalizedCorrelationImageFilterIUC2IF2(itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC2IF2):
    """


    Calculate normalized cross correlation using FFTs.

    This filter calculates the normalized cross correlation (NCC) of two
    images using FFTs instead of spatial correlation. It is much faster
    than spatial correlation for reasonably large structuring elements.
    This filter is a subclass of the more general
    MaskedFFTNormalizedCorrelationImageFilter and operates by essentially
    setting the masks in that algorithm to images of ones. As described in
    detail in the references below, there is no computational overhead to
    utilizing the more general masked algorithm because the FFTs of the
    images of ones are still necessary for the computations.

    Inputs: Two images are required as inputs, fixedImage and movingImage.
    In the context of correlation, inputs are often defined as: "image"
    and "template". In this filter, the fixedImage plays the role of the
    image, and the movingImage plays the role of the template. However,
    this filter is capable of correlating any two images and is not
    restricted to small movingImages (templates).

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify how many voxels of the two images must overlap; any
    location in the correlation map that results from fewer than this
    number of voxels will be set to zero. Larger values zero-out pixels on
    a larger border around the correlation image. Thus, larger values
    remove less stable computations but also limit the capture range. If
    RequiredNumberOfOverlappingPixels is set to 0, the default, no zeroing
    will take place.

    Image size: fixedImage and movingImage need not be the same size.
    Furthermore, whereas some algorithms require that the "template" be
    smaller than the "image" because of errors in the regions where the
    two are not fully overlapping, this filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain,
    all input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the NCC of
    the two images and its values range from -1.0 to 1.0. The size of this
    NCC image is, by definition, size(fixedImage) + size(movingImage) - 1.

    Example filter usage:

    WARNING:  The pixel type of the output image must be of real type
    (float or double). ConceptChecking is used to enforce the output pixel
    type. You will get a compilation error if the pixel type of the output
    image is not float or double.  References: 1) D. Padfield. "Masked
    object registration in the Fourier domain." Transactions on Image
    Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.

    : Dirk Padfield, GE Global Research, padfield@research.ge.com

    C++ includes: itkFFTNormalizedCorrelationImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkFFTNormalizedCorrelationImageFilterIUC2IF2_Pointer":
        """__New_orig__() -> itkFFTNormalizedCorrelationImageFilterIUC2IF2_Pointer"""
        return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUC2IF2___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkFFTNormalizedCorrelationImageFilterIUC2IF2_Pointer":
        """Clone(itkFFTNormalizedCorrelationImageFilterIUC2IF2 self) -> itkFFTNormalizedCorrelationImageFilterIUC2IF2_Pointer"""
        return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUC2IF2_Clone(self)

    __swig_destroy__ = _itkFFTNormalizedCorrelationImageFilterPython.delete_itkFFTNormalizedCorrelationImageFilterIUC2IF2

    def cast(obj: 'itkLightObject') -> "itkFFTNormalizedCorrelationImageFilterIUC2IF2 *":
        """cast(itkLightObject obj) -> itkFFTNormalizedCorrelationImageFilterIUC2IF2"""
        return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUC2IF2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkFFTNormalizedCorrelationImageFilterIUC2IF2

        Create a new object of the class itkFFTNormalizedCorrelationImageFilterIUC2IF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkFFTNormalizedCorrelationImageFilterIUC2IF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkFFTNormalizedCorrelationImageFilterIUC2IF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkFFTNormalizedCorrelationImageFilterIUC2IF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkFFTNormalizedCorrelationImageFilterIUC2IF2.Clone = new_instancemethod(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUC2IF2_Clone, None, itkFFTNormalizedCorrelationImageFilterIUC2IF2)
itkFFTNormalizedCorrelationImageFilterIUC2IF2_swigregister = _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUC2IF2_swigregister
itkFFTNormalizedCorrelationImageFilterIUC2IF2_swigregister(itkFFTNormalizedCorrelationImageFilterIUC2IF2)

def itkFFTNormalizedCorrelationImageFilterIUC2IF2___New_orig__() -> "itkFFTNormalizedCorrelationImageFilterIUC2IF2_Pointer":
    """itkFFTNormalizedCorrelationImageFilterIUC2IF2___New_orig__() -> itkFFTNormalizedCorrelationImageFilterIUC2IF2_Pointer"""
    return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUC2IF2___New_orig__()

def itkFFTNormalizedCorrelationImageFilterIUC2IF2_cast(obj: 'itkLightObject') -> "itkFFTNormalizedCorrelationImageFilterIUC2IF2 *":
    """itkFFTNormalizedCorrelationImageFilterIUC2IF2_cast(itkLightObject obj) -> itkFFTNormalizedCorrelationImageFilterIUC2IF2"""
    return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUC2IF2_cast(obj)

class itkFFTNormalizedCorrelationImageFilterIUC3ID3(itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC3ID3):
    """


    Calculate normalized cross correlation using FFTs.

    This filter calculates the normalized cross correlation (NCC) of two
    images using FFTs instead of spatial correlation. It is much faster
    than spatial correlation for reasonably large structuring elements.
    This filter is a subclass of the more general
    MaskedFFTNormalizedCorrelationImageFilter and operates by essentially
    setting the masks in that algorithm to images of ones. As described in
    detail in the references below, there is no computational overhead to
    utilizing the more general masked algorithm because the FFTs of the
    images of ones are still necessary for the computations.

    Inputs: Two images are required as inputs, fixedImage and movingImage.
    In the context of correlation, inputs are often defined as: "image"
    and "template". In this filter, the fixedImage plays the role of the
    image, and the movingImage plays the role of the template. However,
    this filter is capable of correlating any two images and is not
    restricted to small movingImages (templates).

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify how many voxels of the two images must overlap; any
    location in the correlation map that results from fewer than this
    number of voxels will be set to zero. Larger values zero-out pixels on
    a larger border around the correlation image. Thus, larger values
    remove less stable computations but also limit the capture range. If
    RequiredNumberOfOverlappingPixels is set to 0, the default, no zeroing
    will take place.

    Image size: fixedImage and movingImage need not be the same size.
    Furthermore, whereas some algorithms require that the "template" be
    smaller than the "image" because of errors in the regions where the
    two are not fully overlapping, this filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain,
    all input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the NCC of
    the two images and its values range from -1.0 to 1.0. The size of this
    NCC image is, by definition, size(fixedImage) + size(movingImage) - 1.

    Example filter usage:

    WARNING:  The pixel type of the output image must be of real type
    (float or double). ConceptChecking is used to enforce the output pixel
    type. You will get a compilation error if the pixel type of the output
    image is not float or double.  References: 1) D. Padfield. "Masked
    object registration in the Fourier domain." Transactions on Image
    Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.

    : Dirk Padfield, GE Global Research, padfield@research.ge.com

    C++ includes: itkFFTNormalizedCorrelationImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkFFTNormalizedCorrelationImageFilterIUC3ID3_Pointer":
        """__New_orig__() -> itkFFTNormalizedCorrelationImageFilterIUC3ID3_Pointer"""
        return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUC3ID3___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkFFTNormalizedCorrelationImageFilterIUC3ID3_Pointer":
        """Clone(itkFFTNormalizedCorrelationImageFilterIUC3ID3 self) -> itkFFTNormalizedCorrelationImageFilterIUC3ID3_Pointer"""
        return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUC3ID3_Clone(self)

    __swig_destroy__ = _itkFFTNormalizedCorrelationImageFilterPython.delete_itkFFTNormalizedCorrelationImageFilterIUC3ID3

    def cast(obj: 'itkLightObject') -> "itkFFTNormalizedCorrelationImageFilterIUC3ID3 *":
        """cast(itkLightObject obj) -> itkFFTNormalizedCorrelationImageFilterIUC3ID3"""
        return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUC3ID3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkFFTNormalizedCorrelationImageFilterIUC3ID3

        Create a new object of the class itkFFTNormalizedCorrelationImageFilterIUC3ID3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkFFTNormalizedCorrelationImageFilterIUC3ID3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkFFTNormalizedCorrelationImageFilterIUC3ID3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkFFTNormalizedCorrelationImageFilterIUC3ID3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkFFTNormalizedCorrelationImageFilterIUC3ID3.Clone = new_instancemethod(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUC3ID3_Clone, None, itkFFTNormalizedCorrelationImageFilterIUC3ID3)
itkFFTNormalizedCorrelationImageFilterIUC3ID3_swigregister = _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUC3ID3_swigregister
itkFFTNormalizedCorrelationImageFilterIUC3ID3_swigregister(itkFFTNormalizedCorrelationImageFilterIUC3ID3)

def itkFFTNormalizedCorrelationImageFilterIUC3ID3___New_orig__() -> "itkFFTNormalizedCorrelationImageFilterIUC3ID3_Pointer":
    """itkFFTNormalizedCorrelationImageFilterIUC3ID3___New_orig__() -> itkFFTNormalizedCorrelationImageFilterIUC3ID3_Pointer"""
    return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUC3ID3___New_orig__()

def itkFFTNormalizedCorrelationImageFilterIUC3ID3_cast(obj: 'itkLightObject') -> "itkFFTNormalizedCorrelationImageFilterIUC3ID3 *":
    """itkFFTNormalizedCorrelationImageFilterIUC3ID3_cast(itkLightObject obj) -> itkFFTNormalizedCorrelationImageFilterIUC3ID3"""
    return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUC3ID3_cast(obj)

class itkFFTNormalizedCorrelationImageFilterIUC3IF3(itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC3IF3):
    """


    Calculate normalized cross correlation using FFTs.

    This filter calculates the normalized cross correlation (NCC) of two
    images using FFTs instead of spatial correlation. It is much faster
    than spatial correlation for reasonably large structuring elements.
    This filter is a subclass of the more general
    MaskedFFTNormalizedCorrelationImageFilter and operates by essentially
    setting the masks in that algorithm to images of ones. As described in
    detail in the references below, there is no computational overhead to
    utilizing the more general masked algorithm because the FFTs of the
    images of ones are still necessary for the computations.

    Inputs: Two images are required as inputs, fixedImage and movingImage.
    In the context of correlation, inputs are often defined as: "image"
    and "template". In this filter, the fixedImage plays the role of the
    image, and the movingImage plays the role of the template. However,
    this filter is capable of correlating any two images and is not
    restricted to small movingImages (templates).

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify how many voxels of the two images must overlap; any
    location in the correlation map that results from fewer than this
    number of voxels will be set to zero. Larger values zero-out pixels on
    a larger border around the correlation image. Thus, larger values
    remove less stable computations but also limit the capture range. If
    RequiredNumberOfOverlappingPixels is set to 0, the default, no zeroing
    will take place.

    Image size: fixedImage and movingImage need not be the same size.
    Furthermore, whereas some algorithms require that the "template" be
    smaller than the "image" because of errors in the regions where the
    two are not fully overlapping, this filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain,
    all input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the NCC of
    the two images and its values range from -1.0 to 1.0. The size of this
    NCC image is, by definition, size(fixedImage) + size(movingImage) - 1.

    Example filter usage:

    WARNING:  The pixel type of the output image must be of real type
    (float or double). ConceptChecking is used to enforce the output pixel
    type. You will get a compilation error if the pixel type of the output
    image is not float or double.  References: 1) D. Padfield. "Masked
    object registration in the Fourier domain." Transactions on Image
    Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.

    : Dirk Padfield, GE Global Research, padfield@research.ge.com

    C++ includes: itkFFTNormalizedCorrelationImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkFFTNormalizedCorrelationImageFilterIUC3IF3_Pointer":
        """__New_orig__() -> itkFFTNormalizedCorrelationImageFilterIUC3IF3_Pointer"""
        return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUC3IF3___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkFFTNormalizedCorrelationImageFilterIUC3IF3_Pointer":
        """Clone(itkFFTNormalizedCorrelationImageFilterIUC3IF3 self) -> itkFFTNormalizedCorrelationImageFilterIUC3IF3_Pointer"""
        return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUC3IF3_Clone(self)

    __swig_destroy__ = _itkFFTNormalizedCorrelationImageFilterPython.delete_itkFFTNormalizedCorrelationImageFilterIUC3IF3

    def cast(obj: 'itkLightObject') -> "itkFFTNormalizedCorrelationImageFilterIUC3IF3 *":
        """cast(itkLightObject obj) -> itkFFTNormalizedCorrelationImageFilterIUC3IF3"""
        return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUC3IF3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkFFTNormalizedCorrelationImageFilterIUC3IF3

        Create a new object of the class itkFFTNormalizedCorrelationImageFilterIUC3IF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkFFTNormalizedCorrelationImageFilterIUC3IF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkFFTNormalizedCorrelationImageFilterIUC3IF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkFFTNormalizedCorrelationImageFilterIUC3IF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkFFTNormalizedCorrelationImageFilterIUC3IF3.Clone = new_instancemethod(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUC3IF3_Clone, None, itkFFTNormalizedCorrelationImageFilterIUC3IF3)
itkFFTNormalizedCorrelationImageFilterIUC3IF3_swigregister = _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUC3IF3_swigregister
itkFFTNormalizedCorrelationImageFilterIUC3IF3_swigregister(itkFFTNormalizedCorrelationImageFilterIUC3IF3)

def itkFFTNormalizedCorrelationImageFilterIUC3IF3___New_orig__() -> "itkFFTNormalizedCorrelationImageFilterIUC3IF3_Pointer":
    """itkFFTNormalizedCorrelationImageFilterIUC3IF3___New_orig__() -> itkFFTNormalizedCorrelationImageFilterIUC3IF3_Pointer"""
    return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUC3IF3___New_orig__()

def itkFFTNormalizedCorrelationImageFilterIUC3IF3_cast(obj: 'itkLightObject') -> "itkFFTNormalizedCorrelationImageFilterIUC3IF3 *":
    """itkFFTNormalizedCorrelationImageFilterIUC3IF3_cast(itkLightObject obj) -> itkFFTNormalizedCorrelationImageFilterIUC3IF3"""
    return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUC3IF3_cast(obj)

class itkFFTNormalizedCorrelationImageFilterIUS2ID2(itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS2ID2):
    """


    Calculate normalized cross correlation using FFTs.

    This filter calculates the normalized cross correlation (NCC) of two
    images using FFTs instead of spatial correlation. It is much faster
    than spatial correlation for reasonably large structuring elements.
    This filter is a subclass of the more general
    MaskedFFTNormalizedCorrelationImageFilter and operates by essentially
    setting the masks in that algorithm to images of ones. As described in
    detail in the references below, there is no computational overhead to
    utilizing the more general masked algorithm because the FFTs of the
    images of ones are still necessary for the computations.

    Inputs: Two images are required as inputs, fixedImage and movingImage.
    In the context of correlation, inputs are often defined as: "image"
    and "template". In this filter, the fixedImage plays the role of the
    image, and the movingImage plays the role of the template. However,
    this filter is capable of correlating any two images and is not
    restricted to small movingImages (templates).

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify how many voxels of the two images must overlap; any
    location in the correlation map that results from fewer than this
    number of voxels will be set to zero. Larger values zero-out pixels on
    a larger border around the correlation image. Thus, larger values
    remove less stable computations but also limit the capture range. If
    RequiredNumberOfOverlappingPixels is set to 0, the default, no zeroing
    will take place.

    Image size: fixedImage and movingImage need not be the same size.
    Furthermore, whereas some algorithms require that the "template" be
    smaller than the "image" because of errors in the regions where the
    two are not fully overlapping, this filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain,
    all input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the NCC of
    the two images and its values range from -1.0 to 1.0. The size of this
    NCC image is, by definition, size(fixedImage) + size(movingImage) - 1.

    Example filter usage:

    WARNING:  The pixel type of the output image must be of real type
    (float or double). ConceptChecking is used to enforce the output pixel
    type. You will get a compilation error if the pixel type of the output
    image is not float or double.  References: 1) D. Padfield. "Masked
    object registration in the Fourier domain." Transactions on Image
    Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.

    : Dirk Padfield, GE Global Research, padfield@research.ge.com

    C++ includes: itkFFTNormalizedCorrelationImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkFFTNormalizedCorrelationImageFilterIUS2ID2_Pointer":
        """__New_orig__() -> itkFFTNormalizedCorrelationImageFilterIUS2ID2_Pointer"""
        return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUS2ID2___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkFFTNormalizedCorrelationImageFilterIUS2ID2_Pointer":
        """Clone(itkFFTNormalizedCorrelationImageFilterIUS2ID2 self) -> itkFFTNormalizedCorrelationImageFilterIUS2ID2_Pointer"""
        return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUS2ID2_Clone(self)

    __swig_destroy__ = _itkFFTNormalizedCorrelationImageFilterPython.delete_itkFFTNormalizedCorrelationImageFilterIUS2ID2

    def cast(obj: 'itkLightObject') -> "itkFFTNormalizedCorrelationImageFilterIUS2ID2 *":
        """cast(itkLightObject obj) -> itkFFTNormalizedCorrelationImageFilterIUS2ID2"""
        return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUS2ID2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkFFTNormalizedCorrelationImageFilterIUS2ID2

        Create a new object of the class itkFFTNormalizedCorrelationImageFilterIUS2ID2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkFFTNormalizedCorrelationImageFilterIUS2ID2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkFFTNormalizedCorrelationImageFilterIUS2ID2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkFFTNormalizedCorrelationImageFilterIUS2ID2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkFFTNormalizedCorrelationImageFilterIUS2ID2.Clone = new_instancemethod(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUS2ID2_Clone, None, itkFFTNormalizedCorrelationImageFilterIUS2ID2)
itkFFTNormalizedCorrelationImageFilterIUS2ID2_swigregister = _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUS2ID2_swigregister
itkFFTNormalizedCorrelationImageFilterIUS2ID2_swigregister(itkFFTNormalizedCorrelationImageFilterIUS2ID2)

def itkFFTNormalizedCorrelationImageFilterIUS2ID2___New_orig__() -> "itkFFTNormalizedCorrelationImageFilterIUS2ID2_Pointer":
    """itkFFTNormalizedCorrelationImageFilterIUS2ID2___New_orig__() -> itkFFTNormalizedCorrelationImageFilterIUS2ID2_Pointer"""
    return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUS2ID2___New_orig__()

def itkFFTNormalizedCorrelationImageFilterIUS2ID2_cast(obj: 'itkLightObject') -> "itkFFTNormalizedCorrelationImageFilterIUS2ID2 *":
    """itkFFTNormalizedCorrelationImageFilterIUS2ID2_cast(itkLightObject obj) -> itkFFTNormalizedCorrelationImageFilterIUS2ID2"""
    return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUS2ID2_cast(obj)

class itkFFTNormalizedCorrelationImageFilterIUS2IF2(itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS2IF2):
    """


    Calculate normalized cross correlation using FFTs.

    This filter calculates the normalized cross correlation (NCC) of two
    images using FFTs instead of spatial correlation. It is much faster
    than spatial correlation for reasonably large structuring elements.
    This filter is a subclass of the more general
    MaskedFFTNormalizedCorrelationImageFilter and operates by essentially
    setting the masks in that algorithm to images of ones. As described in
    detail in the references below, there is no computational overhead to
    utilizing the more general masked algorithm because the FFTs of the
    images of ones are still necessary for the computations.

    Inputs: Two images are required as inputs, fixedImage and movingImage.
    In the context of correlation, inputs are often defined as: "image"
    and "template". In this filter, the fixedImage plays the role of the
    image, and the movingImage plays the role of the template. However,
    this filter is capable of correlating any two images and is not
    restricted to small movingImages (templates).

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify how many voxels of the two images must overlap; any
    location in the correlation map that results from fewer than this
    number of voxels will be set to zero. Larger values zero-out pixels on
    a larger border around the correlation image. Thus, larger values
    remove less stable computations but also limit the capture range. If
    RequiredNumberOfOverlappingPixels is set to 0, the default, no zeroing
    will take place.

    Image size: fixedImage and movingImage need not be the same size.
    Furthermore, whereas some algorithms require that the "template" be
    smaller than the "image" because of errors in the regions where the
    two are not fully overlapping, this filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain,
    all input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the NCC of
    the two images and its values range from -1.0 to 1.0. The size of this
    NCC image is, by definition, size(fixedImage) + size(movingImage) - 1.

    Example filter usage:

    WARNING:  The pixel type of the output image must be of real type
    (float or double). ConceptChecking is used to enforce the output pixel
    type. You will get a compilation error if the pixel type of the output
    image is not float or double.  References: 1) D. Padfield. "Masked
    object registration in the Fourier domain." Transactions on Image
    Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.

    : Dirk Padfield, GE Global Research, padfield@research.ge.com

    C++ includes: itkFFTNormalizedCorrelationImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkFFTNormalizedCorrelationImageFilterIUS2IF2_Pointer":
        """__New_orig__() -> itkFFTNormalizedCorrelationImageFilterIUS2IF2_Pointer"""
        return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUS2IF2___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkFFTNormalizedCorrelationImageFilterIUS2IF2_Pointer":
        """Clone(itkFFTNormalizedCorrelationImageFilterIUS2IF2 self) -> itkFFTNormalizedCorrelationImageFilterIUS2IF2_Pointer"""
        return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUS2IF2_Clone(self)

    __swig_destroy__ = _itkFFTNormalizedCorrelationImageFilterPython.delete_itkFFTNormalizedCorrelationImageFilterIUS2IF2

    def cast(obj: 'itkLightObject') -> "itkFFTNormalizedCorrelationImageFilterIUS2IF2 *":
        """cast(itkLightObject obj) -> itkFFTNormalizedCorrelationImageFilterIUS2IF2"""
        return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUS2IF2_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkFFTNormalizedCorrelationImageFilterIUS2IF2

        Create a new object of the class itkFFTNormalizedCorrelationImageFilterIUS2IF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkFFTNormalizedCorrelationImageFilterIUS2IF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkFFTNormalizedCorrelationImageFilterIUS2IF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkFFTNormalizedCorrelationImageFilterIUS2IF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkFFTNormalizedCorrelationImageFilterIUS2IF2.Clone = new_instancemethod(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUS2IF2_Clone, None, itkFFTNormalizedCorrelationImageFilterIUS2IF2)
itkFFTNormalizedCorrelationImageFilterIUS2IF2_swigregister = _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUS2IF2_swigregister
itkFFTNormalizedCorrelationImageFilterIUS2IF2_swigregister(itkFFTNormalizedCorrelationImageFilterIUS2IF2)

def itkFFTNormalizedCorrelationImageFilterIUS2IF2___New_orig__() -> "itkFFTNormalizedCorrelationImageFilterIUS2IF2_Pointer":
    """itkFFTNormalizedCorrelationImageFilterIUS2IF2___New_orig__() -> itkFFTNormalizedCorrelationImageFilterIUS2IF2_Pointer"""
    return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUS2IF2___New_orig__()

def itkFFTNormalizedCorrelationImageFilterIUS2IF2_cast(obj: 'itkLightObject') -> "itkFFTNormalizedCorrelationImageFilterIUS2IF2 *":
    """itkFFTNormalizedCorrelationImageFilterIUS2IF2_cast(itkLightObject obj) -> itkFFTNormalizedCorrelationImageFilterIUS2IF2"""
    return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUS2IF2_cast(obj)

class itkFFTNormalizedCorrelationImageFilterIUS3ID3(itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS3ID3):
    """


    Calculate normalized cross correlation using FFTs.

    This filter calculates the normalized cross correlation (NCC) of two
    images using FFTs instead of spatial correlation. It is much faster
    than spatial correlation for reasonably large structuring elements.
    This filter is a subclass of the more general
    MaskedFFTNormalizedCorrelationImageFilter and operates by essentially
    setting the masks in that algorithm to images of ones. As described in
    detail in the references below, there is no computational overhead to
    utilizing the more general masked algorithm because the FFTs of the
    images of ones are still necessary for the computations.

    Inputs: Two images are required as inputs, fixedImage and movingImage.
    In the context of correlation, inputs are often defined as: "image"
    and "template". In this filter, the fixedImage plays the role of the
    image, and the movingImage plays the role of the template. However,
    this filter is capable of correlating any two images and is not
    restricted to small movingImages (templates).

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify how many voxels of the two images must overlap; any
    location in the correlation map that results from fewer than this
    number of voxels will be set to zero. Larger values zero-out pixels on
    a larger border around the correlation image. Thus, larger values
    remove less stable computations but also limit the capture range. If
    RequiredNumberOfOverlappingPixels is set to 0, the default, no zeroing
    will take place.

    Image size: fixedImage and movingImage need not be the same size.
    Furthermore, whereas some algorithms require that the "template" be
    smaller than the "image" because of errors in the regions where the
    two are not fully overlapping, this filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain,
    all input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the NCC of
    the two images and its values range from -1.0 to 1.0. The size of this
    NCC image is, by definition, size(fixedImage) + size(movingImage) - 1.

    Example filter usage:

    WARNING:  The pixel type of the output image must be of real type
    (float or double). ConceptChecking is used to enforce the output pixel
    type. You will get a compilation error if the pixel type of the output
    image is not float or double.  References: 1) D. Padfield. "Masked
    object registration in the Fourier domain." Transactions on Image
    Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.

    : Dirk Padfield, GE Global Research, padfield@research.ge.com

    C++ includes: itkFFTNormalizedCorrelationImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkFFTNormalizedCorrelationImageFilterIUS3ID3_Pointer":
        """__New_orig__() -> itkFFTNormalizedCorrelationImageFilterIUS3ID3_Pointer"""
        return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUS3ID3___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkFFTNormalizedCorrelationImageFilterIUS3ID3_Pointer":
        """Clone(itkFFTNormalizedCorrelationImageFilterIUS3ID3 self) -> itkFFTNormalizedCorrelationImageFilterIUS3ID3_Pointer"""
        return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUS3ID3_Clone(self)

    __swig_destroy__ = _itkFFTNormalizedCorrelationImageFilterPython.delete_itkFFTNormalizedCorrelationImageFilterIUS3ID3

    def cast(obj: 'itkLightObject') -> "itkFFTNormalizedCorrelationImageFilterIUS3ID3 *":
        """cast(itkLightObject obj) -> itkFFTNormalizedCorrelationImageFilterIUS3ID3"""
        return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUS3ID3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkFFTNormalizedCorrelationImageFilterIUS3ID3

        Create a new object of the class itkFFTNormalizedCorrelationImageFilterIUS3ID3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkFFTNormalizedCorrelationImageFilterIUS3ID3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkFFTNormalizedCorrelationImageFilterIUS3ID3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkFFTNormalizedCorrelationImageFilterIUS3ID3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkFFTNormalizedCorrelationImageFilterIUS3ID3.Clone = new_instancemethod(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUS3ID3_Clone, None, itkFFTNormalizedCorrelationImageFilterIUS3ID3)
itkFFTNormalizedCorrelationImageFilterIUS3ID3_swigregister = _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUS3ID3_swigregister
itkFFTNormalizedCorrelationImageFilterIUS3ID3_swigregister(itkFFTNormalizedCorrelationImageFilterIUS3ID3)

def itkFFTNormalizedCorrelationImageFilterIUS3ID3___New_orig__() -> "itkFFTNormalizedCorrelationImageFilterIUS3ID3_Pointer":
    """itkFFTNormalizedCorrelationImageFilterIUS3ID3___New_orig__() -> itkFFTNormalizedCorrelationImageFilterIUS3ID3_Pointer"""
    return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUS3ID3___New_orig__()

def itkFFTNormalizedCorrelationImageFilterIUS3ID3_cast(obj: 'itkLightObject') -> "itkFFTNormalizedCorrelationImageFilterIUS3ID3 *":
    """itkFFTNormalizedCorrelationImageFilterIUS3ID3_cast(itkLightObject obj) -> itkFFTNormalizedCorrelationImageFilterIUS3ID3"""
    return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUS3ID3_cast(obj)

class itkFFTNormalizedCorrelationImageFilterIUS3IF3(itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS3IF3):
    """


    Calculate normalized cross correlation using FFTs.

    This filter calculates the normalized cross correlation (NCC) of two
    images using FFTs instead of spatial correlation. It is much faster
    than spatial correlation for reasonably large structuring elements.
    This filter is a subclass of the more general
    MaskedFFTNormalizedCorrelationImageFilter and operates by essentially
    setting the masks in that algorithm to images of ones. As described in
    detail in the references below, there is no computational overhead to
    utilizing the more general masked algorithm because the FFTs of the
    images of ones are still necessary for the computations.

    Inputs: Two images are required as inputs, fixedImage and movingImage.
    In the context of correlation, inputs are often defined as: "image"
    and "template". In this filter, the fixedImage plays the role of the
    image, and the movingImage plays the role of the template. However,
    this filter is capable of correlating any two images and is not
    restricted to small movingImages (templates).

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify how many voxels of the two images must overlap; any
    location in the correlation map that results from fewer than this
    number of voxels will be set to zero. Larger values zero-out pixels on
    a larger border around the correlation image. Thus, larger values
    remove less stable computations but also limit the capture range. If
    RequiredNumberOfOverlappingPixels is set to 0, the default, no zeroing
    will take place.

    Image size: fixedImage and movingImage need not be the same size.
    Furthermore, whereas some algorithms require that the "template" be
    smaller than the "image" because of errors in the regions where the
    two are not fully overlapping, this filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain,
    all input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the NCC of
    the two images and its values range from -1.0 to 1.0. The size of this
    NCC image is, by definition, size(fixedImage) + size(movingImage) - 1.

    Example filter usage:

    WARNING:  The pixel type of the output image must be of real type
    (float or double). ConceptChecking is used to enforce the output pixel
    type. You will get a compilation error if the pixel type of the output
    image is not float or double.  References: 1) D. Padfield. "Masked
    object registration in the Fourier domain." Transactions on Image
    Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.

    : Dirk Padfield, GE Global Research, padfield@research.ge.com

    C++ includes: itkFFTNormalizedCorrelationImageFilter.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkFFTNormalizedCorrelationImageFilterIUS3IF3_Pointer":
        """__New_orig__() -> itkFFTNormalizedCorrelationImageFilterIUS3IF3_Pointer"""
        return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUS3IF3___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkFFTNormalizedCorrelationImageFilterIUS3IF3_Pointer":
        """Clone(itkFFTNormalizedCorrelationImageFilterIUS3IF3 self) -> itkFFTNormalizedCorrelationImageFilterIUS3IF3_Pointer"""
        return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUS3IF3_Clone(self)

    __swig_destroy__ = _itkFFTNormalizedCorrelationImageFilterPython.delete_itkFFTNormalizedCorrelationImageFilterIUS3IF3

    def cast(obj: 'itkLightObject') -> "itkFFTNormalizedCorrelationImageFilterIUS3IF3 *":
        """cast(itkLightObject obj) -> itkFFTNormalizedCorrelationImageFilterIUS3IF3"""
        return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUS3IF3_cast(obj)

    cast = staticmethod(cast)

    def New(*args, **kargs):
        """New() -> itkFFTNormalizedCorrelationImageFilterIUS3IF3

        Create a new object of the class itkFFTNormalizedCorrelationImageFilterIUS3IF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkFFTNormalizedCorrelationImageFilterIUS3IF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkFFTNormalizedCorrelationImageFilterIUS3IF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkFFTNormalizedCorrelationImageFilterIUS3IF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkFFTNormalizedCorrelationImageFilterIUS3IF3.Clone = new_instancemethod(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUS3IF3_Clone, None, itkFFTNormalizedCorrelationImageFilterIUS3IF3)
itkFFTNormalizedCorrelationImageFilterIUS3IF3_swigregister = _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUS3IF3_swigregister
itkFFTNormalizedCorrelationImageFilterIUS3IF3_swigregister(itkFFTNormalizedCorrelationImageFilterIUS3IF3)

def itkFFTNormalizedCorrelationImageFilterIUS3IF3___New_orig__() -> "itkFFTNormalizedCorrelationImageFilterIUS3IF3_Pointer":
    """itkFFTNormalizedCorrelationImageFilterIUS3IF3___New_orig__() -> itkFFTNormalizedCorrelationImageFilterIUS3IF3_Pointer"""
    return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUS3IF3___New_orig__()

def itkFFTNormalizedCorrelationImageFilterIUS3IF3_cast(obj: 'itkLightObject') -> "itkFFTNormalizedCorrelationImageFilterIUS3IF3 *":
    """itkFFTNormalizedCorrelationImageFilterIUS3IF3_cast(itkLightObject obj) -> itkFFTNormalizedCorrelationImageFilterIUS3IF3"""
    return _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUS3IF3_cast(obj)


import itkHelpers
@itkHelpers.accept_numpy_array_like_xarray
def fft_normalized_correlation_image_filter(*args, **kwargs):
    """Procedural interface for FFTNormalizedCorrelationImageFilter"""
    import itk
    instance = itk.FFTNormalizedCorrelationImageFilter.New(*args, **kwargs)
    return instance.__internal_call__()

def fft_normalized_correlation_image_filter_init_docstring():
    import itk
    import itkTemplate
    import itkHelpers
    if isinstance(itk.FFTNormalizedCorrelationImageFilter, itkTemplate.itkTemplate):
        filter_object = itk.FFTNormalizedCorrelationImageFilter.values()[0]
    else:
        filter_object = itk.FFTNormalizedCorrelationImageFilter

    fft_normalized_correlation_image_filter.__doc__ = filter_object.__doc__
    fft_normalized_correlation_image_filter.__doc__ += "\n Args are Input(s) to the filter.\n"
    fft_normalized_correlation_image_filter.__doc__ += "Available Keyword Arguments:\n"
    fft_normalized_correlation_image_filter.__doc__ += "".join([
        "  " + itkHelpers.camel_to_snake_case(item[3:]) + "\n"
        for item in dir(filter_object)
        if item[:3] == "Set"])



