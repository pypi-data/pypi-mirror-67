#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import Status.ttypes
import Types.ttypes

from thrift.transport import TTransport
all_structs = []


class StatestoreServiceVersion(object):
    V1 = 0

    _VALUES_TO_NAMES = {
        0: "V1",
    }

    _NAMES_TO_VALUES = {
        "V1": 0,
    }


class TPoolStats(object):
    """
    Attributes:
     - num_admitted_running
     - num_queued
     - backend_mem_reserved
    """


    def __init__(self, num_admitted_running=None, num_queued=None, backend_mem_reserved=None,):
        self.num_admitted_running = num_admitted_running
        self.num_queued = num_queued
        self.backend_mem_reserved = backend_mem_reserved

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.num_admitted_running = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.num_queued = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.backend_mem_reserved = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPoolStats')
        if self.num_admitted_running is not None:
            oprot.writeFieldBegin('num_admitted_running', TType.I64, 1)
            oprot.writeI64(self.num_admitted_running)
            oprot.writeFieldEnd()
        if self.num_queued is not None:
            oprot.writeFieldBegin('num_queued', TType.I64, 2)
            oprot.writeI64(self.num_queued)
            oprot.writeFieldEnd()
        if self.backend_mem_reserved is not None:
            oprot.writeFieldBegin('backend_mem_reserved', TType.I64, 3)
            oprot.writeI64(self.backend_mem_reserved)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.num_admitted_running is None:
            raise TProtocolException(message='Required field num_admitted_running is unset!')
        if self.num_queued is None:
            raise TProtocolException(message='Required field num_queued is unset!')
        if self.backend_mem_reserved is None:
            raise TProtocolException(message='Required field backend_mem_reserved is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TExecutorGroupDesc(object):
    """
    Attributes:
     - name
     - min_size
    """


    def __init__(self, name=None, min_size=None,):
        self.name = name
        self.min_size = min_size

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.min_size = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TExecutorGroupDesc')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.min_size is not None:
            oprot.writeFieldBegin('min_size', TType.I64, 2)
            oprot.writeI64(self.min_size)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocolException(message='Required field name is unset!')
        if self.min_size is None:
            raise TProtocolException(message='Required field min_size is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TBackendDescriptor(object):
    """
    Attributes:
     - backend_id
     - address
     - ip_address
     - is_coordinator
     - is_executor
     - debug_http_address
     - secure_webserver
     - krpc_address
     - admit_mem_limit
     - is_quiescing
     - executor_groups
     - admission_slots
    """


    def __init__(self, backend_id=None, address=None, ip_address=None, is_coordinator=None, is_executor=None, debug_http_address=None, secure_webserver=None, krpc_address=None, admit_mem_limit=None, is_quiescing=None, executor_groups=None, admission_slots=None,):
        self.backend_id = backend_id
        self.address = address
        self.ip_address = ip_address
        self.is_coordinator = is_coordinator
        self.is_executor = is_executor
        self.debug_http_address = debug_http_address
        self.secure_webserver = secure_webserver
        self.krpc_address = krpc_address
        self.admit_mem_limit = admit_mem_limit
        self.is_quiescing = is_quiescing
        self.executor_groups = executor_groups
        self.admission_slots = admission_slots

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.backend_id = Types.ttypes.TUniqueId()
                    self.backend_id.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.address = Types.ttypes.TNetworkAddress()
                    self.address.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.ip_address = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.is_coordinator = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.is_executor = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.debug_http_address = Types.ttypes.TNetworkAddress()
                    self.debug_http_address.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.secure_webserver = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRUCT:
                    self.krpc_address = Types.ttypes.TNetworkAddress()
                    self.krpc_address.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I64:
                    self.admit_mem_limit = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.BOOL:
                    self.is_quiescing = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.LIST:
                    self.executor_groups = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = TExecutorGroupDesc()
                        _elem5.read(iprot)
                        self.executor_groups.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.I64:
                    self.admission_slots = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TBackendDescriptor')
        if self.backend_id is not None:
            oprot.writeFieldBegin('backend_id', TType.STRUCT, 1)
            self.backend_id.write(oprot)
            oprot.writeFieldEnd()
        if self.address is not None:
            oprot.writeFieldBegin('address', TType.STRUCT, 2)
            self.address.write(oprot)
            oprot.writeFieldEnd()
        if self.ip_address is not None:
            oprot.writeFieldBegin('ip_address', TType.STRING, 3)
            oprot.writeString(self.ip_address.encode('utf-8') if sys.version_info[0] == 2 else self.ip_address)
            oprot.writeFieldEnd()
        if self.is_coordinator is not None:
            oprot.writeFieldBegin('is_coordinator', TType.BOOL, 4)
            oprot.writeBool(self.is_coordinator)
            oprot.writeFieldEnd()
        if self.is_executor is not None:
            oprot.writeFieldBegin('is_executor', TType.BOOL, 5)
            oprot.writeBool(self.is_executor)
            oprot.writeFieldEnd()
        if self.debug_http_address is not None:
            oprot.writeFieldBegin('debug_http_address', TType.STRUCT, 6)
            self.debug_http_address.write(oprot)
            oprot.writeFieldEnd()
        if self.secure_webserver is not None:
            oprot.writeFieldBegin('secure_webserver', TType.BOOL, 7)
            oprot.writeBool(self.secure_webserver)
            oprot.writeFieldEnd()
        if self.krpc_address is not None:
            oprot.writeFieldBegin('krpc_address', TType.STRUCT, 8)
            self.krpc_address.write(oprot)
            oprot.writeFieldEnd()
        if self.admit_mem_limit is not None:
            oprot.writeFieldBegin('admit_mem_limit', TType.I64, 9)
            oprot.writeI64(self.admit_mem_limit)
            oprot.writeFieldEnd()
        if self.is_quiescing is not None:
            oprot.writeFieldBegin('is_quiescing', TType.BOOL, 10)
            oprot.writeBool(self.is_quiescing)
            oprot.writeFieldEnd()
        if self.executor_groups is not None:
            oprot.writeFieldBegin('executor_groups', TType.LIST, 11)
            oprot.writeListBegin(TType.STRUCT, len(self.executor_groups))
            for iter6 in self.executor_groups:
                iter6.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.admission_slots is not None:
            oprot.writeFieldBegin('admission_slots', TType.I64, 12)
            oprot.writeI64(self.admission_slots)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.backend_id is None:
            raise TProtocolException(message='Required field backend_id is unset!')
        if self.address is None:
            raise TProtocolException(message='Required field address is unset!')
        if self.ip_address is None:
            raise TProtocolException(message='Required field ip_address is unset!')
        if self.is_coordinator is None:
            raise TProtocolException(message='Required field is_coordinator is unset!')
        if self.is_executor is None:
            raise TProtocolException(message='Required field is_executor is unset!')
        if self.admit_mem_limit is None:
            raise TProtocolException(message='Required field admit_mem_limit is unset!')
        if self.is_quiescing is None:
            raise TProtocolException(message='Required field is_quiescing is unset!')
        if self.executor_groups is None:
            raise TProtocolException(message='Required field executor_groups is unset!')
        if self.admission_slots is None:
            raise TProtocolException(message='Required field admission_slots is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TTopicItem(object):
    """
    Attributes:
     - key
     - value
     - deleted
    """


    def __init__(self, key=None, value=None, deleted=False,):
        self.key = key
        self.value = value
        self.deleted = deleted

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.value = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.deleted = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TTopicItem')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 2)
            oprot.writeString(self.value.encode('utf-8') if sys.version_info[0] == 2 else self.value)
            oprot.writeFieldEnd()
        if self.deleted is not None:
            oprot.writeFieldBegin('deleted', TType.BOOL, 3)
            oprot.writeBool(self.deleted)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.key is None:
            raise TProtocolException(message='Required field key is unset!')
        if self.value is None:
            raise TProtocolException(message='Required field value is unset!')
        if self.deleted is None:
            raise TProtocolException(message='Required field deleted is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TTopicDelta(object):
    """
    Attributes:
     - topic_name
     - topic_entries
     - is_delta
     - from_version
     - to_version
     - min_subscriber_topic_version
     - clear_topic_entries
    """


    def __init__(self, topic_name=None, topic_entries=None, is_delta=None, from_version=None, to_version=None, min_subscriber_topic_version=None, clear_topic_entries=None,):
        self.topic_name = topic_name
        self.topic_entries = topic_entries
        self.is_delta = is_delta
        self.from_version = from_version
        self.to_version = to_version
        self.min_subscriber_topic_version = min_subscriber_topic_version
        self.clear_topic_entries = clear_topic_entries

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.topic_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.topic_entries = []
                    (_etype10, _size7) = iprot.readListBegin()
                    for _i11 in range(_size7):
                        _elem12 = TTopicItem()
                        _elem12.read(iprot)
                        self.topic_entries.append(_elem12)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.is_delta = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.from_version = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.to_version = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.min_subscriber_topic_version = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.clear_topic_entries = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TTopicDelta')
        if self.topic_name is not None:
            oprot.writeFieldBegin('topic_name', TType.STRING, 1)
            oprot.writeString(self.topic_name.encode('utf-8') if sys.version_info[0] == 2 else self.topic_name)
            oprot.writeFieldEnd()
        if self.topic_entries is not None:
            oprot.writeFieldBegin('topic_entries', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.topic_entries))
            for iter13 in self.topic_entries:
                iter13.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.is_delta is not None:
            oprot.writeFieldBegin('is_delta', TType.BOOL, 3)
            oprot.writeBool(self.is_delta)
            oprot.writeFieldEnd()
        if self.from_version is not None:
            oprot.writeFieldBegin('from_version', TType.I64, 4)
            oprot.writeI64(self.from_version)
            oprot.writeFieldEnd()
        if self.to_version is not None:
            oprot.writeFieldBegin('to_version', TType.I64, 5)
            oprot.writeI64(self.to_version)
            oprot.writeFieldEnd()
        if self.min_subscriber_topic_version is not None:
            oprot.writeFieldBegin('min_subscriber_topic_version', TType.I64, 6)
            oprot.writeI64(self.min_subscriber_topic_version)
            oprot.writeFieldEnd()
        if self.clear_topic_entries is not None:
            oprot.writeFieldBegin('clear_topic_entries', TType.BOOL, 7)
            oprot.writeBool(self.clear_topic_entries)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.topic_name is None:
            raise TProtocolException(message='Required field topic_name is unset!')
        if self.topic_entries is None:
            raise TProtocolException(message='Required field topic_entries is unset!')
        if self.is_delta is None:
            raise TProtocolException(message='Required field is_delta is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TTopicRegistration(object):
    """
    Attributes:
     - topic_name
     - is_transient
     - populate_min_subscriber_topic_version
     - filter_prefix
    """


    def __init__(self, topic_name=None, is_transient=None, populate_min_subscriber_topic_version=False, filter_prefix=None,):
        self.topic_name = topic_name
        self.is_transient = is_transient
        self.populate_min_subscriber_topic_version = populate_min_subscriber_topic_version
        self.filter_prefix = filter_prefix

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.topic_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.is_transient = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.populate_min_subscriber_topic_version = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.filter_prefix = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TTopicRegistration')
        if self.topic_name is not None:
            oprot.writeFieldBegin('topic_name', TType.STRING, 1)
            oprot.writeString(self.topic_name.encode('utf-8') if sys.version_info[0] == 2 else self.topic_name)
            oprot.writeFieldEnd()
        if self.is_transient is not None:
            oprot.writeFieldBegin('is_transient', TType.BOOL, 2)
            oprot.writeBool(self.is_transient)
            oprot.writeFieldEnd()
        if self.populate_min_subscriber_topic_version is not None:
            oprot.writeFieldBegin('populate_min_subscriber_topic_version', TType.BOOL, 3)
            oprot.writeBool(self.populate_min_subscriber_topic_version)
            oprot.writeFieldEnd()
        if self.filter_prefix is not None:
            oprot.writeFieldBegin('filter_prefix', TType.STRING, 4)
            oprot.writeString(self.filter_prefix.encode('utf-8') if sys.version_info[0] == 2 else self.filter_prefix)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.topic_name is None:
            raise TProtocolException(message='Required field topic_name is unset!')
        if self.is_transient is None:
            raise TProtocolException(message='Required field is_transient is unset!')
        if self.populate_min_subscriber_topic_version is None:
            raise TProtocolException(message='Required field populate_min_subscriber_topic_version is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TRegisterSubscriberRequest(object):
    """
    Attributes:
     - protocol_version
     - subscriber_id
     - subscriber_location
     - topic_registrations
    """


    def __init__(self, protocol_version=0, subscriber_id=None, subscriber_location=None, topic_registrations=None,):
        self.protocol_version = protocol_version
        self.subscriber_id = subscriber_id
        self.subscriber_location = subscriber_location
        self.topic_registrations = topic_registrations

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.protocol_version = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.subscriber_id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.subscriber_location = Types.ttypes.TNetworkAddress()
                    self.subscriber_location.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.topic_registrations = []
                    (_etype17, _size14) = iprot.readListBegin()
                    for _i18 in range(_size14):
                        _elem19 = TTopicRegistration()
                        _elem19.read(iprot)
                        self.topic_registrations.append(_elem19)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TRegisterSubscriberRequest')
        if self.protocol_version is not None:
            oprot.writeFieldBegin('protocol_version', TType.I32, 1)
            oprot.writeI32(self.protocol_version)
            oprot.writeFieldEnd()
        if self.subscriber_id is not None:
            oprot.writeFieldBegin('subscriber_id', TType.STRING, 2)
            oprot.writeString(self.subscriber_id.encode('utf-8') if sys.version_info[0] == 2 else self.subscriber_id)
            oprot.writeFieldEnd()
        if self.subscriber_location is not None:
            oprot.writeFieldBegin('subscriber_location', TType.STRUCT, 3)
            self.subscriber_location.write(oprot)
            oprot.writeFieldEnd()
        if self.topic_registrations is not None:
            oprot.writeFieldBegin('topic_registrations', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.topic_registrations))
            for iter20 in self.topic_registrations:
                iter20.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.protocol_version is None:
            raise TProtocolException(message='Required field protocol_version is unset!')
        if self.subscriber_id is None:
            raise TProtocolException(message='Required field subscriber_id is unset!')
        if self.subscriber_location is None:
            raise TProtocolException(message='Required field subscriber_location is unset!')
        if self.topic_registrations is None:
            raise TProtocolException(message='Required field topic_registrations is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TRegisterSubscriberResponse(object):
    """
    Attributes:
     - status
     - registration_id
    """


    def __init__(self, status=None, registration_id=None,):
        self.status = status
        self.registration_id = registration_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status.ttypes.TStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.registration_id = Types.ttypes.TUniqueId()
                    self.registration_id.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TRegisterSubscriberResponse')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.registration_id is not None:
            oprot.writeFieldBegin('registration_id', TType.STRUCT, 2)
            self.registration_id.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TUpdateStateRequest(object):
    """
    Attributes:
     - protocol_version
     - topic_deltas
     - registration_id
    """


    def __init__(self, protocol_version=0, topic_deltas=None, registration_id=None,):
        self.protocol_version = protocol_version
        self.topic_deltas = topic_deltas
        self.registration_id = registration_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.protocol_version = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.topic_deltas = {}
                    (_ktype22, _vtype23, _size21) = iprot.readMapBegin()
                    for _i25 in range(_size21):
                        _key26 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val27 = TTopicDelta()
                        _val27.read(iprot)
                        self.topic_deltas[_key26] = _val27
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.registration_id = Types.ttypes.TUniqueId()
                    self.registration_id.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TUpdateStateRequest')
        if self.protocol_version is not None:
            oprot.writeFieldBegin('protocol_version', TType.I32, 1)
            oprot.writeI32(self.protocol_version)
            oprot.writeFieldEnd()
        if self.topic_deltas is not None:
            oprot.writeFieldBegin('topic_deltas', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.topic_deltas))
            for kiter28, viter29 in self.topic_deltas.items():
                oprot.writeString(kiter28.encode('utf-8') if sys.version_info[0] == 2 else kiter28)
                viter29.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.registration_id is not None:
            oprot.writeFieldBegin('registration_id', TType.STRUCT, 3)
            self.registration_id.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.protocol_version is None:
            raise TProtocolException(message='Required field protocol_version is unset!')
        if self.topic_deltas is None:
            raise TProtocolException(message='Required field topic_deltas is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TUpdateStateResponse(object):
    """
    Attributes:
     - status
     - topic_updates
     - skipped
    """


    def __init__(self, status=None, topic_updates=None, skipped=None,):
        self.status = status
        self.topic_updates = topic_updates
        self.skipped = skipped

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status.ttypes.TStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.topic_updates = []
                    (_etype33, _size30) = iprot.readListBegin()
                    for _i34 in range(_size30):
                        _elem35 = TTopicDelta()
                        _elem35.read(iprot)
                        self.topic_updates.append(_elem35)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.skipped = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TUpdateStateResponse')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.topic_updates is not None:
            oprot.writeFieldBegin('topic_updates', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.topic_updates))
            for iter36 in self.topic_updates:
                iter36.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.skipped is not None:
            oprot.writeFieldBegin('skipped', TType.BOOL, 3)
            oprot.writeBool(self.skipped)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.topic_updates is None:
            raise TProtocolException(message='Required field topic_updates is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class THeartbeatRequest(object):
    """
    Attributes:
     - registration_id
    """


    def __init__(self, registration_id=None,):
        self.registration_id = registration_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.registration_id = Types.ttypes.TUniqueId()
                    self.registration_id.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('THeartbeatRequest')
        if self.registration_id is not None:
            oprot.writeFieldBegin('registration_id', TType.STRUCT, 1)
            self.registration_id.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class THeartbeatResponse(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('THeartbeatResponse')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(TPoolStats)
TPoolStats.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'num_admitted_running', None, None, ),  # 1
    (2, TType.I64, 'num_queued', None, None, ),  # 2
    (3, TType.I64, 'backend_mem_reserved', None, None, ),  # 3
)
all_structs.append(TExecutorGroupDesc)
TExecutorGroupDesc.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.I64, 'min_size', None, None, ),  # 2
)
all_structs.append(TBackendDescriptor)
TBackendDescriptor.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'backend_id', [Types.ttypes.TUniqueId, None], None, ),  # 1
    (2, TType.STRUCT, 'address', [Types.ttypes.TNetworkAddress, None], None, ),  # 2
    (3, TType.STRING, 'ip_address', 'UTF8', None, ),  # 3
    (4, TType.BOOL, 'is_coordinator', None, None, ),  # 4
    (5, TType.BOOL, 'is_executor', None, None, ),  # 5
    (6, TType.STRUCT, 'debug_http_address', [Types.ttypes.TNetworkAddress, None], None, ),  # 6
    (7, TType.BOOL, 'secure_webserver', None, None, ),  # 7
    (8, TType.STRUCT, 'krpc_address', [Types.ttypes.TNetworkAddress, None], None, ),  # 8
    (9, TType.I64, 'admit_mem_limit', None, None, ),  # 9
    (10, TType.BOOL, 'is_quiescing', None, None, ),  # 10
    (11, TType.LIST, 'executor_groups', (TType.STRUCT, [TExecutorGroupDesc, None], False), None, ),  # 11
    (12, TType.I64, 'admission_slots', None, None, ),  # 12
)
all_structs.append(TTopicItem)
TTopicItem.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'value', 'UTF8', None, ),  # 2
    (3, TType.BOOL, 'deleted', None, False, ),  # 3
)
all_structs.append(TTopicDelta)
TTopicDelta.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'topic_name', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'topic_entries', (TType.STRUCT, [TTopicItem, None], False), None, ),  # 2
    (3, TType.BOOL, 'is_delta', None, None, ),  # 3
    (4, TType.I64, 'from_version', None, None, ),  # 4
    (5, TType.I64, 'to_version', None, None, ),  # 5
    (6, TType.I64, 'min_subscriber_topic_version', None, None, ),  # 6
    (7, TType.BOOL, 'clear_topic_entries', None, None, ),  # 7
)
all_structs.append(TTopicRegistration)
TTopicRegistration.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'topic_name', 'UTF8', None, ),  # 1
    (2, TType.BOOL, 'is_transient', None, None, ),  # 2
    (3, TType.BOOL, 'populate_min_subscriber_topic_version', None, False, ),  # 3
    (4, TType.STRING, 'filter_prefix', 'UTF8', None, ),  # 4
)
all_structs.append(TRegisterSubscriberRequest)
TRegisterSubscriberRequest.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'protocol_version', None, 0, ),  # 1
    (2, TType.STRING, 'subscriber_id', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'subscriber_location', [Types.ttypes.TNetworkAddress, None], None, ),  # 3
    (4, TType.LIST, 'topic_registrations', (TType.STRUCT, [TTopicRegistration, None], False), None, ),  # 4
)
all_structs.append(TRegisterSubscriberResponse)
TRegisterSubscriberResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status.ttypes.TStatus, None], None, ),  # 1
    (2, TType.STRUCT, 'registration_id', [Types.ttypes.TUniqueId, None], None, ),  # 2
)
all_structs.append(TUpdateStateRequest)
TUpdateStateRequest.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'protocol_version', None, 0, ),  # 1
    (2, TType.MAP, 'topic_deltas', (TType.STRING, 'UTF8', TType.STRUCT, [TTopicDelta, None], False), None, ),  # 2
    (3, TType.STRUCT, 'registration_id', [Types.ttypes.TUniqueId, None], None, ),  # 3
)
all_structs.append(TUpdateStateResponse)
TUpdateStateResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status.ttypes.TStatus, None], None, ),  # 1
    (2, TType.LIST, 'topic_updates', (TType.STRUCT, [TTopicDelta, None], False), None, ),  # 2
    (3, TType.BOOL, 'skipped', None, None, ),  # 3
)
all_structs.append(THeartbeatRequest)
THeartbeatRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'registration_id', [Types.ttypes.TUniqueId, None], None, ),  # 1
)
all_structs.append(THeartbeatResponse)
THeartbeatResponse.thrift_spec = (
)
fix_spec(all_structs)
del all_structs
